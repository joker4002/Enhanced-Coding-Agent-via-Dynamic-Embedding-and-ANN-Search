{"chunk_id": "c5b32106abedce51d9142451a22a87b3c6fdee2d", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "function", "name": "_make_timedelta", "qualname": "_make_timedelta", "start_line": 52, "end_line": 56, "docstring": null, "code": "def _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)", "code_truncated": false}
{"chunk_id": "d8e1e548b0d74489e38636dd026adf46eb04032a", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "class", "name": "App", "qualname": "App", "start_line": 59, "end_line": 964, "docstring": "The flask object implements a WSGI application and acts as the central\nobject.  It is passed the name of the module or package of the\napplication.  Once it is created it will act as a central registry for\nthe view functions, the URL rules, template configuration and much more.\n\nThe name of the package is used to resolve resources from inside the\npackage or the folder the module is contained in depending on if the\npackage parameter resolves to an actual python package (a folder with\nan :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\nFor more information about resource loading, see :func:`open_resource`.\n\nUsually you create a :class:`Flask` instance in your main module or\nin the :file:`__init__.py` file of your package like this::\n\n    from flask import Flask\n    app = Flask(__name__)\n\n.. admonition:: About the First Parameter\n\n    The idea of the first parameter is to give Flask an idea of what\n    belongs to your application.  This name is used to find resources\n    on the filesystem, can be used by extensions to improve debugging\n    information and a lot more.\n\n    So it's important what you provide there.  If you are using a single\n    module, `__name__` is always the correct value.  If you however are\n    using a package, it's usually recommended to hardcode the name of\n    your package there.\n\n    For example if your application is defined in :file:`yourapplication/app.py`\n    you should create it with one of the two versions below::\n\n        app = Flask('yourapplication')\n        app = Flask(__name__.split('.')[0])\n\n    Why is that?  The application will work even with `__name__`, thanks\n    to how resources are looked up.  However it will make debugging more\n    painful.  Certain extensions can make assumptions based on the\n    import name of your application.  For example the Flask-SQLAlchemy\n    extension will look for the code in your application that triggered\n    an SQL query in debug mode.  If the import name is not properly set\n    up, that debugging information is lost.  (For example it would only\n    pick up SQL queries in `yourapplication.app` and not\n    `yourapplication.views.frontend`)\n\n.. versionadded:: 0.7\n   The `static_url_path`, `static_folder`, and `template_folder`\n   parameters were added.\n\n.. versionadded:: 0.8\n   The `instance_path` and `instance_relative_config` parameters were\n   added.\n\n.. versionadded:: 0.11\n   The `root_path` parameter was added.\n\n.. versionadded:: 1.0\n   The ``host_matching`` and ``static_host`` parameters were added.\n\n.. versionadded:: 1.0\n   The ``subdomain_matching`` parameter was added. Subdomain\n   matching needs to be enabled manually now. Setting\n   :data:`SERVER_NAME` does not implicitly enable it.\n\n:param import_name: the name of the application package\n:param static_url_path: can be used to specify a different path for the\n                        static files on the web.  Defaults to the name\n                        of the `static_folder` folder.\n:param static_folder: The folder with static files that is served at\n    ``static_url_path``. Relative to the application ``root_path``\n    or an absolute path. Defaults to ``'static'``.\n:param static_host: the host to use when adding the static route.\n    Defaults to None. Required when using ``host_matching=True``\n    with a ``static_folder`` configured.\n:param host_matching: set ``url_map.host_matching`` attribute.\n    Defaults to False.\n:param subdomain_matching: consider the subdomain relative to\n    :data:`SERVER_NAME` when matching routes. Defaults to False.\n:param template_folder: the folder that contains the templates that should\n                        be used by the application.  Defaults to\n                        ``'templates'`` folder in the root path of the\n                        application.\n:param instance_path: An alternative instance path for the application.\n                      By default the folder ``'instance'`` next to the\n                      package or module is assumed to be the instance\n                      path.\n:param instance_relative_config: if set to ``True`` relative filenames\n                                 for loading the config are assumed to\n                                 be relative to the instance path instead\n                                 of the application root.\n:param root_path: The path to the root of the application files.\n    This should only be set manually when it can't be detected\n    automatically, such as for namespace packages.", "code": "class App(Scaffold):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that triggered\n        an SQL query in debug mode.  If the import name is not properly set\n        up, that debugging information is lost.  (For example it would only\n        pick up SQL queries in `yourapplication.app` and not\n        `yourapplication.views.frontend`)\n\n    .. versionadded:: 0.7\n       The `static_url_path`, `static_folder`, and `template_folder`\n       parameters were added.\n\n    .. versionadded:: 0.8\n       The `instance_path` and `instance_relative_config` parameters were\n       added.\n\n    .. versionadded:: 0.11\n       The `root_path` parameter was added.\n\n    .. versionadded:: 1.0\n       The ``host_matching`` and ``static_host`` parameters were added.\n\n    .. versionadded:: 1.0\n       The ``subdomain_matching`` parameter was added. Subdomain\n       matching needs to be enabled manually now. Setting\n       :data:`SERVER_NAME` does not implicitly enable it.\n\n    :param import_name: the name of the application package\n    :param static_url_path: can be used to specify a different path for the\n                            static files on the web.  Defaults to the name\n                            of the `static_folder` folder.\n    :param static_folder: The folder with static files that is served at\n        ``static_url_path``. Relative to the application ``root_path``\n        or an absolute path. Defaults to ``'static'``.\n    :param static_host: the host to use when adding the static route.\n        Defaults to None. Required when using ``host_matching=True``\n        with a ``static_folder`` configured.\n    :param host_matching: set ``url_map.host_matching`` attribute.\n        Defaults to False.\n    :param subdomain_matching: consider the subdomain relative to\n        :data:`SERVER_NAME` when matching routes. Defaults to False.\n    :param template_folder: the folder that contains the templates that should\n                            be used by the application.  Defaults to\n                            ``'templates'`` folder in the root path of the\n                            application.\n    :param instance_path: An alternative instance path for the application.\n                          By default the folder ``'instance'`` next to the\n                          package or module is assumed to be the instance\n                          path.\n    :param instance_relative_config: if set to ``True`` relative filenames\n                                     for loading the config are assumed to\n                                     be relative to the instance path instead\n                                     of the application root.\n    :param root_path: The path to the root of the application files.\n        This should only be set manually when it can't be detected\n        automatically, such as for namespace packages.\n    \"\"\"\n\n    #: The class of the object assigned to :attr:`aborter`, created by\n    #: :meth:`create_aborter`. That object is called by\n    #: :func:`flask.abort` to raise HTTP errors, and can be\n    #: called directly as well.\n    #:\n    #: Defaults to :class:`werkzeug.exceptions.Aborter`.\n    #:\n    #: .. versionadded:: 2.2\n    aborter_class = Aborter\n\n    #: The class that is used for the Jinja environment.\n    #:\n    #: .. versionadded:: 0.11\n    jinja_environment = Environment\n\n    #: The class that is used for the :data:`~flask.g` instance.\n    #:\n    #: Example use cases for a custom class:\n    #:\n    #: 1. Store arbitrary attributes on flask.g.\n    #: 2. Add a property for lazy per-request database connectors.\n    #: 3. Return None instead of AttributeError on unexpected attributes.\n    #: 4. Raise exception if an unexpected attr is set, a \"controlled\" flask.g.\n    #:\n    #: In Flask 0.9 this property was called `request_globals_class` but it\n    #: was changed in 0.10 to :attr:`app_ctx_globals_class` because the\n    #: flask.g object is now application context scoped.\n    #:\n    #: .. versionadded:: 0.10\n    app_ctx_globals_class = _AppCtxGlobals\n\n    #: The class that is used for the ``config`` attribute of this app.\n    #: Defaults to :class:`~flask.Config`.\n    #:\n    #: Example use cases for a custom class:\n    #:\n    #: 1. Default values for certain config options.\n    #: 2. Access to config values through attributes in addition to keys.\n    #:\n    #: .. versionadded:: 0.11\n    config_class = Config\n\n    #: The testing flag.  Set this to ``True`` to enable the test mode of\n    #: Flask extensions (and in the future probably also Flask itself).\n    #: For example this might activate test helpers that have an\n    #: additional runtime cost which should not be enabled by default.\n    #:\n    #: If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the\n    #: default it's implicitly enabled.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``TESTING`` configuration key.  Defaults to ``False``.\n    testing = ConfigAttribute[bool](\"TESTING\")\n\n    #: If a secret key is set, cryptographic components can use this to\n    #: sign cookies and other things. Set this to a complex random value\n    #: when you want to use the secure cookie for instance.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: :data:`SECRET_KEY` configuration key. Defaults to ``None``.\n    secret_key = ConfigAttribute[t.Union[str, bytes, None]](\"SECRET_KEY\")\n\n    #: A :class:`~datetime.timedelta` which is used to set the expiration\n    #: date of a permanent session.  The default is 31 days which makes a\n    #: permanent session survive for roughly one month.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``PERMANENT_SESSION_LIFETIME`` configuration key.  Defaults to\n    #: ``timedelta(days=31)``\n    permanent_session_lifetime = ConfigAttribute[timedelta](\n        \"PERMANENT_SESSION_LIFETIME\",\n        get_converter=_make_timedelta,  # type: ignore[arg-type]\n    )\n\n    json_provider_class: type[J\n...<truncated>...\n", "code_truncated": true}
{"chunk_id": "b195d9c5c5f20c0df7fba6d87bf0c6746428cdec", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "__init__", "qualname": "App.__init__", "start_line": 282, "end_line": 411, "docstring": null, "code": "    def __init__(\n        self,\n        import_name: str,\n        static_url_path: str | None = None,\n        static_folder: str | os.PathLike[str] | None = \"static\",\n        static_host: str | None = None,\n        host_matching: bool = False,\n        subdomain_matching: bool = False,\n        template_folder: str | os.PathLike[str] | None = \"templates\",\n        instance_path: str | None = None,\n        instance_relative_config: bool = False,\n        root_path: str | None = None,\n    ) -> None:\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n        elif not os.path.isabs(instance_path):\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n\n        #: Holds the path to the instance folder.\n        #:\n        #: .. versionadded:: 0.8\n        self.instance_path = instance_path\n\n        #: The configuration dictionary as :class:`Config`.  This behaves\n        #: exactly like a regular dictionary but supports additional methods\n        #: to load a config from files.\n        self.config = self.make_config(instance_relative_config)\n\n        #: An instance of :attr:`aborter_class` created by\n        #: :meth:`make_aborter`. This is called by :func:`flask.abort`\n        #: to raise HTTP errors, and can be called directly as well.\n        #:\n        #: .. versionadded:: 2.2\n        #:     Moved from ``flask.abort``, which calls this object.\n        self.aborter = self.make_aborter()\n\n        self.json: JSONProvider = self.json_provider_class(self)\n        \"\"\"Provides access to JSON methods. Functions in ``flask.json``\n        will call methods on this provider when the application context\n        is active. Used for handling JSON requests and responses.\n\n        An instance of :attr:`json_provider_class`. Can be customized by\n        changing that attribute on a subclass, or by assigning to this\n        attribute afterwards.\n\n        The default, :class:`~flask.json.provider.DefaultJSONProvider`,\n        uses Python's built-in :mod:`json` library. A different provider\n        can use a different JSON library.\n\n        .. versionadded:: 2.2\n        \"\"\"\n\n        #: A list of functions that are called by\n        #: :meth:`handle_url_build_error` when :meth:`.url_for` raises a\n        #: :exc:`~werkzeug.routing.BuildError`. Each function is called\n        #: with ``error``, ``endpoint`` and ``values``. If a function\n        #: returns ``None`` or raises a ``BuildError``, it is skipped.\n        #: Otherwise, its return value is returned by ``url_for``.\n        #:\n        #: .. versionadded:: 0.9\n        self.url_build_error_handlers: list[\n            t.Callable[[Exception, str, dict[str, t.Any]], str]\n        ] = []\n\n        #: A list of functions that are called when the application context\n        #: is destroyed.  Since the application context is also torn down\n        #: if the request ends this is the place to store code that disconnects\n        #: from databases.\n        #:\n        #: .. versionadded:: 0.9\n        self.teardown_appcontext_funcs: list[ft.TeardownCallable] = []\n\n        #: A list of shell context processor functions that should be run\n        #: when a shell context is created.\n        #:\n        #: .. versionadded:: 0.11\n        self.shell_context_processors: list[ft.ShellContextProcessorCallable] = []\n\n        #: Maps registered blueprint names to blueprint objects. The\n        #: dict retains the order the blueprints were registered in.\n        #: Blueprints can be registered multiple times, this dict does\n        #: not track how often they were attached.\n        #:\n        #: .. versionadded:: 0.7\n        self.blueprints: dict[str, Blueprint] = {}\n\n        #: a place where extensions can store application specific state.  For\n        #: example this is where an extension could store database engines and\n        #: similar things.\n        #:\n        #: The key must match the name of the extension module. For example in\n        #: case of a \"Flask-Foo\" extension in `flask_foo`, the key would be\n        #: ``'foo'``.\n        #:\n        #: .. versionadded:: 0.7\n        self.extensions: dict[str, t.Any] = {}\n\n        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n        #: this to change the routing converters after the class was created\n        #: but before any routes are connected.  Example::\n        #:\n        #:    from werkzeug.routing import BaseConverter\n        #:\n        #:    class ListConverter(BaseConverter):\n        #:        def to_python(self, value):\n        #:            return value.split(',')\n        #:        def to_url(self, values):\n        #:            return ','.join(super(ListConverter, self).to_url(value)\n        #:                            for value in values)\n        #:\n        #:    app = Flask(__name__)\n        #:    app.url_map.converters['list'] = ListConverter\n        self.url_map = self.url_map_class(host_matching=host_matching)\n\n        self.subdomain_matching = subdomain_matching\n\n        # tracks internally if the application already handled at least one\n        # request.\n        self._got_first_request = False", "code_truncated": false}
{"chunk_id": "4796316b2dddf620935e0452c21ef9f02f8c867e", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "_check_setup_finished", "qualname": "App._check_setup_finished", "start_line": 413, "end_line": 423, "docstring": null, "code": "    def _check_setup_finished(self, f_name: str) -> None:\n        if self._got_first_request:\n            raise AssertionError(\n                f\"The setup method '{f_name}' can no longer be called\"\n                \" on the application. It has already handled its first\"\n                \" request, any changes will not be applied\"\n                \" consistently.\\n\"\n                \"Make sure all imports, decorators, functions, etc.\"\n                \" needed to set up the application are done before\"\n                \" running it.\"\n            )", "code_truncated": false}
{"chunk_id": "db57206579fe68e5787d3dbdb2e5c5813a4f86cb", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "name", "qualname": "App.name", "start_line": 426, "end_line": 440, "docstring": "The name of the application.  This is usually the import name\nwith the difference that it's guessed from the run file if the\nimport name is main.  This name is used as a display name when\nFlask needs the name of the application.  It can be set and overridden\nto change the value.\n\n.. versionadded:: 0.8", "code": "    def name(self) -> str:\n        \"\"\"The name of the application.  This is usually the import name\n        with the difference that it's guessed from the run file if the\n        import name is main.  This name is used as a display name when\n        Flask needs the name of the application.  It can be set and overridden\n        to change the value.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.import_name == \"__main__\":\n            fn: str | None = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n            return os.path.splitext(os.path.basename(fn))[0]\n        return self.import_name", "code_truncated": false}
{"chunk_id": "5fe8320f7fc9c7430b83b0dc0cf9a69a1894f558", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "logger", "qualname": "App.logger", "start_line": 443, "end_line": 467, "docstring": "A standard Python :class:`~logging.Logger` for the app, with\nthe same name as :attr:`name`.\n\nIn debug mode, the logger's :attr:`~logging.Logger.level` will\nbe set to :data:`~logging.DEBUG`.\n\nIf there are no handlers configured, a default handler will be\nadded. See :doc:`/logging` for more information.\n\n.. versionchanged:: 1.1.0\n    The logger takes the same name as :attr:`name` rather than\n    hard-coding ``\"flask.app\"``.\n\n.. versionchanged:: 1.0.0\n    Behavior was simplified. The logger is always named\n    ``\"flask.app\"``. The level is only set during configuration,\n    it doesn't check ``app.debug`` each time. Only one format is\n    used, not different ones depending on ``app.debug``. No\n    handlers are removed, and a handler is only added if no\n    handlers are already configured.\n\n.. versionadded:: 0.3", "code": "    def logger(self) -> logging.Logger:\n        \"\"\"A standard Python :class:`~logging.Logger` for the app, with\n        the same name as :attr:`name`.\n\n        In debug mode, the logger's :attr:`~logging.Logger.level` will\n        be set to :data:`~logging.DEBUG`.\n\n        If there are no handlers configured, a default handler will be\n        added. See :doc:`/logging` for more information.\n\n        .. versionchanged:: 1.1.0\n            The logger takes the same name as :attr:`name` rather than\n            hard-coding ``\"flask.app\"``.\n\n        .. versionchanged:: 1.0.0\n            Behavior was simplified. The logger is always named\n            ``\"flask.app\"``. The level is only set during configuration,\n            it doesn't check ``app.debug`` each time. Only one format is\n            used, not different ones depending on ``app.debug``. No\n            handlers are removed, and a handler is only added if no\n            handlers are already configured.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        return create_logger(self)", "code_truncated": false}
{"chunk_id": "dc995c73ac8ca7543a6c1befe5a96ed88d5b6a12", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "jinja_env", "qualname": "App.jinja_env", "start_line": 470, "end_line": 477, "docstring": "The Jinja environment used to load templates.\n\nThe environment is created the first time this property is\naccessed. Changing :attr:`jinja_options` after that will have no\neffect.", "code": "    def jinja_env(self) -> Environment:\n        \"\"\"The Jinja environment used to load templates.\n\n        The environment is created the first time this property is\n        accessed. Changing :attr:`jinja_options` after that will have no\n        effect.\n        \"\"\"\n        return self.create_jinja_environment()", "code_truncated": false}
{"chunk_id": "691ecd88436dd444df51ed37bddf59b3ac0488cb", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "create_jinja_environment", "qualname": "App.create_jinja_environment", "start_line": 479, "end_line": 480, "docstring": null, "code": "    def create_jinja_environment(self) -> Environment:\n        raise NotImplementedError()", "code_truncated": false}
{"chunk_id": "c6513202b6b6af43787b97073bbe379b2b796aad", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "make_config", "qualname": "App.make_config", "start_line": 482, "end_line": 496, "docstring": "Used to create the config attribute by the Flask constructor.\nThe `instance_relative` parameter is passed in from the constructor\nof Flask (there named `instance_relative_config`) and indicates if\nthe config should be relative to the instance path or the root path\nof the application.\n\n.. versionadded:: 0.8", "code": "    def make_config(self, instance_relative: bool = False) -> Config:\n        \"\"\"Used to create the config attribute by the Flask constructor.\n        The `instance_relative` parameter is passed in from the constructor\n        of Flask (there named `instance_relative_config`) and indicates if\n        the config should be relative to the instance path or the root path\n        of the application.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)", "code_truncated": false}
{"chunk_id": "17f2c955735ab2c55d10fbe472a45a4ca9a9765c", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "make_aborter", "qualname": "App.make_aborter", "start_line": 498, "end_line": 508, "docstring": "Create the object to assign to :attr:`aborter`. That object\nis called by :func:`flask.abort` to raise HTTP errors, and can\nbe called directly as well.\n\nBy default, this creates an instance of :attr:`aborter_class`,\nwhich defaults to :class:`werkzeug.exceptions.Aborter`.\n\n.. versionadded:: 2.2", "code": "    def make_aborter(self) -> Aborter:\n        \"\"\"Create the object to assign to :attr:`aborter`. That object\n        is called by :func:`flask.abort` to raise HTTP errors, and can\n        be called directly as well.\n\n        By default, this creates an instance of :attr:`aborter_class`,\n        which defaults to :class:`werkzeug.exceptions.Aborter`.\n\n        .. versionadded:: 2.2\n        \"\"\"\n        return self.aborter_class()", "code_truncated": false}
{"chunk_id": "97e191056ca6486f73df02ed734814bf6b6a7985", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "auto_find_instance_path", "qualname": "App.auto_find_instance_path", "start_line": 510, "end_line": 521, "docstring": "Tries to locate the instance path if it was not provided to the\nconstructor of the application class.  It will basically calculate\nthe path to a folder named ``instance`` next to your main file or\nthe package.\n\n.. versionadded:: 0.8", "code": "    def auto_find_instance_path(self) -> str:\n        \"\"\"Tries to locate the instance path if it was not provided to the\n        constructor of the application class.  It will basically calculate\n        the path to a folder named ``instance`` next to your main file or\n        the package.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n            return os.path.join(package_path, \"instance\")\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")", "code_truncated": false}
{"chunk_id": "f3e16f446c9c5cd0fcd6be473c17ee7f2ccad9bf", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "create_global_jinja_loader", "qualname": "App.create_global_jinja_loader", "start_line": 523, "end_line": 534, "docstring": "Creates the loader for the Jinja environment.  Can be used to\noverride just the loader and keeping the rest unchanged.  It's\ndiscouraged to override this function.  Instead one should override\nthe :meth:`jinja_loader` function instead.\n\nThe global loader dispatches between the loaders of the application\nand the individual blueprints.\n\n.. versionadded:: 0.7", "code": "    def create_global_jinja_loader(self) -> DispatchingJinjaLoader:\n        \"\"\"Creates the loader for the Jinja environment.  Can be used to\n        override just the loader and keeping the rest unchanged.  It's\n        discouraged to override this function.  Instead one should override\n        the :meth:`jinja_loader` function instead.\n\n        The global loader dispatches between the loaders of the application\n        and the individual blueprints.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        return DispatchingJinjaLoader(self)", "code_truncated": false}
{"chunk_id": "ef0566ce1e79198d30189e4cf73bb11ef0997c61", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "select_jinja_autoescape", "qualname": "App.select_jinja_autoescape", "start_line": 536, "end_line": 547, "docstring": "Returns ``True`` if autoescaping should be active for the given\ntemplate name. If no template name is given, returns `True`.\n\n.. versionchanged:: 2.2\n    Autoescaping is now enabled by default for ``.svg`` files.\n\n.. versionadded:: 0.5", "code": "    def select_jinja_autoescape(self, filename: str) -> bool:\n        \"\"\"Returns ``True`` if autoescaping should be active for the given\n        template name. If no template name is given, returns `True`.\n\n        .. versionchanged:: 2.2\n            Autoescaping is now enabled by default for ``.svg`` files.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\", \".svg\"))", "code_truncated": false}
{"chunk_id": "7cd63dd765a74952bf58b4eaef1cd789fb817105", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "debug", "qualname": "App.debug", "start_line": 550, "end_line": 560, "docstring": "Whether debug mode is enabled. When using ``flask run`` to start the\ndevelopment server, an interactive debugger will be shown for unhandled\nexceptions, and the server will be reloaded when code changes. This maps to the\n:data:`DEBUG` config key. It may not behave as expected if set late.\n\n**Do not enable debug mode when deploying in production.**\n\nDefault: ``False``", "code": "    def debug(self) -> bool:\n        \"\"\"Whether debug mode is enabled. When using ``flask run`` to start the\n        development server, an interactive debugger will be shown for unhandled\n        exceptions, and the server will be reloaded when code changes. This maps to the\n        :data:`DEBUG` config key. It may not behave as expected if set late.\n\n        **Do not enable debug mode when deploying in production.**\n\n        Default: ``False``\n        \"\"\"\n        return self.config[\"DEBUG\"]  # type: ignore[no-any-return]", "code_truncated": false}
{"chunk_id": "469171d62a549ccf4840a8e90f16bef9326e4e9c", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "debug", "qualname": "App.debug", "start_line": 563, "end_line": 567, "docstring": null, "code": "    def debug(self, value: bool) -> None:\n        self.config[\"DEBUG\"] = value\n\n        if self.config[\"TEMPLATES_AUTO_RELOAD\"] is None:\n            self.jinja_env.auto_reload = value", "code_truncated": false}
{"chunk_id": "080ae014166e64107367e8e32590248c62dcc701", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "register_blueprint", "qualname": "App.register_blueprint", "start_line": 570, "end_line": 595, "docstring": "Register a :class:`~flask.Blueprint` on the application. Keyword\narguments passed to this method will override the defaults set on the\nblueprint.\n\nCalls the blueprint's :meth:`~flask.Blueprint.register` method after\nrecording the blueprint in the application's :attr:`blueprints`.\n\n:param blueprint: The blueprint to register.\n:param url_prefix: Blueprint routes will be prefixed with this.\n:param subdomain: Blueprint routes will match on this subdomain.\n:param url_defaults: Blueprint routes will use these default values for\n    view arguments.\n:param options: Additional keyword arguments are passed to\n    :class:`~flask.blueprints.BlueprintSetupState`. They can be\n    accessed in :meth:`~flask.Blueprint.record` callbacks.\n\n.. versionchanged:: 2.0.1\n    The ``name`` option can be used to change the (pre-dotted)\n    name the blueprint is registered with. This allows the same\n    blueprint to be registered multiple times with unique names\n    for ``url_for``.\n\n.. versionadded:: 0.7", "code": "    def register_blueprint(self, blueprint: Blueprint, **options: t.Any) -> None:\n        \"\"\"Register a :class:`~flask.Blueprint` on the application. Keyword\n        arguments passed to this method will override the defaults set on the\n        blueprint.\n\n        Calls the blueprint's :meth:`~flask.Blueprint.register` method after\n        recording the blueprint in the application's :attr:`blueprints`.\n\n        :param blueprint: The blueprint to register.\n        :param url_prefix: Blueprint routes will be prefixed with this.\n        :param subdomain: Blueprint routes will match on this subdomain.\n        :param url_defaults: Blueprint routes will use these default values for\n            view arguments.\n        :param options: Additional keyword arguments are passed to\n            :class:`~flask.blueprints.BlueprintSetupState`. They can be\n            accessed in :meth:`~flask.Blueprint.record` callbacks.\n\n        .. versionchanged:: 2.0.1\n            The ``name`` option can be used to change the (pre-dotted)\n            name the blueprint is registered with. This allows the same\n            blueprint to be registered multiple times with unique names\n            for ``url_for``.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        blueprint.register(self, options)", "code_truncated": false}
{"chunk_id": "21c8952678dfdb08a0f5235d87bb9fcd7b9319b7", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "iter_blueprints", "qualname": "App.iter_blueprints", "start_line": 597, "end_line": 602, "docstring": "Iterates over all blueprints by the order they were registered.\n\n.. versionadded:: 0.11", "code": "    def iter_blueprints(self) -> t.ValuesView[Blueprint]:\n        \"\"\"Iterates over all blueprints by the order they were registered.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        return self.blueprints.values()", "code_truncated": false}
{"chunk_id": "aa6e127f5bc80dd25610dae68a6cf424845b75e2", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "add_url_rule", "qualname": "App.add_url_rule", "start_line": 605, "end_line": 661, "docstring": null, "code": "    def add_url_rule(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        provide_automatic_options: bool | None = None,\n        **options: t.Any,\n    ) -> None:\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)  # type: ignore\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n\n        # if the methods are not given and the view_func object knows its\n        # methods we can use that instead.  If neither exists, we go with\n        # a tuple of only ``GET`` as default.\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n\n        # Methods that should always be added\n        required_methods: set[str] = set(getattr(view_func, \"required_methods\", ()))\n\n        # starting with Flask 0.8 the view_func object can disable and\n        # force-enable the automatic options handling.\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods and self.config[\"PROVIDE_AUTOMATIC_OPTIONS\"]:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n\n        # Add the required methods now.\n        methods |= required_methods\n\n        rule_obj = self.url_rule_class(rule, methods=methods, **options)\n        rule_obj.provide_automatic_options = provide_automatic_options  # type: ignore[attr-defined]\n\n        self.url_map.add(rule_obj)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func", "code_truncated": false}
{"chunk_id": "ca0040d23a50f7215406da6da3fcf0807e51deaf", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "template_filter", "qualname": "App.template_filter", "start_line": 664, "end_line": 683, "docstring": "A decorator that is used to register custom template filter.\nYou can specify a name for the filter, otherwise the function\nname will be used. Example::\n\n  @app.template_filter()\n  def reverse(s):\n      return s[::-1]\n\n:param name: the optional name of the filter, otherwise the\n             function name will be used.", "code": "    def template_filter(\n        self, name: str | None = None\n    ) -> t.Callable[[T_template_filter], T_template_filter]:\n        \"\"\"A decorator that is used to register custom template filter.\n        You can specify a name for the filter, otherwise the function\n        name will be used. Example::\n\n          @app.template_filter()\n          def reverse(s):\n              return s[::-1]\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n\n        def decorator(f: T_template_filter) -> T_template_filter:\n            self.add_template_filter(f, name=name)\n            return f\n\n        return decorator", "code_truncated": false}
{"chunk_id": "813594455d9d505a0bc594068f4b6cd4174ad491", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "add_template_filter", "qualname": "App.add_template_filter", "start_line": 686, "end_line": 695, "docstring": "Register a custom template filter.  Works exactly like the\n:meth:`template_filter` decorator.\n\n:param name: the optional name of the filter, otherwise the\n             function name will be used.", "code": "    def add_template_filter(\n        self, f: ft.TemplateFilterCallable, name: str | None = None\n    ) -> None:\n        \"\"\"Register a custom template filter.  Works exactly like the\n        :meth:`template_filter` decorator.\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.filters[name or f.__name__] = f", "code_truncated": false}
{"chunk_id": "2569198fe96bebb5852974b9a4a6bfd8d473f232", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "template_test", "qualname": "App.template_test", "start_line": 698, "end_line": 724, "docstring": "A decorator that is used to register custom template test.\nYou can specify a name for the test, otherwise the function\nname will be used. Example::\n\n  @app.template_test()\n  def is_prime(n):\n      if n == 2:\n          return True\n      for i in range(2, int(math.ceil(math.sqrt(n))) + 1):\n          if n % i == 0:\n              return False\n      return True\n\n.. versionadded:: 0.10\n\n:param name: the optional name of the test, otherwise the\n             function name will be used.", "code": "    def template_test(\n        self, name: str | None = None\n    ) -> t.Callable[[T_template_test], T_template_test]:\n        \"\"\"A decorator that is used to register custom template test.\n        You can specify a name for the test, otherwise the function\n        name will be used. Example::\n\n          @app.template_test()\n          def is_prime(n):\n              if n == 2:\n                  return True\n              for i in range(2, int(math.ceil(math.sqrt(n))) + 1):\n                  if n % i == 0:\n                      return False\n              return True\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n\n        def decorator(f: T_template_test) -> T_template_test:\n            self.add_template_test(f, name=name)\n            return f\n\n        return decorator", "code_truncated": false}
{"chunk_id": "d35b1879a9c3177ae6ee76e2e19f560f2f7957ab", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "add_template_test", "qualname": "App.add_template_test", "start_line": 727, "end_line": 738, "docstring": "Register a custom template test.  Works exactly like the\n:meth:`template_test` decorator.\n\n.. versionadded:: 0.10\n\n:param name: the optional name of the test, otherwise the\n             function name will be used.", "code": "    def add_template_test(\n        self, f: ft.TemplateTestCallable, name: str | None = None\n    ) -> None:\n        \"\"\"Register a custom template test.  Works exactly like the\n        :meth:`template_test` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.tests[name or f.__name__] = f", "code_truncated": false}
{"chunk_id": "e71cad5967d9d02731655d2349fcf367443e18d1", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "template_global", "qualname": "App.template_global", "start_line": 741, "end_line": 762, "docstring": "A decorator that is used to register a custom template global function.\nYou can specify a name for the global function, otherwise the function\nname will be used. Example::\n\n    @app.template_global()\n    def double(n):\n        return 2 * n\n\n.. versionadded:: 0.10\n\n:param name: the optional name of the global function, otherwise the\n             function name will be used.", "code": "    def template_global(\n        self, name: str | None = None\n    ) -> t.Callable[[T_template_global], T_template_global]:\n        \"\"\"A decorator that is used to register a custom template global function.\n        You can specify a name for the global function, otherwise the function\n        name will be used. Example::\n\n            @app.template_global()\n            def double(n):\n                return 2 * n\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global function, otherwise the\n                     function name will be used.\n        \"\"\"\n\n        def decorator(f: T_template_global) -> T_template_global:\n            self.add_template_global(f, name=name)\n            return f\n\n        return decorator", "code_truncated": false}
{"chunk_id": "8fd9b4abe5836dde6767d78840182a143277301a", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "add_template_global", "qualname": "App.add_template_global", "start_line": 765, "end_line": 776, "docstring": "Register a custom template global function. Works exactly like the\n:meth:`template_global` decorator.\n\n.. versionadded:: 0.10\n\n:param name: the optional name of the global function, otherwise the\n             function name will be used.", "code": "    def add_template_global(\n        self, f: ft.TemplateGlobalCallable, name: str | None = None\n    ) -> None:\n        \"\"\"Register a custom template global function. Works exactly like the\n        :meth:`template_global` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global function, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.globals[name or f.__name__] = f", "code_truncated": false}
{"chunk_id": "6059b8cff063ad2af1c963477b73418d17680c1f", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "teardown_appcontext", "qualname": "App.teardown_appcontext", "start_line": 779, "end_line": 810, "docstring": "Registers a function to be called when the application\ncontext is popped. The application context is typically popped\nafter the request context for each request, at the end of CLI\ncommands, or after a manually pushed context ends.\n\n.. code-block:: python\n\n    with app.app_context():\n        ...\n\nWhen the ``with`` block exits (or ``ctx.pop()`` is called), the\nteardown functions are called just before the app context is\nmade inactive. Since a request context typically also manages an\napplication context it would also be called when you pop a\nrequest context.\n\nWhen a teardown function was called because of an unhandled\nexception it will be passed an error object. If an\n:meth:`errorhandler` is registered, it will handle the exception\nand the teardown will not receive it.\n\nTeardown functions must avoid raising exceptions. If they\nexecute code that might fail they must surround that code with a\n``try``/``except`` block and log any errors.\n\nThe return values of teardown functions are ignored.\n\n.. versionadded:: 0.9", "code": "    def teardown_appcontext(self, f: T_teardown) -> T_teardown:\n        \"\"\"Registers a function to be called when the application\n        context is popped. The application context is typically popped\n        after the request context for each request, at the end of CLI\n        commands, or after a manually pushed context ends.\n\n        .. code-block:: python\n\n            with app.app_context():\n                ...\n\n        When the ``with`` block exits (or ``ctx.pop()`` is called), the\n        teardown functions are called just before the app context is\n        made inactive. Since a request context typically also manages an\n        application context it would also be called when you pop a\n        request context.\n\n        When a teardown function was called because of an unhandled\n        exception it will be passed an error object. If an\n        :meth:`errorhandler` is registered, it will handle the exception\n        and the teardown will not receive it.\n\n        Teardown functions must avoid raising exceptions. If they\n        execute code that might fail they must surround that code with a\n        ``try``/``except`` block and log any errors.\n\n        The return values of teardown functions are ignored.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        self.teardown_appcontext_funcs.append(f)\n        return f", "code_truncated": false}
{"chunk_id": "acb72a9eddf4034d2c3c9a4428458dc0eb313585", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "shell_context_processor", "qualname": "App.shell_context_processor", "start_line": 813, "end_line": 821, "docstring": "Registers a shell context processor function.\n\n.. versionadded:: 0.11", "code": "    def shell_context_processor(\n        self, f: T_shell_context_processor\n    ) -> T_shell_context_processor:\n        \"\"\"Registers a shell context processor function.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        self.shell_context_processors.append(f)\n        return f", "code_truncated": false}
{"chunk_id": "bd8aa579677d2103529098bf0dde5363bf27801b", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "_find_error_handler", "qualname": "App._find_error_handler", "start_line": 823, "end_line": 846, "docstring": "Return a registered error handler for an exception in this order:\nblueprint handler for a specific code, app handler for a specific code,\nblueprint handler for an exception class, app handler for an exception\nclass, or ``None`` if a suitable handler is not found.", "code": "    def _find_error_handler(\n        self, e: Exception, blueprints: list[str]\n    ) -> ft.ErrorHandlerCallable | None:\n        \"\"\"Return a registered error handler for an exception in this order:\n        blueprint handler for a specific code, app handler for a specific code,\n        blueprint handler for an exception class, app handler for an exception\n        class, or ``None`` if a suitable handler is not found.\n        \"\"\"\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        names = (*blueprints, None)\n\n        for c in (code, None) if code is not None else (None,):\n            for name in names:\n                handler_map = self.error_handler_spec[name][c]\n\n                if not handler_map:\n                    continue\n\n                for cls in exc_class.__mro__:\n                    handler = handler_map.get(cls)\n\n                    if handler is not None:\n                        return handler\n        return None", "code_truncated": false}
{"chunk_id": "72546f3f59b50590d57414770de886085622f2f1", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "trap_http_exception", "qualname": "App.trap_http_exception", "start_line": 848, "end_line": 881, "docstring": "Checks if an HTTP exception should be trapped or not.  By default\nthis will return ``False`` for all exceptions except for a bad request\nkey error if ``TRAP_BAD_REQUEST_ERRORS`` is set to ``True``.  It\nalso returns ``True`` if ``TRAP_HTTP_EXCEPTIONS`` is set to ``True``.\n\nThis is called for all HTTP exceptions raised by a view function.\nIf it returns ``True`` for any exception the error handler for this\nexception is not called and it shows up as regular exception in the\ntraceback.  This is helpful for debugging implicitly raised HTTP\nexceptions.\n\n.. versionchanged:: 1.0\n    Bad request errors are not trapped by default in debug mode.\n\n.. versionadded:: 0.8", "code": "    def trap_http_exception(self, e: Exception) -> bool:\n        \"\"\"Checks if an HTTP exception should be trapped or not.  By default\n        this will return ``False`` for all exceptions except for a bad request\n        key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to ``True``.  It\n        also returns ``True`` if ``TRAP_HTTP_EXCEPTIONS`` is set to ``True``.\n\n        This is called for all HTTP exceptions raised by a view function.\n        If it returns ``True`` for any exception the error handler for this\n        exception is not called and it shows up as regular exception in the\n        traceback.  This is helpful for debugging implicitly raised HTTP\n        exceptions.\n\n        .. versionchanged:: 1.0\n            Bad request errors are not trapped by default in debug mode.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n\n        # if unset, trap key errors in debug mode\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n\n        return False", "code_truncated": false}
{"chunk_id": "4fd106d0acc60784e359a803c65f9744a62087b2", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "should_ignore_error", "qualname": "App.should_ignore_error", "start_line": 883, "end_line": 891, "docstring": "This is called to figure out if an error should be ignored\nor not as far as the teardown system is concerned.  If this\nfunction returns ``True`` then the teardown handlers will not be\npassed the error.\n\n.. versionadded:: 0.10", "code": "    def should_ignore_error(self, error: BaseException | None) -> bool:\n        \"\"\"This is called to figure out if an error should be ignored\n        or not as far as the teardown system is concerned.  If this\n        function returns ``True`` then the teardown handlers will not be\n        passed the error.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return False", "code_truncated": false}
{"chunk_id": "0fe87bd449f395823c39ea148f7c889540f4c12f", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "redirect", "qualname": "App.redirect", "start_line": 893, "end_line": 909, "docstring": "Create a redirect response object.\n\nThis is called by :func:`flask.redirect`, and can be called\ndirectly as well.\n\n:param location: The URL to redirect to.\n:param code: The status code for the redirect.\n\n.. versionadded:: 2.2\n    Moved from ``flask.redirect``, which calls this method.", "code": "    def redirect(self, location: str, code: int = 302) -> BaseResponse:\n        \"\"\"Create a redirect response object.\n\n        This is called by :func:`flask.redirect`, and can be called\n        directly as well.\n\n        :param location: The URL to redirect to.\n        :param code: The status code for the redirect.\n\n        .. versionadded:: 2.2\n            Moved from ``flask.redirect``, which calls this method.\n        \"\"\"\n        return _wz_redirect(\n            location,\n            code=code,\n            Response=self.response_class,  # type: ignore[arg-type]\n        )", "code_truncated": false}
{"chunk_id": "1c6a2d953793959fcb82bc2bdb28a28346b5ccbd", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "inject_url_defaults", "qualname": "App.inject_url_defaults", "start_line": 911, "end_line": 930, "docstring": "Injects the URL defaults for the given endpoint directly into\nthe values dictionary passed.  This is used internally and\nautomatically called on URL building.\n\n.. versionadded:: 0.7", "code": "    def inject_url_defaults(self, endpoint: str, values: dict[str, t.Any]) -> None:\n        \"\"\"Injects the URL defaults for the given endpoint directly into\n        the values dictionary passed.  This is used internally and\n        automatically called on URL building.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        names: t.Iterable[str | None] = (None,)\n\n        # url_for may be called outside a request context, parse the\n        # passed endpoint instead of using request.blueprints.\n        if \".\" in endpoint:\n            names = chain(\n                names, reversed(_split_blueprint_path(endpoint.rpartition(\".\")[0]))\n            )\n\n        for name in names:\n            if name in self.url_default_functions:\n                for func in self.url_default_functions[name]:\n                    func(endpoint, values)", "code_truncated": false}
{"chunk_id": "07ba41ceb2d3059832f5847a2c36e09fe36ad136", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "symbol_type": "method", "name": "handle_url_build_error", "qualname": "App.handle_url_build_error", "start_line": 932, "end_line": 964, "docstring": "Called by :meth:`.url_for` if a\n:exc:`~werkzeug.routing.BuildError` was raised. If this returns\na value, it will be returned by ``url_for``, otherwise the error\nwill be re-raised.\n\nEach function in :attr:`url_build_error_handlers` is called with\n``error``, ``endpoint`` and ``values``. If a function returns\n``None`` or raises a ``BuildError``, it is skipped. Otherwise,\nits return value is returned by ``url_for``.\n\n:param error: The active ``BuildError`` being handled.\n:param endpoint: The endpoint being built.\n:param values: The keyword arguments passed to ``url_for``.", "code": "    def handle_url_build_error(\n        self, error: BuildError, endpoint: str, values: dict[str, t.Any]\n    ) -> str:\n        \"\"\"Called by :meth:`.url_for` if a\n        :exc:`~werkzeug.routing.BuildError` was raised. If this returns\n        a value, it will be returned by ``url_for``, otherwise the error\n        will be re-raised.\n\n        Each function in :attr:`url_build_error_handlers` is called with\n        ``error``, ``endpoint`` and ``values``. If a function returns\n        ``None`` or raises a ``BuildError``, it is skipped. Otherwise,\n        its return value is returned by ``url_for``.\n\n        :param error: The active ``BuildError`` being handled.\n        :param endpoint: The endpoint being built.\n        :param values: The keyword arguments passed to ``url_for``.\n        \"\"\"\n        for handler in self.url_build_error_handlers:\n            try:\n                rv = handler(error, endpoint, values)\n            except BuildError as e:\n                # make error available outside except block\n                error = e\n            else:\n                if rv is not None:\n                    return rv\n\n        # Re-raise if called with an active exception, otherwise raise\n        # the passed in exception.\n        if error is sys.exc_info()[1]:\n            raise\n\n        raise error", "code_truncated": false}
{"chunk_id": "7f0c359aad4268bf236509bc1333835e34a3124c", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "symbol_type": "class", "name": "BlueprintSetupState", "qualname": "BlueprintSetupState", "start_line": 34, "end_line": 116, "docstring": "Temporary holder object for registering a blueprint with the\napplication.  An instance of this class is created by the\n:meth:`~flask.Blueprint.make_setup_state` method and later passed\nto all register callback functions.", "code": "class BlueprintSetupState:\n    \"\"\"Temporary holder object for registering a blueprint with the\n    application.  An instance of this class is created by the\n    :meth:`~flask.Blueprint.make_setup_state` method and later passed\n    to all register callback functions.\n    \"\"\"\n\n    def __init__(\n        self,\n        blueprint: Blueprint,\n        app: App,\n        options: t.Any,\n        first_registration: bool,\n    ) -> None:\n        #: a reference to the current application\n        self.app = app\n\n        #: a reference to the blueprint that created this setup state.\n        self.blueprint = blueprint\n\n        #: a dictionary with all options that were passed to the\n        #: :meth:`~flask.Flask.register_blueprint` method.\n        self.options = options\n\n        #: as blueprints can be registered multiple times with the\n        #: application and not everything wants to be registered\n        #: multiple times on it, this attribute can be used to figure\n        #: out if the blueprint was registered in the past already.\n        self.first_registration = first_registration\n\n        subdomain = self.options.get(\"subdomain\")\n        if subdomain is None:\n            subdomain = self.blueprint.subdomain\n\n        #: The subdomain that the blueprint should be active for, ``None``\n        #: otherwise.\n        self.subdomain = subdomain\n\n        url_prefix = self.options.get(\"url_prefix\")\n        if url_prefix is None:\n            url_prefix = self.blueprint.url_prefix\n        #: The prefix that should be used for all URLs defined on the\n        #: blueprint.\n        self.url_prefix = url_prefix\n\n        self.name = self.options.get(\"name\", blueprint.name)\n        self.name_prefix = self.options.get(\"name_prefix\", \"\")\n\n        #: A dictionary with URL defaults that is added to each and every\n        #: URL that was defined with the blueprint.\n        self.url_defaults = dict(self.blueprint.url_values_defaults)\n        self.url_defaults.update(self.options.get(\"url_defaults\", ()))\n\n    def add_url_rule(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"A helper method to register a rule (and optionally a view function)\n        to the application.  The endpoint is automatically prefixed with the\n        blueprint's name.\n        \"\"\"\n        if self.url_prefix is not None:\n            if rule:\n                rule = \"/\".join((self.url_prefix.rstrip(\"/\"), rule.lstrip(\"/\")))\n            else:\n                rule = self.url_prefix\n        options.setdefault(\"subdomain\", self.subdomain)\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)  # type: ignore\n        defaults = self.url_defaults\n        if \"defaults\" in options:\n            defaults = dict(defaults, **options.pop(\"defaults\"))\n\n        self.app.add_url_rule(\n            rule,\n            f\"{self.name_prefix}.{self.name}.{endpoint}\".lstrip(\".\"),\n            view_func,\n            defaults=defaults,\n            **options,\n        )", "code_truncated": false}
{"chunk_id": "9e23e53f49d961e84b6ea3826e6fc27d069e339d", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "symbol_type": "method", "name": "__init__", "qualname": "BlueprintSetupState.__init__", "start_line": 41, "end_line": 85, "docstring": null, "code": "    def __init__(\n        self,\n        blueprint: Blueprint,\n        app: App,\n        options: t.Any,\n        first_registration: bool,\n    ) -> None:\n        #: a reference to the current application\n        self.app = app\n\n        #: a reference to the blueprint that created this setup state.\n        self.blueprint = blueprint\n\n        #: a dictionary with all options that were passed to the\n        #: :meth:`~flask.Flask.register_blueprint` method.\n        self.options = options\n\n        #: as blueprints can be registered multiple times with the\n        #: application and not everything wants to be registered\n        #: multiple times on it, this attribute can be used to figure\n        #: out if the blueprint was registered in the past already.\n        self.first_registration = first_registration\n\n        subdomain = self.options.get(\"subdomain\")\n        if subdomain is None:\n            subdomain = self.blueprint.subdomain\n\n        #: The subdomain that the blueprint should be active for, ``None``\n        #: otherwise.\n        self.subdomain = subdomain\n\n        url_prefix = self.options.get(\"url_prefix\")\n        if url_prefix is None:\n            url_prefix = self.blueprint.url_prefix\n        #: The prefix that should be used for all URLs defined on the\n        #: blueprint.\n        self.url_prefix = url_prefix\n\n        self.name = self.options.get(\"name\", blueprint.name)\n        self.name_prefix = self.options.get(\"name_prefix\", \"\")\n\n        #: A dictionary with URL defaults that is added to each and every\n        #: URL that was defined with the blueprint.\n        self.url_defaults = dict(self.blueprint.url_values_defaults)\n        self.url_defaults.update(self.options.get(\"url_defaults\", ()))", "code_truncated": false}
{"chunk_id": "5da66ec3713bd62dcf402fd5a782459a0146cc90", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "symbol_type": "method", "name": "add_url_rule", "qualname": "BlueprintSetupState.add_url_rule", "start_line": 87, "end_line": 116, "docstring": "A helper method to register a rule (and optionally a view function)\nto the application.  The endpoint is automatically prefixed with the\nblueprint's name.", "code": "    def add_url_rule(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"A helper method to register a rule (and optionally a view function)\n        to the application.  The endpoint is automatically prefixed with the\n        blueprint's name.\n        \"\"\"\n        if self.url_prefix is not None:\n            if rule:\n                rule = \"/\".join((self.url_prefix.rstrip(\"/\"), rule.lstrip(\"/\")))\n            else:\n                rule = self.url_prefix\n        options.setdefault(\"subdomain\", self.subdomain)\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)  # type: ignore\n        defaults = self.url_defaults\n        if \"defaults\" in options:\n            defaults = dict(defaults, **options.pop(\"defaults\"))\n\n        self.app.add_url_rule(\n            rule,\n            f\"{self.name_prefix}.{self.name}.{endpoint}\".lstrip(\".\"),\n            view_func,\n            defaults=defaults,\n            **options,\n        )", "code_truncated": false}
{"chunk_id": "050eb8c31229f16efc649b2a5db466224acdf8df", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "symbol_type": "class", "name": "Blueprint", "qualname": "Blueprint", "start_line": 119, "end_line": 632, "docstring": "Represents a blueprint, a collection of routes and other\napp-related functions that can be registered on a real application\nlater.\n\nA blueprint is an object that allows defining application functions\nwithout requiring an application object ahead of time. It uses the\nsame decorators as :class:`~flask.Flask`, but defers the need for an\napplication by recording them for later registration.\n\nDecorating a function with a blueprint creates a deferred function\nthat is called with :class:`~flask.blueprints.BlueprintSetupState`\nwhen the blueprint is registered on an application.\n\nSee :doc:`/blueprints` for more information.\n\n:param name: The name of the blueprint. Will be prepended to each\n    endpoint name.\n:param import_name: The name of the blueprint package, usually\n    ``__name__``. This helps locate the ``root_path`` for the\n    blueprint.\n:param static_folder: A folder with static files that should be\n    served by the blueprint's static route. The path is relative to\n    the blueprint's root path. Blueprint static files are disabled\n    by default.\n:param static_url_path: The url to serve static files from.\n    Defaults to ``static_folder``. If the blueprint does not have\n    a ``url_prefix``, the app's static route will take precedence,\n    and the blueprint's static files won't be accessible.\n:param template_folder: A folder with templates that should be added\n    to the app's template search path. The path is relative to the\n    blueprint's root path. Blueprint templates are disabled by\n    default. Blueprint templates have a lower precedence than those\n    in the app's templates folder.\n:param url_prefix: A path to prepend to all of the blueprint's URLs,\n    to make them distinct from the rest of the app's routes.\n:param subdomain: A subdomain that blueprint routes will match on by\n    default.\n:param url_defaults: A dict of default values that blueprint routes\n    will receive by default.\n:param root_path: By default, the blueprint will automatically set\n    this based on ``import_name``. In certain situations this\n    automatic detection can fail, so the path can be specified\n    manually instead.\n\n.. versionchanged:: 1.1.0\n    Blueprints have a ``cli`` group to register nested CLI commands.\n    The ``cli_group`` parameter controls the name of the group under\n    the ``flask`` command.\n\n.. versionadded:: 0.7", "code": "class Blueprint(Scaffold):\n    \"\"\"Represents a blueprint, a collection of routes and other\n    app-related functions that can be registered on a real application\n    later.\n\n    A blueprint is an object that allows defining application functions\n    without requiring an application object ahead of time. It uses the\n    same decorators as :class:`~flask.Flask`, but defers the need for an\n    application by recording them for later registration.\n\n    Decorating a function with a blueprint creates a deferred function\n    that is called with :class:`~flask.blueprints.BlueprintSetupState`\n    when the blueprint is registered on an application.\n\n    See :doc:`/blueprints` for more information.\n\n    :param name: The name of the blueprint. Will be prepended to each\n        endpoint name.\n    :param import_name: The name of the blueprint package, usually\n        ``__name__``. This helps locate the ``root_path`` for the\n        blueprint.\n    :param static_folder: A folder with static files that should be\n        served by the blueprint's static route. The path is relative to\n        the blueprint's root path. Blueprint static files are disabled\n        by default.\n    :param static_url_path: The url to serve static files from.\n        Defaults to ``static_folder``. If the blueprint does not have\n        a ``url_prefix``, the app's static route will take precedence,\n        and the blueprint's static files won't be accessible.\n    :param template_folder: A folder with templates that should be added\n        to the app's template search path. The path is relative to the\n        blueprint's root path. Blueprint templates are disabled by\n        default. Blueprint templates have a lower precedence than those\n        in the app's templates folder.\n    :param url_prefix: A path to prepend to all of the blueprint's URLs,\n        to make them distinct from the rest of the app's routes.\n    :param subdomain: A subdomain that blueprint routes will match on by\n        default.\n    :param url_defaults: A dict of default values that blueprint routes\n        will receive by default.\n    :param root_path: By default, the blueprint will automatically set\n        this based on ``import_name``. In certain situations this\n        automatic detection can fail, so the path can be specified\n        manually instead.\n\n    .. versionchanged:: 1.1.0\n        Blueprints have a ``cli`` group to register nested CLI commands.\n        The ``cli_group`` parameter controls the name of the group under\n        the ``flask`` command.\n\n    .. versionadded:: 0.7\n    \"\"\"\n\n    _got_registered_once = False\n\n    def __init__(\n        self,\n        name: str,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        url_prefix: str | None = None,\n        subdomain: str | None = None,\n        url_defaults: dict[str, t.Any] | None = None,\n        root_path: str | None = None,\n        cli_group: str | None = _sentinel,  # type: ignore[assignment]\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n\n        if not name:\n            raise ValueError(\"'name' may not be empty.\")\n\n        if \".\" in name:\n            raise ValueError(\"'name' may not contain a dot '.' character.\")\n\n        self.name = name\n        self.url_prefix = url_prefix\n        self.subdomain = subdomain\n        self.deferred_functions: list[DeferredSetupFunction] = []\n\n        if url_defaults is None:\n            url_defaults = {}\n\n        self.url_values_defaults = url_defaults\n        self.cli_group = cli_group\n        self._blueprints: list[tuple[Blueprint, dict[str, t.Any]]] = []\n\n    def _check_setup_finished(self, f_name: str) -> None:\n        if self._got_registered_once:\n            raise AssertionError(\n                f\"The setup method '{f_name}' can no longer be called on the blueprint\"\n                f\" '{self.name}'. It has already been registered at least once, any\"\n                \" changes will not be applied consistently.\\n\"\n                \"Make sure all imports, decorators, functions, etc. needed to set up\"\n                \" the blueprint are done before registering it.\"\n            )\n\n    @setupmethod\n    def record(self, func: DeferredSetupFunction) -> None:\n        \"\"\"Registers a function that is called when the blueprint is\n        registered on the application.  This function is called with the\n        state as argument as returned by the :meth:`make_setup_state`\n        method.\n        \"\"\"\n        self.deferred_functions.append(func)\n\n    @setupmethod\n    def record_once(self, func: DeferredSetupFunction) -> None:\n        \"\"\"Works like :meth:`record` but wraps the function in another\n        function that will ensure the function is only called once.  If the\n        blueprint is registered a second time on the application, the\n        function passed is not called.\n        \"\"\"\n\n        def wrapper(state: BlueprintSetupState) -> None:\n            if state.first_registration:\n                func(state)\n\n        self.record(update_wrapper(wrapper, func))\n\n    def make_setup_state(\n        self, app: App, options: dict[str, t.Any], first_registration: bool = False\n    ) -> BlueprintSetupState:\n        \"\"\"Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState`\n        object that is later passed to the register callback functions.\n        Subclasses can override this to return a subclass of the setup state.\n        \"\"\"\n        return BlueprintSetupState(self, app, options, first_registration)\n\n    @setupmethod\n    def register_blueprint(self, blueprint: Blueprint, **options: t.Any) -> None:\n        \"\"\"Register a :class:`~flask.Blueprint` on this blueprint. Keyword\n        arguments passed to this method will override the defaults set\n        on the blueprint.\n\n        .. versionchanged:: 2.0.1\n            The ``name`` option can be used to change the (pre-dotted)\n            name the blueprint is registered with. This allows the same\n            blueprint to be registered multiple times with unique names\n            for ``url_for``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        if blueprint is self:\n            raise ValueError(\"Cannot register a blueprint on itself\")\n        self._blueprints.append((blueprint, options))\n\n    def register(self, app: App, options: dict[str, t.Any]) -> None:\n        \"\"\"Called by :meth:`Flask.register_blueprint` to register all\n        views and callbacks registered on the blueprint with the\n        application. Creates a :class:`.BlueprintSetupState` and calls\n        each :meth:`record` callback with it.\n\n        :param app: The application this blueprint is being registered\n            with.\n        :param options: Keyword arguments forwarded from\n            :meth:`~Flask.register_blueprint`.\n\n        .. versionchanged:: 2.3\n            Nested blueprints now correctly apply subdomains.\n\n        .. versionchanged:: 2.1\n            Registering the same blueprint with the same name multiple\n            times is an error.\n\n        .. versionchanged:: 2.0.1\n            Nested blueprints are registered with their dotted name.\n            This allows different blueprints with the same name to be\n            nested at different locations.\n\n        .. versionchanged:: 2.0.1\n            The ``name`` option can be used to change the (pre-dotted)\n            name the blueprint is registered with. This allows the same\n            blueprint to be registered multiple times with unique names\n            for ``url_for``.\n        \"\"\"\n        name_prefix = options.get(\"name_prefix\", \"\")\n        self_name = options.get(\"name\", self.name)\n        name = f\"{name_prefix}.{self_name}\".lstrip(\".\")\n\n        if name in app.blueprints:\n    \n...<truncated>...\n", "code_truncated": true}
{"chunk_id": "4a15cd3b26430caeb872f19ee57b7d0deb3c943b", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "symbol_type": "method", "name": "__init__", "qualname": "Blueprint.__init__", "start_line": 174, "end_line": 211, "docstring": null, "code": "    def __init__(\n        self,\n        name: str,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        url_prefix: str | None = None,\n        subdomain: str | None = None,\n        url_defaults: dict[str, t.Any] | None = None,\n        root_path: str | None = None,\n        cli_group: str | None = _sentinel,  # type: ignore[assignment]\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n\n        if not name:\n            raise ValueError(\"'name' may not be empty.\")\n\n        if \".\" in name:\n            raise ValueError(\"'name' may not contain a dot '.' character.\")\n\n        self.name = name\n        self.url_prefix = url_prefix\n        self.subdomain = subdomain\n        self.deferred_functions: list[DeferredSetupFunction] = []\n\n        if url_defaults is None:\n            url_defaults = {}\n\n        self.url_values_defaults = url_defaults\n        self.cli_group = cli_group\n        self._blueprints: list[tuple[Blueprint, dict[str, t.Any]]] = []", "code_truncated": false}
{"chunk_id": "263b75b731c031841002d59bc4d02b1888e999ec", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "symbol_type": "method", "name": "_check_setup_finished", "qualname": "Blueprint._check_setup_finished", "start_line": 213, "end_line": 221, "docstring": null, "code": "    def _check_setup_finished(self, f_name: str) -> None:\n        if self._got_registered_once:\n            raise AssertionError(\n                f\"The setup method '{f_name}' can no longer be called on the blueprint\"\n                f\" '{self.name}'. It has already been registered at least once, any\"\n                \" changes will not be applied consistently.\\n\"\n                \"Make sure all imports, decorators, functions, etc. needed to set up\"\n                \" the blueprint are done before registering it.\"\n            )", "code_truncated": false}
{"chunk_id": "19c64700651ca0aac083d837afb21a2455d48c2a", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "symbol_type": "method", "name": "record", "qualname": "Blueprint.record", "start_line": 224, "end_line": 230, "docstring": "Registers a function that is called when the blueprint is\nregistered on the application.  This function is called with the\nstate as argument as returned by the :meth:`make_setup_state`\nmethod.", "code": "    def record(self, func: DeferredSetupFunction) -> None:\n        \"\"\"Registers a function that is called when the blueprint is\n        registered on the application.  This function is called with the\n        state as argument as returned by the :meth:`make_setup_state`\n        method.\n        \"\"\"\n        self.deferred_functions.append(func)", "code_truncated": false}
{"chunk_id": "83e3801266e6e403bbb1c599b2f2a3bc155e67ee", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "symbol_type": "method", "name": "record_once", "qualname": "Blueprint.record_once", "start_line": 233, "end_line": 244, "docstring": "Works like :meth:`record` but wraps the function in another\nfunction that will ensure the function is only called once.  If the\nblueprint is registered a second time on the application, the\nfunction passed is not called.", "code": "    def record_once(self, func: DeferredSetupFunction) -> None:\n        \"\"\"Works like :meth:`record` but wraps the function in another\n        function that will ensure the function is only called once.  If the\n        blueprint is registered a second time on the application, the\n        function passed is not called.\n        \"\"\"\n\n        def wrapper(state: BlueprintSetupState) -> None:\n            if state.first_registration:\n                func(state)\n\n        self.record(update_wrapper(wrapper, func))", "code_truncated": false}
{"chunk_id": "29304152079461a508cf1dfac77165ca2f133ac1", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "symbol_type": "method", "name": "make_setup_state", "qualname": "Blueprint.make_setup_state", "start_line": 246, "end_line": 253, "docstring": "Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState`\nobject that is later passed to the register callback functions.\nSubclasses can override this to return a subclass of the setup state.", "code": "    def make_setup_state(\n        self, app: App, options: dict[str, t.Any], first_registration: bool = False\n    ) -> BlueprintSetupState:\n        \"\"\"Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState`\n        object that is later passed to the register callback functions.\n        Subclasses can override this to return a subclass of the setup state.\n        \"\"\"\n        return BlueprintSetupState(self, app, options, first_registration)", "code_truncated": false}
{"chunk_id": "24470ee7108c483a9ebebccc2d621e4f43beba97", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "symbol_type": "method", "name": "register_blueprint", "qualname": "Blueprint.register_blueprint", "start_line": 256, "end_line": 271, "docstring": "Register a :class:`~flask.Blueprint` on this blueprint. Keyword\narguments passed to this method will override the defaults set\non the blueprint.\n\n.. versionchanged:: 2.0.1\n    The ``name`` option can be used to change the (pre-dotted)\n    name the blueprint is registered with. This allows the same\n    blueprint to be registered multiple times with unique names\n    for ``url_for``.\n\n.. versionadded:: 2.0", "code": "    def register_blueprint(self, blueprint: Blueprint, **options: t.Any) -> None:\n        \"\"\"Register a :class:`~flask.Blueprint` on this blueprint. Keyword\n        arguments passed to this method will override the defaults set\n        on the blueprint.\n\n        .. versionchanged:: 2.0.1\n            The ``name`` option can be used to change the (pre-dotted)\n            name the blueprint is registered with. This allows the same\n            blueprint to be registered multiple times with unique names\n            for ``url_for``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        if blueprint is self:\n            raise ValueError(\"Cannot register a blueprint on itself\")\n        self._blueprints.append((blueprint, options))", "code_truncated": false}
{"chunk_id": "0ccb67a8a1fa0e6433839b0105192d8c71accff4", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "symbol_type": "method", "name": "register", "qualname": "Blueprint.register", "start_line": 273, "end_line": 377, "docstring": "Called by :meth:`Flask.register_blueprint` to register all\nviews and callbacks registered on the blueprint with the\napplication. Creates a :class:`.BlueprintSetupState` and calls\neach :meth:`record` callback with it.\n\n:param app: The application this blueprint is being registered\n    with.\n:param options: Keyword arguments forwarded from\n    :meth:`~Flask.register_blueprint`.\n\n.. versionchanged:: 2.3\n    Nested blueprints now correctly apply subdomains.\n\n.. versionchanged:: 2.1\n    Registering the same blueprint with the same name multiple\n    times is an error.\n\n.. versionchanged:: 2.0.1\n    Nested blueprints are registered with their dotted name.\n    This allows different blueprints with the same name to be\n    nested at different locations.\n\n.. versionchanged:: 2.0.1\n    The ``name`` option can be used to change the (pre-dotted)\n    name the blueprint is registered with. This allows the same\n    blueprint to be registered multiple times with unique names\n    for ``url_for``.", "code": "    def register(self, app: App, options: dict[str, t.Any]) -> None:\n        \"\"\"Called by :meth:`Flask.register_blueprint` to register all\n        views and callbacks registered on the blueprint with the\n        application. Creates a :class:`.BlueprintSetupState` and calls\n        each :meth:`record` callback with it.\n\n        :param app: The application this blueprint is being registered\n            with.\n        :param options: Keyword arguments forwarded from\n            :meth:`~Flask.register_blueprint`.\n\n        .. versionchanged:: 2.3\n            Nested blueprints now correctly apply subdomains.\n\n        .. versionchanged:: 2.1\n            Registering the same blueprint with the same name multiple\n            times is an error.\n\n        .. versionchanged:: 2.0.1\n            Nested blueprints are registered with their dotted name.\n            This allows different blueprints with the same name to be\n            nested at different locations.\n\n        .. versionchanged:: 2.0.1\n            The ``name`` option can be used to change the (pre-dotted)\n            name the blueprint is registered with. This allows the same\n            blueprint to be registered multiple times with unique names\n            for ``url_for``.\n        \"\"\"\n        name_prefix = options.get(\"name_prefix\", \"\")\n        self_name = options.get(\"name\", self.name)\n        name = f\"{name_prefix}.{self_name}\".lstrip(\".\")\n\n        if name in app.blueprints:\n            bp_desc = \"this\" if app.blueprints[name] is self else \"a different\"\n            existing_at = f\" '{name}'\" if self_name != name else \"\"\n\n            raise ValueError(\n                f\"The name '{self_name}' is already registered for\"\n                f\" {bp_desc} blueprint{existing_at}. Use 'name=' to\"\n                f\" provide a unique name.\"\n            )\n\n        first_bp_registration = not any(bp is self for bp in app.blueprints.values())\n        first_name_registration = name not in app.blueprints\n\n        app.blueprints[name] = self\n        self._got_registered_once = True\n        state = self.make_setup_state(app, options, first_bp_registration)\n\n        if self.has_static_folder:\n            state.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                view_func=self.send_static_file,  # type: ignore[attr-defined]\n                endpoint=\"static\",\n            )\n\n        # Merge blueprint data into parent.\n        if first_bp_registration or first_name_registration:\n            self._merge_blueprint_funcs(app, name)\n\n        for deferred in self.deferred_functions:\n            deferred(state)\n\n        cli_resolved_group = options.get(\"cli_group\", self.cli_group)\n\n        if self.cli.commands:\n            if cli_resolved_group is None:\n                app.cli.commands.update(self.cli.commands)\n            elif cli_resolved_group is _sentinel:\n                self.cli.name = name\n                app.cli.add_command(self.cli)\n            else:\n                self.cli.name = cli_resolved_group\n                app.cli.add_command(self.cli)\n\n        for blueprint, bp_options in self._blueprints:\n            bp_options = bp_options.copy()\n            bp_url_prefix = bp_options.get(\"url_prefix\")\n            bp_subdomain = bp_options.get(\"subdomain\")\n\n            if bp_subdomain is None:\n                bp_subdomain = blueprint.subdomain\n\n            if state.subdomain is not None and bp_subdomain is not None:\n                bp_options[\"subdomain\"] = bp_subdomain + \".\" + state.subdomain\n            elif bp_subdomain is not None:\n                bp_options[\"subdomain\"] = bp_subdomain\n            elif state.subdomain is not None:\n                bp_options[\"subdomain\"] = state.subdomain\n\n            if bp_url_prefix is None:\n                bp_url_prefix = blueprint.url_prefix\n\n            if state.url_prefix is not None and bp_url_prefix is not None:\n                bp_options[\"url_prefix\"] = (\n                    state.url_prefix.rstrip(\"/\") + \"/\" + bp_url_prefix.lstrip(\"/\")\n                )\n            elif bp_url_prefix is not None:\n                bp_options[\"url_prefix\"] = bp_url_prefix\n            elif state.url_prefix is not None:\n                bp_options[\"url_prefix\"] = state.url_prefix\n\n            bp_options[\"name_prefix\"] = name\n            blueprint.register(app, bp_options)", "code_truncated": false}
{"chunk_id": "8a3d7b954cac8c75d598ee17583b3a8497ce7af8", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "symbol_type": "method", "name": "_merge_blueprint_funcs", "qualname": "Blueprint._merge_blueprint_funcs", "start_line": 379, "end_line": 410, "docstring": null, "code": "    def _merge_blueprint_funcs(self, app: App, name: str) -> None:\n        def extend(\n            bp_dict: dict[ft.AppOrBlueprintKey, list[t.Any]],\n            parent_dict: dict[ft.AppOrBlueprintKey, list[t.Any]],\n        ) -> None:\n            for key, values in bp_dict.items():\n                key = name if key is None else f\"{name}.{key}\"\n                parent_dict[key].extend(values)\n\n        for key, value in self.error_handler_spec.items():\n            key = name if key is None else f\"{name}.{key}\"\n            value = defaultdict(\n                dict,\n                {\n                    code: {exc_class: func for exc_class, func in code_values.items()}\n                    for code, code_values in value.items()\n                },\n            )\n            app.error_handler_spec[key] = value\n\n        for endpoint, func in self.view_functions.items():\n            app.view_functions[endpoint] = func\n\n        extend(self.before_request_funcs, app.before_request_funcs)\n        extend(self.after_request_funcs, app.after_request_funcs)\n        extend(\n            self.teardown_request_funcs,\n            app.teardown_request_funcs,\n        )\n        extend(self.url_default_functions, app.url_default_functions)\n        extend(self.url_value_preprocessors, app.url_value_preprocessors)\n        extend(self.template_context_processors, app.template_context_processors)", "code_truncated": false}
{"chunk_id": "f41009b67a3927ef7a561c0a130593aba5a4399d", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "symbol_type": "method", "name": "add_url_rule", "qualname": "Blueprint.add_url_rule", "start_line": 413, "end_line": 441, "docstring": "Register a URL rule with the blueprint. See :meth:`.Flask.add_url_rule` for\nfull documentation.\n\nThe URL rule is prefixed with the blueprint's URL prefix. The endpoint name,\nused with :func:`url_for`, is prefixed with the blueprint's name.", "code": "    def add_url_rule(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        provide_automatic_options: bool | None = None,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"Register a URL rule with the blueprint. See :meth:`.Flask.add_url_rule` for\n        full documentation.\n\n        The URL rule is prefixed with the blueprint's URL prefix. The endpoint name,\n        used with :func:`url_for`, is prefixed with the blueprint's name.\n        \"\"\"\n        if endpoint and \".\" in endpoint:\n            raise ValueError(\"'endpoint' may not contain a dot '.' character.\")\n\n        if view_func and hasattr(view_func, \"__name__\") and \".\" in view_func.__name__:\n            raise ValueError(\"'view_func' name may not contain a dot '.' character.\")\n\n        self.record(\n            lambda s: s.add_url_rule(\n                rule,\n                endpoint,\n                view_func,\n                provide_automatic_options=provide_automatic_options,\n                **options,\n            )\n        )", "code_truncated": false}
{"chunk_id": "ca9069882255da60cc0d50ae24217ebd2b62d28d", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "symbol_type": "method", "name": "app_template_filter", "qualname": "Blueprint.app_template_filter", "start_line": 444, "end_line": 458, "docstring": "Register a template filter, available in any template rendered by the\napplication. Equivalent to :meth:`.Flask.template_filter`.\n\n:param name: the optional name of the filter, otherwise the\n             function name will be used.", "code": "    def app_template_filter(\n        self, name: str | None = None\n    ) -> t.Callable[[T_template_filter], T_template_filter]:\n        \"\"\"Register a template filter, available in any template rendered by the\n        application. Equivalent to :meth:`.Flask.template_filter`.\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n\n        def decorator(f: T_template_filter) -> T_template_filter:\n            self.add_app_template_filter(f, name=name)\n            return f\n\n        return decorator", "code_truncated": false}
{"chunk_id": "378b4375ddd68319c2ca0ee7832f05511a9e32e3", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "symbol_type": "method", "name": "add_app_template_filter", "qualname": "Blueprint.add_app_template_filter", "start_line": 461, "end_line": 475, "docstring": "Register a template filter, available in any template rendered by the\napplication. Works like the :meth:`app_template_filter` decorator. Equivalent to\n:meth:`.Flask.add_template_filter`.\n\n:param name: the optional name of the filter, otherwise the\n             function name will be used.", "code": "    def add_app_template_filter(\n        self, f: ft.TemplateFilterCallable, name: str | None = None\n    ) -> None:\n        \"\"\"Register a template filter, available in any template rendered by the\n        application. Works like the :meth:`app_template_filter` decorator. Equivalent to\n        :meth:`.Flask.add_template_filter`.\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n\n        def register_template(state: BlueprintSetupState) -> None:\n            state.app.jinja_env.filters[name or f.__name__] = f\n\n        self.record_once(register_template)", "code_truncated": false}
{"chunk_id": "5326a1725a58e81c9da2975225e954c86e169c95", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "symbol_type": "method", "name": "app_template_test", "qualname": "Blueprint.app_template_test", "start_line": 478, "end_line": 494, "docstring": "Register a template test, available in any template rendered by the\napplication. Equivalent to :meth:`.Flask.template_test`.\n\n.. versionadded:: 0.10\n\n:param name: the optional name of the test, otherwise the\n             function name will be used.", "code": "    def app_template_test(\n        self, name: str | None = None\n    ) -> t.Callable[[T_template_test], T_template_test]:\n        \"\"\"Register a template test, available in any template rendered by the\n        application. Equivalent to :meth:`.Flask.template_test`.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n\n        def decorator(f: T_template_test) -> T_template_test:\n            self.add_app_template_test(f, name=name)\n            return f\n\n        return decorator", "code_truncated": false}
{"chunk_id": "e8c4994bbbf204f08e9eb25b0e4101a0d5882f61", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "symbol_type": "method", "name": "add_app_template_test", "qualname": "Blueprint.add_app_template_test", "start_line": 497, "end_line": 513, "docstring": "Register a template test, available in any template rendered by the\napplication. Works like the :meth:`app_template_test` decorator. Equivalent to\n:meth:`.Flask.add_template_test`.\n\n.. versionadded:: 0.10\n\n:param name: the optional name of the test, otherwise the\n             function name will be used.", "code": "    def add_app_template_test(\n        self, f: ft.TemplateTestCallable, name: str | None = None\n    ) -> None:\n        \"\"\"Register a template test, available in any template rendered by the\n        application. Works like the :meth:`app_template_test` decorator. Equivalent to\n        :meth:`.Flask.add_template_test`.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n\n        def register_template(state: BlueprintSetupState) -> None:\n            state.app.jinja_env.tests[name or f.__name__] = f\n\n        self.record_once(register_template)", "code_truncated": false}
{"chunk_id": "89f6b178a99873ebce20ae994752030d18b35cad", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "symbol_type": "method", "name": "app_template_global", "qualname": "Blueprint.app_template_global", "start_line": 516, "end_line": 532, "docstring": "Register a template global, available in any template rendered by the\napplication. Equivalent to :meth:`.Flask.template_global`.\n\n.. versionadded:: 0.10\n\n:param name: the optional name of the global, otherwise the\n             function name will be used.", "code": "    def app_template_global(\n        self, name: str | None = None\n    ) -> t.Callable[[T_template_global], T_template_global]:\n        \"\"\"Register a template global, available in any template rendered by the\n        application. Equivalent to :meth:`.Flask.template_global`.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global, otherwise the\n                     function name will be used.\n        \"\"\"\n\n        def decorator(f: T_template_global) -> T_template_global:\n            self.add_app_template_global(f, name=name)\n            return f\n\n        return decorator", "code_truncated": false}
{"chunk_id": "9ddb74d21f370f8250ffd43dcdf5321d8210e7da", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "symbol_type": "method", "name": "add_app_template_global", "qualname": "Blueprint.add_app_template_global", "start_line": 535, "end_line": 551, "docstring": "Register a template global, available in any template rendered by the\napplication. Works like the :meth:`app_template_global` decorator. Equivalent to\n:meth:`.Flask.add_template_global`.\n\n.. versionadded:: 0.10\n\n:param name: the optional name of the global, otherwise the\n             function name will be used.", "code": "    def add_app_template_global(\n        self, f: ft.TemplateGlobalCallable, name: str | None = None\n    ) -> None:\n        \"\"\"Register a template global, available in any template rendered by the\n        application. Works like the :meth:`app_template_global` decorator. Equivalent to\n        :meth:`.Flask.add_template_global`.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global, otherwise the\n                     function name will be used.\n        \"\"\"\n\n        def register_template(state: BlueprintSetupState) -> None:\n            state.app.jinja_env.globals[name or f.__name__] = f\n\n        self.record_once(register_template)", "code_truncated": false}
{"chunk_id": "d0e25a3bd2b4e073ff754483036396a315715c1b", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "symbol_type": "method", "name": "before_app_request", "qualname": "Blueprint.before_app_request", "start_line": 554, "end_line": 561, "docstring": "Like :meth:`before_request`, but before every request, not only those handled\nby the blueprint. Equivalent to :meth:`.Flask.before_request`.", "code": "    def before_app_request(self, f: T_before_request) -> T_before_request:\n        \"\"\"Like :meth:`before_request`, but before every request, not only those handled\n        by the blueprint. Equivalent to :meth:`.Flask.before_request`.\n        \"\"\"\n        self.record_once(\n            lambda s: s.app.before_request_funcs.setdefault(None, []).append(f)\n        )\n        return f", "code_truncated": false}
{"chunk_id": "c19a26db512d86a71223c4bcd2f571bed8fc3277", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "symbol_type": "method", "name": "after_app_request", "qualname": "Blueprint.after_app_request", "start_line": 564, "end_line": 571, "docstring": "Like :meth:`after_request`, but after every request, not only those handled\nby the blueprint. Equivalent to :meth:`.Flask.after_request`.", "code": "    def after_app_request(self, f: T_after_request) -> T_after_request:\n        \"\"\"Like :meth:`after_request`, but after every request, not only those handled\n        by the blueprint. Equivalent to :meth:`.Flask.after_request`.\n        \"\"\"\n        self.record_once(\n            lambda s: s.app.after_request_funcs.setdefault(None, []).append(f)\n        )\n        return f", "code_truncated": false}
{"chunk_id": "e2ddd853876ade931d7ed5d4e852a9dd33cc1194", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "symbol_type": "method", "name": "teardown_app_request", "qualname": "Blueprint.teardown_app_request", "start_line": 574, "end_line": 581, "docstring": "Like :meth:`teardown_request`, but after every request, not only those\nhandled by the blueprint. Equivalent to :meth:`.Flask.teardown_request`.", "code": "    def teardown_app_request(self, f: T_teardown) -> T_teardown:\n        \"\"\"Like :meth:`teardown_request`, but after every request, not only those\n        handled by the blueprint. Equivalent to :meth:`.Flask.teardown_request`.\n        \"\"\"\n        self.record_once(\n            lambda s: s.app.teardown_request_funcs.setdefault(None, []).append(f)\n        )\n        return f", "code_truncated": false}
{"chunk_id": "4c51b8a8ab88e2317e44c3d5de87e4700d6ec3f4", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "symbol_type": "method", "name": "app_context_processor", "qualname": "Blueprint.app_context_processor", "start_line": 584, "end_line": 593, "docstring": "Like :meth:`context_processor`, but for templates rendered by every view, not\nonly by the blueprint. Equivalent to :meth:`.Flask.context_processor`.", "code": "    def app_context_processor(\n        self, f: T_template_context_processor\n    ) -> T_template_context_processor:\n        \"\"\"Like :meth:`context_processor`, but for templates rendered by every view, not\n        only by the blueprint. Equivalent to :meth:`.Flask.context_processor`.\n        \"\"\"\n        self.record_once(\n            lambda s: s.app.template_context_processors.setdefault(None, []).append(f)\n        )\n        return f", "code_truncated": false}
{"chunk_id": "cda2b45a8dcaf8db39532ef6eee41af4035234a0", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "symbol_type": "method", "name": "app_errorhandler", "qualname": "Blueprint.app_errorhandler", "start_line": 596, "end_line": 610, "docstring": "Like :meth:`errorhandler`, but for every request, not only those handled by\nthe blueprint. Equivalent to :meth:`.Flask.errorhandler`.", "code": "    def app_errorhandler(\n        self, code: type[Exception] | int\n    ) -> t.Callable[[T_error_handler], T_error_handler]:\n        \"\"\"Like :meth:`errorhandler`, but for every request, not only those handled by\n        the blueprint. Equivalent to :meth:`.Flask.errorhandler`.\n        \"\"\"\n\n        def decorator(f: T_error_handler) -> T_error_handler:\n            def from_blueprint(state: BlueprintSetupState) -> None:\n                state.app.errorhandler(code)(f)\n\n            self.record_once(from_blueprint)\n            return f\n\n        return decorator", "code_truncated": false}
{"chunk_id": "6191cddbe7cb97660d4272b5315e9df7db50b0ec", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "symbol_type": "method", "name": "app_url_value_preprocessor", "qualname": "Blueprint.app_url_value_preprocessor", "start_line": 613, "end_line": 622, "docstring": "Like :meth:`url_value_preprocessor`, but for every request, not only those\nhandled by the blueprint. Equivalent to :meth:`.Flask.url_value_preprocessor`.", "code": "    def app_url_value_preprocessor(\n        self, f: T_url_value_preprocessor\n    ) -> T_url_value_preprocessor:\n        \"\"\"Like :meth:`url_value_preprocessor`, but for every request, not only those\n        handled by the blueprint. Equivalent to :meth:`.Flask.url_value_preprocessor`.\n        \"\"\"\n        self.record_once(\n            lambda s: s.app.url_value_preprocessors.setdefault(None, []).append(f)\n        )\n        return f", "code_truncated": false}
{"chunk_id": "8c67db6e91094948956abd7c6e573ef75dc8be66", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "symbol_type": "method", "name": "app_url_defaults", "qualname": "Blueprint.app_url_defaults", "start_line": 625, "end_line": 632, "docstring": "Like :meth:`url_defaults`, but for every request, not only those handled by\nthe blueprint. Equivalent to :meth:`.Flask.url_defaults`.", "code": "    def app_url_defaults(self, f: T_url_defaults) -> T_url_defaults:\n        \"\"\"Like :meth:`url_defaults`, but for every request, not only those handled by\n        the blueprint. Equivalent to :meth:`.Flask.url_defaults`.\n        \"\"\"\n        self.record_once(\n            lambda s: s.app.url_default_functions.setdefault(None, []).append(f)\n        )\n        return f", "code_truncated": false}
{"chunk_id": "05e91afd01dc698b08ad76bf0adb047235c40edc", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "function", "name": "setupmethod", "qualname": "setupmethod", "start_line": 42, "end_line": 49, "docstring": null, "code": "def setupmethod(f: F) -> F:\n    f_name = f.__name__\n\n    def wrapper_func(self: Scaffold, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        self._check_setup_finished(f_name)\n        return f(self, *args, **kwargs)\n\n    return t.cast(F, update_wrapper(wrapper_func, f))", "code_truncated": false}
{"chunk_id": "8e0ec1897600e6fbc6e4ac95b19400cb38009677", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "class", "name": "Scaffold", "qualname": "Scaffold", "start_line": 52, "end_line": 698, "docstring": "Common behavior shared between :class:`~flask.Flask` and\n:class:`~flask.blueprints.Blueprint`.\n\n:param import_name: The import name of the module where this object\n    is defined. Usually :attr:`__name__` should be used.\n:param static_folder: Path to a folder of static files to serve.\n    If this is set, a static route will be added.\n:param static_url_path: URL prefix for the static route.\n:param template_folder: Path to a folder containing template files.\n    for rendering. If this is set, a Jinja loader will be added.\n:param root_path: The path that static, template, and resource files\n    are relative to. Typically not set, it is discovered based on\n    the ``import_name``.\n\n.. versionadded:: 2.0", "code": "class Scaffold:\n    \"\"\"Common behavior shared between :class:`~flask.Flask` and\n    :class:`~flask.blueprints.Blueprint`.\n\n    :param import_name: The import name of the module where this object\n        is defined. Usually :attr:`__name__` should be used.\n    :param static_folder: Path to a folder of static files to serve.\n        If this is set, a static route will be added.\n    :param static_url_path: URL prefix for the static route.\n    :param template_folder: Path to a folder containing template files.\n        for rendering. If this is set, a Jinja loader will be added.\n    :param root_path: The path that static, template, and resource files\n        are relative to. Typically not set, it is discovered based on\n        the ``import_name``.\n\n    .. versionadded:: 2.0\n    \"\"\"\n\n    cli: Group\n    name: str\n    _static_folder: str | None = None\n    _static_url_path: str | None = None\n\n    def __init__(\n        self,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        root_path: str | None = None,\n    ):\n        #: The name of the package or module that this object belongs\n        #: to. Do not change this once it is set by the constructor.\n        self.import_name = import_name\n\n        self.static_folder = static_folder\n        self.static_url_path = static_url_path\n\n        #: The path to the templates folder, relative to\n        #: :attr:`root_path`, to add to the template loader. ``None`` if\n        #: templates should not be added.\n        self.template_folder = template_folder\n\n        if root_path is None:\n            root_path = get_root_path(self.import_name)\n\n        #: Absolute path to the package on the filesystem. Used to look\n        #: up resources contained in the package.\n        self.root_path = root_path\n\n        #: A dictionary mapping endpoint names to view functions.\n        #:\n        #: To register a view function, use the :meth:`route` decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.view_functions: dict[str, ft.RouteCallable] = {}\n\n        #: A data structure of registered error handlers, in the format\n        #: ``{scope: {code: {class: handler}}}``. The ``scope`` key is\n        #: the name of a blueprint the handlers are active for, or\n        #: ``None`` for all requests. The ``code`` key is the HTTP\n        #: status code for ``HTTPException``, or ``None`` for\n        #: other exceptions. The innermost dictionary maps exception\n        #: classes to handler functions.\n        #:\n        #: To register an error handler, use the :meth:`errorhandler`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.error_handler_spec: dict[\n            ft.AppOrBlueprintKey,\n            dict[int | None, dict[type[Exception], ft.ErrorHandlerCallable]],\n        ] = defaultdict(lambda: defaultdict(dict))\n\n        #: A data structure of functions to call at the beginning of\n        #: each request, in the format ``{scope: [functions]}``. The\n        #: ``scope`` key is the name of a blueprint the functions are\n        #: active for, or ``None`` for all requests.\n        #:\n        #: To register a function, use the :meth:`before_request`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.before_request_funcs: dict[\n            ft.AppOrBlueprintKey, list[ft.BeforeRequestCallable]\n        ] = defaultdict(list)\n\n        #: A data structure of functions to call at the end of each\n        #: request, in the format ``{scope: [functions]}``. The\n        #: ``scope`` key is the name of a blueprint the functions are\n        #: active for, or ``None`` for all requests.\n        #:\n        #: To register a function, use the :meth:`after_request`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.after_request_funcs: dict[\n            ft.AppOrBlueprintKey, list[ft.AfterRequestCallable[t.Any]]\n        ] = defaultdict(list)\n\n        #: A data structure of functions to call at the end of each\n        #: request even if an exception is raised, in the format\n        #: ``{scope: [functions]}``. The ``scope`` key is the name of a\n        #: blueprint the functions are active for, or ``None`` for all\n        #: requests.\n        #:\n        #: To register a function, use the :meth:`teardown_request`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.teardown_request_funcs: dict[\n            ft.AppOrBlueprintKey, list[ft.TeardownCallable]\n        ] = defaultdict(list)\n\n        #: A data structure of functions to call to pass extra context\n        #: values when rendering templates, in the format\n        #: ``{scope: [functions]}``. The ``scope`` key is the name of a\n        #: blueprint the functions are active for, or ``None`` for all\n        #: requests.\n        #:\n        #: To register a function, use the :meth:`context_processor`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.template_context_processors: dict[\n            ft.AppOrBlueprintKey, list[ft.TemplateContextProcessorCallable]\n        ] = defaultdict(list, {None: [_default_template_ctx_processor]})\n\n        #: A data structure of functions to call to modify the keyword\n        #: arguments passed to the view function, in the format\n        #: ``{scope: [functions]}``. The ``scope`` key is the name of a\n        #: blueprint the functions are active for, or ``None`` for all\n        #: requests.\n        #:\n        #: To register a function, use the\n        #: :meth:`url_value_preprocessor` decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.url_value_preprocessors: dict[\n            ft.AppOrBlueprintKey,\n            list[ft.URLValuePreprocessorCallable],\n        ] = defaultdict(list)\n\n        #: A data structure of functions to call to modify the keyword\n        #: arguments when generating URLs, in the format\n        #: ``{scope: [functions]}``. The ``scope`` key is the name of a\n        #: blueprint the functions are active for, or ``None`` for all\n        #: requests.\n        #:\n        #: To register a function, use the :meth:`url_defaults`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.url_default_functions: dict[\n            ft.AppOrBlueprintKey, list[ft.URLDefaultCallable]\n        ] = defaultdict(list)\n\n    def __repr__(self) -> str:\n        return f\"<{type(self).__name__} {self.name!r}>\"\n\n    def _check_setup_finished(self, f_name: str) -> None:\n        raise NotImplementedError\n\n    @property\n    def static_folder(self) -> str | None:\n        \"\"\"The absolute path to the configured static folder. ``None``\n        if no static folder is set.\n        \"\"\"\n        if self._static_folder is not None:\n            return os.path.join(self.root_path, self._static_folder)\n        else:\n            return None\n\n    @static_folder.setter\n    def static_folder(self, value: str | os.PathLike[str] | None) -> None:\n        if value is not None:\n            value = os.fspath(value).rstrip(r\"\\/\")\n\n        self._static_folder = value\n\n    @property\n    def has_static_folder(self) -> bool\n...<truncated>...\n", "code_truncated": true}
{"chunk_id": "249b7c49c275bc4a8326279c76c88b136abf4c1b", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "method", "name": "__init__", "qualname": "Scaffold.__init__", "start_line": 75, "end_line": 215, "docstring": null, "code": "    def __init__(\n        self,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        root_path: str | None = None,\n    ):\n        #: The name of the package or module that this object belongs\n        #: to. Do not change this once it is set by the constructor.\n        self.import_name = import_name\n\n        self.static_folder = static_folder\n        self.static_url_path = static_url_path\n\n        #: The path to the templates folder, relative to\n        #: :attr:`root_path`, to add to the template loader. ``None`` if\n        #: templates should not be added.\n        self.template_folder = template_folder\n\n        if root_path is None:\n            root_path = get_root_path(self.import_name)\n\n        #: Absolute path to the package on the filesystem. Used to look\n        #: up resources contained in the package.\n        self.root_path = root_path\n\n        #: A dictionary mapping endpoint names to view functions.\n        #:\n        #: To register a view function, use the :meth:`route` decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.view_functions: dict[str, ft.RouteCallable] = {}\n\n        #: A data structure of registered error handlers, in the format\n        #: ``{scope: {code: {class: handler}}}``. The ``scope`` key is\n        #: the name of a blueprint the handlers are active for, or\n        #: ``None`` for all requests. The ``code`` key is the HTTP\n        #: status code for ``HTTPException``, or ``None`` for\n        #: other exceptions. The innermost dictionary maps exception\n        #: classes to handler functions.\n        #:\n        #: To register an error handler, use the :meth:`errorhandler`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.error_handler_spec: dict[\n            ft.AppOrBlueprintKey,\n            dict[int | None, dict[type[Exception], ft.ErrorHandlerCallable]],\n        ] = defaultdict(lambda: defaultdict(dict))\n\n        #: A data structure of functions to call at the beginning of\n        #: each request, in the format ``{scope: [functions]}``. The\n        #: ``scope`` key is the name of a blueprint the functions are\n        #: active for, or ``None`` for all requests.\n        #:\n        #: To register a function, use the :meth:`before_request`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.before_request_funcs: dict[\n            ft.AppOrBlueprintKey, list[ft.BeforeRequestCallable]\n        ] = defaultdict(list)\n\n        #: A data structure of functions to call at the end of each\n        #: request, in the format ``{scope: [functions]}``. The\n        #: ``scope`` key is the name of a blueprint the functions are\n        #: active for, or ``None`` for all requests.\n        #:\n        #: To register a function, use the :meth:`after_request`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.after_request_funcs: dict[\n            ft.AppOrBlueprintKey, list[ft.AfterRequestCallable[t.Any]]\n        ] = defaultdict(list)\n\n        #: A data structure of functions to call at the end of each\n        #: request even if an exception is raised, in the format\n        #: ``{scope: [functions]}``. The ``scope`` key is the name of a\n        #: blueprint the functions are active for, or ``None`` for all\n        #: requests.\n        #:\n        #: To register a function, use the :meth:`teardown_request`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.teardown_request_funcs: dict[\n            ft.AppOrBlueprintKey, list[ft.TeardownCallable]\n        ] = defaultdict(list)\n\n        #: A data structure of functions to call to pass extra context\n        #: values when rendering templates, in the format\n        #: ``{scope: [functions]}``. The ``scope`` key is the name of a\n        #: blueprint the functions are active for, or ``None`` for all\n        #: requests.\n        #:\n        #: To register a function, use the :meth:`context_processor`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.template_context_processors: dict[\n            ft.AppOrBlueprintKey, list[ft.TemplateContextProcessorCallable]\n        ] = defaultdict(list, {None: [_default_template_ctx_processor]})\n\n        #: A data structure of functions to call to modify the keyword\n        #: arguments passed to the view function, in the format\n        #: ``{scope: [functions]}``. The ``scope`` key is the name of a\n        #: blueprint the functions are active for, or ``None`` for all\n        #: requests.\n        #:\n        #: To register a function, use the\n        #: :meth:`url_value_preprocessor` decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.url_value_preprocessors: dict[\n            ft.AppOrBlueprintKey,\n            list[ft.URLValuePreprocessorCallable],\n        ] = defaultdict(list)\n\n        #: A data structure of functions to call to modify the keyword\n        #: arguments when generating URLs, in the format\n        #: ``{scope: [functions]}``. The ``scope`` key is the name of a\n        #: blueprint the functions are active for, or ``None`` for all\n        #: requests.\n        #:\n        #: To register a function, use the :meth:`url_defaults`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.url_default_functions: dict[\n            ft.AppOrBlueprintKey, list[ft.URLDefaultCallable]\n        ] = defaultdict(list)", "code_truncated": false}
{"chunk_id": "611beb9a02b1d71cd2cead88a75f3abc9b658053", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "method", "name": "__repr__", "qualname": "Scaffold.__repr__", "start_line": 217, "end_line": 218, "docstring": null, "code": "    def __repr__(self) -> str:\n        return f\"<{type(self).__name__} {self.name!r}>\"", "code_truncated": false}
{"chunk_id": "03d086c77c070722ef1941cff00694f8754498de", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "method", "name": "_check_setup_finished", "qualname": "Scaffold._check_setup_finished", "start_line": 220, "end_line": 221, "docstring": null, "code": "    def _check_setup_finished(self, f_name: str) -> None:\n        raise NotImplementedError", "code_truncated": false}
{"chunk_id": "9247c94e92f20fdc343e7ab179357f8ac934eadb", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "method", "name": "static_folder", "qualname": "Scaffold.static_folder", "start_line": 224, "end_line": 231, "docstring": "The absolute path to the configured static folder. ``None``\nif no static folder is set.", "code": "    def static_folder(self) -> str | None:\n        \"\"\"The absolute path to the configured static folder. ``None``\n        if no static folder is set.\n        \"\"\"\n        if self._static_folder is not None:\n            return os.path.join(self.root_path, self._static_folder)\n        else:\n            return None", "code_truncated": false}
{"chunk_id": "69be2bba82b3b6ca75ac3001ae180933808a41a9", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "method", "name": "static_folder", "qualname": "Scaffold.static_folder", "start_line": 234, "end_line": 238, "docstring": null, "code": "    def static_folder(self, value: str | os.PathLike[str] | None) -> None:\n        if value is not None:\n            value = os.fspath(value).rstrip(r\"\\/\")\n\n        self._static_folder = value", "code_truncated": false}
{"chunk_id": "d9156a1a6be2d48c54e7ad4e85e58a0c8f619c85", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "method", "name": "has_static_folder", "qualname": "Scaffold.has_static_folder", "start_line": 241, "end_line": 246, "docstring": "``True`` if :attr:`static_folder` is set.\n\n.. versionadded:: 0.5", "code": "    def has_static_folder(self) -> bool:\n        \"\"\"``True`` if :attr:`static_folder` is set.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        return self.static_folder is not None", "code_truncated": false}
{"chunk_id": "98d2b9e24c28a5eab62c9c8ef2656e02120fccb9", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "method", "name": "static_url_path", "qualname": "Scaffold.static_url_path", "start_line": 249, "end_line": 262, "docstring": "The URL prefix that the static route will be accessible from.\n\nIf it was not configured during init, it is derived from\n:attr:`static_folder`.", "code": "    def static_url_path(self) -> str | None:\n        \"\"\"The URL prefix that the static route will be accessible from.\n\n        If it was not configured during init, it is derived from\n        :attr:`static_folder`.\n        \"\"\"\n        if self._static_url_path is not None:\n            return self._static_url_path\n\n        if self.static_folder is not None:\n            basename = os.path.basename(self.static_folder)\n            return f\"/{basename}\".rstrip(\"/\")\n\n        return None", "code_truncated": false}
{"chunk_id": "55a983241687196d6d93fc5dc2c071361c24b2f9", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "method", "name": "static_url_path", "qualname": "Scaffold.static_url_path", "start_line": 265, "end_line": 269, "docstring": null, "code": "    def static_url_path(self, value: str | None) -> None:\n        if value is not None:\n            value = value.rstrip(\"/\")\n\n        self._static_url_path = value", "code_truncated": false}
{"chunk_id": "4f5cc157cb71fb544b624cb9305b25f857925881", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "method", "name": "jinja_loader", "qualname": "Scaffold.jinja_loader", "start_line": 272, "end_line": 282, "docstring": "The Jinja loader for this object's templates. By default this\nis a class :class:`jinja2.loaders.FileSystemLoader` to\n:attr:`template_folder` if it is set.\n\n.. versionadded:: 0.5", "code": "    def jinja_loader(self) -> BaseLoader | None:\n        \"\"\"The Jinja loader for this object's templates. By default this\n        is a class :class:`jinja2.loaders.FileSystemLoader` to\n        :attr:`template_folder` if it is set.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        if self.template_folder is not None:\n            return FileSystemLoader(os.path.join(self.root_path, self.template_folder))\n        else:\n            return None", "code_truncated": false}
{"chunk_id": "4af640e7e06d11cdf8ea784937fe3d22f46c5e4d", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "method", "name": "_method_route", "qualname": "Scaffold._method_route", "start_line": 284, "end_line": 293, "docstring": null, "code": "    def _method_route(\n        self,\n        method: str,\n        rule: str,\n        options: dict[str, t.Any],\n    ) -> t.Callable[[T_route], T_route]:\n        if \"methods\" in options:\n            raise TypeError(\"Use the 'route' decorator to use the 'methods' argument.\")\n\n        return self.route(rule, methods=[method], **options)", "code_truncated": false}
{"chunk_id": "0747d75901073e225a4c23c21f6cf4f83cafadda", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "method", "name": "get", "qualname": "Scaffold.get", "start_line": 296, "end_line": 301, "docstring": "Shortcut for :meth:`route` with ``methods=[\"GET\"]``.\n\n.. versionadded:: 2.0", "code": "    def get(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"GET\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"GET\", rule, options)", "code_truncated": false}
{"chunk_id": "1119173357bbfc9df42dd4d116a7159bc7f00d8b", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "method", "name": "post", "qualname": "Scaffold.post", "start_line": 304, "end_line": 309, "docstring": "Shortcut for :meth:`route` with ``methods=[\"POST\"]``.\n\n.. versionadded:: 2.0", "code": "    def post(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"POST\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"POST\", rule, options)", "code_truncated": false}
{"chunk_id": "af1b9bc776d2e8aaf509de16ff78884cc4b66673", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "method", "name": "put", "qualname": "Scaffold.put", "start_line": 312, "end_line": 317, "docstring": "Shortcut for :meth:`route` with ``methods=[\"PUT\"]``.\n\n.. versionadded:: 2.0", "code": "    def put(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"PUT\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"PUT\", rule, options)", "code_truncated": false}
{"chunk_id": "0e53684e4adc2cf5290f6a4274bd7f8f7e73adf0", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "method", "name": "delete", "qualname": "Scaffold.delete", "start_line": 320, "end_line": 325, "docstring": "Shortcut for :meth:`route` with ``methods=[\"DELETE\"]``.\n\n.. versionadded:: 2.0", "code": "    def delete(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"DELETE\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"DELETE\", rule, options)", "code_truncated": false}
{"chunk_id": "314078b6d2ad097294306e03a03fa1b2e1b9a6b2", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "method", "name": "patch", "qualname": "Scaffold.patch", "start_line": 328, "end_line": 333, "docstring": "Shortcut for :meth:`route` with ``methods=[\"PATCH\"]``.\n\n.. versionadded:: 2.0", "code": "    def patch(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"PATCH\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"PATCH\", rule, options)", "code_truncated": false}
{"chunk_id": "5459d1828a8ff0c86a4589cf51f5570b17081caa", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "method", "name": "route", "qualname": "Scaffold.route", "start_line": 336, "end_line": 365, "docstring": "Decorate a view function to register it with the given URL\nrule and options. Calls :meth:`add_url_rule`, which has more\ndetails about the implementation.\n\n.. code-block:: python\n\n    @app.route(\"/\")\n    def index():\n        return \"Hello, World!\"\n\nSee :ref:`url-route-registrations`.\n\nThe endpoint name for the route defaults to the name of the view\nfunction if the ``endpoint`` parameter isn't passed.\n\nThe ``methods`` parameter defaults to ``[\"GET\"]``. ``HEAD`` and\n``OPTIONS`` are added automatically.\n\n:param rule: The URL rule string.\n:param options: Extra options passed to the\n    :class:`~werkzeug.routing.Rule` object.", "code": "    def route(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Decorate a view function to register it with the given URL\n        rule and options. Calls :meth:`add_url_rule`, which has more\n        details about the implementation.\n\n        .. code-block:: python\n\n            @app.route(\"/\")\n            def index():\n                return \"Hello, World!\"\n\n        See :ref:`url-route-registrations`.\n\n        The endpoint name for the route defaults to the name of the view\n        function if the ``endpoint`` parameter isn't passed.\n\n        The ``methods`` parameter defaults to ``[\"GET\"]``. ``HEAD`` and\n        ``OPTIONS`` are added automatically.\n\n        :param rule: The URL rule string.\n        :param options: Extra options passed to the\n            :class:`~werkzeug.routing.Rule` object.\n        \"\"\"\n\n        def decorator(f: T_route) -> T_route:\n            endpoint = options.pop(\"endpoint\", None)\n            self.add_url_rule(rule, endpoint, f, **options)\n            return f\n\n        return decorator", "code_truncated": false}
{"chunk_id": "7babe777293f2a8cca496c96ddc8706eede1c771", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "method", "name": "add_url_rule", "qualname": "Scaffold.add_url_rule", "start_line": 368, "end_line": 433, "docstring": "Register a rule for routing incoming requests and building\nURLs. The :meth:`route` decorator is a shortcut to call this\nwith the ``view_func`` argument. These are equivalent:\n\n.. code-block:: python\n\n    @app.route(\"/\")\n    def index():\n        ...\n\n.. code-block:: python\n\n    def index():\n        ...\n\n    app.add_url_rule(\"/\", view_func=index)\n\nSee :ref:`url-route-registrations`.\n\nThe endpoint name for the route defaults to the name of the view\nfunction if the ``endpoint`` parameter isn't passed. An error\nwill be raised if a function has already been registered for the\nendpoint.\n\nThe ``methods`` parameter defaults to ``[\"GET\"]``. ``HEAD`` is\nalways added automatically, and ``OPTIONS`` is added\nautomatically by default.\n\n``view_func`` does not necessarily need to be passed, but if the\nrule should participate in routing an endpoint name must be\nassociated with a view function at some point with the\n:meth:`endpoint` decorator.\n\n.. code-block:: python\n\n    app.add_url_rule(\"/\", endpoint=\"index\")\n\n    @app.endpoint(\"index\")\n    def index():\n        ...\n\nIf ``view_func`` has a ``required_methods`` attribute, those\nmethods are added to the passed and automatic methods. If it\nhas a ``provide_automatic_methods`` attribute, it is used as the\ndefault if the parameter is not passed.\n\n:param rule: The URL rule string.\n:param endpoint: The endpoint name to associate with the rule\n    and view function. Used when routing and building URLs.\n    Defaults to ``view_func.__name__``.\n:param view_func: The view function to associate with the\n    endpoint name.\n:param provide_automatic_options: Add the ``OPTIONS`` method and\n    respond to ``OPTIONS`` requests automatically.\n:param options: Extra options passed to the\n    :class:`~werkzeug.routing.Rule` object.", "code": "    def add_url_rule(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        provide_automatic_options: bool | None = None,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"Register a rule for routing incoming requests and building\n        URLs. The :meth:`route` decorator is a shortcut to call this\n        with the ``view_func`` argument. These are equivalent:\n\n        .. code-block:: python\n\n            @app.route(\"/\")\n            def index():\n                ...\n\n        .. code-block:: python\n\n            def index():\n                ...\n\n            app.add_url_rule(\"/\", view_func=index)\n\n        See :ref:`url-route-registrations`.\n\n        The endpoint name for the route defaults to the name of the view\n        function if the ``endpoint`` parameter isn't passed. An error\n        will be raised if a function has already been registered for the\n        endpoint.\n\n        The ``methods`` parameter defaults to ``[\"GET\"]``. ``HEAD`` is\n        always added automatically, and ``OPTIONS`` is added\n        automatically by default.\n\n        ``view_func`` does not necessarily need to be passed, but if the\n        rule should participate in routing an endpoint name must be\n        associated with a view function at some point with the\n        :meth:`endpoint` decorator.\n\n        .. code-block:: python\n\n            app.add_url_rule(\"/\", endpoint=\"index\")\n\n            @app.endpoint(\"index\")\n            def index():\n                ...\n\n        If ``view_func`` has a ``required_methods`` attribute, those\n        methods are added to the passed and automatic methods. If it\n        has a ``provide_automatic_methods`` attribute, it is used as the\n        default if the parameter is not passed.\n\n        :param rule: The URL rule string.\n        :param endpoint: The endpoint name to associate with the rule\n            and view function. Used when routing and building URLs.\n            Defaults to ``view_func.__name__``.\n        :param view_func: The view function to associate with the\n            endpoint name.\n        :param provide_automatic_options: Add the ``OPTIONS`` method and\n            respond to ``OPTIONS`` requests automatically.\n        :param options: Extra options passed to the\n            :class:`~werkzeug.routing.Rule` object.\n        \"\"\"\n        raise NotImplementedError", "code_truncated": false}
{"chunk_id": "4f21ccb0551be74d522c0fbca88828609f6503fb", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "method", "name": "endpoint", "qualname": "Scaffold.endpoint", "start_line": 436, "end_line": 457, "docstring": "Decorate a view function to register it for the given\nendpoint. Used if a rule is added without a ``view_func`` with\n:meth:`add_url_rule`.\n\n.. code-block:: python\n\n    app.add_url_rule(\"/ex\", endpoint=\"example\")\n\n    @app.endpoint(\"example\")\n    def example():\n        ...\n\n:param endpoint: The endpoint name to associate with the view\n    function.", "code": "    def endpoint(self, endpoint: str) -> t.Callable[[F], F]:\n        \"\"\"Decorate a view function to register it for the given\n        endpoint. Used if a rule is added without a ``view_func`` with\n        :meth:`add_url_rule`.\n\n        .. code-block:: python\n\n            app.add_url_rule(\"/ex\", endpoint=\"example\")\n\n            @app.endpoint(\"example\")\n            def example():\n                ...\n\n        :param endpoint: The endpoint name to associate with the view\n            function.\n        \"\"\"\n\n        def decorator(f: F) -> F:\n            self.view_functions[endpoint] = f\n            return f\n\n        return decorator", "code_truncated": false}
{"chunk_id": "4c2970425ab41d4079ee04af35417a1ed242cf16", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "method", "name": "before_request", "qualname": "Scaffold.before_request", "start_line": 460, "end_line": 484, "docstring": "Register a function to run before each request.\n\nFor example, this can be used to open a database connection, or\nto load the logged in user from the session.\n\n.. code-block:: python\n\n    @app.before_request\n    def load_user():\n        if \"user_id\" in session:\n            g.user = db.session.get(session[\"user_id\"])\n\nThe function will be called without any arguments. If it returns\na non-``None`` value, the value is handled as if it was the\nreturn value from the view, and further request handling is\nstopped.\n\nThis is available on both app and blueprint objects. When used on an app, this\nexecutes before every request. When used on a blueprint, this executes before\nevery request that the blueprint handles. To register with a blueprint and\nexecute before every request, use :meth:`.Blueprint.before_app_request`.", "code": "    def before_request(self, f: T_before_request) -> T_before_request:\n        \"\"\"Register a function to run before each request.\n\n        For example, this can be used to open a database connection, or\n        to load the logged in user from the session.\n\n        .. code-block:: python\n\n            @app.before_request\n            def load_user():\n                if \"user_id\" in session:\n                    g.user = db.session.get(session[\"user_id\"])\n\n        The function will be called without any arguments. If it returns\n        a non-``None`` value, the value is handled as if it was the\n        return value from the view, and further request handling is\n        stopped.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        executes before every request. When used on a blueprint, this executes before\n        every request that the blueprint handles. To register with a blueprint and\n        execute before every request, use :meth:`.Blueprint.before_app_request`.\n        \"\"\"\n        self.before_request_funcs.setdefault(None, []).append(f)\n        return f", "code_truncated": false}
{"chunk_id": "d87ae98730a1c6ae7bb9935dedf725e0096089fe", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "method", "name": "after_request", "qualname": "Scaffold.after_request", "start_line": 487, "end_line": 505, "docstring": "Register a function to run after each request to this object.\n\nThe function is called with the response object, and must return\na response object. This allows the functions to modify or\nreplace the response before it is sent.\n\nIf a function raises an exception, any remaining\n``after_request`` functions will not be called. Therefore, this\nshould not be used for actions that must execute, such as to\nclose resources. Use :meth:`teardown_request` for that.\n\nThis is available on both app and blueprint objects. When used on an app, this\nexecutes after every request. When used on a blueprint, this executes after\nevery request that the blueprint handles. To register with a blueprint and\nexecute after every request, use :meth:`.Blueprint.after_app_request`.", "code": "    def after_request(self, f: T_after_request) -> T_after_request:\n        \"\"\"Register a function to run after each request to this object.\n\n        The function is called with the response object, and must return\n        a response object. This allows the functions to modify or\n        replace the response before it is sent.\n\n        If a function raises an exception, any remaining\n        ``after_request`` functions will not be called. Therefore, this\n        should not be used for actions that must execute, such as to\n        close resources. Use :meth:`teardown_request` for that.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        executes after every request. When used on a blueprint, this executes after\n        every request that the blueprint handles. To register with a blueprint and\n        execute after every request, use :meth:`.Blueprint.after_app_request`.\n        \"\"\"\n        self.after_request_funcs.setdefault(None, []).append(f)\n        return f", "code_truncated": false}
{"chunk_id": "4a74154eeeef49e5968ba1beb8e36cd6bf8d29de", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "method", "name": "teardown_request", "qualname": "Scaffold.teardown_request", "start_line": 508, "end_line": 539, "docstring": "Register a function to be called when the request context is\npopped. Typically this happens at the end of each request, but\ncontexts may be pushed manually as well during testing.\n\n.. code-block:: python\n\n    with app.test_request_context():\n        ...\n\nWhen the ``with`` block exits (or ``ctx.pop()`` is called), the\nteardown functions are called just before the request context is\nmade inactive.\n\nWhen a teardown function was called because of an unhandled\nexception it will be passed an error object. If an\n:meth:`errorhandler` is registered, it will handle the exception\nand the teardown will not receive it.\n\nTeardown functions must avoid raising exceptions. If they\nexecute code that might fail they must surround that code with a\n``try``/``except`` block and log any errors.\n\nThe return values of teardown functions are ignored.\n\nThis is available on both app and blueprint objects. When used on an app, this\nexecutes after every request. When used on a blueprint, this executes after\nevery request that the blueprint handles. To register with a blueprint and\nexecute after every request, use :meth:`.Blueprint.teardown_app_request`.", "code": "    def teardown_request(self, f: T_teardown) -> T_teardown:\n        \"\"\"Register a function to be called when the request context is\n        popped. Typically this happens at the end of each request, but\n        contexts may be pushed manually as well during testing.\n\n        .. code-block:: python\n\n            with app.test_request_context():\n                ...\n\n        When the ``with`` block exits (or ``ctx.pop()`` is called), the\n        teardown functions are called just before the request context is\n        made inactive.\n\n        When a teardown function was called because of an unhandled\n        exception it will be passed an error object. If an\n        :meth:`errorhandler` is registered, it will handle the exception\n        and the teardown will not receive it.\n\n        Teardown functions must avoid raising exceptions. If they\n        execute code that might fail they must surround that code with a\n        ``try``/``except`` block and log any errors.\n\n        The return values of teardown functions are ignored.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        executes after every request. When used on a blueprint, this executes after\n        every request that the blueprint handles. To register with a blueprint and\n        execute after every request, use :meth:`.Blueprint.teardown_app_request`.\n        \"\"\"\n        self.teardown_request_funcs.setdefault(None, []).append(f)\n        return f", "code_truncated": false}
{"chunk_id": "497a3c90d82eeb8caa272503f2864e4ae4c8a96b", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "method", "name": "context_processor", "qualname": "Scaffold.context_processor", "start_line": 542, "end_line": 556, "docstring": "Registers a template context processor function. These functions run before\nrendering a template. The keys of the returned dict are added as variables\navailable in the template.\n\nThis is available on both app and blueprint objects. When used on an app, this\nis called for every rendered template. When used on a blueprint, this is called\nfor templates rendered from the blueprint's views. To register with a blueprint\nand affect every template, use :meth:`.Blueprint.app_context_processor`.", "code": "    def context_processor(\n        self,\n        f: T_template_context_processor,\n    ) -> T_template_context_processor:\n        \"\"\"Registers a template context processor function. These functions run before\n        rendering a template. The keys of the returned dict are added as variables\n        available in the template.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        is called for every rendered template. When used on a blueprint, this is called\n        for templates rendered from the blueprint's views. To register with a blueprint\n        and affect every template, use :meth:`.Blueprint.app_context_processor`.\n        \"\"\"\n        self.template_context_processors[None].append(f)\n        return f", "code_truncated": false}
{"chunk_id": "8f4d6c85195c17a8b0a97f7f7320bf216bd6e334", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "method", "name": "url_value_preprocessor", "qualname": "Scaffold.url_value_preprocessor", "start_line": 559, "end_line": 581, "docstring": "Register a URL value preprocessor function for all view\nfunctions in the application. These functions will be called before the\n:meth:`before_request` functions.\n\nThe function can modify the values captured from the matched url before\nthey are passed to the view. For example, this can be used to pop a\ncommon language code value and place it in ``g`` rather than pass it to\nevery view.\n\nThe function is passed the endpoint name and values dict. The return\nvalue is ignored.\n\nThis is available on both app and blueprint objects. When used on an app, this\nis called for every request. When used on a blueprint, this is called for\nrequests that the blueprint handles. To register with a blueprint and affect\nevery request, use :meth:`.Blueprint.app_url_value_preprocessor`.", "code": "    def url_value_preprocessor(\n        self,\n        f: T_url_value_preprocessor,\n    ) -> T_url_value_preprocessor:\n        \"\"\"Register a URL value preprocessor function for all view\n        functions in the application. These functions will be called before the\n        :meth:`before_request` functions.\n\n        The function can modify the values captured from the matched url before\n        they are passed to the view. For example, this can be used to pop a\n        common language code value and place it in ``g`` rather than pass it to\n        every view.\n\n        The function is passed the endpoint name and values dict. The return\n        value is ignored.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        is called for every request. When used on a blueprint, this is called for\n        requests that the blueprint handles. To register with a blueprint and affect\n        every request, use :meth:`.Blueprint.app_url_value_preprocessor`.\n        \"\"\"\n        self.url_value_preprocessors[None].append(f)\n        return f", "code_truncated": false}
{"chunk_id": "a3398dc9a21c2376643493b9811f41a09d376a69", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "method", "name": "url_defaults", "qualname": "Scaffold.url_defaults", "start_line": 584, "end_line": 595, "docstring": "Callback function for URL defaults for all view functions of the\napplication.  It's called with the endpoint and values and should\nupdate the values passed in place.\n\nThis is available on both app and blueprint objects. When used on an app, this\nis called for every request. When used on a blueprint, this is called for\nrequests that the blueprint handles. To register with a blueprint and affect\nevery request, use :meth:`.Blueprint.app_url_defaults`.", "code": "    def url_defaults(self, f: T_url_defaults) -> T_url_defaults:\n        \"\"\"Callback function for URL defaults for all view functions of the\n        application.  It's called with the endpoint and values and should\n        update the values passed in place.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        is called for every request. When used on a blueprint, this is called for\n        requests that the blueprint handles. To register with a blueprint and affect\n        every request, use :meth:`.Blueprint.app_url_defaults`.\n        \"\"\"\n        self.url_default_functions[None].append(f)\n        return f", "code_truncated": false}
{"chunk_id": "2557f46e899624d3ea41ba8aadb8b5fb7fc38070", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "method", "name": "errorhandler", "qualname": "Scaffold.errorhandler", "start_line": 598, "end_line": 639, "docstring": "Register a function to handle errors by code or exception class.\n\nA decorator that is used to register a function given an\nerror code.  Example::\n\n    @app.errorhandler(404)\n    def page_not_found(error):\n        return 'This page does not exist', 404\n\nYou can also register handlers for arbitrary exceptions::\n\n    @app.errorhandler(DatabaseError)\n    def special_exception_handler(error):\n        return 'Database connection failed', 500\n\nThis is available on both app and blueprint objects. When used on an app, this\ncan handle errors from every request. When used on a blueprint, this can handle\nerrors from requests that the blueprint handles. To register with a blueprint\nand affect every request, use :meth:`.Blueprint.app_errorhandler`.\n\n.. versionadded:: 0.7\n    Use :meth:`register_error_handler` instead of modifying\n    :attr:`error_handler_spec` directly, for application wide error\n    handlers.\n\n.. versionadded:: 0.7\n   One can now additionally also register custom exception types\n   that do not necessarily have to be a subclass of the\n   :class:`~werkzeug.exceptions.HTTPException` class.\n\n:param code_or_exception: the code as integer for the handler, or\n                          an arbitrary exception", "code": "    def errorhandler(\n        self, code_or_exception: type[Exception] | int\n    ) -> t.Callable[[T_error_handler], T_error_handler]:\n        \"\"\"Register a function to handle errors by code or exception class.\n\n        A decorator that is used to register a function given an\n        error code.  Example::\n\n            @app.errorhandler(404)\n            def page_not_found(error):\n                return 'This page does not exist', 404\n\n        You can also register handlers for arbitrary exceptions::\n\n            @app.errorhandler(DatabaseError)\n            def special_exception_handler(error):\n                return 'Database connection failed', 500\n\n        This is available on both app and blueprint objects. When used on an app, this\n        can handle errors from every request. When used on a blueprint, this can handle\n        errors from requests that the blueprint handles. To register with a blueprint\n        and affect every request, use :meth:`.Blueprint.app_errorhandler`.\n\n        .. versionadded:: 0.7\n            Use :meth:`register_error_handler` instead of modifying\n            :attr:`error_handler_spec` directly, for application wide error\n            handlers.\n\n        .. versionadded:: 0.7\n           One can now additionally also register custom exception types\n           that do not necessarily have to be a subclass of the\n           :class:`~werkzeug.exceptions.HTTPException` class.\n\n        :param code_or_exception: the code as integer for the handler, or\n                                  an arbitrary exception\n        \"\"\"\n\n        def decorator(f: T_error_handler) -> T_error_handler:\n            self.register_error_handler(code_or_exception, f)\n            return f\n\n        return decorator", "code_truncated": false}
{"chunk_id": "879153e0105bce6d32f8da3c2fafde3bbacbea79", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "method", "name": "register_error_handler", "qualname": "Scaffold.register_error_handler", "start_line": 642, "end_line": 654, "docstring": "Alternative error attach function to the :meth:`errorhandler`\ndecorator that is more straightforward to use for non decorator\nusage.\n\n.. versionadded:: 0.7", "code": "    def register_error_handler(\n        self,\n        code_or_exception: type[Exception] | int,\n        f: ft.ErrorHandlerCallable,\n    ) -> None:\n        \"\"\"Alternative error attach function to the :meth:`errorhandler`\n        decorator that is more straightforward to use for non decorator\n        usage.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        exc_class, code = self._get_exc_class_and_code(code_or_exception)\n        self.error_handler_spec[None][code][exc_class] = f", "code_truncated": false}
{"chunk_id": "b333352e4473a01a1869157e8a110c69169c963e", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "method", "name": "_get_exc_class_and_code", "qualname": "Scaffold._get_exc_class_and_code", "start_line": 657, "end_line": 698, "docstring": "Get the exception class being handled. For HTTP status codes\nor ``HTTPException`` subclasses, return both the exception and\nstatus code.\n\n:param exc_class_or_code: Any exception class, or an HTTP status\n    code as an integer.", "code": "    def _get_exc_class_and_code(\n        exc_class_or_code: type[Exception] | int,\n    ) -> tuple[type[Exception], int | None]:\n        \"\"\"Get the exception class being handled. For HTTP status codes\n        or ``HTTPException`` subclasses, return both the exception and\n        status code.\n\n        :param exc_class_or_code: Any exception class, or an HTTP status\n            code as an integer.\n        \"\"\"\n        exc_class: type[Exception]\n\n        if isinstance(exc_class_or_code, int):\n            try:\n                exc_class = default_exceptions[exc_class_or_code]\n            except KeyError:\n                raise ValueError(\n                    f\"'{exc_class_or_code}' is not a recognized HTTP\"\n                    \" error code. Use a subclass of HTTPException with\"\n                    \" that code instead.\"\n                ) from None\n        else:\n            exc_class = exc_class_or_code\n\n        if isinstance(exc_class, Exception):\n            raise TypeError(\n                f\"{exc_class!r} is an instance, not a class. Handlers\"\n                \" can only be registered for Exception classes or HTTP\"\n                \" error codes.\"\n            )\n\n        if not issubclass(exc_class, Exception):\n            raise ValueError(\n                f\"'{exc_class.__name__}' is not a subclass of Exception.\"\n                \" Handlers can only be registered for Exception classes\"\n                \" or HTTP error codes.\"\n            )\n\n        if issubclass(exc_class, HTTPException):\n            return exc_class, exc_class.code\n        else:\n            return exc_class, None", "code_truncated": false}
{"chunk_id": "e07696ed4ecf664b480e879d17bfc71d432de4b0", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "function", "name": "_endpoint_from_view_func", "qualname": "_endpoint_from_view_func", "start_line": 701, "end_line": 706, "docstring": "Internal helper that returns the default endpoint for a given\nfunction.  This always is the function name.", "code": "def _endpoint_from_view_func(view_func: ft.RouteCallable) -> str:\n    \"\"\"Internal helper that returns the default endpoint for a given\n    function.  This always is the function name.\n    \"\"\"\n    assert view_func is not None, \"expected view func if endpoint is not provided.\"\n    return view_func.__name__", "code_truncated": false}
{"chunk_id": "7dd242583cf743e623679c1927f3f5481feff401", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "function", "name": "_find_package_path", "qualname": "_find_package_path", "start_line": 709, "end_line": 751, "docstring": "Find the path that contains the package or module.", "code": "def _find_package_path(import_name: str) -> str:\n    \"\"\"Find the path that contains the package or module.\"\"\"\n    root_mod_name, _, _ = import_name.partition(\".\")\n\n    try:\n        root_spec = importlib.util.find_spec(root_mod_name)\n\n        if root_spec is None:\n            raise ValueError(\"not found\")\n    except (ImportError, ValueError):\n        # ImportError: the machinery told us it does not exist\n        # ValueError:\n        #    - the module name was invalid\n        #    - the module name is __main__\n        #    - we raised `ValueError` due to `root_spec` being `None`\n        return os.getcwd()\n\n    if root_spec.submodule_search_locations:\n        if root_spec.origin is None or root_spec.origin == \"namespace\":\n            # namespace package\n            package_spec = importlib.util.find_spec(import_name)\n\n            if package_spec is not None and package_spec.submodule_search_locations:\n                # Pick the path in the namespace that contains the submodule.\n                package_path = pathlib.Path(\n                    os.path.commonpath(package_spec.submodule_search_locations)\n                )\n                search_location = next(\n                    location\n                    for location in root_spec.submodule_search_locations\n                    if package_path.is_relative_to(location)\n                )\n            else:\n                # Pick the first path.\n                search_location = root_spec.submodule_search_locations[0]\n\n            return os.path.dirname(search_location)\n        else:\n            # package with __init__.py\n            return os.path.dirname(os.path.dirname(root_spec.origin))\n    else:\n        # module\n        return os.path.dirname(root_spec.origin)  # type: ignore[type-var, return-value]", "code_truncated": false}
{"chunk_id": "7ff8c2c3890e727a62e6b02d9ef00d0a01a1f4d2", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "symbol_type": "function", "name": "find_package", "qualname": "find_package", "start_line": 754, "end_line": 792, "docstring": "Find the prefix that a package is installed under, and the path\nthat it would be imported from.\n\nThe prefix is the directory containing the standard directory\nhierarchy (lib, bin, etc.). If the package is not installed to the\nsystem (:attr:`sys.prefix`) or a virtualenv (``site-packages``),\n``None`` is returned.\n\nThe path is the entry in :attr:`sys.path` that contains the package\nfor import. If the package is not installed, it's assumed that the\npackage was imported from the current working directory.", "code": "def find_package(import_name: str) -> tuple[str | None, str]:\n    \"\"\"Find the prefix that a package is installed under, and the path\n    that it would be imported from.\n\n    The prefix is the directory containing the standard directory\n    hierarchy (lib, bin, etc.). If the package is not installed to the\n    system (:attr:`sys.prefix`) or a virtualenv (``site-packages``),\n    ``None`` is returned.\n\n    The path is the entry in :attr:`sys.path` that contains the package\n    for import. If the package is not installed, it's assumed that the\n    package was imported from the current working directory.\n    \"\"\"\n    package_path = _find_package_path(import_name)\n    py_prefix = os.path.abspath(sys.prefix)\n\n    # installed to the system\n    if pathlib.PurePath(package_path).is_relative_to(py_prefix):\n        return py_prefix, package_path\n\n    site_parent, site_folder = os.path.split(package_path)\n\n    # installed to a virtualenv\n    if site_folder.lower() == \"site-packages\":\n        parent, folder = os.path.split(site_parent)\n\n        # Windows (prefix/lib/site-packages)\n        if folder.lower() == \"lib\":\n            return parent, package_path\n\n        # Unix (prefix/lib/pythonX.Y/site-packages)\n        if os.path.basename(parent).lower() == \"lib\":\n            return os.path.dirname(parent), package_path\n\n        # something else (prefix/site-packages)\n        return site_parent, package_path\n\n    # not installed\n    return None, package_path", "code_truncated": false}
