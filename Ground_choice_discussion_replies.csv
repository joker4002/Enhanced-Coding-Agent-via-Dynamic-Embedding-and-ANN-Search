id,repo,number,url,created_at,category,reply_count,question_title,question_text,replies_text
1,pallets/flask,5905,https://github.com/orgs/pallets/discussions/5905,2026-01-29T20:42:31Z,Q&A,1,Flask app crashes when using send_file() with BytesIO object in debug mode,"Flask app crashes when using send_file() with BytesIO object in debug mode When using send_file() with a BytesIO object while debug=True, the application raises a ValueError on the second request to the same endpoint. Environment:  Python version: 3.11.4 Flask version: 3.0.2 Werkzeug version: 3.0.1 OS: Ubuntu 22.04  Steps to Reproduce: from flask import Flask, send_file from io import BytesIO  app = Flask(__name__)  @app.route('/download') def download():     buffer = BytesIO()     buffer.write(b'Hello World')     buffer.seek(0)     return send_file(buffer, mimetype='text/plain', download_name='hello.txt')  if __name__ == '__main__':     app.run(debug=True)  Run the app with python app.py Visit http://127.0.0.1:5000/download once (works fine) Refresh the page (crashes)  Expected Behavior: The file should download successfully on every request. Actual Behavior: ValueError: I/O operation on closed file.",[1] davidism: I can't reproduce this issue with the example provided. Multiple requests result in successful responses. There's something else going on beyond what you've shown.
2,pallets/flask,5894,https://github.com/orgs/pallets/discussions/5894,2026-01-22T20:36:33Z,Q&A,1,Issue with send_file() and send_from_directory() not sending,"Issue with send_file() and send_from_directory() not sending I'm following the pattern here to try and send a file from temporary storage and I'm encountering an error that I don't know how to debug.  I was hoping somebody here can help. I have a view function that redirects to a function that calls send_file() (I've tried both send_file() and send_from_directory).  I'm not seeing any exceptions and everything seems to work fine, but the file is not sending.  When I open up dev tools in Chrome or Edge, however i can see the file in the network panel (no error code there either -- it redirected with status code 200). And if I double-click it it will then be downloaded as an attachment.  Any clue why it is not sending automatically?  Not sure if it matters, but I'm using Flask==2.3.2, but I've tried with Flask==3.1.2 as well. Here's the gist of what I'm doing: @app.route('/some-function', methods=['GET','POST']) def some_function():     # some stuff happens (I define filename and do some other simple things)     if request.method == 'POST':         updates = request.data    # get some data  -- this works fine         df = pandas_function(updates)    # do some stuff with that data -- this works fine         df.to_excel(os.path.join(app.cofing['UPLOAD_FOLDER'], filename)  # write file -- this works fine          return redirect(url_for('download_file', filename=filename))     return render_template('some_template.html')  @app.route('/uploads/<filename>') def download_file(filename):     print('i just redirected')    # this prints so it seems like it redirected successfully     return send_from_directory(os.path.join(current_app.root_path, app.config['UPLOAD_FOLDER']), filename, as_attachment=True) Thanks for any help you can offer!","[1] davidism: You're returning text (a URL), not a redirect. Use return redirect(url_for(...))."
3,pallets/flask,5886,https://github.com/orgs/pallets/discussions/5886,2026-01-12T11:59:28Z,Q&A,3,How to add HTML into a Beautiful Table cell?,"How to add HTML into a Beautiful Table cell? Hi, first time question asker here. I am trying to add some HTML code into a table based on Miguel Grinberg's Beautiful basic table.  I am still a novice at Flask, so please forgive me if this is a ""stupid"" question.  When I use the following, the table displays as expected: new gridjs.Grid({ columns: [ { id: 'event_id', name: 'Event ID', sort: false } ... But when I add the following formatter sequence, the table fails to display. new gridjs.Grid({ columns: [ { id: 'event_id', name: 'Event ID', sort: false, formatter: (cell) => html('${cell}') }, ... What am I doing wrong?  Is there a way to add HTML (and specifically href) to a table cell? Thank you for your time and consideration. Best regards, ET","[1] miguelgrinberg: See this example, which inserts an email link in a table cell. In your example above you appear to be using single quotes inside the html() function. If you want to use JS template expressions you have to use back ticks instead. Finally, if your cell variable has HTML code, be very careful of introducing XSS vulnerabilities in your code. I suggest you use an approach more similar to the one I linked, where the cell value is just data, and the HTML markup is added by you explicitly.  [2] etwakaoz: Miguel, thank you very much for your help.  I'm almost there :-).  I got the formatter to work and able to create an href.  But now I would like to pass a parameter to my url.  I thought something like the following would work, but it looks like the '$' is unexpected by jinja. const url = {{ url_for(""judgesdb.update_event"", event_id=${cell}) }}; jinja2.exceptions.TemplateSyntaxError: unexpected char '$' looking to use url in html(<a href=""${url}""> ${cell} </a>) }, I'm guessing that jinja doesn't like '$', but do not know how to get around this error.  I'm an old C programmer writing python like C. Thanks for any help.  [3] etwakaoz: Thanks again for all your help.  I was beginning to think this was the case and now I have to learn JavaScript ."
4,pallets/flask,5862,https://github.com/orgs/pallets/discussions/5862,2025-12-13T10:43:23Z,Ideas,3,Proposal: CLI command to validate API endpoints by making test requests,"Proposal: CLI command to validate API endpoints by making test requests Motivation When working on Flask applications with many API endpoints, it is sometimes useful to quickly check whether all registered routes can be accessed without raising unexpected errors (e.g. unhandled exceptions, 500 errors). At the moment, developers typically need to write custom scripts or tests to perform this kind of basic validation. Providing an opt-in CLI command could help improve developer experience, especially during local development. Proposal Introduce an optional Flask CLI command (for example, flask check-endpoints) that iterates over registered routes and makes test requests using Flaskâ€™s test client. The goal would not be full correctness testing, but a lightweight sanity check to detect obvious runtime errors. Possible initial scope:  Only routes with simple methods (e.g. GET by default) Skip routes with required path parameters Report endpoints that raise exceptions or return 5xx responses Development-only usage  Design considerations  The command should be fully opt-in and not affect existing behavior. No network requests; use Flaskâ€™s built-in test client. Keep output simple and readable (similar to flask routes). Advanced features (custom payloads, auth, etc.) could be out of scope initially.  Open questions  Should this live as a core CLI command or as an optional extension? How should endpoints with required parameters or authentication be handled? Should the command fail on the first error or report all failures?  Feedback on the general direction and scope would be appreciated before starting an implementation.","[1] ThiefMaster: I think you could easily create that as a standalone package that integrates in the flask-cli via an entrypoint.  [2] jyup-escape: @ThiefMaster Yes, so I've already created it, and I'd like to discuss here what features would be useful.  [3] jyup-escape: I'll send you a PR for now, so please take a look."
5,pallets/flask,5778,https://github.com/orgs/pallets/discussions/5778,2025-07-18T13:41:52Z,Q&A,1,Memory consumption spikes when an api endpoint with file upload capability is hit.,"Memory consumption spikes when an api endpoint with file upload capability is hit. I have an API application, created using connexion framework, which uses FlaskApp configuration. This app exposes an endpoint where users/consumers can upload artifacts(ranging from 2.5 MB to 400 MB) and they will be then upload to an internal storage platform. The pain point is, when the user selects a larger data file(~320 MB) to upload, the application often runs into OOM issue and eventually user receives 502 status response. Running dmesg command inside containers show the gunicorn thread being killed by oom_killer It would be of great help if someone here could guide in avoiding such OOM issues for Flask Applications. API Specifaction openapi: 3.0.0 info:   description: Description   version: 1.1.1   title:  API  servers:   - url: /api/v1     description: base path for version 1 of the API  components:    responses:     BinaryFile:       description: Content of stored binary file       content:         ""*/*"":           schema:             type: string             format: binary     BadArgument:       description: Request Validation failed       content:         application/json:           schema:             $ref: ""#/components/schemas/Error""     NotFound:       description: Not Found (e.g. for a given Id)       content:         application/json:           schema:             $ref: ""#/components/schemas/Error""     InternalServerError:       description: Internal Server Error       content:         application/json:           schema:             $ref: ""#/components/schemas/Error""     ServiceUnavailable:       description: Service Temporary Unavailable       content:         application/json:           schema:             $ref: ""#/components/schemas/Error""    parameters:     OrganizationId:       name: teamId       in: path       required: true       schema:         type: string         format: path         additionalProperties: false         anyOf:           - $ref: ""#/components/schemas/Id""           - $ref: ""#/components/schemas/TeamId""     TicketId:       name: ticketId       in: path       required: true       schema:         $ref: ""#/components/schemas/Id""     ArtifactDataFileType:       name: dataType       in: path       required: true       schema:         $ref: ""#/components/schemas/ArtifactDataFileType""    schemas:     Id:       description: Unique identifier of a Object/Document/Entity etc       type: string       # On why UUID is used see https://www.cockroachlabs.com/docs/stable/sql-faqs.html#what-are-the-differences-between-uuid-sequences-and-unique_rowid       format: string     SubscriptionType:       description: Subscription type       type: string       enum: [small, medium, large]       nullable: true     ArtifactDataFileType:       type: string       enum: [ artifact ]     TeamId:       type: string       description: Team's unique identifier     # According to ""Problem Details for HTTP APIs"" -> https://tools.ietf.org/html/draft-ietf-appsawg-http-problem-00     Error:       type: object       description: An Error object returned if something went wrong       additionalProperties: true       properties:         detail:           type: string         status:           type: integer         title:           type: string         type:           type: string     ArtifactBodyWithSubscriptionType:       type: object       additionalProperties: false       properties:         data:           type: string           format: binary         subscriptionType:           $ref: ""#/components/schemas/SubscriptionType""   paths:   '/team/{teamId}/ticket/{ticketId}/{dataType}':     parameters:       - $ref: ""#/components/parameters/OrganizationId""       - $ref: ""#/components/parameters/TicketId""       - $ref: ""#/components/parameters/ArtifactDataFileType""     post:       summary: Upload Artifact data file for this Ticket       x-openapi-router-controller: app.operations.epics       operationId: upload_data       requestBody:         required: true         content:           multipart/form-data:             schema:               $ref: '#/components/schemas/ArtifactBodyWithSubscriptionType'       responses:         '201':           description: Uploaded         '400':           $ref: ""#/components/responses/BadArgument""         '404':           $ref: ""#/components/responses/NotFound""         '500':           $ref: ""#/components/responses/InternalServerError""         '503':           $ref: ""#/components/responses/ServiceUnavailable"" Python function import logging from http import HTTPStatus from typing import BinaryIO  from connexion import problem  from app.operations import _not_found from app.models.ticket import Ticket from app.storage import Storages   logger = logging.getLogger(__name__)   class Storages:     """"""     Internal platform to store artifacts.     """"""     def __init__(self, data_path):         self.data_path: str = data_path      def save(self, data_path: str, data: BinaryIO):         """"""         API call to internal platform to store artifacts.         """"""         pass      def ticket_path(self, ticket: Ticket, data_type):         """"""         Returns the path where the ticket data should be stored.         """"""         # This is a placeholder implementation.         # The actual implementation would return a path based on the ticket and data type.         return f""{self.data_path}/{ticket.id}/{data_type}""   def _get_ticket(params):     """"""     Helper function to retrieve the ticket from the parameters.     """"""     ...     return   def upload_data(**params):     # Checking file     data = params[""data""]     file_name = data.filename     if not file_name:         return problem(HTTPStatus.INTERNAL_SERVER_ERROR, ""Cannot upload file"", ""File is not provided"")      # Checking existence of ticket     ticket = _get_ticket(params)     if not ticket:         return _not_found(Ticket, params[""ticketId""])      # Saving file in storage     data_type = params[""dataType""]      try:         storage = Storages(data_path=""/path/to/storage/on/internal/platform""),         data_path = storage.ticket_path(ticket, data_type)         storage.save(data_path, data)     except Exception as ex:         logger.error(f""cannot upload file into storage: {ex}"", exc_info=True)         return problem(HTTPStatus.INTERNAL_SERVER_ERROR, ""Cannot upload file"", ""Problems with storage"")      return None, HTTPStatus.CREATED Pipfile [[source]] url = ""https://pypi.org/simple/"" verify_ssl = true name = ""pypi""  [requires] python_version = ""3.11""  [packages] backoff = ""~=2.2.0"" boto3 = ""~=1.26.0"" connexion = {extras = [""flask"", ""uvicorn"", ""swagger-ui""],version = ""~=3.2.0""} gunicorn = {extras = [""gevent""],version = ""~=23.0.0""} aiohttp = ""~=3.10.10"" aiohttp_retry = ""~=2.8.3"" greenlet = ""==3.1.1"" kubernetes = ""~=24.0"" psycopg-c = ""~=3.2.2"" psycopg-pool = ""~=3.2.3"" rfc3339-validator = ""~=0.1.0"" shapely = ""~=2.1.0"" jsonschema = ""~=4.23.0""  Application startup command python -m gunicorn --worker-class uvicorn.workers.UvicornWorker --workers 5 --bind 0.0.0.0:$PORT --access-logfile - --access-logformat ""%(t)s %(h)s %(l)s %(p)s \""%(m)s %(U)s%(q)s\"" %(s)s %(b)s %(L)s \""%(f)s\"" \""%(a)s\"""" app.wsgi:app Filtered logs [ERROR] Worker (pid:62) was sent SIGKILL! Perhaps out of memory? [INFO] Booting worker with pid: 96 System info:  Application is deployed on Kubernetes. Python version 3.11 Resource allocation:  Memory limit 3GB    In a thread regarding same issue on Connexion forum , I received following feedback: spec-first/connexion#2062 (comment)  FWIW I think this is more a Flask question than a Connexion question. I checked the Flask doc about file upload: https://flask.palletsprojects.com/en/stable/patterns/fileuploads/ There I found this:  So how exactly does Flask handle uploads? Well it will store them in the webserverâ€™s memory if the files are reasonably small, otherwise in a temporary location (as returned by tempfile.gettempdir()). But how do you specify the maximum file size after which an upload is aborted? By default Flask will happily accept file uploads with an unlimited amount of memory, but you can limit that by setting the MAX_CONTENT_LENGTH config key:  I didn't see a way to specify the threshold that Flask uses to decide whether to use a ""temporary location"" instead of memory. Not sure this is really helpful, sorry.  What I'm looking for is recommendations on better implementation to avoid spike in Memory consumption.","[1] yesminehe: Hi @athujoshi24, to fix OOM issues with large file uploads, set app.config['MAX_CONTENT_LENGTH'] = 450 * 1024 * 1024 and override Request._get_file_stream to use disk-based TemporaryFile. Stream uploads in chunks with shutil.copyfileobj(data.stream, f, length=1610241024). Reduce Gunicorn workers to 1 (--workers 1 --preload) and increase Kubernetes memory to 4 GB. Consider NGINX for buffering or S3 presigned URLs for scalability."
6,pallets/flask,5773,https://github.com/orgs/pallets/discussions/5773,2025-07-14T14:48:29Z,Q&A,2,Why does my Flask route return a 405 error when I submit a form?,"Why does my Flask route return a 405 error when I submit a form? I'm using Flask and trying to handle a form submission with POST, but I keep getting a 405 Method Not Allowed error. Here's the basic code: from flask import Flask, request  app = Flask(__name__)  @app.route(""/submit"") def submit():     if request.method == ""POST"":         name = request.form[""name""]         return f""Hello, {name}!""     return ""Invalid method"" I submit the form from an HTML page using method=""POST"", but Flask still returns a 405. What am I doing wrong?","[1] ThiefMaster: Because you need methods=('GET', 'POST') on your route() call to allow POST in addition to GET.  [2] Istituto-freudinttheprodev: Great question! The issue is that your route is only set to accept GET requests by default, since you didnâ€™t specify the allowed methods. To fix the 405 error, you need to explicitly allow POST in the route definition using the methods parameter: @app.route(""/submit"", methods=[""GET"", ""POST""]) def submit():     if request.method == ""POST"":         name = request.form[""name""]         return f""Hello, {name}!""     return ""Invalid method"" This tells Flask to accept both GET and POST requests on that route. Let me know if it works! âœ…"
7,pallets/flask,5771,https://github.com/orgs/pallets/discussions/5771,2025-07-12T06:38:46Z,Q&A,2,flask and pdbpp gives `signal only works in main thread of the main interpreter`,"flask and pdbpp gives `signal only works in main thread of the main interpreter` This is my code example: from flask import Flask  app = Flask(__name__)   @app.route(""/status"") def status():     breakpoint()     return {""status"": ""ok""}   if __name__ == '__main__':     app.run() Accessing /status, I get: -> breakpoint() 127.0.0.1 - - [12/Jul/2025 08:32:24] ""GET /status HTTP/1.1"" 500 - Traceback (most recent call last):   File ""/home/kmille/.cache/pypoetry/virtualenvs/zammad-pgp-autoimport-webhook-jd1kDdnL-py3.13/lib/python3.13/site-packages/flask/app.py"", line 1536, in __call__     return self.wsgi_app(environ, start_response)            ~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^   File ""/home/kmille/.cache/pypoetry/virtualenvs/zammad-pgp-autoimport-webhook-jd1kDdnL-py3.13/lib/python3.13/site-packages/flask/app.py"", line 1514, in wsgi_app     response = self.handle_exception(e)   File ""/home/kmille/.cache/pypoetry/virtualenvs/zammad-pgp-autoimport-webhook-jd1kDdnL-py3.13/lib/python3.13/site-packages/flask/app.py"", line 1511, in wsgi_app     response = self.full_dispatch_request()   File ""/home/kmille/.cache/pypoetry/virtualenvs/zammad-pgp-autoimport-webhook-jd1kDdnL-py3.13/lib/python3.13/site-packages/flask/app.py"", line 919, in full_dispatch_request     rv = self.handle_user_exception(e)   File ""/home/kmille/.cache/pypoetry/virtualenvs/zammad-pgp-autoimport-webhook-jd1kDdnL-py3.13/lib/python3.13/site-packages/flask/app.py"", line 917, in full_dispatch_request     rv = self.dispatch_request()   File ""/home/kmille/.cache/pypoetry/virtualenvs/zammad-pgp-autoimport-webhook-jd1kDdnL-py3.13/lib/python3.13/site-packages/flask/app.py"", line 902, in dispatch_request     return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^   File ""/home/kmille/projects/zammad-pgp-autoimport-webhook/src/zammad_pgp_autoimport_webhook/test_run.py"", line 8, in status     breakpoint()     ~~~~~~~~~~^^   File ""/usr/lib/python3.13/bdb.py"", line 116, in trace_dispatch     return self.dispatch_opcode(frame, arg)            ~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^   File ""/usr/lib/python3.13/bdb.py"", line 215, in dispatch_opcode     self.user_opcode(frame)     ~~~~~~~~~~~~~~~~^^^^^^^   File ""/usr/lib/python3.13/pdb.py"", line 448, in user_line     self.interaction(frame, None)     ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^   File ""/home/kmille/.cache/pypoetry/virtualenvs/zammad-pgp-autoimport-webhook-jd1kDdnL-py3.13/lib/python3.13/site-packages/pdbpp.py"", line 431, in interaction     return self._interaction(frame, tb)            ~~~~~~~~~~~~~~~~~^^^^^^^^^^^   File ""/home/kmille/.cache/pypoetry/virtualenvs/zammad-pgp-autoimport-webhook-jd1kDdnL-py3.13/lib/python3.13/site-packages/pdbpp.py"", line 465, in _interaction     self._cmdloop()     ~~~~~~~~~~~~~^^   File ""/usr/lib/python3.13/pdb.py"", line 511, in _cmdloop     self.cmdloop()     ~~~~~~~~~~~~^^   File ""/usr/lib/python3.13/cmd.py"", line 134, in cmdloop     line = input(self.prompt)   File ""/usr/lib/python3.13/_pyrepl/readline.py"", line 364, in input     reader = self.get_reader()   File ""/usr/lib/python3.13/_pyrepl/readline.py"", line 358, in get_reader     console = Console(self.f_in, self.f_out, encoding=ENCODING)   File ""/usr/lib/python3.13/_pyrepl/unix_console.py"", line 202, in __init__     signal.signal(signal.SIGCONT, self._sigcont_handler)     ~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File ""/usr/lib/python3.13/signal.py"", line 58, in signal     handler = _signal.signal(_enum_to_int(signalnum), _enum_to_int(handler)) ValueError: signal only works in main thread of the main interpreter  Versions I use poetry show -l | grep -e flask -e pdbpp                         flask              3.1.1     3.1.1    A simple framework for building comple... pdbpp              0.11.6    0.11.6   pdb++, a drop-in replacement for pdb  Using Python 3.13.5. Thanks for your help! I'm wondering why I'm the only one having this... Couldn't find something in the web...","[1] yesminehe: The breakpoint() call is meant for interactive debugging and isnâ€™t suitable for a running Flask application, especially in a multi-threaded environment. Remove it from the /status route  [2] kmille: Yea, but I want to debug at some point. And it worked in the past... â€¦ On July 18, 2025 11:49:15 PM GMT+02:00, Yasmine Hichri ***@***.***> wrote: The breakpoint() call is meant for interactive debugging and isnâ€™t suitable for a running Flask application, especially in a multi-threaded environment. Remove it from the /status route  -- Reply to this email directly or view it on GitHub: #5771 (comment) You are receiving this because you authored the thread.  Message ID: ***@***.***>"
8,pallets/flask,5758,https://github.com/orgs/pallets/discussions/5758,2025-06-11T17:15:34Z,Q&A,1,Is there any good way to contribute?,Is there any good way to contribute? I'm new to contributing to big repositories --- is there any good starting points that I could help wth?,"[1] davidism: You can find our contributing guide here: https://palletsprojects.com/contributing/ You won't find much to work on in Flask itself. The front page of the guide provides many ideas, including where to contribute:  Besides the core Pallets projects, there is an entire ecosystem of extensions built on top of them. We also have our own dependencies that we use for our development environment. Improving the ecosystem we're part of is a great way to contribute to Pallets."
9,pallets/flask,5749,https://github.com/orgs/pallets/discussions/5749,2025-06-01T23:28:52Z,Ideas,2,Flask/Werkzeug: Don't send content-type header with 204 response?,"Flask/Werkzeug: Don't send content-type header with 204 response? I received a warning form the Python webtest library when responding with a 204 HTTP status code b/c Flask (or Werkzeug, I didn't dig to find where it happens) adds a Content-Type header by default: ('Content-Type', 'text/html; charset=utf-8'). Led me to a discussion with Claude about what the spec says regarding.  It sounds like it's not prohibited but would make sense to not add the header if the status code is 204. It's a small thing, but should Flask/Werkzeug take the status code into account before adding a content type header?","[1] davidism: Werkzeug Response.default_mimetype sets the Content-Type header when creating a response if it's not given. Response.get_wsgi_headers removes the Content-Length header when sending a 204 response. Content-Length spec directly says that a 204 response must not contain this header, and Werkzeug therefore removes it. Content-Type spec doesn't make any statement about not sending the header. While we do have the logic in place already to do something on certain status codes, I'm wary of adding this. It's not required according to spec, and might result in more requests to remove other headers despite the spec not requiring it. If you're commonly sending 204 responses, you can write a helper to produce a response in the exact form you need: def make_204(...):     response = Response(status=204)     del response.headers[""content-type""]     ...     return response You can also override Flask.response_class, or Flask.make_response, to add extra behaviors you need.  [2] rsyring: It's not required according to spec, and might result in more requests to remove other headers despite the spec not requiring it.  Fair enough.  :) Thanks for the discussion and suggestions you provided."
10,pallets/flask,5744,https://github.com/orgs/pallets/discussions/5744,2025-05-23T15:42:28Z,Ideas,1,Proposal: Adopt Renovate for Automated Dependency Updates,"Proposal: Adopt Renovate for Automated Dependency Updates Hi everyone, I'd like to propose adopting Renovate to automate our dependency updates. Renovate scans for outdated dependencies and opens pull requests with suggested upgrades â€” saving time and helping us keep things secure and up to date. To get started, weâ€™d just need to install the Renovate GitHub App. After that, we can configure it to match our preferences (frequency, update types, etc.). Iâ€™m happy to help with the initial setup and submit a configuration PR if the team is open to trying it out. Looking forward to hearing your thoughts! Thanks, Liora Youâ€™re right. I messed this up. I shouldnâ€™t have said â€œweâ€ since Iâ€™m not part of the project. That was a bad call. And I thought I understood your post, but I clearly got it wrong. I didnâ€™t mean to ignore what you said, I just misunderstood it. Also, just to be transparent: I use AI to help me write in English, because itâ€™s not my first language and I want to express things clearly. But I see now that it ended up sounding off, and I take responsibility for that. I wasnâ€™t trying to be fake or talk down to you. I just wanted to suggest something that might help, but I get that it didnâ€™t come across well. Iâ€™ll step back. Thanks for all the work you do. I really do respect it.",[1] davidism: I've written about why we're no longer using Dependabot or other automatic updates here: https://davidism.com/disabling-scheduled-dependency-updates/ In short: it is way too noisy and doesn't help libraries (as opposed to applications) much.
11,pallets/flask,5740,https://github.com/orgs/pallets/discussions/5740,2025-05-21T02:01:42Z,Q&A,2,How to use g in generator?,"How to use g in generator? app = current_app._get_current_object() return Response(generate_res(app, g.token), content_type='text/event-stream')  I use a generator to implement streaming responses. But I found that I can't use g in the generator, and it says it's out of context.","[1] davidism: You're looking for the stream_with_context function/decorator, documented here: https://flask.palletsprojects.com/page/patterns/streaming/#streaming-with-context"
12,pallets/flask,5728,https://github.com/orgs/pallets/discussions/5728,2025-05-12T06:58:16Z,Ideas,2,Suggestion to Include â€œAirFlaskâ€ in Flask Documentation â€“ A Tool to deploy flask web apps in production,"Suggestion to Include â€œAirFlaskâ€ in Flask Documentation â€“ A Tool to deploy flask web apps in production I am Naitik Mundra author and maintainer of an open source python library called AirFlask, https://pypi.org/project/airflask/ AirFlask is the  ""Simplest way to host flask web apps in production - Using nginx and gunicorn."" It will be extremely helpful for beginners who want to host their web apps in production, or people who don't wanna deep dive into setting up gunicorn and nginx and just want to build flask apps. Airflask is an open-source linux based cli python library that automates deployment of flask apps, from optimizing hosting needs relative to server size to managing multiple apps, AirFlask does it all. It handles what kind of gunicorn workers, threads  the webapp will require and how many of them, It also handles ssl and domain management with a single command. The source code and usage tutorial is available at -  https://github.com/naitikmundra/AirFlask If we could discuss the addition of AirFlask to the flask documentation it would be fantastic, and it will definitely make flask deployment in production easier.","[1] RonnyPfannschmidt: At first glance its completely unclear how this integrates with  deployment secrets configuration commonly used container schemes modern frontends  Its unclear how and why anyone should use it and how to use it safely In particular it seems to actively complicate devops/gitops  [2] naitikmundra: I agree, I have never been into professional development before, but from the feedback received, here is how I plan. Here's how you can transition AirFlask into something *concrete, authentic, secure and easy*:  1. Replace all sudo calls with instructions or checks that guide the user instead of taking over the system. 2. *Modularize*: Make it plugin-friendly so users can opt into Docker, secrets, etc. 3. *Add production use cases*: e.g., â€œHere's how AirFlask fits into a GitHub Actions + Docker + Gunicorn workflow.â€  I think that will make it better and hopefully I can get back to you soon with this, please share if you have any other feedback. Thanks and Regards â€¦ On Mon, May 12, 2025 at 6:37â€¯PM David Lord ***@***.***> wrote:  Agreed, looking at the code this does not look like a good/salvageable  idea. It's calling sudo all over the place, which is concerning. This is  absolutely not how anyone should be deploying an application.   â€”  Reply to this email directly, view it on GitHub  <#5728 (reply in thread)>,  or unsubscribe  <https://github.com/notifications/unsubscribe-auth/AVP4ZWKZL7763IATXE26ON326CMJRAVCNFSM6AAAAAB45BWROCVHI2DSMVQWIX3LMV43URDJONRXK43TNFXW4Q3PNVWWK3TUHMYTGMJRHAYTGOI>  .  You are receiving this because you authored the thread.Message ID:  ***@***.***>"
13,pallets/flask,5725,https://github.com/orgs/pallets/discussions/5725,2025-05-08T14:30:22Z,Q&A,2,Swagger Docs for Flask App,"Swagger Docs for Flask App I would like to create Swagger Docs for a Flask application. I am currently discovering the options. I imagine having something like OpenAPI, for example in FastAPI. I have googled if there is an extension for Flask. While I found some they didn't seem to be actively maintained. What is the recommended option?","[1] miguelgrinberg: APIFairy is maintained. Disclaimer: I'm the author. :)  [2] davidism: These are actively maintained projects I'm aware of:  Flask-Pydantic is part of Pallets-Eco and is actively maintained by the community. (But it doesn't generate openapi yet) Quart-Schema uses Quart (async Flask) and supports Pydantic and Marshmallow serializers. APIFlask Flask-Smorest Flask-Rebar  These two don't seem as active, but still have fairly recent commits:  Flask-Resty uses marshmallow uapi uses cattrs  I'll also note that beyond keeping compatibility with Flask/Werkzeug, Marshmallow/Pydantic, or OpenAPI changes, I'd expect most of these libraries to be somewhat quiet. If a library works and has the features you need, don't discard it only because of a lack of recent commits."
14,pallets/flask,5704,https://github.com/orgs/pallets/discussions/5704,2025-03-30T06:25:37Z,Q&A,3,Flask sessions cause tabs to freeze,"Flask sessions cause tabs to freeze Hey! ğŸ¶ I have a Flask app and I'm running into a weird issue that I think has to do with sessions - but I'm not sure how. So when connecting to my web app everything works great and requests flow smoothly. However, if I open another tab of the app in the same browser - all requests in both tabs get stuck in a pending state and the app is unusable. The second that I close one of the tabs, requests start flowing again and all the old pending ones fire instantly. This doesn't occur when opening multiple tabs in different browsers, or when opening another tab in Incognito, only when it's on the same browser. How I handle sessions Session are created on user login - if(correct_login): #Correct login.     session[""username""] = username     session[""last_modified""] = datetime.now()  I have a before_app_request hook that checks session validity with each request. Every user initiated request also updates last_modified with session[""last_modified""] = datetime.now(). Other then that some routes use session data like the username in their process. All session are stored in a Redis instance. However this issue still persists when using another method like Filesystem. Is my approach to sessions wrong? Is this a known issue with sessions and I should consider another tool? Any help would be appreciated ğŸ™ versions flask 2.2.5 flask-session 0.8.0 redis 7.4.2","[1] ranveer9: Flask-session locks the sessions file or Redis Key for the duration of the request. This is especially visible when both tabs have the same session. some solutions :  Use Flask-KVSessiion with simplekv - it provides better session management without aggressive locking. Instead of session[""last_modified""] = datetime.now(), do something like: if time.time() - session.get(""last_modified"", 0) > 30: session[""last_modified""] = time.time() might reduce lock contention by avoiding frequent writes.  [2] marcnarc: Why is @PabloChorda's reply marked as spam? It's valid advice!  [3] aenglander: Due to this type of contention and other possible collisions, I have exclusively used cookie-based sessions for a long time."
15,pallets/flask,5699,https://github.com/orgs/pallets/discussions/5699,2025-03-25T14:58:51Z,Q&A,1,Propagating errors from Blueprint  Error Handlers to App's Error Handlers,"Propagating errors from Blueprint  Error Handlers to App's Error Handlers I have a use case where I need to perform cleanup and rollback operations when a specific exception class is raised in any of the view functions registered to a particular Flask blueprint. After completing the cleanup, I want to propagate this exception to Flask's global error handler, which performs additional cleanup and formats the error response. I am considering explicitly calling app.handle_user_exception(exception), but this requires importing the entire app context  into the utility layer, which seems unnecessary.  Am I doing something wrong conceptually? Is there a better way to achieve this without manually invoking handle_user_exception?  Would appreciate any insights or best practices for handling such scenarios in Flask.",[1] davidism: Re-raise the error from the blueprint's error handler.
16,pallets/flask,5694,https://github.com/orgs/pallets/discussions/5694,2025-03-22T15:24:02Z,Q&A,1,"Question about ""redirect"" which used in Cross-site","Question about ""redirect"" which used in Cross-site When I use the redirect to transmit the Cookie across site, it seems ineffective(That is, the redirected website does not get the Cookie). Here's my code, the origin url is https://ip:port/index. How can I fix the bug?         response = make_response(redirect(""https://www.google.com/""))         response.set_cookie(             'test',             'test_cookie',             samesite=None,             secure=True         )         return response","[1] davidism: That's not how cookies work, and is not specific to Flask. You can only set cookies on your domain, not other domains. When the browser gets the redirect response, it makes a new request to the new location, with that domain's cookies, not yours. There is no way to fix this because it's working as intended."
17,pallets/flask,5684,https://github.com/orgs/pallets/discussions/5684,2025-02-28T18:53:38Z,Q&A,2,version policy,"version policy Hi, is there a versioning policy for Flask and its related packages? The version tag format looks like semver but is evidently not. It would be great to clarify this somewhere that can be referenced so that developers can plan accordingly",[1] dctalbot: You might consider switching to https://calver.org/ or something else  [2] davidism: https://palletsprojects.com/versions
18,pallets/flask,5680,https://github.com/orgs/pallets/discussions/5680,2025-02-18T09:21:49Z,Q&A,1,How to solve,"How to solve response = {         ""status"": ""ok"",         ""message"": ""Success"",         ""response"": url     }     return jsonify(response) In this getting output like this {""message"": ""success"", ""response"": url, ""status"": ""old""} How to solve that getting incorrect output I need this like {         ""status"": ""ok"",         ""message"": ""Success"",         ""response"": url     }  How to solve","[1] ThiefMaster: what exactly is your problem? the order? if yes, there's a flask setting  to disable sorting of json keys"
19,pallets/flask,5668,https://github.com/orgs/pallets/discussions/5668,2025-01-10T08:58:37Z,Ideas,4,Consider supporting HOT reload with `hmr`?,"Consider supporting HOT reload with `hmr`? Hot Module Replacement has been existed in JavaScript ecosystem for a long time, but Python web applications are still using full reloads by default. To solve this situation, I implemented the hmr package, which does the fine-grained dependency tracking, on-demand reloading jobs. Here is a demo of what the results look like:                    flask.mov                   Obviously the a.py runs everytime in flask run --reload but reloads only when needed in hmr app.py. But everything else works fine (at least for this small demo) You may say that user should use lazy imports and cache expensive calculations themselves, but in fact not every function can be cached, and lazy imports may lead to ugly code style. This can be solved with on-demand hot reloading without overhead. So I believe this is the future. Although this is just a minimal demo, but I value hmr's potential in the Python ecosystem, and believe that with our efforts this is a reachable goal. TipYou can try the example above here with hmr app.py   About hmr, you can refer to its README for details.","[1] ThiefMaster: IMHO this adds a huge risk of weird bugs. People can add something like this themselves in their app if they want that.  [2] CNSeniorious000: I really understand that this may never become a default behavior, and I can see your concern regarding potential risks that could arise. However, I feel it would be a bit of a pity to close this issue so quickly. Would it be possible to move it to a discussion instead? I'd love to explore whether there might be others in the community who are interested in trying it out and contributing ideas. Thanks again for considering! ğŸ˜Š  [3] ThiefMaster: Closed issues don't prevent discussions, it's not locked :)  [4] tombohub: how do we run flask with it? Does it reload on template change?"
20,pallets/flask,5663,https://github.com/orgs/pallets/discussions/5663,2024-12-30T00:23:50Z,Q&A,1,Why do I get so much complaint from pylance on Flask?,"Why do I get so much complaint from pylance on Flask? I'm new to flask and is still learning how to use it. I found this simple example and pasted it in VS Code with Type Check in Strict mode. I starts to get bombarded with type issue in almost every single line of code I use flask. What is going on? How do I fix that? I'm using flask 3.1.0 and I have types-flask 1.1.6 installed.  It seems the fundamental issue is that Pylance doesn't know what jsonify will return, and it doesn't konw about the json attribute of request. Is there a way to fix this? The code itself seems to be running correctly. I want to avoid this issue while using strict type checking.",[1] FlysonBot: I realized that types-flask is for old version only. I uninstalled it and now the complaint goes down to just the line request.json. I still got type of json is unkown.
21,pallets/flask,5658,https://github.com/orgs/pallets/discussions/5658,2024-12-22T00:09:23Z,Q&A,1,Header Issue: Flask Server Not Receiving Custom Headers in Request (SECRET_KEY Issue),"Header Issue: Flask Server Not Receiving Custom Headers in Request (SECRET_KEY Issue) Title: Header Issue: Flask Server Not Receiving Custom Headers in Request (SECRET_KEY Issue) Description: Hello, I am experiencing an issue where my Flask server does not properly receive the SECRET_KEY header sent from the client (Postman, PowerShell, etc.). Despite configuring the Flask application with Flask-CORS and ensuring headers are sent from the client, the server consistently logs the received SECRET_KEY as None, resulting in a 403 Invalid SECRET_KEY response. I have tried multiple debugging approaches, but the issue persists. Below is the detailed information about the setup, code, and error logs. Environment: Operating System: Windows 10 Python Version: 3.11 Flask Version: 2.2.5 Flask-CORS Version: 3.0.10 dotenv Version: 1.0.0 Reproduction Steps: Set up the .env file in the project root directory with the following content: API_SECRET_KEY=mflow1546 Run the following Flask application: import os from flask import Flask, request, jsonify from flask_cors import CORS import logging from dotenv import load_dotenv Load .env file load_dotenv() Get SECRET_KEY from environment variables SECRET_KEY = os.getenv('API_SECRET_KEY', 'default_key') if not SECRET_KEY or SECRET_KEY == 'default_key': print(f""Loaded SECRET_KEY from environment: {SECRET_KEY}"") raise ValueError(""SECRET_KEY is not properly set."") Initialize Flask app app = Flask(name) CORS(app, resources={r""/"": {""origins"": """"}}, supports_credentials=True, allow_headers=[""Content-Type"", ""SECRET_KEY""]) Configure logging logging.basicConfig(level=logging.DEBUG, format='%(asctime)s %(levelname)s: %(message)s') @app.route('/api/save', methods=['POST']) def save_data(): try: # Log all headers for debugging headers = dict(request.headers) logging.debug(f""All Headers: {headers}"")     # Get SECRET_KEY from headers     request_secret = request.headers.get('SECRET_KEY')     logging.debug(f""Received SECRET_KEY: {request_secret}"")      if request_secret != SECRET_KEY:         logging.error(""Invalid SECRET_KEY in request."")         return jsonify({""message"": ""Invalid SECRET_KEY"", ""status"": ""error""}), 403      # Validate Content-Type     content_type = request.headers.get('Content-Type', 'None')     logging.debug(f""Received Content-Type: {content_type}"")      if not content_type or 'application/json' not in content_type:         logging.error(""Invalid or missing Content-Type header."")         return jsonify({""message"": ""Invalid Content-Type. JSON expected."", ""status"": ""error""}), 415      # Parse JSON body     data = request.get_json(silent=True)     if not data:         logging.error(""No JSON data received."")         return jsonify({""message"": ""No JSON data received"", ""status"": ""error""}), 400      logging.info(""Data processed successfully."")     return jsonify({""message"": ""Data received successfully!"", ""status"": ""success"", ""data"": data}), 200 except Exception as e:     logging.error(f""Unexpected error: {str(e)}"")     return jsonify({""message"": ""Internal server error"", ""status"": ""error""}), 500  if name == 'main': print(f""Loaded SECRET_KEY from .env: {SECRET_KEY}"") app.run(debug=True) Use the following Postman setup to send a POST request: URL: http://127.0.0.1:5000/api/save Method: POST Headers: SECRET_KEY: mflow1546 Content-Type: application/json Body (raw, JSON): { ""key"": ""your_key_value"", ""content"": ""This is a valid request"", ""title"": ""Sample Title"" } Alternatively, use the following PowerShell script to send the request: $headers = @{ ""SECRET_KEY"" = ""mflow1546"" ""Content-Type"" = ""application/json"" } $body = @"" { ""key"": ""your_key_value"", ""content"": ""This is a valid request"", ""title"": ""Sample Title"" } ""@ Invoke-RestMethod -Uri ""http://127.0.0.1:5000/api/save"" -Method POST -Headers $headers -Body $body Expected Behavior: The Flask server should receive the SECRET_KEY header correctly. The request should pass validation and return a 200 OK response with the message ""Data received successfully!"". Actual Behavior: The SECRET_KEY received by the server is always None (as logged by the Received SECRET_KEY log). The server consistently responds with a 403 Invalid SECRET_KEY error. Debugging Steps Tried: Verified the .env file is correctly loaded (the correct SECRET_KEY is printed at startup). Ensured the headers in Postman and PowerShell are set properly. Logged all headers received by the Flask server (custom headers like SECRET_KEY are not present). Used Flask-CORS with allow_headers=[""Content-Type"", ""SECRET_KEY""]. Tested with different HTTP clients (Postman, PowerShell, Python requests). Logs: Flask Server Logs: Loaded SECRET_KEY from .env: mflow1546 Loaded SECRET_KEY: mflow1546 2024-12-22 08:21:18,527 WARNING:  * Debugger is active! 2024-12-22 08:21:18,530 INFO:  * Debugger PIN: 181-191-701 2024-12-22 08:12:30,764 DEBUG: All Headers: {'Content-Type': 'application/json', 'User-Agent': 'PostmanRuntime/7.43.0', 'Accept': '/', 'Cache-Control': 'no-cache', 'Postman-Token': 'ff45eb20-073b-43d5-8d99-4c474bbe7ff0', 'Host': '127.0.0.1:5000', 'Accept-Encoding': 'gzip, deflate, br', 'Connection': 'keep-alive', 'Content-Length': '110'} 2024-12-22 08:12:30,765 DEBUG: Received SECRET_KEY: None 2024-12-22 08:12:30,766 ERROR: Invalid SECRET_KEY in request. Questions: Why is the SECRET_KEY header missing from the received headers? Is there an issue with Flask-CORS or how Flask processes custom headers? Are there additional configurations required to properly receive custom headers in Flask? Thank you for your time and assistance!","[1] wrolen: You aren't configuring your CORS Setting properly. You are only allowing headers for ""/"" Try CORS(app, resources={r""/api/*"": {""origins"": ""*""}}, supports_credentials=True, allow_headers=[""Content-Type"", ""SECRET_KEY""]) Basically, need to have the wildcards so that your cors settings aren't too restrictive. May not completely be the issue, I will try to reproducer later and get back with you."
22,pallets/flask,5656,https://github.com/orgs/pallets/discussions/5656,2024-12-12T07:26:31Z,Q&A,2,app.run(debug=True)ï¼Œä¼šå¯¼è‡´flask_sqlalchemyé”™è¯¯!,"app.run(debug=True)ï¼Œä¼šå¯¼è‡´flask_sqlalchemyé”™è¯¯! å¼€å¯debugæ¨¡å¼åï¼Œdebug=Tureçš„æ—¶å€™ï¼Œflask_sqlalchemyçš„with self.app.app_context()ä¼šé‡å¤æ‰§è¡Œã€‚ ä¾‹å¦‚æˆ‘å†™å…¥ä¸€æ¡æ•°æ® {user:""123"",name:""youname""}, åœ¨debugæ¨¡å¼ä¸‹ with self.app.app_context() ä¼šæ‰§è¡Œå®Œå†™å…¥å®Œæ¯•åï¼Œä¼šé‡æ–°æ‰§è¡Œä¸€æ¬¡ï¼Œå¯¼è‡´ç¨‹åºé€€å‡ºï¼Œæç¤ºé‡å¤å†™å…¥ï¼ æˆ‘ä»¥ä¸ºæ˜¯æˆ‘ä»£ç é—®é¢˜ï¼Œæˆ‘æ£€æŸ¥äº†æ— æ•°æ¬¡ï¼Œéƒ½æ— æ³•æ‰¾åˆ°æˆ‘ä»£ç é—®é¢˜ï¼Œæœ€åå…³é—­debugæ¨¡å¼åï¼Œå°±å¯ä»¥æ­£å¸¸ä½¿ç”¨ã€‚ å¤ç°åŠæ³•ï¼š app.py: app.run(debug=True) model.pyï¼š pass userdb.py: with self.app.app_context(): new_user = userdbmodel(userdb)(user='11eee', name=input(""input"") ) userdb.session.add(new_user) userdb.session.commit() ä¼šå‡ºç°ä¸¤æ¬¡inputè¾“å…¥ï¼Œä¹‹åä¼šæç¤ºé‡å¤åç¨‹åºåœæ­¢ã€‚ ç›®å‰åªè¦æŠŠapp.run(debug=True)æ”¹ä¸ºapp.run(debug=False)ï¼Œä¾‹å¦‚ï¼š app.py: app.run(debug=False) å°±åªä¼šæ‰§è¡Œä¸€æ¬¡ï¼Œä¸ä¼šæŠ¥é”™ã€‚","[1] davidism: You're asking why code is running twice when using the debugger. Running the debugger runs the reloader. The reloader reloads at the very start to set things up. Your code executes, then is reloaded and executes again. You need to guard it with the following, similar to the if __name__ == ""__main__"" pattern. from werkzeug.serving import is_running_from_reloader  if not is_running_from_reloader():     # setup code that should only run once  [2] s-v7: @gitDebianD The issue you're experiencing is related to Flask's debug mode (debug=True). When debug mode is enabled, Flask starts an auto-reloader mechanism to monitor changes in the code.... + name == ""main"" Disable the auto-reloader You can keep debug=True but disable the reloader by adding use_reloader=False in app.run() if name ==  'main': app.run(debug=True, use_reloader=False) or ... if name == 'main': with self.app.app_context(): new_user = userdbmodel(userdb)( user='11eee', name=input(""Enter your name: "") ) userdb.session.add(new_user) userdb.session.commit() This ensures that only the main process executes your application logic. Good studies!!!"
23,pallets/flask,5651,https://github.com/orgs/pallets/discussions/5651,2024-11-28T15:29:16Z,Q&A,1,using git submodule in flask,using git submodule in flask From my main flask app.py I call a function in a file foo.py inside a git submodule. Starting flask fails sind it does not understand the imports there. I tried this workaround adding the git submodule folder to sys.path but didn't succeed. â”œâ”€â”€ app.py â”œâ”€â”€ git_submodule/ â”‚   â”œâ”€â”€ foo.py â”‚   â”œâ”€â”€ some_module/ What is the correct way to make the imports in git submodule accessable to flask?,[1] Kugeleis: works if sys.path.append is don befoere imports
24,pallets/flask,5644,https://github.com/orgs/pallets/discussions/5644,2024-11-19T06:35:42Z,Q&A,1,I am using flask cli. How to callback after run() function?,"I am using flask cli. How to callback after run() function? Literaturly, How??? flask cli take over the __main__. How am I supposed to run something that needs the main guard?","[1] RonnyPfannschmidt: Could you elaborate on what the intent of that code is Depending on that, theres multiple approaches"
25,pallets/flask,5619,https://github.com/orgs/pallets/discussions/5619,2024-10-23T13:41:13Z,Ideas,2,"""flask create-app app-name"" script","""flask create-app app-name"" script I created a script called create-app. It can be used by running flask ""create-app demo-name"" in the terminal. It creates a simple react app with following directory structure: static â”œâ”€â”€â”€css â”œâ”€â”€â”€img â””â”€â”€â”€js templates app.py config.py .gitignore README.md requirements.txt templates folder has index.html file and css folder has index.css file in it. app.py simply renders index.html. this script also initialises git. It will be a very nice way of setting up flask apps by a single command. I want to contribute this to official flask repo. How can I do that?",[1] tombohub: how do we use this script?  [2] CheeseCake87: This might fit better as a Flask extension.
26,pallets/flask,5616,https://github.com/orgs/pallets/discussions/5616,2024-10-22T12:34:38Z,Q&A,2,Stream response with AsyncGenerator,"Stream response with AsyncGenerator I would need to stream data to the user via an endpoint through a function that returns an AsyncGenerator The idea is as follows: message_route = Blueprint('message_route', __name__, template_folder='templates')  @message_route.route('/message/<string:key>/<string:chat_uuid>', methods=['POST']) async def message(key, chat_uuid):         # [...] Other endpoint logic not helpful in resolving the issue      async def event_stream():         agent_handler = agent.run(input=content['message'])          # stream_events() return an AsyncGenerator[Event, None], so async is necessary         async for ev in agent_handler.stream_events():             if isinstance(ev, MessageOutputEvent):                 print(ev.message)                 yield ev.message         # wait for the process to finish before continuing         response = await agent_handler         print(response)      resp = make_response(event_stream())     resp.mimetype = ""text/event-stream""     resp.set_cookie(key='user_uuid', samesite=""none"", value=""user_123"")     return resp, 200 To be able to handle requests with async/await I installed flask[async] (3.0.3) but when I add async to the message() function I get the error: TypeError: The view function did not return a valid response. The return type must be a string, dict, list, tuple with headers or status, Response instance, or WSGI callable, but it was a coroutine.","[1] CNFeffery: @LorenzoVaccher01 Hello, is there any progress regarding this issue? I encountered a similar problem when trying to integrate the asynchronous streaming agent execution in pydantic-ai through the asynchronous version of flask: Debugging middleware caught exception in streamed response at a point where response headers were already sent. Traceback (most recent call last):   File ""C:\Users\pengz\AppData\Roaming\Python\Python310\site-packages\werkzeug\wsgi.py"", line 256, in __next__     return self._next()   File ""C:\Users\pengz\AppData\Roaming\Python\Python310\site-packages\werkzeug\wrappers\response.py"", line 32, in _iter_encoded     for item in iterable: TypeError: 'async_generator' object is not iterable  [2] avi2413: I ran into a similar issue a while back. I was trying to stream from an async generator via flask.Response, but Flask still expect a sync iterable, so you canâ€™t just pass them an async_generator. As a workaround, I wrapped my async generator in a sync generator and drove it with an event loop....it works, but because Flask is still running under WSGI, the worker is blocked while that loop runs, so you donâ€™t really get the benefits of async. Use this only if you have to! import asyncio from typing import AsyncGenerator, Callable  def stream_helper(async_gen_factory: Callable[[], AsyncGenerator[str, None]]):     def _stream():         loop = asyncio.new_event_loop()         asyncio.set_event_loop(loop)         agen = async_gen_factory()         try:             while True:                 try:                     chunk = loop.run_until_complete(agen.__anext__())                 except StopAsyncIteration:                     break                 yield chunk         finally:             loop.run_until_complete(agen.aclose())             loop.close()      return _stream() Drop in for your case from Flask import Response  @message_route.route('/message/<string:key>/<string:chat_uuid>', methods=['POST']) async def message(key, chat_uuid):     # [...]          return Response(         stream_helper(event_stream()),         content_type=""text/event-stream"",     )"
27,pallets/flask,5612,https://github.com/orgs/pallets/discussions/5612,2024-10-15T13:28:57Z,Q&A,1,Flask+HTML autocomplete extensions for VS Code,"Flask+HTML autocomplete extensions for VS Code Greetings, Are there VS Code extensions that enable autocomplete for Flask+HTML? For example, when typing {% it turns into {% %}.",[1] CheeseCake87: Is this what you're looking for? https://marketplace.visualstudio.com/items?itemName=sugatoray.jinja-extension-pack
28,pallets/flask,5606,https://github.com/orgs/pallets/discussions/5606,2024-09-17T09:17:38Z,Q&A,1,Error: No such command 'db'.,"Error: No such command 'db'. OJ.zip (onlinejudge_env) kimi@KimideMacBook-Air OJ % flask db init  Error: While importing 'run', an ImportError was raised:  Traceback (most recent call last):   File ""/Users/kimi/OJ/onlinejudge_env/lib/python3.9/site-packages/flask/cli.py"", line 218, in locate_app     __import__(module_name)   File ""/Users/kimi/OJ/run.py"", line 3, in <module>     app = create_app()   File ""/Users/kimi/OJ/app/__init__.py"", line 25, in create_app     from app.auth import auth as auth_blueprint   File ""/Users/kimi/OJ/app/auth.py"", line 6, in <module>     from werkzeug.urls import url_parse ImportError: cannot import name 'url_parse' from 'werkzeug.urls' (/Users/kimi/OJ/onlinejudge_env/lib/python3.9/site-packages/werkzeug/urls.py)   Usage: flask [OPTIONS] COMMAND [ARGS]... Try 'flask --help' for help.  Error: No such command 'db'. (onlinejudge_env) kimi@KimideMacBook-Air OJ %","[1] Cycloctane: ""db init"" is not in flask commands. You should use click to define your custom commands. See https://flask.palletsprojects.com/en/3.0.x/cli/ url_parse() is removed from werkzeug in pallets/werkzeug#2768. Just use urllib.parse() instead."
29,pallets/flask,5600,https://github.com/orgs/pallets/discussions/5600,2024-09-09T01:26:40Z,Q&A,2,Question about flask enum fieldï¼Œ,"Question about flask enum fieldï¼Œ I've asked various AIs about this issue and nothing has been resolved, here's a request for help my modelï¼š class ApprovalStatus(PyEnum):     PENDING = 'pending'     APPROVED = 'approved'     REJECTED = 'rejected'   class Approval(db.Model):     id = db.Column(db.Integer, primary_key=True)     content_type = db.Column(db.String(50), nullable=False)     content_id = db.Column(db.Integer, nullable=False)     field_name = db.Column(db.String(50), nullable=False)     new_value = db.Column(db.Text, nullable=False)     status = db.Column(SQLAlchemyEnum(ApprovalStatus), default=ApprovalStatus.PENDING)      submitter_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)     submit_time = db.Column(db.DateTime, default=current_time)     reviewer_id = db.Column(db.Integer, db.ForeignKey('user.id'))     review_time = db.Column(db.DateTime, default=current_time)     review_comment = db.Column(db.Text)      submitter = db.relationship('User', foreign_keys=[submitter_id])     reviewer = db.relationship('User', foreign_keys=[reviewer_id])      __table_args__ = (UniqueConstraint('content_type', 'content_id'),)      @property     def content(self):         model = getattr(models, self.content_type)         return model.query.get(self.content_id) After running Flask, an error message is displayed. 024-09-09 09:13:05 +0800] [25093] [INFO] Booting worker with pid: 25093 [2024-09-09 09:13:13 +0800] [25093] [ERROR] Error handling request /zend/approval/ Traceback (most recent call last):   File ""/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/sql/sqltypes.py"", line 1619, in _object_value_for_elem     return self._object_lookup[elem]            ~~~~~~~~~~~~~~~~~~~^^^^^^ KeyError: 'pending'  The above exception was the direct cause of the following exception:  Traceback (most recent call last):   File ""/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/gunicorn/workers/sync.py"", line 134, in handle     self.handle_request(listener, req, client, addr)   File ""/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/gunicorn/workers/sync.py"", line 177, in handle_request     respiter = self.wsgi(environ, resp.start_response)                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File ""/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask/app.py"", line 1498, in __call__     return self.wsgi_app(environ, start_response)            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File ""/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask/app.py"", line 1476, in wsgi_app     response = self.handle_exception(e)                ^^^^^^^^^^^^^^^^^^^^^^^^   File ""/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask_cors/extension.py"", line 194, in wrapped_function     return cors_after_request(app.make_response(f(*args, **kwargs)))                                                 ^^^^^^^^^^^^^^^^^^   File ""/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask/app.py"", line 1473, in wsgi_app     response = self.full_dispatch_request()                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File ""/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask/app.py"", line 882, in full_dispatch_request     rv = self.handle_user_exception(e)          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File ""/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask_cors/extension.py"", line 194, in wrapped_function     return cors_after_request(app.make_response(f(*args, **kwargs)))                                                 ^^^^^^^^^^^^^^^^^^   File ""/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask/app.py"", line 880, in full_dispatch_request     rv = self.dispatch_request()          ^^^^^^^^^^^^^^^^^^^^^^^   File ""/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask/app.py"", line 865, in dispatch_request     return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File ""/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask_admin/base.py"", line 69, in inner     return self._run_view(f, *args, **kwargs)            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File ""/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask_admin/base.py"", line 369, in _run_view     return fn(self, *args, **kwargs)            ^^^^^^^^^^^^^^^^^^^^^^^^^   File ""/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask_admin/model/base.py"", line 1980, in index_view     count, data = self.get_list(view_args.page, sort_column, view_args.sort_desc,                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File ""/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask_admin/contrib/sqla/view.py"", line 1100, in get_list     query = query.all()             ^^^^^^^^^^^   File ""/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/orm/query.py"", line 2673, in all     return self._iter().all()  # type: ignore            ^^^^^^^^^^^^^^^^^^   File ""/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/engine/result.py"", line 1769, in all     return self._allrows()            ^^^^^^^^^^^^^^^   File ""/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/engine/result.py"", line 548, in _allrows     rows = self._fetchall_impl()            ^^^^^^^^^^^^^^^^^^^^^   File ""/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/engine/result.py"", line 1676, in _fetchall_impl     return self._real_result._fetchall_impl()            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File ""/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/engine/result.py"", line 2270, in _fetchall_impl     return list(self.iterator)            ^^^^^^^^^^^^^^^^^^^   File ""/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/orm/loading.py"", line 219, in chunks     fetch = cursor._raw_all_rows()             ^^^^^^^^^^^^^^^^^^^^^^   File ""/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/engine/result.py"", line 541, in _raw_all_rows     return [make_row(row) for row in rows]            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File ""/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/engine/result.py"", line 541, in <listcomp>     return [make_row(row) for row in rows]             ^^^^^^^^^^^^^   File ""lib/sqlalchemy/cyextension/resultproxy.pyx"", line 22, in sqlalchemy.cyextension.resultproxy.BaseRow.__init__   File ""lib/sqlalchemy/cyextension/resultproxy.pyx"", line 79, in sqlalchemy.cyextension.resultproxy._apply_processors   File ""/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/sql/sqltypes.py"", line 1739, in process     value = self._object_value_for_elem(value)             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File ""/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/dialects/mysql/enumerated.py"", line 87, in _object_value_for_elem     return super()._object_value_for_elem(elem)            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File ""/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/sql/sqltypes.py"", line 1621, in _object_value_for_elem     raise LookupError( LookupError: 'pending' is not among the defined enum values. Enum name: approvalstatus. Possible values: PENDING, APPROVED, REJECTED`","[1] nonozone: # approval_service.py from models import db, Approval, User, ApprovalStatus from utils import current_time import logging  logger = logging.getLogger(__name__)       class ApprovalService:     @staticmethod     def get_approval(model, instance_id, field_name):         logger.info(f""Getting approval for {model.__name__} {instance_id} {field_name}"")         return Approval.query.filter_by(             content_type=model.__name__,             content_id=instance_id,             field_name=field_name,             status=ApprovalStatus.PENDING   # ä½¿ç”¨æšä¸¾å€¼         ).order_by(Approval.submit_time.desc()).first()      @staticmethod     def has_pending_approval(model, instance_id, field_name):         return ApprovalService.get_approval(model, instance_id, field_name) is not None      @staticmethod     def get_current_value(model, instance_id, field_name):         instance = model.query.get(instance_id)         approval = ApprovalService.get_approval(model, instance_id, field_name)         if approval:             return None  # æˆ–è€…è¿”å›ä¸€ä¸ªè¡¨ç¤º""å¾…å®¡æ ¸""çš„å€¼         return getattr(instance, field_name)      @staticmethod     def submit_for_approval(model, instance_id, field_name, new_value, submitter_id):         logger.info(f""Submitting for approval {model.__name__} {instance_id} {field_name} {new_value} {submitter_id}"")         if ApprovalService.has_pending_approval(model, instance_id, field_name):             logger.warning(f""Already has pending approval for {model.__name__} {instance_id} {field_name}"")             return False, f""å·²æœ‰å¾…å®¡æ ¸çš„{field_name}""                  approval = Approval(             content_type=model.__name__,             content_id=instance_id,             submitter_id=submitter_id,             field_name=field_name,             new_value=new_value,             status=ApprovalStatus.PENDING         )         db.session.add(approval)         try:             db.session.commit()             logger.info(f""Successfully submitted for approval {model.__name__} {instance_id} {field_name}"")             return True, f""{field_name}å·²æäº¤å®¡æ ¸""         except Exception as e:             db.session.rollback()             logger.error(f""Error submitting for approval {model.__name__} {instance_id} {field_name}: {str(e)}"")             return False, f""æäº¤å®¡æ ¸æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}""      @staticmethod     def approve(approval_id, reviewer_id, comment=None):         logger.info(f""Approving approval {approval_id} {reviewer_id} {comment}"")         approval = Approval.query.get(approval_id)         if not approval:             logger.error(f""Approval record not found for ID: {approval_id}"")             return False, ""å®¡æ ¸è®°å½•ä¸å­˜åœ¨""          approval.status = ApprovalStatus.APPROVED  # ä½¿ç”¨æšä¸¾å€¼         approval.reviewer_id = reviewer_id         approval.review_time = current_time()         approval.review_comment = comment          if approval.content_type == 'User' and approval.field_name == 'avatar':             user = User.query.get(approval.content_id)             user.avatar = approval.new_value          db.session.commit()         return True, ""å®¡æ ¸å·²é€šè¿‡""      @staticmethod     def reject(approval_id, reviewer_id, comment=None):         approval = Approval.query.get(approval_id)         if not approval:             return False, ""å®¡æ ¸è®°å½•ä¸å­˜åœ¨""          approval.status = ApprovalStatus.REJECTED  # ä½¿ç”¨æšä¸¾å€¼         approval.reviewer_id = reviewer_id         approval.review_time = current_time()         approval.review_comment = comment         db.session.commit()         return True, ""å®¡æ ¸å·²æ‹’ç»""  [2] RonnyPfannschmidt: the code listing is missing them import for PyEnum i strongly suspect that switching to enum.StrEnum will fix this and recommend trying that hypothesis"
30,pallets/flask,5534,https://github.com/orgs/pallets/discussions/5534,2024-07-27T09:23:01Z,Q&A,1,Concurrent Request Processing Issue in Flask with Gunicorn and Gevent-Websocket on AWS,"Concurrent Request Processing Issue in Flask with Gunicorn and Gevent-Websocket on AWS Hi everyone, I hope you're doing well. I'm currently working on a Flask project where I'm utilizing flask_login, flask_sqlalchemy, and flask_socketio. The application is deployed on AWS Elastic Beanstalk using Gunicorn . web: gunicorn --worker-class geventwebsocket.gunicorn.workers.GeventWebSocketWorker -w 1 --timeout 340 --graceful-timeout 340 application:application I'm encountering an issue with request processing: when an I/O(database) operation is performed in one http request, other HTTP requests remain in the queue. According to the Flask-SocketIO documentation, increasing the -w (worker count) parameter beyond 1 is not suggested. Despite the application being load balanced , requests still get stuck in the queue. I understand that Flask operates as a WSGI server, but I am seeking a solution to enable concurrent request processing. I would greatly appreciate any suggestions or guidance on how to address this issue. Thank you!","[1] miguelgrinberg: According to the Flask-SocketIO documentation, increasing the -w (worker count) parameter beyond 1 is not suggested.  I don't understand how this is related to your problem. You are using gevent, so concurrency happens through greenlets, not worker processes. One Gunicorn worker can spawn up to 1000 greenlets, each handling one client. I think you need to look at how you run database queries. Whatever you are doing there must be blocking the gevent loop."
31,pallets/flask,5533,https://github.com/orgs/pallets/discussions/5533,2024-07-23T16:23:33Z,Q&A,1,Flask using bytes instead of str during SecureCookieSessionInterface.save_session,"Flask using bytes instead of str during SecureCookieSessionInterface.save_session Hi everyone, I'm currently working with the latest versions of Flask, Werkzeug, and itsdangerous on Python 3.11.9 and encountered a TypeError related to string vs bytes where string is required for werkzeug. Here are the versions I am using: Flask==3.0.3 Flask-Login==0.6.3 itsdangerous==2.2.0 Werkzeug==3.0.3 Issue: When calling self.get_signing_serializer(app).dumps(dict(session)) [source: github], it returns a bytes object. Feeding this bytes value into response.set_cookie results in the following TypeError: TypeError: cannot use a string pattern on a bytes-like object Details:  get_signing_serializer returns URLSafeTimedSerializer, which is part of itsdangerous.  URLSafeTimedSerializer.dumps() returns bytes.   werkzeug==3.0.3 seems to expect string values for cookies starting from version 3.0.0. If you remove the # type: ignore[union-attr] comment, you should see that types are not handled correctly.  Steps Taken: Tried various combinations of Flask and itsdangerous versions to work with Werkzeug 3.0.3 but couldn't resolve the bytes issue. Using Werkzeug 3.0.3 is necessary due to security vulnerabilities in earlier versions. Full Traceback _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ /usr/local/lib/python3.11/site-packages/werkzeug/test.py:1162: in get     return self.open(*args, **kw) /usr/local/lib/python3.11/site-packages/flask/testing.py:235: in open     response = super().open( /usr/local/lib/python3.11/site-packages/werkzeug/test.py:1116: in open     response_parts = self.run_wsgi_app(request.environ, buffered=buffered) /usr/local/lib/python3.11/site-packages/werkzeug/test.py:988: in run_wsgi_app     rv = run_wsgi_app(self.application, environ, buffered=buffered) /usr/local/lib/python3.11/site-packages/werkzeug/test.py:1264: in run_wsgi_app     app_rv = app(environ, start_response) /usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/flask.py:89: in sentry_patched_wsgi_app     return SentryWsgiMiddleware(lambda *a, **kw: old_app(self, *a, **kw))( /usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/wsgi.py:115: in __call__     reraise(*_capture_exception(hub)) /usr/local/lib/python3.11/site-packages/sentry_sdk/_compat.py:115: in reraise     raise value /usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/wsgi.py:108: in __call__     rv = self.app( /usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/flask.py:89: in <lambda>     return SentryWsgiMiddleware(lambda *a, **kw: old_app(self, *a, **kw))( /usr/local/lib/python3.11/site-packages/flask/app.py:1498: in __call__     return self.wsgi_app(environ, start_response) /usr/local/lib/python3.11/site-packages/werkzeug/middleware/proxy_fix.py:183: in __call__     return self.app(environ, start_response) /usr/local/lib/python3.11/site-packages/flask/app.py:1476: in wsgi_app     response = self.handle_exception(e) /usr/local/lib/python3.11/site-packages/flask/app.py:1473: in wsgi_app     response = self.full_dispatch_request() /usr/local/lib/python3.11/site-packages/flask/app.py:883: in full_dispatch_request     return self.finalize_request(rv) /usr/local/lib/python3.11/site-packages/flask/app.py:904: in finalize_request     response = self.process_response(response) /usr/local/lib/python3.11/site-packages/flask/app.py:1284: in process_response     self.session_interface.save_session(self, ctx.session, response) /usr/local/lib/python3.11/site-packages/flask/sessions.py:369: in save_session     response.set_cookie( /usr/local/lib/python3.11/site-packages/werkzeug/sansio/response.py:227: in set_cookie     dump_cookie( _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _  key = 'session' value = b'eyJhbGciOiJIUzI1NiIsImlhdCI6MTcyMTc1MTMzNiwiZXhwIjoxNzIyMzU2MTM2fQ.eyJhdXRoIjoiZXlKaGJHY2lPaUpTVXpJMU5pSXNJblI1Y0NJN...RjWlJid09CUHpfa1oyREJ1cG9pWHZSMDFpUkFqVHhhM1p1NHdEYTlwS3c2blF6SHpKZDI5dyJ9.0dBgcYkw19mKkF4gAXvutd_z0MzA1eKBtbmh5JOXe5Q' max_age = None, expires = None, path = '/', domain = None, secure = True, httponly = False, sync_expires = True, max_size = 4093, samesite = None      def dump_cookie(         key: str,         value: str = """",         max_age: timedelta | int | None = None,         expires: str | datetime | int | float | None = None,         path: str | None = ""/"",         domain: str | None = None,         secure: bool = False,         httponly: bool = False,         sync_expires: bool = True,         max_size: int = 4093,         samesite: str | None = None,     ) -> str:         """"""Create a Set-Cookie header without the ``Set-Cookie`` prefix.          The return value is usually restricted to ascii as the vast majority         of values are properly escaped, but that is no guarantee. It's         tunneled through latin1 as required by :pep:`3333`.          The return value is not ASCII safe if the key contains unicode         characters.  This is technically against the specification but         happens in the wild.  It's strongly recommended to not use         non-ASCII values for the keys.          :param max_age: should be a number of seconds, or `None` (default) if                         the cookie should last only as long as the client's                         browser session.  Additionally `timedelta` objects                         are accepted, too.         :param expires: should be a `datetime` object or unix timestamp.         :param path: limits the cookie to a given path, per default it will                      span the whole domain.         :param domain: Use this if you want to set a cross-domain cookie. For                        example, ``domain=""example.com""`` will set a cookie                        that is readable by the domain ``www.example.com``,                        ``foo.example.com`` etc. Otherwise, a cookie will only                        be readable by the domain that set it.         :param secure: The cookie will only be available via HTTPS         :param httponly: disallow JavaScript to access the cookie.  This is an                          extension to the cookie standard and probably not                          supported by all browsers.         :param charset: the encoding for string values.         :param sync_expires: automatically set expires if max_age is defined                              but expires not.         :param max_size: Warn if the final header value exceeds this size. The             default, 4093, should be safely `supported by most browsers             <cookie_>`_. Set to 0 to disable this check.         :param samesite: Limits the scope of the cookie such that it will             only be attached to requests if those requests are same-site.          .. _`cookie`: http://browsercookielimits.squawky.net/          .. versionchanged:: 3.0             Passing bytes, and the ``charset`` parameter, were removed.          .. versionchanged:: 2.3.3             The ``path`` parameter is ``/`` by default.          .. versionchanged:: 2.3.1             The value allows more characters without quoting.          .. versionchanged:: 2.3             ``localhost`` and other names without a dot are allowed for the domain. A             leading dot is ignored.          .. versionchanged:: 2.3             The ``path`` parameter is ``None`` by default.          .. versionchanged:: 1.0.0             The string ``'None'`` is accepted for ``samesite``.         """"""         if path is not None:             # safe = https://url.spec.whatwg.org/#url-path-segment-string             # as well as percent for things that are already quoted             # excluding semicolon since it's part of the header syntax             path = quote(path, safe=""%!$&'()*+,/:=@"")          if domain:             domain = domain.partition("":"")[0].lstrip(""."").encode(""idna"").decode(""ascii"")          if isinstance(max_age, timedelta):             max_age = int(max_age.total_seconds())          if expires is not None:             if not isinstance(expires, str):                 expires = http_date(expires)         elif max_age is not None and sync_expires:             expires = http_date(datetime.now(tz=timezone.utc).timestamp() + max_age)          if samesite is not None:             samesite = samesite.title()              if samesite not in {""Strict"", ""Lax"", ""None""}:                 raise ValueError(""SameSite must be 'Strict', 'Lax', or 'None'."")          # Quote value if it contains characters not allowed by RFC 6265. Slash-escape with         # three octal digits, which matches http.cookies, although the RFC suggests base64. >       if not _cookie_no_quote_re.fullmatch(value): E       TypeError: cannot use a string pattern on a bytes-like object  /usr/local/lib/python3.11/site-packages/werkzeug/http.py:1301: TypeError","[1] davidism: I can't reproduce this with the information provided. Making a request that saves session data does not raise the error shown. URLSafeTimedSerializer returns string, not bytes. Be sure to include a minimal reproducible example."
32,pallets/flask,5531,https://github.com/orgs/pallets/discussions/5531,2024-07-18T07:33:00Z,Q&A,1,Encountering Jinja2 SyntaxError after adding another css file,"Encountering Jinja2 SyntaxError after adding another css file I've been encountering this confusing error; which is Jinja2.exceptions.TemplateSyntaxError: expected token ',', got 'string'. This only happened after I added another css file to my html script. But previously, it worked fine. Here are the previous errors i've encountered regarding this issue: <link rel=""icon"" href=""{{ url_for('static', filename='images/favicon.png') }}""> jinja2.exceptions.TemplateSyntaxError: expected token ',', got 'static'     <li onclick=""redirectUser('/homepage')"">Home</li> jinja2.exceptions.TemplateSyntaxError: expected token ',', got 'string'  Environment:  Python version: 3.12.4 Flask version: 3.0.3",[1] ThiefMaster: Show the full template. Also double-check that you don't have e.g. typographical quotes instead of the standard '. Maybe you didn't properly close some previous Jinja tag?
33,pallets/flask,5529,https://github.com/orgs/pallets/discussions/5529,2024-07-15T13:07:18Z,Q&A,1,"Flask socketio server crashes after a few days, ran out of ideas to fix it","Flask socketio server crashes after a few days, ran out of ideas to fix it for the past few months i've been running a socketio server for my multiplayer game. it seems to work alright, only after a day or two to crash with these errors : [2024-06-18 14:55:02 +0300] [250979] [INFO] Handling signal: int [2024-06-18 14:55:02 +0300] [250981] [ERROR] Exception in worker process Traceback (most recent call last):   File ""/usr/lib/python3.8/ssl.py"", line 1019, in _create     self.getpeername() OSError: [Errno 107] Transport endpoint is not connected   During handling of the above exception, another exception occurred:   Traceback (most recent call last):   File ""/usr/local/lib/python3.8/dist-packages/gunicorn/arbiter.py"", line 609, in spawn_worker     worker.init_process()   File ""/usr/local/lib/python3.8/dist-packages/gunicorn/workers/geventlet.py"", line 143, in init_process     super().init_process()   File ""/usr/local/lib/python3.8/dist-packages/gunicorn/workers/base.py"", line 142, in init_process     self.run()   File ""/usr/local/lib/python3.8/dist-packages/gunicorn/workers/geventlet.py"", line 182, in run     a.wait()   File ""/usr/local/lib/python3.8/dist-packages/eventlet/greenthread.py"", line 225, in wait     return self._exit_event.wait()   File ""/usr/local/lib/python3.8/dist-packages/eventlet/event.py"", line 131, in wait     current.throw(*self._exc)   File ""/usr/local/lib/python3.8/dist-packages/eventlet/greenthread.py"", line 265, in main     result = function(*args, **kwargs)   File ""/usr/local/lib/python3.8/dist-packages/gunicorn/workers/geventlet.py"", line 83, in _eventlet_serve     conn, addr = sock.accept()   File ""/usr/local/lib/python3.8/dist-packages/eventlet/greenio/base.py"", line 228, in accept     self._trampoline(fd, read=True, timeout=self.gettimeout(), timeout_exc=_timeout_exc)   File ""/usr/local/lib/python3.8/dist-packages/eventlet/greenio/base.py"", line 206, in _trampoline     return trampoline(fd, read=read, write=write, timeout=timeout,   File ""/usr/local/lib/python3.8/dist-packages/eventlet/hubs/__init__.py"", line 157, in trampoline     return hub.switch()   File ""/usr/local/lib/python3.8/dist-packages/eventlet/hubs/hub.py"", line 310, in switch     return self.greenlet.switch()   File ""/usr/local/lib/python3.8/dist-packages/gunicorn/workers/geventlet.py"", line 102, in _eventlet_stop     client.wait()   File ""/usr/local/lib/python3.8/dist-packages/eventlet/greenthread.py"", line 225, in wait     return self._exit_event.wait()   File ""/usr/local/lib/python3.8/dist-packages/eventlet/event.py"", line 131, in wait     current.throw(*self._exc)   File ""/usr/local/lib/python3.8/dist-packages/eventlet/greenthread.py"", line 265, in main     result = function(*args, **kwargs)   File ""/usr/local/lib/python3.8/dist-packages/gunicorn/workers/geventlet.py"", line 156, in handle     client = ssl_wrap_socket(client, self.cfg)   File ""/usr/local/lib/python3.8/dist-packages/gunicorn/sock.py"", line 229, in ssl_wrap_socket     return ssl_context(conf).wrap_socket(sock,   File ""/usr/local/lib/python3.8/dist-packages/eventlet/green/ssl.py"", line 436, in wrap_socket     return GreenSSLSocket(sock, *a, _context=self, **kw)   File ""/usr/local/lib/python3.8/dist-packages/eventlet/green/ssl.py"", line 65, in __new__     ret = _original_sslsocket._create(   File ""/usr/lib/python3.8/ssl.py"", line 1031, in _create     notconn_pre_handshake_data = self.recv(1)   File ""/usr/lib/python3.8/ssl.py"", line 1257, in recv     return super().recv(buflen, flags) ConnectionResetError: [Errno 104] Connection reset by peer  Here is the server code, most likely it crashes on disconnection: https://pastebin.com/tSCS1d6a I'm running it with gunicorn, but the same used to hapen when i ran it like a normal flask app. This is on ubuntu. once the process is stopped and restarted, it works again fine, only to repeat after a few days again. I've tried running the whole thing with gunicorn using this command : gunicorn --workers 1 --worker-class eventlet --bind 0.0.0.0:5000 --certfile=/etc/ssl/chained.pem --keyfile=/etc/ssl/private/private-unencrypted.key --error-logfile ./error.txt --access-logfile ./access.txt RequestManager:app I've tried logging when the crash happens, seems to be on disconnection, but really not sure, cant pin point exactly. Tried a few other things, basically ran out of ideas, nothing seems to fix it.",[1] miguelgrinberg: This is likely an issue with eventlet's implementation of SSL. Unfortunately there isn't much that can be done since eventlet is not well maintained anymore. Maybe try switching to gevent?
34,pallets/flask,5528,https://github.com/orgs/pallets/discussions/5528,2024-07-14T08:12:45Z,Ideas,1,Add support to enable asyncio REPL in `flask shell` command,"Add support to enable asyncio REPL in `flask shell` command As flask and sqlalchemy have async support now, add support to enable asyncio REPL in flask shell command would be more convienient to test async code. Like python3 -m asyncio enables asyncio REPL, something like flask shell --async would make sense. What do you think?","[1] yuxiaoy1: @davidism Hello David, how about the suggestion?"
35,pallets/flask,5520,https://github.com/orgs/pallets/discussions/5520,2024-07-07T16:39:32Z,Q&A,2,Optimisation in deployment,Optimisation in deployment I'm seeking optimization strategies for a Flask-based face recognition app using YOLO and DeepFace libraries. The app works fine on localhost but consistently hits memory limits on free-tier hosting services. What are the best practices to reduce memory usage in Flask apps with ML models? Looking for specific optimizations for resource-constrainedÂ platforms.,"[1] ThiefMaster: Not using free hosting for ML and other compute-heavy deployment would probably be a good idea. Also, this sounds pretty much like a case on how to optimize your ML usage, and not how to optimize Flask (IMHO those two things should even run separately and not in the same process)  [2] NikhilKalloli: Consider using Streamlit instead of Flask. It offers better memory allocation for ML projects like your face recognition app. This can help address your deployment memory issues. For implementation details, check this"
36,pallets/flask,5518,https://github.com/orgs/pallets/discussions/5518,2024-07-05T17:42:35Z,Q&A,1,Flask ready command,Flask ready command is there any command to just type and create a basic flask app that show hello world or any thing like npm does?,"[1] ThiefMaster: https://github.com/pallets/flask?tab=readme-ov-file#a-simple-example It's so simple, there's no need for a command to generate this..."
,,,,,,,,,
38,pallets/flask,5507,https://github.com/orgs/pallets/discussions/5507,2024-06-24T17:34:49Z,Q&A,1,Clarify semantics of app context,"Clarify semantics of app context Thanks for building Flask! I'm one of the maintainers of https://github.com/google/mesop which is a Python UI framework built on Flask. Mesop uses g to maintain request-specific context (essentially the UI data for the current request), see call site example I read through the Flask docs and am not 100% sure whether this is an appropriate use of g. From https://flask.palletsprojects.com/en/3.0.x/api/#flask.g:  This is a good place to store resources during a request. For example, a before_request function could load a user object from a session id, then set g.user to be used in the view function.  This makes it sound like g is suitable as I'm trying to store information about the current request.  From https://flask.palletsprojects.com/en/3.0.x/appcontext/:  Flask automatically pushes an application context when handling a request  This suggests that an application context is always created inside the scope of a request. However, https://flask.palletsprojects.com/en/3.0.x/api/#flask.ctx.AppContext states:  An app context is created and pushed at the beginning of each request if one is not already active  This seems to suggest an application context is not always created inside the scope of a request. These two docs seem to contradict one another (or perhaps I'm mis-reading it). Any clarification would be helpful.  One of the complexities with our use case is that other developers are building on top of Mesop and could create app contexts, and I want to make sure that when I'm binding a value to g, it's to a local-specific app context and not some more global app context that persists across requests.","[1] davidism: This makes it sound like g is suitable as I'm trying to store information about the current request.  g is the appropriate place to store per-request data. For extensions, we recommend using a prefix like _extension_name_ as a namespace to avoid any potential name conflicts. See https://flask.palletsprojects.com/en/3.0.x/extensiondev/ and specifically https://flask.palletsprojects.com/en/3.0.x/extensiondev/#data-during-a-request for extension dev docs about this."
39,pallets/flask,5506,https://github.com/orgs/pallets/discussions/5506,2024-06-21T17:58:52Z,Q&A,1,FLASK==3.0.3/ Werkzeug==3.0.0 Cannot import name 'url_quote' from 'werkzeug.urls',FLASK==3.0.3/ Werkzeug==3.0.0 Cannot import name 'url_quote' from 'werkzeug.urls' I keep getting the error:  Cannot import name 'url_quote' from 'werkzeug.urls'. I'm using python 3.12 I've tried the following combinations with no success: Flask==3.0.3 Werkzeug==3.0.0 Flask==2.2.2 Werkzeug==2.2.2 Flask == 2.0.1 Werkzeug==2.2.2 flask>=2.0 Werkzeug>=2.0 flask==2.01 Werkzeug==2.2.2 Please Help!,"[1] davidism: Be sure to include a minimal reproducible example, including the full traceback when you get an error. Using the latest versions of Flask and Werkzeug do not have this problem. It's likely this error is coming from an extension, either an old version or one that has not been updated to work with modern versions of Flask."
40,pallets/flask,5505,https://github.com/orgs/pallets/discussions/5505,2024-06-21T11:30:15Z,Q&A,2,Accessing and `flask.g` and `flask.current_app` in a `threading.Thread`,"Accessing and `flask.g` and `flask.current_app` in a `threading.Thread` I loop over a list and start a Thread. I donâ€™t have access to flask.app and flask.g in the function executed by the Thread. I tried to pass app as a parameter with no success. Any idea? from flask import current_app as app  def my_function(app):   with app.app_context():         app.logger.info(""Lorem ipsum"")  def enqueue_my_function(queue, app):     for chunk in my_function(app):         queue.put(chunk)     queue.put(None)  # ... Thread(target=enqueue_my_function, args=(queue, app)).start() I got this error:  RuntimeError: Working outside of application context. This typically means that you attempted to use functionality that needed the current application. To solve this, set up an application context with app.app_context(). See the documentation for more information.  I have read the documentation but still donâ€™t understand the issue.","[1] ThiefMaster: Pass app._get_current_object() instead of app to your Thread. The current_app proxy is thread-local so of course it won't work when accessed from a different thread. And FWIW, aliasing current_app as app and then having a function arg named app as well is not helpful in making your code more readable (especially outside a small example snippet) Also, the general advice: Depending on what you want to do, a background task daemon like Celery that runs in a different process may be better than running a thread within your webapp itself.  [2] lucpotage: Thank you very much @ThiefMaster, it works! from flask import current_app, g  def my_function(app):   with app.app_context():         app.logger.info(""Lorem ipsum"")         g.something = ""Dolor sit amet""  def enqueue_my_function(queue, app):     for chunk in my_function(app):         queue.put(chunk)     queue.put(None)  # ... Thread(target=enqueue_my_function, args=(queue, current_app. _get_current_object())).start() I will have a look at background task daemon like Celery."
41,pallets/flask,5501,https://github.com/orgs/pallets/discussions/5501,2024-06-14T20:45:30Z,Q&A,2,Potential bad practice with secret key in tutorial example,"Potential bad practice with secret key in tutorial example So, while looking at the tutorial, I noticed something odd: The page describing the secret key (https://flask.palletsprojects.com/en/3.0.x/config/#SECRET_KEY) says to not commit the secret key, but the tutorial puts the secret key in init.py, which is almost certainly gonna be commited.","[1] FavoritoHJS: and as per tradition, i think of a solution mere seconds after publishing my question it doesn't really matter if it's commited, so long as the repo is fully private. Once you share it is where problems arise.  [2] ThiefMaster: I think the point of the tutorial is to have something simple. Adding a config wile would make it more complex..."
,,,,,,,,,
43,pallets/flask,5484,https://github.com/orgs/pallets/discussions/5484,2024-05-19T00:42:22Z,Ideas,1,Rendering templates documentation edit,"Rendering templates documentation edit I am working through the quickstart guide and testing out templates, and this code snippet confused me a bit: from flask import render_template  @app.route('/hello/') @app.route('/hello/<name>') def hello(name=None):     return render_template('hello.html', name=name) I wasn't sure why name=name was necessary. I learned that the first name is referring to the variable in the referenced html file: <!doctype html> <title>Hello from Flask</title> {% if name %}   <h1>Hello {{ name }}!</h1> {% else %}   <h1>Hello, World!</h1> {% endif %} This may be trivial, but since it confused me, I thought it might of confused others. I wanted to suggest something like this: @app.route(""/hello/"") @app.route('/hello/<name>') def hello(name=None):     return render_template('hello.html', person=name) with the html file looking like this: <!doctype html> <title>Hello from Flask</title> {% if person %}   <h1>Hello {{ person }}!</h1> {% else %}   <h1>Hello, World!</h1> {% endif %} I think this helps differentiate the variable in the html file from the url variable. Let me know your thoughts. ğŸ˜„","[1] davidism: Makes sense to me, did you want to make a PR?"
44,pallets/flask,5465,https://github.com/orgs/pallets/discussions/5465,2024-04-15T16:52:05Z,Ideas,1,Support for jinja alternatives,"Support for jinja alternatives I suppose this have low chances to happen, but that might be fun to discuss though. I stumbled upon Armin Ronacher's minijinja project, that is a rewrite in Rust. The project announce to be kinda compatible with jinja  MiniJinja attempts a reasonably high level of compatibility with Jinja2, but it does not try to achieve this at all costs  I have noticed that jinja is sometimes the performance bottleneck, notably in unit tests, so the Rust rewrite looks appealing. Flask has a hard dependency towards jinja at the moment, but that would be awesome if it provided some kind of interface that could be filled either by jinja or minijinja. I suppose this would require a lot of work making the code generic, and I am not sure what would be the performance benefit in production environments, but that would be cool :) What do you think?","[1] davidism: I have actually been thinking about this for a long time, especially while I was doing work last year to move things like redirect and url_for to be methods on the Flask app rather than global functions. It would be nice to allow using different template engines, but I'm not sure if it's realistic. There's no standard API for accessing/rendering templates, so right now everything assumes Jinja. There's also no standardization on features or syntax, so extensions that expect Jinja will fail if Mako is plugged in, and I can't think of a good way around that either. Even within different implementations of Jinja, the language itself isn't standardized, so I can't guarantee that they'll all be able to render each other's templates. So yes, I am interested in this, but there's no active work on it. Additionally, if speed in Jinja is an issue, you should look into how you have the caches configured, and look into precompiling the templates. I also have vague ideas around improving the spec, parser, and compiler which could improve things in the long term."
45,pallets/flask,5454,https://github.com/orgs/pallets/discussions/5454,2024-04-02T16:02:24Z,Q&A,1,How to get request's path with parameter not substituted?,"How to get request's path with parameter not substituted? Hello, I hope your day is going well. I'm working with Flask endpoints that have parameters, e.g. @app.route(""/prefix/<param>"", methods=[""GET""]). Suppose param can be a string. I'm looking for a way to access a current route's parametrized path, i.e. /prefix/<param>, not /prefix/abc. How can I do that? What would request.path return? Thank you.",[1] davidism: request.url_rul contains the matched Rule object https://werkzeug.palletsprojects.com/en/3.0.x/routing/#werkzeug.routing.Rule
46,pallets/flask,5443,https://github.com/orgs/pallets/discussions/5443,2024-03-20T11:19:28Z,Q&A,6,Unable to silence logging messages,"Unable to silence logging messages Im getting ~15 of:  127.0.0.1 - - [16/Mar/2024 12:10:13] ""POST / HTTP/1.1"" 200 -  in the terminal when Im running a Dash application. server = flask.Flask(__name__) app = dash.Dash(     __name__,     server=server,     external_stylesheets=[dbc.themes.BOOTSTRAP],     meta_tags=[         {""name"": ""viewport"", ""content"": ""width=device-width, initial-scale=1""}     ], )  (https://github.com/AlexKurek/srt-py/blob/master/srt/dashboard/app.py#L53) How do I silence them? I have found a lot of methods, e.g. Disable console messages in Flask server, but none of them worked. My guess is that since they worked in previous versions of Flask - could this be a regression? Environment:  Python version: 3.11 Flask version: 3.0.2","[1] codespearhead: Try this.  [2] jtrip: Perhaps it is the application server that is doing the logging, which wsgi server are you using? Check to see how to limit logging there.  [3] jtrip: Great, have you tried to silence the logging at that level to see if that resolves the issue for you? I've seen some related discussion here: Pylons/waitress#151 and in the documentation: https://docs.pylonsproject.org/projects/waitress/en/stable/logging.html they suggest something like setup_console_handler = False as a parameter in serve() but I've also seen something like: serve(app, _quiet=True) not sure if there is a version difference there or if either might work. Edit: Oh I also see: ""That _quiet parameter is a testing shim, and is not public API."" So that is not recommended, but one of the other solutions in that issue (151) should help.  [4] jtrip: Can you provide a minimum reproducible example? I don't know much about dash (maybe that is also doing some logging?) not sure how to set that up or how the waitress serve call integrates with the example in your original post. Also it might be good to analyze the results of the things you've tried beyond does or does not work. The first solution you tried is setting the log level, does the app seem to be respecting that or are you seeing entries on a lower level?  [5] jtrip: Ok yeah large applications can be a challenge when debugging. I just made a simple flask + dash + waitress app. Like this: from flask import Flask from dash import Dash from dash import html from waitress import serve import logging  waitress_logger = logging.getLogger('waitress') waitress_logger.setLevel(logging.ERROR)  flask_app = Flask(__name__) flask_app.logger.handlers = waitress_logger.handlers  app = Dash(__name__, server=flask_app, routes_pathname_prefix='/dash/') app.layout = html.Div(children=[     html.H1(children='Hello Dash'), ])  @flask_app.route('/') def hello():     return 'Hello, this is the Flask part! Navigate to /dash/ for the Dash app.'   if __name__ == '__main__':     serve(flask_app, host='0.0.0.0', port=8080)    and I noticed that without the logging handlers setting the level properly I was getting INFO level messages about a task queue. However with the handlers added and level set like in this example I no longer see INFO messages, but would expect to see ERROR messages. So I think that should work. Maybe you could share more details about the exact messages are trying to silence."
47,pallets/flask,5441,https://github.com/orgs/pallets/discussions/5441,2024-03-17T17:35:13Z,Q&A,1,Does Flask suffer of the problem of useless order by on some ORM prefetches ?,"Does Flask suffer of the problem of useless order by on some ORM prefetches ? Hello, Recently I found a problem with Django and submitted a patch in a PR: https://code.djangoproject.com/ticket/35309 django/django#17984 I also developped a work-around for old versions of Django: https://github.com/LLyaudet/django-monkey-patches/blob/main/src/django_monkey_patches/django__orm__prefetch_without_useless_order_by.py I don't know yet Flask details. The idea is just that some models can have a default ordering (I assume this functionality is present in Flask also). And that some ORM may still add this ordering in the SQL query whilst it is not needed because only a single object will be prefetched per instance of the original result set. On very big prefetches I noticed a gain of 10 - 15 %, since the rest of the DB query is mainly an index scan. #ClimateChangeBrake Can someone please dump the queries of such prefetches and see if the bug is present in Flask ? If so submitting a PR should not be too hard. I will try to help. But right now, I start by warning the frameworks ORM I am aware of :) Best regards, Laurent Lyaudet","[1] ThiefMaster: Flask does not contain an ORM. So this is (probably) an SQLAlchemy (not Flask-SQLAlchemy!) question. But AFAIK there is no ordering at all by default (whatever order the DB gives you), and when you use .order_by() it will create a db-level ORDER BY."
48,pallets/flask,5439,https://github.com/orgs/pallets/discussions/5439,2024-03-14T14:17:03Z,Q&A,1,KeyError-  KeyError: 'name',"KeyError-  KeyError: 'name' Traceback (most recent call last): File ""C:\Users\User\AppData\Local\Programs\Python\Python311\Lib\site-packages\flask\app.py"", line 2213, in call return self.wsgi_app(environ, start_response) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File ""C:\Users\User\AppData\Local\Programs\Python\Python311\Lib\site-packages\flask\app.py"", line 2193, in wsgi_app response = self.handle_exception(e) ^^^^^^^^^^^^^^^^^^^^^^^^ File ""C:\Users\User\AppData\Local\Programs\Python\Python311\Lib\site-packages\flask\app.py"", line 2190, in wsgi_app response = self.full_dispatch_request() ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File ""C:\Users\User\AppData\Local\Programs\Python\Python311\Lib\site-packages\flask\app.py"", line 1486, in full_dispatch_request rv = self.handle_user_exception(e) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File ""C:\Users\User\AppData\Local\Programs\Python\Python311\Lib\site-packages\flask\app.py"", line 1484, in full_dispatch_request rv = self.dispatch_request() ^^^^^^^^^^^^^^^^^^^^^^^ File ""C:\Users\User\AppData\Local\Programs\Python\Python311\Lib\site-packages\flask\app.py"", line 1469, in dispatch_request return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File ""d:\root\main.py"", line 73, in dashboard if session['name']: ^^^^^^^^^^^^^^^^ File ""C:\Users\User\AppData\Local\Programs\Python\Python311\Lib\site-packages\flask\sessions.py"", line 79, in getitem return super().getitem(key) ^^^^^^^^^^^^^^^^^^^^^^^^ KeyError: 'name @app.route('/dashboard/') def dashboard():     if session['name']:         return render_template('dashboard.html')              return redirect('/login')","[1] davidism: This is a common Python problem, unrelated to Flask. If you're not sure if a key ('name') is in a dict (session), you should use 'name' in session to check, or use session.get('name') which will return None rather than a key error if it's missing."
49,pallets/flask,5438,https://github.com/orgs/pallets/discussions/5438,2024-03-14T11:45:11Z,Q&A,1,AttributeError: AttributeError: 'str' object has no attribute 'decode',"AttributeError: AttributeError: 'str' object has no attribute 'decode' Traceback (most recent call last):   File ""C:\Users\User\AppData\Local\Programs\Python\Python311\Lib\site-packages\flask\app.py"", line 2213, in __call__     return self.wsgi_app(environ, start_response)            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File ""C:\Users\User\AppData\Local\Programs\Python\Python311\Lib\site-packages\flask\app.py"", line 2193, in wsgi_app     response = self.handle_exception(e)                ^^^^^^^^^^^^^^^^^^^^^^^^   File ""C:\Users\User\AppData\Local\Programs\Python\Python311\Lib\site-packages\flask\app.py"", line 2190, in wsgi_app     response = self.full_dispatch_request()                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File ""C:\Users\User\AppData\Local\Programs\Python\Python311\Lib\site-packages\flask\app.py"", line 1486, in full_dispatch_request     rv = self.handle_user_exception(e)          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File ""C:\Users\User\AppData\Local\Programs\Python\Python311\Lib\site-packages\flask\app.py"", line 1484, in full_dispatch_request     rv = self.dispatch_request()          ^^^^^^^^^^^^^^^^^^^^^^^   File ""C:\Users\User\AppData\Local\Programs\Python\Python311\Lib\site-packages\flask\app.py"", line 1469, in dispatch_request     return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File ""d:\root\main.py"", line 56, in register     New_User = User(email=email, name=name, password=password)                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File ""<string>"", line 4, in __init__   File ""C:\Users\User\AppData\Local\Programs\Python\Python311\Lib\site-packages\sqlalchemy\orm\state.py"", line 566, in _initialize_instance     with util.safe_reraise():   File ""C:\Users\User\AppData\Local\Programs\Python\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py"", line 147, in __exit__     raise exc_value.with_traceback(exc_tb)   File ""C:\Users\User\AppData\Local\Programs\Python\Python311\Lib\site-packages\sqlalchemy\orm\state.py"", line 564, in _initialize_instance     manager.original_init(*mixed[1:], **kwargs)   File ""d:\root\main.py"", line 20, in __init__     self.password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt(password.decode('utf-8')))                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^ AttributeError: 'str' object has no attribute 'decode'  Code: from flask import * from flask_sqlalchemy import SQLAlchemy import bcrypt  app = Flask(__name__)  app.config['SQLALCHEMY_DATABASE_URI'] ='sqlite:///database.db'  db = SQLAlchemy(app) app.secret_key = 'server_secret'  class User(db.Model):     id = db.Column(db.Integer, primary_key=True)     name = db.Column(db.String(100), nullable=False)      email = db.Column(db.String(100), unique=True)     password = db.Column(db.String(100))      def __init__(self, email, password, name):         self.name = name         self.email = email         self.password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt(password.decode('utf-8')))     def check_password(self, password):         return bcrypt.checkpw(password.encode('utf-8'), self.password.encode('utf-8'))  with app.app_context():     db.create_all()   @app.route('/') def home():     return render_template('index.html')  @app.route('/about/') def about():     return render_template('about.html')  @app.route('/login/', methods=['POST', 'GET']) def login():     if request.method == 'POST':         email = request.form['email']         password = request.form['password']          user = User.query.filter_by(email=email).first()         if user and user.check_password(password):             return redirect(url_for('dashboard'))         else:             return redirect(url_for('login'), error='Invalid password or email')  @app.route('/register/', methods=['POST', 'GET']) def register():     if request.method == 'POST':         name = request.form['name']         email = request.form['email']         password = request.form['password']          New_User = User(email=email, name=name, password=password)         db.session.add(New_User)         db.session.commit()          return redirect(url_for('login'))          return render_template('register.html')  app.run(debug=True, port=5500)",[1] ThiefMaster: You want encode and not decode.
50,pallets/flask,5437,https://github.com/orgs/pallets/discussions/5437,2024-03-11T15:44:00Z,Q&A,2,How to avoid duplicate threads in debug mode,"How to avoid duplicate threads in debug mode Issue Description I have a similar issue as #5307 and I also understand the arguments related to threads in web applications. In my case of a web server for controlling Raspberry Pi cameras raspiCamSrv, there are several threads under control of the web app, like live stream, video recording, etc. These threads use the Picamera2 library which starts its own threads. This is normally not an issue because these threads are started by users from the Web UI after the Flask server has started. Now, I have added a motion capture feature, which is also running in an own thread and users want this feature to be automatically started with the server, for example after the device has been rebooted. Currently, I start this thread in the app factory create_app(). And, as in #5307, the thread is started again when I start Flask with the --debug option. I do not seem to have the possibility from my own code to detect whether these threads are already active. The classes from which these threads are started and which hold their references, seem to be initialized again, although they are singletons. Question I am not considering this as a bug. My question is whether there is a possibility in create_app(), to know that the app is being recreated on behalf of the autoloader. Environment:  Python version: 3.11.2 Flask version: 3.0.0 Wekzeug version: 3.0.1","[1] davidism: Use if not is_running_from_reloader(): https://werkzeug.palletsprojects.com/en/3.0.x/serving/#werkzeug.serving.is_running_from_reloader to only do something the first time the dev server starts and not when it reloads.  [2] signag: Thanks for this info. Unfortunately, it does not solve my problem because I posed the wrong question. The right question would have been: How can I know at the first server start that the reloader will restart the server? Then, I could avoid starting the thread at the first start and have it only started the second time."
