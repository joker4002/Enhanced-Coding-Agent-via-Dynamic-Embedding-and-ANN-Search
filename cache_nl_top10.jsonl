{"query": "Flask app crashes when using send_file() with BytesIO object in debug mode When using send_file() with a BytesIO object while debug=True, the application raises a ValueError on the second request to the same endpoint. Environment:  Python version: 3.11.4 Flask version: 3.0.2 Werkzeug version: 3.0.1 OS: Ubuntu 22.04  Steps to Reproduce: from flask import Flask, send_file from io import BytesIO  app = Flask(__name__)  @app.route('/download') def download():     buffer = BytesIO()     buffer.write(b'Hello World')     buffer.seek(0)     return send_file(buffer, mimetype='text/plain', download_name='hello.txt')  if __name__ == '__main__':     app.run(debug=True)  Run the app with python app.py Visit http://127.0.0.1:5000/download once (works fine) Refresh the page (crashes)  Expected Behavior: The file should download successfully on every request. Actual Behavior: ValueError: I/O operation on closed file.", "mode": "nl", "used_query": "Flask app crashes when using send_file() with BytesIO object in debug mode When using send_file() with a BytesIO object while debug=True, the application raises a ValueError on the second request to the same endpoint. Environment:  Python version: 3.11.4 Flask version: 3.0.2 Werkzeug version: 3.0.1 OS: Ubuntu 22.04  Steps to Reproduce: from flask import Flask, send_file from io import BytesIO  app = Flask(__name__)  @app.route('/download') def download():     buffer = BytesIO()     buffer.write(b'Hello World')     buffer.seek(0)     return send_file(buffer, mimetype='text/plain', download_name='hello.txt')  if __name__ == '__main__':     app.run(debug=True)  Run the app with python app.py Visit http://127.0.0.1:5000/download once (works fine) Refresh the page (crashes)  Expected Behavior: The file should download successfully on every request. Actual Behavior: ValueError: I/O operation on closed file.", "gold_terms": ["davidism", "can", "reproduce", "issue", "the", "example", "provided", "requests", "result", "successful", "responses", "something", "else", "going", "beyond", "what", "you", "shown"], "results": [{"rank": 1, "score": 0.6035427451133728, "raw_score": 0.6035427451133728, "source": "flask", "row": 147, "chunk_id": "e4349f8c793a98e1c2a8133fd2dd5d00ea3edd7c", "symbol_type": "function", "qualname": "send_file", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\helpers.py", "start_line": 407, "end_line": 530}, {"rank": 2, "score": 0.5883843898773193, "raw_score": 0.5883843898773193, "source": "docs", "row": 80, "chunk_id": "052d72a8c45997b6522e3a638f947301febf9102", "symbol_type": "doc", "qualname": "debugging.rst#External Debuggers", "file_path": "d:\\499\\docs\\debugging.rst", "start_line": 61, "end_line": 99}, {"rank": 3, "score": 0.5842387080192566, "raw_score": 0.5842387080192566, "source": "flask", "row": 130, "chunk_id": "897ecb46f1df42a07069a2002d9f4d5a22987f95", "symbol_type": "method", "qualname": "FormDataRoutingRedirect.__init__", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\debughelpers.py", "start_line": 57, "end_line": 78}, {"rank": 4, "score": 0.5809895992279053, "raw_score": 0.5809895992279053, "source": "flask", "row": 152, "chunk_id": "66c59e597bab748beac3b4958cd735edc4990b05", "symbol_type": "function", "qualname": "dump", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\json\\__init__.py", "start_line": 47, "end_line": 74}, {"rank": 5, "score": 0.5774531960487366, "raw_score": 0.5774531960487366, "source": "docs", "row": 287, "chunk_id": "bc682ee3609a2936c4ea696a22dacab8d0d57289", "symbol_type": "doc", "qualname": "quickstart.rst#Logging", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 800, "end_line": 827}, {"rank": 6, "score": 0.5742141008377075, "raw_score": 0.5742141008377075, "source": "flask", "row": 9, "chunk_id": "7a4280a5e1bcb934ccb2ddf399d35cb79827c7c1", "symbol_type": "method", "qualname": "Flask.raise_routing_exception", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 478, "end_line": 504}, {"rank": 7, "score": 0.5714982151985168, "raw_score": 0.5714982151985168, "source": "flask", "row": 213, "chunk_id": "9717f361919c4a1fb5541813ab9a2d68630bb15e", "symbol_type": "function", "qualname": "wsgi_errors_stream", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\logging.py", "start_line": 16, "end_line": 28}, {"rank": 8, "score": 0.5677754878997803, "raw_score": 0.5677754878997803, "source": "flask", "row": 360, "chunk_id": "f49b6a78bf160db5c2ffb21b5963c932655cb3e4", "symbol_type": "method", "qualname": "FlaskClient.open", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\testing.py", "start_line": 204, "end_line": 247}, {"rank": 9, "score": 0.5649082660675049, "raw_score": 0.5649082660675049, "source": "flask", "row": 148, "chunk_id": "44808507d2f2fda08e93a65dc9dd11b509ae4e6c", "symbol_type": "function", "qualname": "send_from_directory", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\helpers.py", "start_line": 533, "end_line": 574}, {"rank": 10, "score": 0.5631179809570312, "raw_score": 0.5631179809570312, "source": "flask", "row": 126, "chunk_id": "d1833c5ea2be7f4633451596716a736526ca5420", "symbol_type": "class", "qualname": "DebugFilesKeyError", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\debughelpers.py", "start_line": 23, "end_line": 47}]}
{"query": "Issue with send_file() and send_from_directory() not sending I'm following the pattern here to try and send a file from temporary storage and I'm encountering an error that I don't know how to debug.  I was hoping somebody here can help. I have a view function that redirects to a function that calls send_file() (I've tried both send_file() and send_from_directory).  I'm not seeing any exceptions and everything seems to work fine, but the file is not sending.  When I open up dev tools in Chrome or Edge, however i can see the file in the network panel (no error code there either -- it redirected with status code 200). And if I double-click it it will then be downloaded as an attachment.  Any clue why it is not sending automatically?  Not sure if it matters, but I'm using Flask==2.3.2, but I've tried with Flask==3.1.2 as well. Here's the gist of what I'm doing: @app.route('/some-function', methods=['GET','POST']) def some_function():     # some stuff happens (I define filename and do some other simple things)     if request.method == 'POST':         updates = request.data    # get some data  -- this works fine         df = pandas_function(updates)    # do some stuff with that data -- this works fine         df.to_excel(os.path.join(app.cofing['UPLOAD_FOLDER'], filename)  # write file -- this works fine          return redirect(url_for('download_file', filename=filename))     return render_template('some_template.html')  @app.route('/uploads/<filename>') def download_file(filename):     print('i just redirected')    # this prints so it seems like it redirected successfully     return send_from_directory(os.path.join(current_app.root_path, app.config['UPLOAD_FOLDER']), filename, as_attachment=True) Thanks for any help you can offer!", "mode": "nl", "used_query": "Issue with send_file() and send_from_directory() not sending I'm following the pattern here to try and send a file from temporary storage and I'm encountering an error that I don't know how to debug.  I was hoping somebody here can help. I have a view function that redirects to a function that calls send_file() (I've tried both send_file() and send_from_directory).  I'm not seeing any exceptions and everything seems to work fine, but the file is not sending.  When I open up dev tools in Chrome or Edge, however i can see the file in the network panel (no error code there either -- it redirected with status code 200). And if I double-click it it will then be downloaded as an attachment.  Any clue why it is not sending automatically?  Not sure if it matters, but I'm using Flask==2.3.2, but I've tried with Flask==3.1.2 as well. Here's the gist of what I'm doing: @app.route('/some-function', methods=['GET','POST']) def some_function():     # some stuff happens (I define filename and do some other simple things)     if request.method == 'POST':         updates = request.data    # get some data  -- this works fine         df = pandas_function(updates)    # do some stuff with that data -- this works fine         df.to_excel(os.path.join(app.cofing['UPLOAD_FOLDER'], filename)  # write file -- this works fine          return redirect(url_for('download_file', filename=filename))     return render_template('some_template.html')  @app.route('/uploads/<filename>') def download_file(filename):     print('i just redirected')    # this prints so it seems like it redirected successfully     return send_from_directory(os.path.join(current_app.root_path, app.config['UPLOAD_FOLDER']), filename, as_attachment=True) Thanks for any help you can offer!", "gold_terms": ["davidism", "returning", "text", "not", "redirect", "return", "url_for"], "results": [{"rank": 1, "score": 0.7149240970611572, "raw_score": 0.7149240970611572, "source": "flask", "row": 148, "chunk_id": "44808507d2f2fda08e93a65dc9dd11b509ae4e6c", "symbol_type": "function", "qualname": "send_from_directory", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\helpers.py", "start_line": 533, "end_line": 574}, {"rank": 2, "score": 0.6430784463882446, "raw_score": 0.6430784463882446, "source": "flask", "row": 4, "chunk_id": "c489d69714a72cefb058fb26c8d8d988653fbce5", "symbol_type": "method", "qualname": "Flask.send_static_file", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 308, "end_line": 328}, {"rank": 3, "score": 0.6332122087478638, "raw_score": 0.6332122087478638, "source": "flask", "row": 147, "chunk_id": "e4349f8c793a98e1c2a8133fd2dd5d00ea3edd7c", "symbol_type": "function", "qualname": "send_file", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\helpers.py", "start_line": 407, "end_line": 530}, {"rank": 4, "score": 0.628605842590332, "raw_score": 0.628605842590332, "source": "flask", "row": 39, "chunk_id": "7bbaac0ef0c9600e8a8310bea496e6d1af4d92b9", "symbol_type": "method", "qualname": "Blueprint.send_static_file", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\blueprints.py", "start_line": 82, "end_line": 102}, {"rank": 5, "score": 0.579384982585907, "raw_score": 0.579384982585907, "source": "docs", "row": 204, "chunk_id": "aa56632513da0ec7934d91acb545eab0aa9e26eb", "symbol_type": "doc", "qualname": "patterns\\fileuploads.rst#Uploading Files", "file_path": "d:\\499\\docs\\patterns\\fileuploads.rst", "start_line": 2, "end_line": 12}, {"rank": 6, "score": 0.5746768712997437, "raw_score": 0.5746768712997437, "source": "flask", "row": 38, "chunk_id": "c8305ce1ba2a7a34f2382f3aef5aae18ddf041f4", "symbol_type": "method", "qualname": "Blueprint.get_send_file_max_age", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\blueprints.py", "start_line": 55, "end_line": 80}, {"rank": 7, "score": 0.5722938179969788, "raw_score": 0.5722938179969788, "source": "docs", "row": 280, "chunk_id": "a4b78cdf97e5a4e16b78441aee6759e093d75f7c", "symbol_type": "doc", "qualname": "quickstart.rst#File Uploads", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 507, "end_line": 549}, {"rank": 8, "score": 0.5687886476516724, "raw_score": 0.5687886476516724, "source": "flask", "row": 3, "chunk_id": "7ed3163e62dc47435697e83110e6bd4d52b15476", "symbol_type": "method", "qualname": "Flask.get_send_file_max_age", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 281, "end_line": 306}, {"rank": 9, "score": 0.5555716753005981, "raw_score": 0.5555716753005981, "source": "flask", "row": 130, "chunk_id": "897ecb46f1df42a07069a2002d9f4d5a22987f95", "symbol_type": "method", "qualname": "FormDataRoutingRedirect.__init__", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\debughelpers.py", "start_line": 57, "end_line": 78}, {"rank": 10, "score": 0.5458739995956421, "raw_score": 0.5458739995956421, "source": "docs", "row": 205, "chunk_id": "9d6933869ddb42b5be001aeeb7f46fb0770b9306", "symbol_type": "doc", "qualname": "patterns\\fileuploads.rst#A Gentle Introduction", "file_path": "d:\\499\\docs\\patterns\\fileuploads.rst", "start_line": 15, "end_line": 126}]}
{"query": "How to add HTML into a Beautiful Table cell? Hi, first time question asker here. I am trying to add some HTML code into a table based on Miguel Grinberg's Beautiful basic table.  I am still a novice at Flask, so please forgive me if this is a \"stupid\" question.  When I use the following, the table displays as expected: new gridjs.Grid({ columns: [ { id: 'event_id', name: 'Event ID', sort: false } ... But when I add the following formatter sequence, the table fails to display. new gridjs.Grid({ columns: [ { id: 'event_id', name: 'Event ID', sort: false, formatter: (cell) => html('${cell}') }, ... What am I doing wrong?  Is there a way to add HTML (and specifically href) to a table cell? Thank you for your time and consideration. Best regards, ET", "mode": "nl", "used_query": "How to add HTML into a Beautiful Table cell? Hi, first time question asker here. I am trying to add some HTML code into a table based on Miguel Grinberg's Beautiful basic table.  I am still a novice at Flask, so please forgive me if this is a \"stupid\" question.  When I use the following, the table displays as expected: new gridjs.Grid({ columns: [ { id: 'event_id', name: 'Event ID', sort: false } ... But when I add the following formatter sequence, the table fails to display. new gridjs.Grid({ columns: [ { id: 'event_id', name: 'Event ID', sort: false, formatter: (cell) => html('${cell}') }, ... What am I doing wrong?  Is there a way to add HTML (and specifically href) to a table cell? Thank you for your time and consideration. Best regards, ET", "gold_terms": ["miguelgrinberg", "example", "which", "inserts", "email", "link", "table", "cell", "above", "you", "appear", "using", "single", "quotes", "inside", "the", "html", "function", "want", "use"], "results": [{"rank": 1, "score": 0.39566755294799805, "raw_score": 0.39566755294799805, "source": "docs", "row": 12, "chunk_id": "fbd87be76e29e9913e8259191b165b5cb3a8b354", "symbol_type": "doc", "qualname": "api.rst#JSON Support", "file_path": "d:\\499\\docs\\api.rst", "start_line": 221, "end_line": 261}, {"rank": 2, "score": 0.366145521402359, "raw_score": 0.366145521402359, "source": "docs", "row": 278, "chunk_id": "41660faaae172031611b75193e99aa002ba35d76", "symbol_type": "doc", "qualname": "quickstart.rst#Rendering Templates", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 351, "end_line": 447}, {"rank": 3, "score": 0.36604979634284973, "raw_score": 0.36604979634284973, "source": "docs", "row": 215, "chunk_id": "6e800024d3dadc7de91f3646b59d113b530a0ab2", "symbol_type": "doc", "qualname": "patterns\\javascript.rst#Rendering Templates", "file_path": "d:\\499\\docs\\patterns\\javascript.rst", "start_line": 25, "end_line": 60}, {"rank": 4, "score": 0.3350943624973297, "raw_score": 0.3350943624973297, "source": "docs", "row": 388, "chunk_id": "3b4316b221219dcb0f5833e0f637b574de66c1b1", "symbol_type": "doc", "qualname": "web-security.rst#JSON Security", "file_path": "d:\\499\\docs\\web-security.rst", "start_line": 141, "end_line": 151}, {"rank": 5, "score": 0.33056482672691345, "raw_score": 0.33056482672691345, "source": "docs", "row": 271, "chunk_id": "3f4c35aa993725f9557f7ebf3271d1976f552b91", "symbol_type": "doc", "qualname": "quickstart.rst#HTML Escaping", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 129, "end_line": 152}, {"rank": 6, "score": 0.32782983779907227, "raw_score": 0.32782983779907227, "source": "docs", "row": 311, "chunk_id": "6987818864195d742dc774c64b512a4f95692813", "symbol_type": "doc", "qualname": "templating.rst#Jinja Setup", "file_path": "d:\\499\\docs\\templating.rst", "start_line": 16, "end_line": 29}, {"rank": 7, "score": 0.3264352083206177, "raw_score": 0.3264352083206177, "source": "flask", "row": 195, "chunk_id": "650ef6b558e13943f2ac910994f5d2e40d487c1e", "symbol_type": "method", "qualname": "TagMarkup.to_json", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\json\\tag.py", "start_line": 184, "end_line": 185}, {"rank": 8, "score": 0.324903279542923, "raw_score": 0.324903279542923, "source": "docs", "row": 316, "chunk_id": "706b01ea884838104b3e0294b335d790178a28d5", "symbol_type": "doc", "qualname": "templating.rst#Streaming", "file_path": "d:\\499\\docs\\templating.rst", "start_line": 232, "end_line": 255}, {"rank": 9, "score": 0.3175320625305176, "raw_score": 0.3175320625305176, "source": "docs", "row": 250, "chunk_id": "0fbb9dfa71f16148c8c8a4a536570402a9f21a6f", "symbol_type": "doc", "qualname": "patterns\\streaming.rst#Streaming from Templates", "file_path": "d:\\499\\docs\\patterns\\streaming.rst", "start_line": 30, "end_line": 47}, {"rank": 10, "score": 0.31146854162216187, "raw_score": 0.31146854162216187, "source": "docs", "row": 310, "chunk_id": "0b6ba4a4a2cdacee407fe0ce504b1008b71f20ce", "symbol_type": "doc", "qualname": "templating.rst#Templates", "file_path": "d:\\499\\docs\\templating.rst", "start_line": 2, "end_line": 13}]}
{"query": "Proposal: CLI command to validate API endpoints by making test requests Motivation When working on Flask applications with many API endpoints, it is sometimes useful to quickly check whether all registered routes can be accessed without raising unexpected errors (e.g. unhandled exceptions, 500 errors). At the moment, developers typically need to write custom scripts or tests to perform this kind of basic validation. Providing an opt-in CLI command could help improve developer experience, especially during local development. Proposal Introduce an optional Flask CLI command (for example, flask check-endpoints) that iterates over registered routes and makes test requests using Flask’s test client. The goal would not be full correctness testing, but a lightweight sanity check to detect obvious runtime errors. Possible initial scope:  Only routes with simple methods (e.g. GET by default) Skip routes with required path parameters Report endpoints that raise exceptions or return 5xx responses Development-only usage  Design considerations  The command should be fully opt-in and not affect existing behavior. No network requests; use Flask’s built-in test client. Keep output simple and readable (similar to flask routes). Advanced features (custom payloads, auth, etc.) could be out of scope initially.  Open questions  Should this live as a core CLI command or as an optional extension? How should endpoints with required parameters or authentication be handled? Should the command fail on the first error or report all failures?  Feedback on the general direction and scope would be appreciated before starting an implementation.", "mode": "nl", "used_query": "Proposal: CLI command to validate API endpoints by making test requests Motivation When working on Flask applications with many API endpoints, it is sometimes useful to quickly check whether all registered routes can be accessed without raising unexpected errors (e.g. unhandled exceptions, 500 errors). At the moment, developers typically need to write custom scripts or tests to perform this kind of basic validation. Providing an opt-in CLI command could help improve developer experience, especially during local development. Proposal Introduce an optional Flask CLI command (for example, flask check-endpoints) that iterates over registered routes and makes test requests using Flask’s test client. The goal would not be full correctness testing, but a lightweight sanity check to detect obvious runtime errors. Possible initial scope:  Only routes with simple methods (e.g. GET by default) Skip routes with required path parameters Report endpoints that raise exceptions or return 5xx responses Development-only usage  Design considerations  The command should be fully opt-in and not affect existing behavior. No network requests; use Flask’s built-in test client. Keep output simple and readable (similar to flask routes). Advanced features (custom payloads, auth, etc.) could be out of scope initially.  Open questions  Should this live as a core CLI command or as an optional extension? How should endpoints with required parameters or authentication be handled? Should the command fail on the first error or report all failures?  Feedback on the general direction and scope would be appreciated before starting an implementation.", "gold_terms": ["think", "you", "could", "easily", "create", "standalone", "package", "integrates", "the", "flask", "cli", "via", "entrypoint", "jyup", "escape", "already", "created", "and", "like", "discuss"], "results": [{"rank": 1, "score": 0.6241765022277832, "raw_score": 0.6241765022277832, "source": "docs", "row": 128, "chunk_id": "c858dd7f32dc0e3b6b2d3e4ee5c3e180d46f6920", "symbol_type": "doc", "qualname": "errorhandling.rst#Handling", "file_path": "d:\\499\\docs\\errorhandling.rst", "start_line": 140, "end_line": 174}, {"rank": 2, "score": 0.6078915596008301, "raw_score": 0.6078915596008301, "source": "docs", "row": 131, "chunk_id": "46d93f09dc7d2aef75d165b2f9fff849f61c7cb1", "symbol_type": "doc", "qualname": "errorhandling.rst#Custom Error Pages", "file_path": "d:\\499\\docs\\errorhandling.rst", "start_line": 259, "end_line": 331}, {"rank": 3, "score": 0.6045626401901245, "raw_score": 0.6045626401901245, "source": "flask", "row": 13, "chunk_id": "3f1cdfd211540b7cae8f38853af5273c3831487d", "symbol_type": "method", "qualname": "Flask.test_client", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 669, "end_line": 725}, {"rank": 4, "score": 0.6026043891906738, "raw_score": 0.6026043891906738, "source": "docs", "row": 134, "chunk_id": "8702048bc2762c717b5a7032bb6a43374a8cf951", "symbol_type": "doc", "qualname": "errorhandling.rst#Returning API Errors as JSON", "file_path": "d:\\499\\docs\\errorhandling.rst", "start_line": 435, "end_line": 510}, {"rank": 5, "score": 0.5929638147354126, "raw_score": 0.5929638147354126, "source": "flask", "row": 14, "chunk_id": "9f5f231ea03e1260df1c33a2812e08d4afc79a5b", "symbol_type": "method", "qualname": "Flask.test_cli_runner", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 727, "end_line": 742}, {"rank": 6, "score": 0.5897578597068787, "raw_score": 0.5897578597068787, "source": "docs", "row": 362, "chunk_id": "e14c2b75028e5315eb60b1bf53393bc968190e95", "symbol_type": "doc", "qualname": "tutorial\\tests.rst#Test Coverage", "file_path": "d:\\499\\docs\\tutorial\\tests.rst", "start_line": 4, "end_line": 35}, {"rank": 7, "score": 0.5727856159210205, "raw_score": 0.5727856159210205, "source": "docs", "row": 129, "chunk_id": "d81a7841d06f9c7263b71aa13dd67bd06476a92f", "symbol_type": "doc", "qualname": "errorhandling.rst#Generic Exception Handlers", "file_path": "d:\\499\\docs\\errorhandling.rst", "start_line": 177, "end_line": 235}, {"rank": 8, "score": 0.5714707374572754, "raw_score": 0.5714707374572754, "source": "docs", "row": 282, "chunk_id": "49fb0819a9be095a95d47cdcdd7fb31e4d0d8c12", "symbol_type": "doc", "qualname": "quickstart.rst#Redirects and Errors", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 594, "end_line": 631}, {"rank": 9, "score": 0.5707310438156128, "raw_score": 0.5707310438156128, "source": "docs", "row": 69, "chunk_id": "bc6ef1952c983b8ae2df2541620e44769a487573", "symbol_type": "doc", "qualname": "config.rst#Builtin Configuration Values", "file_path": "d:\\499\\docs\\config.rst", "start_line": 64, "end_line": 451}, {"rank": 10, "score": 0.5703510642051697, "raw_score": 0.5703510642051697, "source": "flask", "row": 360, "chunk_id": "f49b6a78bf160db5c2ffb21b5963c932655cb3e4", "symbol_type": "method", "qualname": "FlaskClient.open", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\testing.py", "start_line": 204, "end_line": 247}]}
{"query": "Memory consumption spikes when an api endpoint with file upload capability is hit. I have an API application, created using connexion framework, which uses FlaskApp configuration. This app exposes an endpoint where users/consumers can upload artifacts(ranging from 2.5 MB to 400 MB) and they will be then upload to an internal storage platform. The pain point is, when the user selects a larger data file(~320 MB) to upload, the application often runs into OOM issue and eventually user receives 502 status response. Running dmesg command inside containers show the gunicorn thread being killed by oom_killer It would be of great help if someone here could guide in avoiding such OOM issues for Flask Applications. API Specifaction openapi: 3.0.0 info:   description: Description   version: 1.1.1   title:  API  servers:   - url: /api/v1     description: base path for version 1 of the API  components:    responses:     BinaryFile:       description: Content of stored binary file       content:         \"*/*\":           schema:             type: string             format: binary     BadArgument:       description: Request Validation failed       content:         application/json:           schema:             $ref: \"#/components/schemas/Error\"     NotFound:       description: Not Found (e.g. for a given Id)       content:         application/json:           schema:             $ref: \"#/components/schemas/Error\"     InternalServerError:       description: Internal Server Error       content:         application/json:           schema:             $ref: \"#/components/schemas/Error\"     ServiceUnavailable:       description: Service Temporary Unavailable       content:         application/json:           schema:             $ref: \"#/components/schemas/Error\"    parameters:     OrganizationId:       name: teamId       in: path       required: true       schema:         type: string         format: path         additionalProperties: false         anyOf:           - $ref: \"#/components/schemas/Id\"           - $ref: \"#/components/schemas/TeamId\"     TicketId:       name: ticketId       in: path       required: true       schema:         $ref: \"#/components/schemas/Id\"     ArtifactDataFileType:       name: dataType       in: path       required: true       schema:         $ref: \"#/components/schemas/ArtifactDataFileType\"    schemas:     Id:       description: Unique identifier of a Object/Document/Entity etc       type: string       # On why UUID is used see https://www.cockroachlabs.com/docs/stable/sql-faqs.html#what-are-the-differences-between-uuid-sequences-and-unique_rowid       format: string     SubscriptionType:       description: Subscription type       type: string       enum: [small, medium, large]       nullable: true     ArtifactDataFileType:       type: string       enum: [ artifact ]     TeamId:       type: string       description: Team's unique identifier     # According to \"Problem Details for HTTP APIs\" -> https://tools.ietf.org/html/draft-ietf-appsawg-http-problem-00     Error:       type: object       description: An Error object returned if something went wrong       additionalProperties: true       properties:         detail:           type: string         status:           type: integer         title:           type: string         type:           type: string     ArtifactBodyWithSubscriptionType:       type: object       additionalProperties: false       properties:         data:           type: string           format: binary         subscriptionType:           $ref: \"#/components/schemas/SubscriptionType\"   paths:   '/team/{teamId}/ticket/{ticketId}/{dataType}':     parameters:       - $ref: \"#/components/parameters/OrganizationId\"       - $ref: \"#/components/parameters/TicketId\"       - $ref: \"#/components/parameters/ArtifactDataFileType\"     post:       summary: Upload Artifact data file for this Ticket       x-openapi-router-controller: app.operations.epics       operationId: upload_data       requestBody:         required: true         content:           multipart/form-data:             schema:               $ref: '#/components/schemas/ArtifactBodyWithSubscriptionType'       responses:         '201':           description: Uploaded         '400':           $ref: \"#/components/responses/BadArgument\"         '404':           $ref: \"#/components/responses/NotFound\"         '500':           $ref: \"#/components/responses/InternalServerError\"         '503':           $ref: \"#/components/responses/ServiceUnavailable\" Python function import logging from http import HTTPStatus from typing import BinaryIO  from connexion import problem  from app.operations import _not_found from app.models.ticket import Ticket from app.storage import Storages   logger = logging.getLogger(__name__)   class Storages:     \"\"\"     Internal platform to store artifacts.     \"\"\"     def __init__(self, data_path):         self.data_path: str = data_path      def save(self, data_path: str, data: BinaryIO):         \"\"\"         API call to internal platform to store artifacts.         \"\"\"         pass      def ticket_path(self, ticket: Ticket, data_type):         \"\"\"         Returns the path where the ticket data should be stored.         \"\"\"         # This is a placeholder implementation.         # The actual implementation would return a path based on the ticket and data type.         return f\"{self.data_path}/{ticket.id}/{data_type}\"   def _get_ticket(params):     \"\"\"     Helper function to retrieve the ticket from the parameters.     \"\"\"     ...     return   def upload_data(**params):     # Checking file     data = params[\"data\"]     file_name = data.filename     if not file_name:         return problem(HTTPStatus.INTERNAL_SERVER_ERROR, \"Cannot upload file\", \"File is not provided\")      # Checking existence of ticket     ticket = _get_ticket(params)     if not ticket:         return _not_found(Ticket, params[\"ticketId\"])      # Saving file in storage     data_type = params[\"dataType\"]      try:         storage = Storages(data_path=\"/path/to/storage/on/internal/platform\"),         data_path = storage.ticket_path(ticket, data_type)         storage.save(data_path, data)     except Exception as ex:         logger.error(f\"cannot upload file into storage: {ex}\", exc_info=True)         return problem(HTTPStatus.INTERNAL_SERVER_ERROR, \"Cannot upload file\", \"Problems with storage\")      return None, HTTPStatus.CREATED Pipfile [[source]] url = \"https://pypi.org/simple/\" verify_ssl = true name = \"pypi\"  [requires] python_version = \"3.11\"  [packages] backoff = \"~=2.2.0\" boto3 = \"~=1.26.0\" connexion = {extras = [\"flask\", \"uvicorn\", \"swagger-ui\"],version = \"~=3.2.0\"} gunicorn = {extras = [\"gevent\"],version = \"~=23.0.0\"} aiohttp = \"~=3.10.10\" aiohttp_retry = \"~=2.8.3\" greenlet = \"==3.1.1\" kubernetes = \"~=24.0\" psycopg-c = \"~=3.2.2\" psycopg-pool = \"~=3.2.3\" rfc3339-validator = \"~=0.1.0\" shapely = \"~=2.1.0\" jsonschema = \"~=4.23.0\"  Application startup command python -m gunicorn --worker-class uvicorn.workers.UvicornWorker --workers 5 --bind 0.0.0.0:$PORT --access-logfile - --access-logformat \"%(t)s %(h)s %(l)s %(p)s \\\"%(m)s %(U)s%(q)s\\\" %(s)s %(b)s %(L)s \\\"%(f)s\\\" \\\"%(a)s\\\"\" app.wsgi:app Filtered logs [ERROR] Worker (pid:62) was sent SIGKILL! Perhaps out of memory? [INFO] Booting worker with pid: 96 System info:  Application is deployed on Kubernetes. Python version 3.11 Resource allocation:  Memory limit 3GB    In a thread regarding same issue on Connexion forum , I received following feedback: spec-first/connexion#2062 (comment)  FWIW I think this is more a Flask question than a Connexion question. I checked the Flask doc about file upload: https://flask.palletsprojects.com/en/stable/patterns/fileuploads/ There I found this:  So how exactly does Flask handle uploads? Well it will store them in the webserver’s memory if the files are reasonably small, otherwise in a temporary location (as returned by tempfile.gettempdir()). But how do you specify the maximum file size after which an upload is aborted? By default Flask will happily accept file uploads with an unlimited amount of memory, but you can limit that by setting the MAX_CONTENT_LENGTH config key:  I didn't see a way to specify the threshold that Flask uses to decide whether to use a \"temporary location\" instead of memory. Not sure this is really helpful, sorry.  What I'm looking for is recommendations on better implementation to avoid spike in Memory consumption.", "mode": "nl", "used_query": "Memory consumption spikes when an api endpoint with file upload capability is hit. I have an API application, created using connexion framework, which uses FlaskApp configuration. This app exposes an endpoint where users/consumers can upload artifacts(ranging from 2.5 MB to 400 MB) and they will be then upload to an internal storage platform. The pain point is, when the user selects a larger data file(~320 MB) to upload, the application often runs into OOM issue and eventually user receives 502 status response. Running dmesg command inside containers show the gunicorn thread being killed by oom_killer It would be of great help if someone here could guide in avoiding such OOM issues for Flask Applications. API Specifaction openapi: 3.0.0 info:   description: Description   version: 1.1.1   title:  API  servers:   - url: /api/v1     description: base path for version 1 of the API  components:    responses:     BinaryFile:       description: Content of stored binary file       content:         \"*/*\":           schema:             type: string             format: binary     BadArgument:       description: Request Validation failed       content:         application/json:           schema:             $ref: \"#/components/schemas/Error\"     NotFound:       description: Not Found (e.g. for a given Id)       content:         application/json:           schema:             $ref: \"#/components/schemas/Error\"     InternalServerError:       description: Internal Server Error       content:         application/json:           schema:             $ref: \"#/components/schemas/Error\"     ServiceUnavailable:       description: Service Temporary Unavailable       content:         application/json:           schema:             $ref: \"#/components/schemas/Error\"    parameters:     OrganizationId:       name: teamId       in: path       required: true       schema:         type: string         format: path         additionalProperties: false         anyOf:           - $ref: \"#/components/schemas/Id\"           - $ref: \"#/components/schemas/TeamId\"     TicketId:       name: ticketId       in: path       required: true       schema:         $ref: \"#/components/schemas/Id\"     ArtifactDataFileType:       name: dataType       in: path       required: true       schema:         $ref: \"#/components/schemas/ArtifactDataFileType\"    schemas:     Id:       description: Unique identifier of a Object/Document/Entity etc       type: string       # On why UUID is used see https://www.cockroachlabs.com/docs/stable/sql-faqs.html#what-are-the-differences-between-uuid-sequences-and-unique_rowid       format: string     SubscriptionType:       description: Subscription type       type: string       enum: [small, medium, large]       nullable: true     ArtifactDataFileType:       type: string       enum: [ artifact ]     TeamId:       type: string       description: Team's unique identifier     # According to \"Problem Details for HTTP APIs\" -> https://tools.ietf.org/html/draft-ietf-appsawg-http-problem-00     Error:       type: object       description: An Error object returned if something went wrong       additionalProperties: true       properties:         detail:           type: string         status:           type: integer         title:           type: string         type:           type: string     ArtifactBodyWithSubscriptionType:       type: object       additionalProperties: false       properties:         data:           type: string           format: binary         subscriptionType:           $ref: \"#/components/schemas/SubscriptionType\"   paths:   '/team/{teamId}/ticket/{ticketId}/{dataType}':     parameters:       - $ref: \"#/components/parameters/OrganizationId\"       - $ref: \"#/components/parameters/TicketId\"       - $ref: \"#/components/parameters/ArtifactDataFileType\"     post:       summary: Upload Artifact data file for this Ticket       x-openapi-router-controller: app.operations.epics       operationId: upload_data       requestBody:         required: true         content:           multipart/form-data:             schema:               $ref: '#/components/schemas/ArtifactBodyWithSubscriptionType'       responses:         '201':           description: Uploaded         '400':           $ref: \"#/components/responses/BadArgument\"         '404':           $ref: \"#/components/responses/NotFound\"         '500':           $ref: \"#/components/responses/InternalServerError\"         '503':           $ref: \"#/components/responses/ServiceUnavailable\" Python function import logging from http import HTTPStatus from typing import BinaryIO  from connexion import problem  from app.operations import _not_found from app.models.ticket import Ticket from app.storage import Storages   logger = logging.getLogger(__name__)   class Storages:     \"\"\"     Internal platform to store artifacts.     \"\"\"     def __init__(self, data_path):         self.data_path: str = data_path      def save(self, data_path: str, data: BinaryIO):         \"\"\"         API call to internal platform to store artifacts.         \"\"\"         pass      def ticket_path(self, ticket: Ticket, data_type):         \"\"\"         Returns the path where the ticket data should be stored.         \"\"\"         # This is a placeholder implementation.         # The actual implementation would return a path based on the ticket and data type.         return f\"{self.data_path}/{ticket.id}/{data_type}\"   def _get_ticket(params):     \"\"\"     Helper function to retrieve the ticket from the parameters.     \"\"\"     ...     return   def upload_data(**params):     # Checking file     data = params[\"data\"]     file_name = data.filename     if not file_name:         return problem(HTTPStatus.INTERNAL_SERVER_ERROR, \"Cannot upload file\", \"File is not provided\")      # Checking existence of ticket     ticket = _get_ticket(params)     if not ticket:         return _not_found(Ticket, params[\"ticketId\"])      # Saving file in storage     data_type = params[\"dataType\"]      try:         storage = Storages(data_path=\"/path/to/storage/on/internal/platform\"),         data_path = storage.ticket_path(ticket, data_type)         storage.save(data_path, data)     except Exception as ex:         logger.error(f\"cannot upload file into storage: {ex}\", exc_info=True)         return problem(HTTPStatus.INTERNAL_SERVER_ERROR, \"Cannot upload file\", \"Problems with storage\")      return None, HTTPStatus.CREATED Pipfile [[source]] url = \"https://pypi.org/simple/\" verify_ssl = true name = \"pypi\"  [requires] python_version = \"3.11\"  [packages] backoff = \"~=2.2.0\" boto3 = \"~=1.26.0\" connexion = {extras = [\"flask\", \"uvicorn\", \"swagger-ui\"],version = \"~=3.2.0\"} gunicorn = {extras = [\"gevent\"],version = \"~=23.0.0\"} aiohttp = \"~=3.10.10\" aiohttp_retry = \"~=2.8.3\" greenlet = \"==3.1.1\" kubernetes = \"~=24.0\" psycopg-c = \"~=3.2.2\" psycopg-pool = \"~=3.2.3\" rfc3339-validator = \"~=0.1.0\" shapely = \"~=2.1.0\" jsonschema = \"~=4.23.0\"  Application startup command python -m gunicorn --worker-class uvicorn.workers.UvicornWorker --workers 5 --bind 0.0.0.0:$PORT --access-logfile - --access-logformat \"%(t)s %(h)s %(l)s %(p)s \\\"%(m)s %(U)s%(q)s\\\" %(s)s %(b)s %(L)s \\\"%(f)s\\\" \\\"%(a)s\\\"\" app.wsgi:app Filtered logs [ERROR] Worker (pid:62) was sent SIGKILL! Perhaps out of memory? [INFO] Booting worker with pid: 96 System info:  Application is deployed on Kubernetes. Python version 3.11 Resource allocation:  Memory limit 3GB    In a thread regarding same issue on Connexion forum , I received following feedback: spec-first/connexion#2062 (comment)  FWIW I think this is more a Flask question than a Connexion question. I checked the Flask doc about file upload: https://flask.palletsprojects.com/en/stable/patterns/fileuploads/ There I found this:  So how exactly does Flask handle uploads? Well it will store them in the webserver’s memory if the files are reasonably small, otherwise in a temporary location (as returned by tempfile.gettempdir()). But how do you specify the maximum file size after which an upload is aborted? By default Flask will happily accept file uploads with an unlimited amount of memory, but you can limit that by setting the MAX_CONTENT_LENGTH config key:  I didn't see a way to specify the threshold that Flask uses to decide whether to use a \"temporary location\" instead of memory. Not sure this is really helpful, sorry.  What I'm looking for is recommendations on better implementation to avoid spike in Memory consumption.", "gold_terms": ["Request._get_file_stream", "yesminehe", "fix", "issues", "large", "file", "uploads", "set", "app", "config", "and", "override", "_get_file_stream", "use", "disk", "based", "chunks", "shutil", "copyfileobj", "data"], "results": [{"rank": 1, "score": 0.5888372659683228, "raw_score": 0.5888372659683228, "source": "docs", "row": 206, "chunk_id": "23c8923abb60b32b20d10843fdd1d0aa5dc0ce00", "symbol_type": "doc", "qualname": "patterns\\fileuploads.rst#Improving Uploads", "file_path": "d:\\499\\docs\\patterns\\fileuploads.rst", "start_line": 129, "end_line": 159}, {"rank": 2, "score": 0.5880423784255981, "raw_score": 0.5880423784255981, "source": "flask", "row": 375, "chunk_id": "aa7a37acd24116cf44872f6bc255ad4c5f589748", "symbol_type": "method", "qualname": "Request.max_form_memory_size", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\wrappers.py", "start_line": 93, "end_line": 113}, {"rank": 3, "score": 0.5350303649902344, "raw_score": 0.5350303649902344, "source": "docs", "row": 385, "chunk_id": "997670d9e824d562b79a247044201d7b0fe24c5c", "symbol_type": "doc", "qualname": "web-security.rst#Resource Use", "file_path": "d:\\499\\docs\\web-security.rst", "start_line": 13, "end_line": 42}, {"rank": 4, "score": 0.48992276191711426, "raw_score": 0.48992276191711426, "source": "docs", "row": 124, "chunk_id": "9cd88f65edeb7f40e4d83398974810dbb4ae1e08", "symbol_type": "doc", "qualname": "errorhandling.rst#Handling Application Errors", "file_path": "d:\\499\\docs\\errorhandling.rst", "start_line": 2, "end_line": 28}, {"rank": 5, "score": 0.4812775254249573, "raw_score": 0.4812775254249573, "source": "flask", "row": 373, "chunk_id": "45410cff31060f374e09c0fb922eb08160d67d01", "symbol_type": "method", "qualname": "Request.max_content_length", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\wrappers.py", "start_line": 60, "end_line": 86}, {"rank": 6, "score": 0.4546782076358795, "raw_score": 0.4546782076358795, "source": "flask", "row": 377, "chunk_id": "17d7a93271b1c4ddd7d7d42afb3e3030f615072a", "symbol_type": "method", "qualname": "Request.max_form_parts", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\wrappers.py", "start_line": 120, "end_line": 140}, {"rank": 7, "score": 0.4367758333683014, "raw_score": 0.4367758333683014, "source": "flask", "row": 29, "chunk_id": "74186adebd1957f9aafdd89b31c4b92a2303f966", "symbol_type": "method", "qualname": "Flask.do_teardown_request", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 1326, "end_line": 1358}, {"rank": 8, "score": 0.4356510639190674, "raw_score": 0.4356510639190674, "source": "docs", "row": 27, "chunk_id": "8925e5ef210b8d675220e419262df0fd950ee8df", "symbol_type": "doc", "qualname": "appcontext.rst#Lifecycle of the Context", "file_path": "d:\\499\\docs\\appcontext.rst", "start_line": 145, "end_line": 167}, {"rank": 9, "score": 0.4341031312942505, "raw_score": 0.4341031312942505, "source": "flask", "row": 152, "chunk_id": "66c59e597bab748beac3b4958cd735edc4990b05", "symbol_type": "function", "qualname": "dump", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\json\\__init__.py", "start_line": 47, "end_line": 74}, {"rank": 10, "score": 0.4221118092536926, "raw_score": 0.4221118092536926, "source": "flask", "row": 153, "chunk_id": "f7bd374a6e54fe45ae7fbe2d58286c5cf5237148", "symbol_type": "function", "qualname": "loads", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\json\\__init__.py", "start_line": 77, "end_line": 105}]}
{"query": "Why does my Flask route return a 405 error when I submit a form? I'm using Flask and trying to handle a form submission with POST, but I keep getting a 405 Method Not Allowed error. Here's the basic code: from flask import Flask, request  app = Flask(__name__)  @app.route(\"/submit\") def submit():     if request.method == \"POST\":         name = request.form[\"name\"]         return f\"Hello, {name}!\"     return \"Invalid method\" I submit the form from an HTML page using method=\"POST\", but Flask still returns a 405. What am I doing wrong?", "mode": "nl", "used_query": "Why does my Flask route return a 405 error when I submit a form? I'm using Flask and trying to handle a form submission with POST, but I keep getting a 405 Method Not Allowed error. Here's the basic code: from flask import Flask, request  app = Flask(__name__)  @app.route(\"/submit\") def submit():     if request.method == \"POST\":         name = request.form[\"name\"]         return f\"Hello, {name}!\"     return \"Invalid method\" I submit the form from an HTML page using method=\"POST\", but Flask still returns a 405. What am I doing wrong?", "gold_terms": ["you", "need", "methods", "route", "call", "allow", "addition", "freudinttheprodev", "question", "issue", "only", "set", "accept", "requests", "default", "since", "didn", "specify", "the", "allowed"], "results": [{"rank": 1, "score": 0.5800988674163818, "raw_score": 0.5800988674163818, "source": "docs", "row": 276, "chunk_id": "46e0245dc43c4f2b32433aa9e46d569b79b5c36c", "symbol_type": "doc", "qualname": "quickstart.rst#HTTP Methods", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 294, "end_line": 333}, {"rank": 2, "score": 0.5698288083076477, "raw_score": 0.5698288083076477, "source": "docs", "row": 266, "chunk_id": "a261c3c3064ebdd47b3d21c5f89029750144948b", "symbol_type": "doc", "qualname": "patterns\\wtforms.rst#In the View", "file_path": "d:\\499\\docs\\patterns\\wtforms.rst", "start_line": 42, "end_line": 69}, {"rank": 3, "score": 0.5660890936851501, "raw_score": 0.5660890936851501, "source": "flask", "row": 130, "chunk_id": "897ecb46f1df42a07069a2002d9f4d5a22987f95", "symbol_type": "method", "qualname": "FormDataRoutingRedirect.__init__", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\debughelpers.py", "start_line": 57, "end_line": 78}, {"rank": 4, "score": 0.5614564418792725, "raw_score": 0.5614564418792725, "source": "docs", "row": 128, "chunk_id": "c858dd7f32dc0e3b6b2d3e4ee5c3e180d46f6920", "symbol_type": "doc", "qualname": "errorhandling.rst#Handling", "file_path": "d:\\499\\docs\\errorhandling.rst", "start_line": 140, "end_line": 174}, {"rank": 5, "score": 0.5423747897148132, "raw_score": 0.5423747897148132, "source": "docs", "row": 221, "chunk_id": "9138ab7d0f126b83befa9c5d2ed02660763cae13", "symbol_type": "doc", "qualname": "patterns\\javascript.rst#Receiving JSON in Views", "file_path": "d:\\499\\docs\\patterns\\javascript.rst", "start_line": 244, "end_line": 261}, {"rank": 6, "score": 0.5317634344100952, "raw_score": 0.5317634344100952, "source": "flask", "row": 129, "chunk_id": "2af3e32a02df90f67ae11525899e121f3d63ab5e", "symbol_type": "class", "qualname": "FormDataRoutingRedirect", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\debughelpers.py", "start_line": 50, "end_line": 78}, {"rank": 7, "score": 0.5209519267082214, "raw_score": 0.5209519267082214, "source": "docs", "row": 173, "chunk_id": "8218f038803ca6014814850e18cd01f4d9dec5e4", "symbol_type": "doc", "qualname": "logging.rst#Logging", "file_path": "d:\\499\\docs\\logging.rst", "start_line": 2, "end_line": 25}, {"rank": 8, "score": 0.5091016292572021, "raw_score": 0.5091016292572021, "source": "docs", "row": 331, "chunk_id": "3ce1893fe8542d947fb31783e339d29caea4164e", "symbol_type": "doc", "qualname": "tutorial\\blog.rst#Create", "file_path": "d:\\499\\docs\\tutorial\\blog.rst", "start_line": 132, "end_line": 188}, {"rank": 9, "score": 0.5087790489196777, "raw_score": 0.5087790489196777, "source": "docs", "row": 210, "chunk_id": "7759d2dd99fb63306acc8abfa97428316d5f0744", "symbol_type": "doc", "qualname": "patterns\\flashing.rst#Simple Flashing", "file_path": "d:\\499\\docs\\patterns\\flashing.rst", "start_line": 15, "end_line": 89}, {"rank": 10, "score": 0.5056759119033813, "raw_score": 0.5056759119033813, "source": "flask", "row": 25, "chunk_id": "c4c7c245f4b73f8fcff8da307b57b288f69b477d", "symbol_type": "method", "qualname": "Flask.url_for", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 1003, "end_line": 1127}]}
{"query": "flask and pdbpp gives `signal only works in main thread of the main interpreter` This is my code example: from flask import Flask  app = Flask(__name__)   @app.route(\"/status\") def status():     breakpoint()     return {\"status\": \"ok\"}   if __name__ == '__main__':     app.run() Accessing /status, I get: -> breakpoint() 127.0.0.1 - - [12/Jul/2025 08:32:24] \"GET /status HTTP/1.1\" 500 - Traceback (most recent call last):   File \"/home/kmille/.cache/pypoetry/virtualenvs/zammad-pgp-autoimport-webhook-jd1kDdnL-py3.13/lib/python3.13/site-packages/flask/app.py\", line 1536, in __call__     return self.wsgi_app(environ, start_response)            ~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/home/kmille/.cache/pypoetry/virtualenvs/zammad-pgp-autoimport-webhook-jd1kDdnL-py3.13/lib/python3.13/site-packages/flask/app.py\", line 1514, in wsgi_app     response = self.handle_exception(e)   File \"/home/kmille/.cache/pypoetry/virtualenvs/zammad-pgp-autoimport-webhook-jd1kDdnL-py3.13/lib/python3.13/site-packages/flask/app.py\", line 1511, in wsgi_app     response = self.full_dispatch_request()   File \"/home/kmille/.cache/pypoetry/virtualenvs/zammad-pgp-autoimport-webhook-jd1kDdnL-py3.13/lib/python3.13/site-packages/flask/app.py\", line 919, in full_dispatch_request     rv = self.handle_user_exception(e)   File \"/home/kmille/.cache/pypoetry/virtualenvs/zammad-pgp-autoimport-webhook-jd1kDdnL-py3.13/lib/python3.13/site-packages/flask/app.py\", line 917, in full_dispatch_request     rv = self.dispatch_request()   File \"/home/kmille/.cache/pypoetry/virtualenvs/zammad-pgp-autoimport-webhook-jd1kDdnL-py3.13/lib/python3.13/site-packages/flask/app.py\", line 902, in dispatch_request     return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^   File \"/home/kmille/projects/zammad-pgp-autoimport-webhook/src/zammad_pgp_autoimport_webhook/test_run.py\", line 8, in status     breakpoint()     ~~~~~~~~~~^^   File \"/usr/lib/python3.13/bdb.py\", line 116, in trace_dispatch     return self.dispatch_opcode(frame, arg)            ~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^   File \"/usr/lib/python3.13/bdb.py\", line 215, in dispatch_opcode     self.user_opcode(frame)     ~~~~~~~~~~~~~~~~^^^^^^^   File \"/usr/lib/python3.13/pdb.py\", line 448, in user_line     self.interaction(frame, None)     ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^   File \"/home/kmille/.cache/pypoetry/virtualenvs/zammad-pgp-autoimport-webhook-jd1kDdnL-py3.13/lib/python3.13/site-packages/pdbpp.py\", line 431, in interaction     return self._interaction(frame, tb)            ~~~~~~~~~~~~~~~~~^^^^^^^^^^^   File \"/home/kmille/.cache/pypoetry/virtualenvs/zammad-pgp-autoimport-webhook-jd1kDdnL-py3.13/lib/python3.13/site-packages/pdbpp.py\", line 465, in _interaction     self._cmdloop()     ~~~~~~~~~~~~~^^   File \"/usr/lib/python3.13/pdb.py\", line 511, in _cmdloop     self.cmdloop()     ~~~~~~~~~~~~^^   File \"/usr/lib/python3.13/cmd.py\", line 134, in cmdloop     line = input(self.prompt)   File \"/usr/lib/python3.13/_pyrepl/readline.py\", line 364, in input     reader = self.get_reader()   File \"/usr/lib/python3.13/_pyrepl/readline.py\", line 358, in get_reader     console = Console(self.f_in, self.f_out, encoding=ENCODING)   File \"/usr/lib/python3.13/_pyrepl/unix_console.py\", line 202, in __init__     signal.signal(signal.SIGCONT, self._sigcont_handler)     ~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/usr/lib/python3.13/signal.py\", line 58, in signal     handler = _signal.signal(_enum_to_int(signalnum), _enum_to_int(handler)) ValueError: signal only works in main thread of the main interpreter  Versions I use poetry show -l | grep -e flask -e pdbpp                         flask              3.1.1     3.1.1    A simple framework for building comple... pdbpp              0.11.6    0.11.6   pdb++, a drop-in replacement for pdb  Using Python 3.13.5. Thanks for your help! I'm wondering why I'm the only one having this... Couldn't find something in the web...", "mode": "nl", "used_query": "flask and pdbpp gives `signal only works in main thread of the main interpreter` This is my code example: from flask import Flask  app = Flask(__name__)   @app.route(\"/status\") def status():     breakpoint()     return {\"status\": \"ok\"}   if __name__ == '__main__':     app.run() Accessing /status, I get: -> breakpoint() 127.0.0.1 - - [12/Jul/2025 08:32:24] \"GET /status HTTP/1.1\" 500 - Traceback (most recent call last):   File \"/home/kmille/.cache/pypoetry/virtualenvs/zammad-pgp-autoimport-webhook-jd1kDdnL-py3.13/lib/python3.13/site-packages/flask/app.py\", line 1536, in __call__     return self.wsgi_app(environ, start_response)            ~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/home/kmille/.cache/pypoetry/virtualenvs/zammad-pgp-autoimport-webhook-jd1kDdnL-py3.13/lib/python3.13/site-packages/flask/app.py\", line 1514, in wsgi_app     response = self.handle_exception(e)   File \"/home/kmille/.cache/pypoetry/virtualenvs/zammad-pgp-autoimport-webhook-jd1kDdnL-py3.13/lib/python3.13/site-packages/flask/app.py\", line 1511, in wsgi_app     response = self.full_dispatch_request()   File \"/home/kmille/.cache/pypoetry/virtualenvs/zammad-pgp-autoimport-webhook-jd1kDdnL-py3.13/lib/python3.13/site-packages/flask/app.py\", line 919, in full_dispatch_request     rv = self.handle_user_exception(e)   File \"/home/kmille/.cache/pypoetry/virtualenvs/zammad-pgp-autoimport-webhook-jd1kDdnL-py3.13/lib/python3.13/site-packages/flask/app.py\", line 917, in full_dispatch_request     rv = self.dispatch_request()   File \"/home/kmille/.cache/pypoetry/virtualenvs/zammad-pgp-autoimport-webhook-jd1kDdnL-py3.13/lib/python3.13/site-packages/flask/app.py\", line 902, in dispatch_request     return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^   File \"/home/kmille/projects/zammad-pgp-autoimport-webhook/src/zammad_pgp_autoimport_webhook/test_run.py\", line 8, in status     breakpoint()     ~~~~~~~~~~^^   File \"/usr/lib/python3.13/bdb.py\", line 116, in trace_dispatch     return self.dispatch_opcode(frame, arg)            ~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^   File \"/usr/lib/python3.13/bdb.py\", line 215, in dispatch_opcode     self.user_opcode(frame)     ~~~~~~~~~~~~~~~~^^^^^^^   File \"/usr/lib/python3.13/pdb.py\", line 448, in user_line     self.interaction(frame, None)     ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^   File \"/home/kmille/.cache/pypoetry/virtualenvs/zammad-pgp-autoimport-webhook-jd1kDdnL-py3.13/lib/python3.13/site-packages/pdbpp.py\", line 431, in interaction     return self._interaction(frame, tb)            ~~~~~~~~~~~~~~~~~^^^^^^^^^^^   File \"/home/kmille/.cache/pypoetry/virtualenvs/zammad-pgp-autoimport-webhook-jd1kDdnL-py3.13/lib/python3.13/site-packages/pdbpp.py\", line 465, in _interaction     self._cmdloop()     ~~~~~~~~~~~~~^^   File \"/usr/lib/python3.13/pdb.py\", line 511, in _cmdloop     self.cmdloop()     ~~~~~~~~~~~~^^   File \"/usr/lib/python3.13/cmd.py\", line 134, in cmdloop     line = input(self.prompt)   File \"/usr/lib/python3.13/_pyrepl/readline.py\", line 364, in input     reader = self.get_reader()   File \"/usr/lib/python3.13/_pyrepl/readline.py\", line 358, in get_reader     console = Console(self.f_in, self.f_out, encoding=ENCODING)   File \"/usr/lib/python3.13/_pyrepl/unix_console.py\", line 202, in __init__     signal.signal(signal.SIGCONT, self._sigcont_handler)     ~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/usr/lib/python3.13/signal.py\", line 58, in signal     handler = _signal.signal(_enum_to_int(signalnum), _enum_to_int(handler)) ValueError: signal only works in main thread of the main interpreter  Versions I use poetry show -l | grep -e flask -e pdbpp                         flask              3.1.1     3.1.1    A simple framework for building comple... pdbpp              0.11.6    0.11.6   pdb++, a drop-in replacement for pdb  Using Python 3.13.5. Thanks for your help! I'm wondering why I'm the only one having this... Couldn't find something in the web...", "gold_terms": ["yesminehe", "breakpoint", "call", "meant", "for", "interactive", "debugging", "and", "isn", "suitable", "running", "application", "especially", "multi", "threaded", "environment", "the", "status", "route", "kmille"], "results": [{"rank": 1, "score": 0.6095972657203674, "raw_score": 0.6095972657203674, "source": "flask", "row": 117, "chunk_id": "45e39c75627746e8d351af755ae300aeba86c26a", "symbol_type": "method", "qualname": "RequestContext.__init__", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\ctx.py", "start_line": 309, "end_line": 335}, {"rank": 2, "score": 0.5942150354385376, "raw_score": 0.5942150354385376, "source": "flask", "row": 34, "chunk_id": "b7e02446548217dced3f45ac401c3c15882e4d7d", "symbol_type": "method", "qualname": "Flask.wsgi_app", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 1479, "end_line": 1527}, {"rank": 3, "score": 0.5849798917770386, "raw_score": 0.5849798917770386, "source": "flask", "row": 30, "chunk_id": "4e2468caf58c41fe6e2f230b8bad4bc767c38fb9", "symbol_type": "method", "qualname": "Flask.do_teardown_appcontext", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 1360, "end_line": 1384}, {"rank": 4, "score": 0.5740336775779724, "raw_score": 0.5740336775779724, "source": "docs", "row": 308, "chunk_id": "538a593ffb72d08cd947d1a2a57c19dca08e1131", "symbol_type": "doc", "qualname": "signals.rst#Signals and Flask's Request Context", "file_path": "d:\\499\\docs\\signals.rst", "start_line": 145, "end_line": 151}, {"rank": 5, "score": 0.5594279766082764, "raw_score": 0.5594279766082764, "source": "flask", "row": 142, "chunk_id": "d2958f0ec1affc8291ca77843bc6023f2553841c", "symbol_type": "function", "qualname": "abort", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\helpers.py", "start_line": 273, "end_line": 293}, {"rank": 6, "score": 0.5548001527786255, "raw_score": 0.5548001527786255, "source": "docs", "row": 25, "chunk_id": "b5c48237ff46027cb663b1f8d52d2a116dec3b2a", "symbol_type": "doc", "qualname": "appcontext.rst#Context During Testing", "file_path": "d:\\499\\docs\\appcontext.rst", "start_line": 76, "end_line": 113}, {"rank": 7, "score": 0.5510560274124146, "raw_score": 0.5510560274124146, "source": "docs", "row": 27, "chunk_id": "8925e5ef210b8d675220e419262df0fd950ee8df", "symbol_type": "doc", "qualname": "appcontext.rst#Lifecycle of the Context", "file_path": "d:\\499\\docs\\appcontext.rst", "start_line": 145, "end_line": 167}, {"rank": 8, "score": 0.5432960987091064, "raw_score": 0.5432960987091064, "source": "docs", "row": 269, "chunk_id": "b8d264939f986dd785aa678ba5bdd6772ecf3dc9", "symbol_type": "doc", "qualname": "quickstart.rst#A Minimal Application", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 9, "end_line": 85}, {"rank": 9, "score": 0.5430655479431152, "raw_score": 0.5430655479431152, "source": "flask", "row": 29, "chunk_id": "74186adebd1957f9aafdd89b31c4b92a2303f966", "symbol_type": "method", "qualname": "Flask.do_teardown_request", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 1326, "end_line": 1358}, {"rank": 10, "score": 0.5412155389785767, "raw_score": 0.5412155389785767, "source": "docs", "row": 53, "chunk_id": "7c6057c887265c80ccd7b81330d1dd730a8f2eab", "symbol_type": "doc", "qualname": "cli.rst#Debug Mode", "file_path": "d:\\499\\docs\\cli.rst", "start_line": 90, "end_line": 113}]}
{"query": "Is there any good way to contribute? I'm new to contributing to big repositories --- is there any good starting points that I could help wth?", "mode": "nl", "used_query": "Is there any good way to contribute? I'm new to contributing to big repositories --- is there any good starting points that I could help wth?", "gold_terms": ["davidism", "can", "find", "our", "contributing", "guide", "https", "palletsprojects", "com", "won", "much", "work", "itself", "front", "page", "the", "provides", "many", "ideas", "including"], "results": [{"rank": 1, "score": 0.524235725402832, "raw_score": 0.524235725402832, "source": "docs", "row": 76, "chunk_id": "6ab3a935b0fb057aa7b9d056fb9a4f3ffcda6249", "symbol_type": "doc", "qualname": "contributing.rst#Contributing", "file_path": "d:\\499\\docs\\contributing.rst", "start_line": 2, "end_line": 8}, {"rank": 2, "score": 0.25774723291397095, "raw_score": 0.25774723291397095, "source": "docs", "row": 144, "chunk_id": "fc7a7779ae77dd518fa31894e112112141432c41", "symbol_type": "doc", "qualname": "extensiondev.rst#Recommended Extension Guidelines", "file_path": "d:\\499\\docs\\extensiondev.rst", "start_line": 253, "end_line": 305}, {"rank": 3, "score": 0.25725269317626953, "raw_score": 0.25725269317626953, "source": "docs", "row": 289, "chunk_id": "a037061d1072fc8fb6d22d81c1f4fd4a6524c30c", "symbol_type": "doc", "qualname": "quickstart.rst#Using Flask Extensions", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 847, "end_line": 853}, {"rank": 4, "score": 0.24998512864112854, "raw_score": 0.24998512864112854, "source": "docs", "row": 335, "chunk_id": "0ec1f861b30101aff957c9648ece100eb6c1354c", "symbol_type": "doc", "qualname": "tutorial\\database.rst#Define and Access the Database", "file_path": "d:\\499\\docs\\tutorial\\database.rst", "start_line": 4, "end_line": 22}, {"rank": 5, "score": 0.24951785802841187, "raw_score": 0.24951785802841187, "source": "docs", "row": 137, "chunk_id": "acbf8e0f421ab8d6eb97e7289d745bf1c98f3a34", "symbol_type": "doc", "qualname": "extensiondev.rst#Flask Extension Development", "file_path": "d:\\499\\docs\\extensiondev.rst", "start_line": 2, "end_line": 23}, {"rank": 6, "score": 0.24319781363010406, "raw_score": 0.24319781363010406, "source": "docs", "row": 328, "chunk_id": "d981a77010086c52390564eb12f1a6816400340c", "symbol_type": "doc", "qualname": "tutorial\\blog.rst#Blog Blueprint", "file_path": "d:\\499\\docs\\tutorial\\blog.rst", "start_line": 4, "end_line": 13}, {"rank": 7, "score": 0.2409965842962265, "raw_score": 0.2409965842962265, "source": "docs", "row": 348, "chunk_id": "dcb8997e409983ff4ae7d6a4c26ac425ee1938a8", "symbol_type": "doc", "qualname": "tutorial\\index.rst#Tutorial", "file_path": "d:\\499\\docs\\tutorial\\index.rst", "start_line": 2, "end_line": 64}, {"rank": 8, "score": 0.23844000697135925, "raw_score": 0.23844000697135925, "source": "docs", "row": 268, "chunk_id": "32265fe033821f6fd6d33f0a542c4c317cae882f", "symbol_type": "doc", "qualname": "quickstart.rst#Quickstart", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 2, "end_line": 6}, {"rank": 9, "score": 0.2236877828836441, "raw_score": 0.2236877828836441, "source": "docs", "row": 340, "chunk_id": "1f594e698247cf9df13512b1fb6c0f1b0f32f658", "symbol_type": "doc", "qualname": "tutorial\\deploy.rst#Deploy to Production", "file_path": "d:\\499\\docs\\tutorial\\deploy.rst", "start_line": 2, "end_line": 12}, {"rank": 10, "score": 0.21506649255752563, "raw_score": 0.21506649255752563, "source": "docs", "row": 353, "chunk_id": "3a18481600be3203bf2e73986e305292c8eb71d5", "symbol_type": "doc", "qualname": "tutorial\\next.rst#Keep Developing!", "file_path": "d:\\499\\docs\\tutorial\\next.rst", "start_line": 2, "end_line": 38}]}
{"query": "Flask/Werkzeug: Don't send content-type header with 204 response? I received a warning form the Python webtest library when responding with a 204 HTTP status code b/c Flask (or Werkzeug, I didn't dig to find where it happens) adds a Content-Type header by default: ('Content-Type', 'text/html; charset=utf-8'). Led me to a discussion with Claude about what the spec says regarding.  It sounds like it's not prohibited but would make sense to not add the header if the status code is 204. It's a small thing, but should Flask/Werkzeug take the status code into account before adding a content type header?", "mode": "nl", "used_query": "Flask/Werkzeug: Don't send content-type header with 204 response? I received a warning form the Python webtest library when responding with a 204 HTTP status code b/c Flask (or Werkzeug, I didn't dig to find where it happens) adds a Content-Type header by default: ('Content-Type', 'text/html; charset=utf-8'). Led me to a discussion with Claude about what the spec says regarding.  It sounds like it's not prohibited but would make sense to not add the header if the status code is 204. It's a small thing, but should Flask/Werkzeug take the status code into account before adding a content type header?", "gold_terms": ["Response.default_mimetype", "Response.get_wsgi_headers", "Flask.response_class", "Flask.make_response", "davidism", "default_mimetype", "sets", "the", "header", "creating", "response", "not", "given", "get_wsgi_headers", "removes", "sending", "spec", "directly", "says", "must"], "results": [{"rank": 1, "score": 0.581552267074585, "raw_score": 0.581552267074585, "source": "flask", "row": 373, "chunk_id": "45410cff31060f374e09c0fb922eb08160d67d01", "symbol_type": "method", "qualname": "Request.max_content_length", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\wrappers.py", "start_line": 60, "end_line": 86}, {"rank": 2, "score": 0.5649937391281128, "raw_score": 0.5649937391281128, "source": "flask", "row": 384, "chunk_id": "e65430f9b3da8a52b9d290a20e1bb8415b691793", "symbol_type": "class", "qualname": "Response", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\wrappers.py", "start_line": 222, "end_line": 257}, {"rank": 3, "score": 0.5589615106582642, "raw_score": 0.5589615106582642, "source": "docs", "row": 127, "chunk_id": "a7d0d6fa76db293c1ad10a21d8b6587985b439d3", "symbol_type": "doc", "qualname": "errorhandling.rst#Registering", "file_path": "d:\\499\\docs\\errorhandling.rst", "start_line": 98, "end_line": 137}, {"rank": 4, "score": 0.528272807598114, "raw_score": 0.528272807598114, "source": "docs", "row": 227, "chunk_id": "05e7995db8e956822b6ca37041bc4c6ba5ef38b7", "symbol_type": "doc", "qualname": "patterns\\methodoverrides.rst#Adding HTTP Method Overrides", "file_path": "d:\\499\\docs\\patterns\\methodoverrides.rst", "start_line": 2, "end_line": 42}, {"rank": 5, "score": 0.5266733765602112, "raw_score": 0.5266733765602112, "source": "docs", "row": 131, "chunk_id": "46d93f09dc7d2aef75d165b2f9fff849f61c7cb1", "symbol_type": "doc", "qualname": "errorhandling.rst#Custom Error Pages", "file_path": "d:\\499\\docs\\errorhandling.rst", "start_line": 259, "end_line": 331}, {"rank": 6, "score": 0.523593544960022, "raw_score": 0.523593544960022, "source": "flask", "row": 9, "chunk_id": "7a4280a5e1bcb934ccb2ddf399d35cb79827c7c1", "symbol_type": "method", "qualname": "Flask.raise_routing_exception", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 478, "end_line": 504}, {"rank": 7, "score": 0.5178956985473633, "raw_score": 0.5178956985473633, "source": "docs", "row": 385, "chunk_id": "997670d9e824d562b79a247044201d7b0fe24c5c", "symbol_type": "doc", "qualname": "web-security.rst#Resource Use", "file_path": "d:\\499\\docs\\web-security.rst", "start_line": 13, "end_line": 42}, {"rank": 8, "score": 0.5139382481575012, "raw_score": 0.5139382481575012, "source": "docs", "row": 386, "chunk_id": "f9c5c9f24b8ebf409b7431876e6ee124b89c59e0", "symbol_type": "doc", "qualname": "web-security.rst#Cross-Site Scripting (XSS)", "file_path": "d:\\499\\docs\\web-security.rst", "start_line": 45, "end_line": 101}, {"rank": 9, "score": 0.5088395476341248, "raw_score": 0.5088395476341248, "source": "docs", "row": 221, "chunk_id": "9138ab7d0f126b83befa9c5d2ed02660763cae13", "symbol_type": "doc", "qualname": "patterns\\javascript.rst#Receiving JSON in Views", "file_path": "d:\\499\\docs\\patterns\\javascript.rst", "start_line": 244, "end_line": 261}, {"rank": 10, "score": 0.5042239427566528, "raw_score": 0.5042239427566528, "source": "docs", "row": 134, "chunk_id": "8702048bc2762c717b5a7032bb6a43374a8cf951", "symbol_type": "doc", "qualname": "errorhandling.rst#Returning API Errors as JSON", "file_path": "d:\\499\\docs\\errorhandling.rst", "start_line": 435, "end_line": 510}]}
{"query": "Proposal: Adopt Renovate for Automated Dependency Updates Hi everyone, I'd like to propose adopting Renovate to automate our dependency updates. Renovate scans for outdated dependencies and opens pull requests with suggested upgrades — saving time and helping us keep things secure and up to date. To get started, we’d just need to install the Renovate GitHub App. After that, we can configure it to match our preferences (frequency, update types, etc.). I’m happy to help with the initial setup and submit a configuration PR if the team is open to trying it out. Looking forward to hearing your thoughts! Thanks, Liora You’re right. I messed this up. I shouldn’t have said “we” since I’m not part of the project. That was a bad call. And I thought I understood your post, but I clearly got it wrong. I didn’t mean to ignore what you said, I just misunderstood it. Also, just to be transparent: I use AI to help me write in English, because it’s not my first language and I want to express things clearly. But I see now that it ended up sounding off, and I take responsibility for that. I wasn’t trying to be fake or talk down to you. I just wanted to suggest something that might help, but I get that it didn’t come across well. I’ll step back. Thanks for all the work you do. I really do respect it.", "mode": "nl", "used_query": "Proposal: Adopt Renovate for Automated Dependency Updates Hi everyone, I'd like to propose adopting Renovate to automate our dependency updates. Renovate scans for outdated dependencies and opens pull requests with suggested upgrades — saving time and helping us keep things secure and up to date. To get started, we’d just need to install the Renovate GitHub App. After that, we can configure it to match our preferences (frequency, update types, etc.). I’m happy to help with the initial setup and submit a configuration PR if the team is open to trying it out. Looking forward to hearing your thoughts! Thanks, Liora You’re right. I messed this up. I shouldn’t have said “we” since I’m not part of the project. That was a bad call. And I thought I understood your post, but I clearly got it wrong. I didn’t mean to ignore what you said, I just misunderstood it. Also, just to be transparent: I use AI to help me write in English, because it’s not my first language and I want to express things clearly. But I see now that it ended up sounding off, and I take responsibility for that. I wasn’t trying to be fake or talk down to you. I just wanted to suggest something that might help, but I get that it didn’t come across well. I’ll step back. Thanks for all the work you do. I really do respect it.", "gold_terms": ["davidism", "written", "about", "why", "longer", "using", "other", "automatic", "updates", "https", "com", "disabling", "scheduled", "dependency", "short", "way", "too", "noisy", "and", "doesn"], "results": [{"rank": 1, "score": 0.29300379753112793, "raw_score": 0.29300379753112793, "source": "docs", "row": 144, "chunk_id": "fc7a7779ae77dd518fa31894e112112141432c41", "symbol_type": "doc", "qualname": "extensiondev.rst#Recommended Extension Guidelines", "file_path": "d:\\499\\docs\\extensiondev.rst", "start_line": 253, "end_line": 305}, {"rank": 2, "score": 0.2528488039970398, "raw_score": 0.2528488039970398, "source": "docs", "row": 73, "chunk_id": "01f4a5e371f6cd14723a30c1b302891a37994e24", "symbol_type": "doc", "qualname": "config.rst#Configuration Best Practices", "file_path": "d:\\499\\docs\\config.rst", "start_line": 635, "end_line": 655}, {"rank": 3, "score": 0.23594464361667633, "raw_score": 0.23594464361667633, "source": "docs", "row": 76, "chunk_id": "6ab3a935b0fb057aa7b9d056fb9a4f3ffcda6249", "symbol_type": "doc", "qualname": "contributing.rst#Contributing", "file_path": "d:\\499\\docs\\contributing.rst", "start_line": 2, "end_line": 8}, {"rank": 4, "score": 0.22092756628990173, "raw_score": 0.22092756628990173, "source": "docs", "row": 48, "chunk_id": "e81e3c4350e22fca921d28275d908f64e74d3bc6", "symbol_type": "doc", "qualname": "changes.rst#Changes", "file_path": "d:\\499\\docs\\changes.rst", "start_line": 2, "end_line": 4}, {"rank": 5, "score": 0.21862991154193878, "raw_score": 0.21862991154193878, "source": "docs", "row": 74, "chunk_id": "05bdb040b2408a856b4b2e77e4280ebb848ca195", "symbol_type": "doc", "qualname": "config.rst#Development / Production", "file_path": "d:\\499\\docs\\config.rst", "start_line": 658, "end_line": 758}, {"rank": 6, "score": 0.20718444883823395, "raw_score": 0.20718444883823395, "source": "docs", "row": 163, "chunk_id": "563e4d19a3200336c82e341d8dc117cbd563a92f", "symbol_type": "doc", "qualname": "installation.rst#Virtual environments", "file_path": "d:\\499\\docs\\installation.rst", "start_line": 63, "end_line": 81}, {"rank": 7, "score": 0.20218214392662048, "raw_score": 0.20218214392662048, "source": "docs", "row": 150, "chunk_id": "90aee9e5e00cf4374efc596f49a351a4aa684b9f", "symbol_type": "doc", "qualname": "gevent.rst#Enabling gevent", "file_path": "d:\\499\\docs\\gevent.rst", "start_line": 23, "end_line": 62}, {"rank": 8, "score": 0.19852694869041443, "raw_score": 0.19852694869041443, "source": "docs", "row": 85, "chunk_id": "74da2a1905c44518004d67fed01e255374b6110e", "symbol_type": "doc", "qualname": "deploying\\eventlet.rst#INTRO", "file_path": "d:\\499\\docs\\deploying\\eventlet.rst", "start_line": 1, "end_line": 1}, {"rank": 9, "score": 0.19684195518493652, "raw_score": 0.19684195518493652, "source": "docs", "row": 191, "chunk_id": "220660b82736339ade6b65ac6e44ad255d16e2a9", "symbol_type": "doc", "qualname": "patterns\\appfactories.rst#Factory Improvements", "file_path": "d:\\499\\docs\\patterns\\appfactories.rst", "start_line": 108, "end_line": 118}, {"rank": 10, "score": 0.19538535177707672, "raw_score": 0.19538535177707672, "source": "docs", "row": 351, "chunk_id": "bd6d0a479daffb59ee34ec7f294222f0c0293814", "symbol_type": "doc", "qualname": "tutorial\\install.rst#Install the Project", "file_path": "d:\\499\\docs\\tutorial\\install.rst", "start_line": 54, "end_line": 89}]}
{"query": "How to use g in generator? app = current_app._get_current_object() return Response(generate_res(app, g.token), content_type='text/event-stream')  I use a generator to implement streaming responses. But I found that I can't use g in the generator, and it says it's out of context.", "mode": "nl", "used_query": "How to use g in generator? app = current_app._get_current_object() return Response(generate_res(app, g.token), content_type='text/event-stream')  I use a generator to implement streaming responses. But I found that I can't use g in the generator, and it says it's out of context.", "gold_terms": ["davidism", "looking", "for", "the", "stream_with_context", "function", "decorator", "documented", "https", "flask", "palletsprojects", "com", "page", "patterns", "streaming", "context"], "results": [{"rank": 1, "score": 0.6331016421318054, "raw_score": 0.6331016421318054, "source": "flask", "row": 138, "chunk_id": "98cf1787ccc0088c9211d12092cafa8790ca73d9", "symbol_type": "function", "qualname": "stream_with_context", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\helpers.py", "start_line": 63, "end_line": 143}, {"rank": 2, "score": 0.619208812713623, "raw_score": 0.619208812713623, "source": "docs", "row": 251, "chunk_id": "ddbffa9459d587f5a13ebae00a904a92aee9de6a", "symbol_type": "doc", "qualname": "patterns\\streaming.rst#Streaming with Context", "file_path": "d:\\499\\docs\\patterns\\streaming.rst", "start_line": 50, "end_line": 85}, {"rank": 3, "score": 0.5167324542999268, "raw_score": 0.5167324542999268, "source": "docs", "row": 249, "chunk_id": "5d7480200e40f11abc23fb13a1890b1fdf0eb76c", "symbol_type": "doc", "qualname": "patterns\\streaming.rst#Basic Usage", "file_path": "d:\\499\\docs\\patterns\\streaming.rst", "start_line": 12, "end_line": 27}, {"rank": 4, "score": 0.49586817622184753, "raw_score": 0.49586817622184753, "source": "flask", "row": 136, "chunk_id": "ab3362ef784a2103493ebc982480d5943ff59021", "symbol_type": "function", "qualname": "stream_with_context", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\helpers.py", "start_line": 52, "end_line": 54}, {"rank": 5, "score": 0.4873638451099396, "raw_score": 0.4873638451099396, "source": "flask", "row": 350, "chunk_id": "14bbe26bff41faa5b46f4738dedfb0f1d56b2878", "symbol_type": "function", "qualname": "stream_template_string", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\templating.py", "start_line": 207, "end_line": 219}, {"rank": 6, "score": 0.4857804775238037, "raw_score": 0.4857804775238037, "source": "flask", "row": 348, "chunk_id": "3defb03b0e6e84e48d3cf3c615eb1374473097e7", "symbol_type": "function", "qualname": "_stream", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\templating.py", "start_line": 165, "end_line": 185}, {"rank": 7, "score": 0.47247445583343506, "raw_score": 0.47247445583343506, "source": "flask", "row": 137, "chunk_id": "b899b395a8f94217728fb14982a9303d65afd033", "symbol_type": "function", "qualname": "stream_with_context", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\helpers.py", "start_line": 58, "end_line": 60}, {"rank": 8, "score": 0.43247032165527344, "raw_score": 0.43247032165527344, "source": "flask", "row": 347, "chunk_id": "e0abb03199cf3ed22e829042d98f4bf84f0b0c15", "symbol_type": "function", "qualname": "render_template_string", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\templating.py", "start_line": 153, "end_line": 162}, {"rank": 9, "score": 0.42665740847587585, "raw_score": 0.42665740847587585, "source": "flask", "row": 26, "chunk_id": "9431920b95ef4bbe7590589d3dc94faba3f249ce", "symbol_type": "method", "qualname": "Flask.make_response", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 1129, "end_line": 1269}, {"rank": 10, "score": 0.42403048276901245, "raw_score": 0.42403048276901245, "source": "docs", "row": 15, "chunk_id": "4c01e9f103fce3c201a60e8e5003b553de8c0d36", "symbol_type": "doc", "qualname": "api.rst#Stream Helpers", "file_path": "d:\\499\\docs\\api.rst", "start_line": 286, "end_line": 288}]}
{"query": "Suggestion to Include “AirFlask” in Flask Documentation – A Tool to deploy flask web apps in production I am Naitik Mundra author and maintainer of an open source python library called AirFlask, https://pypi.org/project/airflask/ AirFlask is the  \"Simplest way to host flask web apps in production - Using nginx and gunicorn.\" It will be extremely helpful for beginners who want to host their web apps in production, or people who don't wanna deep dive into setting up gunicorn and nginx and just want to build flask apps. Airflask is an open-source linux based cli python library that automates deployment of flask apps, from optimizing hosting needs relative to server size to managing multiple apps, AirFlask does it all. It handles what kind of gunicorn workers, threads  the webapp will require and how many of them, It also handles ssl and domain management with a single command. The source code and usage tutorial is available at -  https://github.com/naitikmundra/AirFlask If we could discuss the addition of AirFlask to the flask documentation it would be fantastic, and it will definitely make flask deployment in production easier.", "mode": "nl", "used_query": "Suggestion to Include “AirFlask” in Flask Documentation – A Tool to deploy flask web apps in production I am Naitik Mundra author and maintainer of an open source python library called AirFlask, https://pypi.org/project/airflask/ AirFlask is the  \"Simplest way to host flask web apps in production - Using nginx and gunicorn.\" It will be extremely helpful for beginners who want to host their web apps in production, or people who don't wanna deep dive into setting up gunicorn and nginx and just want to build flask apps. Airflask is an open-source linux based cli python library that automates deployment of flask apps, from optimizing hosting needs relative to server size to managing multiple apps, AirFlask does it all. It handles what kind of gunicorn workers, threads  the webapp will require and how many of them, It also handles ssl and domain management with a single command. The source code and usage tutorial is available at -  https://github.com/naitikmundra/AirFlask If we could discuss the addition of AirFlask to the flask documentation it would be fantastic, and it will definitely make flask deployment in production easier.", "gold_terms": ["first", "glance", "its", "completely", "unclear", "how", "integrates", "deployment", "secrets", "configuration", "commonly", "used", "container", "schemes", "modern", "frontends", "and", "why", "anyone", "should"], "results": [{"rank": 1, "score": 0.6656169891357422, "raw_score": 0.6656169891357422, "source": "docs", "row": 120, "chunk_id": "f381a7c86ffe595599be1fd59dd643c0df35982d", "symbol_type": "doc", "qualname": "design.rst#What does \"micro\" mean?", "file_path": "d:\\499\\docs\\design.rst", "start_line": 134, "end_line": 170}, {"rank": 2, "score": 0.6569775342941284, "raw_score": 0.6569775342941284, "source": "docs", "row": 154, "chunk_id": "5c61764df1218c3aa441416b0c8c6f78df40f6f8", "symbol_type": "doc", "qualname": "index.rst#Welcome to Flask", "file_path": "d:\\499\\docs\\index.rst", "start_line": 4, "end_line": 29}, {"rank": 3, "score": 0.6538790464401245, "raw_score": 0.6538790464401245, "source": "docs", "row": 137, "chunk_id": "acbf8e0f421ab8d6eb97e7289d745bf1c98f3a34", "symbol_type": "doc", "qualname": "extensiondev.rst#Flask Extension Development", "file_path": "d:\\499\\docs\\extensiondev.rst", "start_line": 2, "end_line": 23}, {"rank": 4, "score": 0.6520477533340454, "raw_score": 0.6520477533340454, "source": "docs", "row": 384, "chunk_id": "129666661e21da641cc70247236e34242361161b", "symbol_type": "doc", "qualname": "web-security.rst#Security Considerations", "file_path": "d:\\499\\docs\\web-security.rst", "start_line": 2, "end_line": 10}, {"rank": 5, "score": 0.6428118944168091, "raw_score": 0.6428118944168091, "source": "docs", "row": 290, "chunk_id": "ee45d5f39a617a698ea1c65b8963ce9274952b48", "symbol_type": "doc", "qualname": "quickstart.rst#Deploying to a Web Server", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 856, "end_line": 858}, {"rank": 6, "score": 0.6303113698959351, "raw_score": 0.6303113698959351, "source": "docs", "row": 160, "chunk_id": "baa43f83a648d830e935b5d02b8c0fe11e43fb09", "symbol_type": "doc", "qualname": "installation.rst#Dependencies", "file_path": "d:\\499\\docs\\installation.rst", "start_line": 12, "end_line": 34}, {"rank": 7, "score": 0.6300321817398071, "raw_score": 0.6300321817398071, "source": "docs", "row": 185, "chunk_id": "49b134f9ebbd20f7619b7b7925f523ecd470636d", "symbol_type": "doc", "qualname": "patterns\\appdispatch.rst#Dispatch by Subdomain", "file_path": "d:\\499\\docs\\patterns\\appdispatch.rst", "start_line": 61, "end_line": 131}, {"rank": 8, "score": 0.6293261051177979, "raw_score": 0.6293261051177979, "source": "docs", "row": 93, "chunk_id": "4a3db41fd1376fb8d2ec5837b8abd6d3d71f7b8d", "symbol_type": "doc", "qualname": "deploying\\gunicorn.rst#Running", "file_path": "d:\\499\\docs\\deploying\\gunicorn.rst", "start_line": 40, "end_line": 72}, {"rank": 9, "score": 0.6255648136138916, "raw_score": 0.6255648136138916, "source": "docs", "row": 169, "chunk_id": "daa76bb80df5703fdefee189eac6329ad4a5a22d", "symbol_type": "doc", "qualname": "lifecycle.rst#Application Setup", "file_path": "d:\\499\\docs\\lifecycle.rst", "start_line": 11, "end_line": 62}, {"rank": 10, "score": 0.6196253299713135, "raw_score": 0.6196253299713135, "source": "docs", "row": 168, "chunk_id": "3b4027f1d93cf95d55416555be53b960832d3cb7", "symbol_type": "doc", "qualname": "lifecycle.rst#Application Structure and Lifecycle", "file_path": "d:\\499\\docs\\lifecycle.rst", "start_line": 2, "end_line": 8}]}
{"query": "Swagger Docs for Flask App I would like to create Swagger Docs for a Flask application. I am currently discovering the options. I imagine having something like OpenAPI, for example in FastAPI. I have googled if there is an extension for Flask. While I found some they didn't seem to be actively maintained. What is the recommended option?", "mode": "nl", "used_query": "Swagger Docs for Flask App I would like to create Swagger Docs for a Flask application. I am currently discovering the options. I imagine having something like OpenAPI, for example in FastAPI. I have googled if there is an extension for Flask. While I found some they didn't seem to be actively maintained. What is the recommended option?", "gold_terms": ["miguelgrinberg", "maintained", "the", "author", "davidism", "are", "actively", "projects", "aware", "part", "and", "community", "doesn", "generate", "openapi", "yet", "uses", "async", "supports", "serializers"], "results": [{"rank": 1, "score": 0.550462543964386, "raw_score": 0.550462543964386, "source": "docs", "row": 0, "chunk_id": "a689a867fc1fd922c6ae51cb5e7909605ae5d9eb", "symbol_type": "doc", "qualname": "api.rst#API", "file_path": "d:\\499\\docs\\api.rst", "start_line": 2, "end_line": 9}, {"rank": 2, "score": 0.5478621125221252, "raw_score": 0.5478621125221252, "source": "docs", "row": 154, "chunk_id": "5c61764df1218c3aa441416b0c8c6f78df40f6f8", "symbol_type": "doc", "qualname": "index.rst#Welcome to Flask", "file_path": "d:\\499\\docs\\index.rst", "start_line": 4, "end_line": 29}, {"rank": 3, "score": 0.5336956977844238, "raw_score": 0.5336956977844238, "source": "docs", "row": 155, "chunk_id": "c67b758985d61521f829647d38dcd07128b1294b", "symbol_type": "doc", "qualname": "index.rst#User's Guide", "file_path": "d:\\499\\docs\\index.rst", "start_line": 32, "end_line": 65}, {"rank": 4, "score": 0.5135223865509033, "raw_score": 0.5135223865509033, "source": "flask", "row": 156, "chunk_id": "4e3038bdfbdf80915de18032addbe3441e6e5486", "symbol_type": "class", "qualname": "JSONProvider", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\json\\provider.py", "start_line": 19, "end_line": 105}, {"rank": 5, "score": 0.5101145505905151, "raw_score": 0.5101145505905151, "source": "docs", "row": 290, "chunk_id": "ee45d5f39a617a698ea1c65b8963ce9274952b48", "symbol_type": "doc", "qualname": "quickstart.rst#Deploying to a Web Server", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 856, "end_line": 858}, {"rank": 6, "score": 0.5062410831451416, "raw_score": 0.5062410831451416, "source": "docs", "row": 268, "chunk_id": "32265fe033821f6fd6d33f0a542c4c317cae882f", "symbol_type": "doc", "qualname": "quickstart.rst#Quickstart", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 2, "end_line": 6}, {"rank": 7, "score": 0.5060406923294067, "raw_score": 0.5060406923294067, "source": "docs", "row": 289, "chunk_id": "a037061d1072fc8fb6d22d81c1f4fd4a6524c30c", "symbol_type": "doc", "qualname": "quickstart.rst#Using Flask Extensions", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 847, "end_line": 853}, {"rank": 8, "score": 0.5018365383148193, "raw_score": 0.5018365383148193, "source": "docs", "row": 20, "chunk_id": "2220a9eaec2c9069c57b411715bf14cd91dcd846", "symbol_type": "doc", "qualname": "api.rst#View Function Options", "file_path": "d:\\499\\docs\\api.rst", "start_line": 641, "end_line": 681}, {"rank": 9, "score": 0.49830153584480286, "raw_score": 0.49830153584480286, "source": "docs", "row": 353, "chunk_id": "3a18481600be3203bf2e73986e305292c8eb71d5", "symbol_type": "doc", "qualname": "tutorial\\next.rst#Keep Developing!", "file_path": "d:\\499\\docs\\tutorial\\next.rst", "start_line": 2, "end_line": 38}, {"rank": 10, "score": 0.4933801293373108, "raw_score": 0.4933801293373108, "source": "docs", "row": 148, "chunk_id": "a04c0a04bc1ac6e10978cf3766ff077fe76a44c8", "symbol_type": "doc", "qualname": "extensions.rst#Building Extensions", "file_path": "d:\\499\\docs\\extensions.rst", "start_line": 40, "end_line": 48}]}
{"query": "Flask sessions cause tabs to freeze Hey! 🐶 I have a Flask app and I'm running into a weird issue that I think has to do with sessions - but I'm not sure how. So when connecting to my web app everything works great and requests flow smoothly. However, if I open another tab of the app in the same browser - all requests in both tabs get stuck in a pending state and the app is unusable. The second that I close one of the tabs, requests start flowing again and all the old pending ones fire instantly. This doesn't occur when opening multiple tabs in different browsers, or when opening another tab in Incognito, only when it's on the same browser. How I handle sessions Session are created on user login - if(correct_login): #Correct login.     session[\"username\"] = username     session[\"last_modified\"] = datetime.now()  I have a before_app_request hook that checks session validity with each request. Every user initiated request also updates last_modified with session[\"last_modified\"] = datetime.now(). Other then that some routes use session data like the username in their process. All session are stored in a Redis instance. However this issue still persists when using another method like Filesystem. Is my approach to sessions wrong? Is this a known issue with sessions and I should consider another tool? Any help would be appreciated 🙏 versions flask 2.2.5 flask-session 0.8.0 redis 7.4.2", "mode": "nl", "used_query": "Flask sessions cause tabs to freeze Hey! 🐶 I have a Flask app and I'm running into a weird issue that I think has to do with sessions - but I'm not sure how. So when connecting to my web app everything works great and requests flow smoothly. However, if I open another tab of the app in the same browser - all requests in both tabs get stuck in a pending state and the app is unusable. The second that I close one of the tabs, requests start flowing again and all the old pending ones fire instantly. This doesn't occur when opening multiple tabs in different browsers, or when opening another tab in Incognito, only when it's on the same browser. How I handle sessions Session are created on user login - if(correct_login): #Correct login.     session[\"username\"] = username     session[\"last_modified\"] = datetime.now()  I have a before_app_request hook that checks session validity with each request. Every user initiated request also updates last_modified with session[\"last_modified\"] = datetime.now(). Other then that some routes use session data like the username in their process. All session are stored in a Redis instance. However this issue still persists when using another method like Filesystem. Is my approach to sessions wrong? Is this a known issue with sessions and I should consider another tool? Any help would be appreciated 🙏 versions flask 2.2.5 flask-session 0.8.0 redis 7.4.2", "gold_terms": ["session", "locks", "the", "sessions", "file", "for", "duration", "request", "especially", "visible", "both", "tabs", "same", "some", "solutions", "simplekv", "provides", "better", "management", "without"], "results": [{"rank": 1, "score": 0.6691670417785645, "raw_score": 0.6691670417785645, "source": "flask", "row": 334, "chunk_id": "05e70400f6f69e3dde05f05351cd4c654b8527e2", "symbol_type": "method", "qualname": "SecureCookieSessionInterface.save_session", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sessions.py", "start_line": 351, "end_line": 399}, {"rank": 2, "score": 0.6636195182800293, "raw_score": 0.6636195182800293, "source": "flask", "row": 327, "chunk_id": "ac7ed70a812ed94605cffba646ce037a3841885b", "symbol_type": "method", "qualname": "SessionInterface.should_set_cookie", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sessions.py", "start_line": 247, "end_line": 261}, {"rank": 3, "score": 0.6480602025985718, "raw_score": 0.6480602025985718, "source": "flask", "row": 333, "chunk_id": "cae28cc81c66b2f2d18aee592bf82ef4b2e0c405", "symbol_type": "method", "qualname": "SecureCookieSessionInterface.open_session", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sessions.py", "start_line": 337, "end_line": 349}, {"rank": 4, "score": 0.6464827656745911, "raw_score": 0.6464827656745911, "source": "docs", "row": 6, "chunk_id": "1ade0fefba4b1a607e881e840e63e6868965cf44", "symbol_type": "doc", "qualname": "api.rst#Session Interface", "file_path": "d:\\499\\docs\\api.rst", "start_line": 93, "end_line": 122}, {"rank": 5, "score": 0.6318908333778381, "raw_score": 0.6318908333778381, "source": "docs", "row": 285, "chunk_id": "a40424ac744b8ce63e6fd2e158f036a550e94031", "symbol_type": "doc", "qualname": "quickstart.rst#Sessions", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 722, "end_line": 781}, {"rank": 6, "score": 0.6225136518478394, "raw_score": 0.6225136518478394, "source": "docs", "row": 324, "chunk_id": "32deb0b4a0730650160f0a4dae949d2a16f74ca2", "symbol_type": "doc", "qualname": "testing.rst#Accessing and Modifying the Session", "file_path": "d:\\499\\docs\\testing.rst", "start_line": 203, "end_line": 243}, {"rank": 7, "score": 0.6146407723426819, "raw_score": 0.6146407723426819, "source": "docs", "row": 5, "chunk_id": "8ba361a240d1982b668a83f8eeff69174b353f72", "symbol_type": "doc", "qualname": "api.rst#Sessions", "file_path": "d:\\499\\docs\\api.rst", "start_line": 54, "end_line": 90}, {"rank": 8, "score": 0.6143202781677246, "raw_score": 0.6143202781677246, "source": "flask", "row": 326, "chunk_id": "51aed5482727548b3bfa97c00bb4abbb0b35d246", "symbol_type": "method", "qualname": "SessionInterface.get_expiration_time", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sessions.py", "start_line": 237, "end_line": 245}, {"rank": 9, "score": 0.6141126751899719, "raw_score": 0.6141126751899719, "source": "flask", "row": 328, "chunk_id": "a508815018458e44e12085fe0aaac664d941eb9e", "symbol_type": "method", "qualname": "SessionInterface.open_session", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sessions.py", "start_line": 263, "end_line": 275}, {"rank": 10, "score": 0.6035202741622925, "raw_score": 0.6035202741622925, "source": "docs", "row": 9, "chunk_id": "ed3eba241917d57b514d27e353ec8ddbbf3be8a7", "symbol_type": "doc", "qualname": "api.rst#Application Globals", "file_path": "d:\\499\\docs\\api.rst", "start_line": 143, "end_line": 173}]}
{"query": "Propagating errors from Blueprint  Error Handlers to App's Error Handlers I have a use case where I need to perform cleanup and rollback operations when a specific exception class is raised in any of the view functions registered to a particular Flask blueprint. After completing the cleanup, I want to propagate this exception to Flask's global error handler, which performs additional cleanup and formats the error response. I am considering explicitly calling app.handle_user_exception(exception), but this requires importing the entire app context  into the utility layer, which seems unnecessary.  Am I doing something wrong conceptually? Is there a better way to achieve this without manually invoking handle_user_exception?  Would appreciate any insights or best practices for handling such scenarios in Flask.", "mode": "nl", "used_query": "Propagating errors from Blueprint  Error Handlers to App's Error Handlers I have a use case where I need to perform cleanup and rollback operations when a specific exception class is raised in any of the view functions registered to a particular Flask blueprint. After completing the cleanup, I want to propagate this exception to Flask's global error handler, which performs additional cleanup and formats the error response. I am considering explicitly calling app.handle_user_exception(exception), but this requires importing the entire app context  into the utility layer, which seems unnecessary.  Am I doing something wrong conceptually? Is there a better way to achieve this without manually invoking handle_user_exception?  Would appreciate any insights or best practices for handling such scenarios in Flask.", "gold_terms": ["davidism", "raise", "the", "error", "blueprint", "handler"], "results": [{"rank": 1, "score": 0.7163954973220825, "raw_score": 0.7163954973220825, "source": "flask", "row": 271, "chunk_id": "cda2b45a8dcaf8db39532ef6eee41af4035234a0", "symbol_type": "method", "qualname": "Blueprint.app_errorhandler", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "start_line": 596, "end_line": 610}, {"rank": 2, "score": 0.7154268026351929, "raw_score": 0.7154268026351929, "source": "flask", "row": 300, "chunk_id": "2557f46e899624d3ea41ba8aadb8b5fb7fc38070", "symbol_type": "method", "qualname": "Scaffold.errorhandler", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "start_line": 598, "end_line": 639}, {"rank": 3, "score": 0.7010815143585205, "raw_score": 0.7010815143585205, "source": "docs", "row": 133, "chunk_id": "94d7446568e8c60779dcda520cf8662cff306860", "symbol_type": "doc", "qualname": "errorhandling.rst#Blueprint Error Handlers", "file_path": "d:\\499\\docs\\errorhandling.rst", "start_line": 392, "end_line": 432}, {"rank": 4, "score": 0.6910128593444824, "raw_score": 0.6910128593444824, "source": "flask", "row": 17, "chunk_id": "407803e8e585924fcfd1670d11e6a858cccc3454", "symbol_type": "method", "qualname": "Flask.handle_exception", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 811, "end_line": 862}, {"rank": 5, "score": 0.6714299917221069, "raw_score": 0.6714299917221069, "source": "flask", "row": 16, "chunk_id": "c447a98bc3f8d8c104d9c90f301e7f4519b16bc0", "symbol_type": "method", "qualname": "Flask.handle_user_exception", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 779, "end_line": 809}, {"rank": 6, "score": 0.6655229330062866, "raw_score": 0.6655229330062866, "source": "docs", "row": 47, "chunk_id": "38efa1a851c084849bfaa1e9b7cbd85590a90890", "symbol_type": "doc", "qualname": "blueprints.rst#Blueprint Error Handlers", "file_path": "d:\\499\\docs\\blueprints.rst", "start_line": 285, "end_line": 315}, {"rank": 7, "score": 0.6532451510429382, "raw_score": 0.6532451510429382, "source": "flask", "row": 242, "chunk_id": "bd8aa579677d2103529098bf0dde5363bf27801b", "symbol_type": "method", "qualname": "App._find_error_handler", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "start_line": 823, "end_line": 846}, {"rank": 8, "score": 0.6509798765182495, "raw_score": 0.6509798765182495, "source": "docs", "row": 127, "chunk_id": "a7d0d6fa76db293c1ad10a21d8b6587985b439d3", "symbol_type": "doc", "qualname": "errorhandling.rst#Registering", "file_path": "d:\\499\\docs\\errorhandling.rst", "start_line": 98, "end_line": 137}, {"rank": 9, "score": 0.6389691829681396, "raw_score": 0.6389691829681396, "source": "docs", "row": 131, "chunk_id": "46d93f09dc7d2aef75d165b2f9fff849f61c7cb1", "symbol_type": "doc", "qualname": "errorhandling.rst#Custom Error Pages", "file_path": "d:\\499\\docs\\errorhandling.rst", "start_line": 259, "end_line": 331}, {"rank": 10, "score": 0.6369563341140747, "raw_score": 0.6369563341140747, "source": "docs", "row": 130, "chunk_id": "e5ee69f66081dd9a463bc8a457cab1461a41f412", "symbol_type": "doc", "qualname": "errorhandling.rst#Unhandled Exceptions", "file_path": "d:\\499\\docs\\errorhandling.rst", "start_line": 238, "end_line": 256}]}
{"query": "Question about \"redirect\" which used in Cross-site When I use the redirect to transmit the Cookie across site, it seems ineffective(That is, the redirected website does not get the Cookie). Here's my code, the origin url is https://ip:port/index. How can I fix the bug?         response = make_response(redirect(\"https://www.google.com/\"))         response.set_cookie(             'test',             'test_cookie',             samesite=None,             secure=True         )         return response", "mode": "nl", "used_query": "Question about \"redirect\" which used in Cross-site When I use the redirect to transmit the Cookie across site, it seems ineffective(That is, the redirected website does not get the Cookie). Here's my code, the origin url is https://ip:port/index. How can I fix the bug?         response = make_response(redirect(\"https://www.google.com/\"))         response.set_cookie(             'test',             'test_cookie',             samesite=None,             secure=True         )         return response", "gold_terms": ["davidism", "not", "how", "cookies", "work", "and", "specific", "can", "only", "set", "domain", "other", "domains", "the", "browser", "gets", "redirect", "response", "makes", "new"], "results": [{"rank": 1, "score": 0.5875693559646606, "raw_score": 0.5875693559646606, "source": "flask", "row": 334, "chunk_id": "05e70400f6f69e3dde05f05351cd4c654b8527e2", "symbol_type": "method", "qualname": "SecureCookieSessionInterface.save_session", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sessions.py", "start_line": 351, "end_line": 399}, {"rank": 2, "score": 0.5754356980323792, "raw_score": 0.5754356980323792, "source": "docs", "row": 394, "chunk_id": "12436a2ed1924123a36381e9296f5d2ab3e27074", "symbol_type": "doc", "qualname": "web-security.rst#Set-Cookie options", "file_path": "d:\\499\\docs\\web-security.rst", "start_line": 213, "end_line": 270}, {"rank": 3, "score": 0.5702675580978394, "raw_score": 0.5702675580978394, "source": "flask", "row": 320, "chunk_id": "cb74cf5dc359b6300f54c65791ca52e1837cf54a", "symbol_type": "method", "qualname": "SessionInterface.get_cookie_domain", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sessions.py", "start_line": 189, "end_line": 199}, {"rank": 4, "score": 0.5381877422332764, "raw_score": 0.5381877422332764, "source": "flask", "row": 323, "chunk_id": "b095683def6a0eec3502f2de2a5a603d3c842799", "symbol_type": "method", "qualname": "SessionInterface.get_cookie_secure", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sessions.py", "start_line": 216, "end_line": 220}, {"rank": 5, "score": 0.525510311126709, "raw_score": 0.525510311126709, "source": "flask", "row": 321, "chunk_id": "15e2fbb1efb7aa2cc8a54abd17c8e1ce4b01d330", "symbol_type": "method", "qualname": "SessionInterface.get_cookie_path", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sessions.py", "start_line": 201, "end_line": 207}, {"rank": 6, "score": 0.5205485820770264, "raw_score": 0.5205485820770264, "source": "flask", "row": 324, "chunk_id": "02fc75542aec0973fabd3b60d7d02e4568a52c5a", "symbol_type": "method", "qualname": "SessionInterface.get_cookie_samesite", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sessions.py", "start_line": 222, "end_line": 227}, {"rank": 7, "score": 0.5052045583724976, "raw_score": 0.5052045583724976, "source": "flask", "row": 322, "chunk_id": "2d56d20db760030b3b190abfff5d5475e8973d95", "symbol_type": "method", "qualname": "SessionInterface.get_cookie_httponly", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sessions.py", "start_line": 209, "end_line": 214}, {"rank": 8, "score": 0.49062860012054443, "raw_score": 0.49062860012054443, "source": "flask", "row": 333, "chunk_id": "cae28cc81c66b2f2d18aee592bf82ef4b2e0c405", "symbol_type": "method", "qualname": "SecureCookieSessionInterface.open_session", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sessions.py", "start_line": 337, "end_line": 349}, {"rank": 9, "score": 0.4817291796207428, "raw_score": 0.4817291796207428, "source": "docs", "row": 281, "chunk_id": "3cf10a702b65a62f00ca19541e60ca6bfc064e82", "symbol_type": "doc", "qualname": "quickstart.rst#Cookies", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 552, "end_line": 591}, {"rank": 10, "score": 0.4733434021472931, "raw_score": 0.4733434021472931, "source": "flask", "row": 327, "chunk_id": "ac7ed70a812ed94605cffba646ce037a3841885b", "symbol_type": "method", "qualname": "SessionInterface.should_set_cookie", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sessions.py", "start_line": 247, "end_line": 261}]}
{"query": "version policy Hi, is there a versioning policy for Flask and its related packages? The version tag format looks like semver but is evidently not. It would be great to clarify this somewhere that can be referenced so that developers can plan accordingly", "mode": "nl", "used_query": "version policy Hi, is there a versioning policy for Flask and its related packages? The version tag format looks like semver but is evidently not. It would be great to clarify this somewhere that can be referenced so that developers can plan accordingly", "gold_terms": ["dctalbot", "might", "consider", "switching", "https", "calver", "org", "something", "else", "davidism", "palletsprojects", "com", "versions"], "results": [{"rank": 1, "score": 0.5688962936401367, "raw_score": 0.5688962936401367, "source": "docs", "row": 75, "chunk_id": "173ccf506b3f5597139062640eea4df89584758f", "symbol_type": "doc", "qualname": "config.rst#Instance Folders", "file_path": "d:\\499\\docs\\config.rst", "start_line": 761, "end_line": 839}, {"rank": 2, "score": 0.554650068283081, "raw_score": 0.554650068283081, "source": "flask", "row": 7, "chunk_id": "e611ef2592e61ab0a6af35ffdcf2360f04187d56", "symbol_type": "method", "qualname": "Flask.create_jinja_environment", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 385, "end_line": 423}, {"rank": 3, "score": 0.5436766147613525, "raw_score": 0.5436766147613525, "source": "flask", "row": 49, "chunk_id": "f50cd701612495d569c579c17a2b8eb9aabe6857", "symbol_type": "function", "qualname": "get_version", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\cli.py", "start_line": 267, "end_line": 280}, {"rank": 4, "score": 0.541917085647583, "raw_score": 0.541917085647583, "source": "docs", "row": 161, "chunk_id": "f753690a4865b7db23cc07cf4b9114ce860c349d", "symbol_type": "doc", "qualname": "installation.rst#Optional dependencies", "file_path": "d:\\499\\docs\\installation.rst", "start_line": 37, "end_line": 49}, {"rank": 5, "score": 0.5370718240737915, "raw_score": 0.5370718240737915, "source": "flask", "row": 153, "chunk_id": "f7bd374a6e54fe45ae7fbe2d58286c5cf5237148", "symbol_type": "function", "qualname": "loads", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\json\\__init__.py", "start_line": 77, "end_line": 105}, {"rank": 6, "score": 0.5352785587310791, "raw_score": 0.5352785587310791, "source": "flask", "row": 62, "chunk_id": "a73988ed626172b3de845c440c16f38334d8d609", "symbol_type": "method", "qualname": "FlaskGroup._load_plugin_commands", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\cli.py", "start_line": 600, "end_line": 615}, {"rank": 7, "score": 0.5323877930641174, "raw_score": 0.5323877930641174, "source": "docs", "row": 287, "chunk_id": "bc682ee3609a2936c4ea696a22dacab8d0d57289", "symbol_type": "doc", "qualname": "quickstart.rst#Logging", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 800, "end_line": 827}, {"rank": 8, "score": 0.5304983854293823, "raw_score": 0.5304983854293823, "source": "docs", "row": 160, "chunk_id": "baa43f83a648d830e935b5d02b8c0fe11e43fb09", "symbol_type": "doc", "qualname": "installation.rst#Dependencies", "file_path": "d:\\499\\docs\\installation.rst", "start_line": 12, "end_line": 34}, {"rank": 9, "score": 0.5230953097343445, "raw_score": 0.5230953097343445, "source": "docs", "row": 159, "chunk_id": "c916bf2a90d304338adda05defe498d0e1b9b21b", "symbol_type": "doc", "qualname": "installation.rst#Python Version", "file_path": "d:\\499\\docs\\installation.rst", "start_line": 6, "end_line": 9}, {"rank": 10, "score": 0.5176455974578857, "raw_score": 0.5176455974578857, "source": "flask", "row": 151, "chunk_id": "0600b3e965906602129528674a9a09175ca2b891", "symbol_type": "function", "qualname": "dumps", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\json\\__init__.py", "start_line": 13, "end_line": 44}]}
{"query": "How to solve response = {         \"status\": \"ok\",         \"message\": \"Success\",         \"response\": url     }     return jsonify(response) In this getting output like this {\"message\": \"success\", \"response\": url, \"status\": \"old\"} How to solve that getting incorrect output I need this like {         \"status\": \"ok\",         \"message\": \"Success\",         \"response\": url     }  How to solve", "mode": "nl", "used_query": "How to solve response = {         \"status\": \"ok\",         \"message\": \"Success\",         \"response\": url     }     return jsonify(response) In this getting output like this {\"message\": \"success\", \"response\": url, \"status\": \"old\"} How to solve that getting incorrect output I need this like {         \"status\": \"ok\",         \"message\": \"Success\",         \"response\": url     }  How to solve", "gold_terms": ["what", "exactly", "problem", "the", "order", "yes", "flask", "setting", "disable", "sorting", "json", "keys"], "results": [{"rank": 1, "score": 0.45383644104003906, "raw_score": 0.45383644104003906, "source": "docs", "row": 221, "chunk_id": "9138ab7d0f126b83befa9c5d2ed02660763cae13", "symbol_type": "doc", "qualname": "patterns\\javascript.rst#Receiving JSON in Views", "file_path": "d:\\499\\docs\\patterns\\javascript.rst", "start_line": 244, "end_line": 261}, {"rank": 2, "score": 0.4468533992767334, "raw_score": 0.4468533992767334, "source": "docs", "row": 220, "chunk_id": "660e6f6ea9bbae0ea090f794693207c6fa9236c7", "symbol_type": "doc", "qualname": "patterns\\javascript.rst#Return JSON from Views", "file_path": "d:\\499\\docs\\patterns\\javascript.rst", "start_line": 206, "end_line": 241}, {"rank": 3, "score": 0.4437173902988434, "raw_score": 0.4437173902988434, "source": "docs", "row": 218, "chunk_id": "b70b21d67abb46801724e360f214b05ce4783926", "symbol_type": "doc", "qualname": "patterns\\javascript.rst#Following Redirects", "file_path": "d:\\499\\docs\\patterns\\javascript.rst", "start_line": 161, "end_line": 180}, {"rank": 4, "score": 0.42565590143203735, "raw_score": 0.42565590143203735, "source": "flask", "row": 168, "chunk_id": "33d30b56cf8b44ee87e090a41e7e85600b622a4f", "symbol_type": "method", "qualname": "DefaultJSONProvider.response", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\json\\provider.py", "start_line": 189, "end_line": 215}, {"rank": 5, "score": 0.4200783967971802, "raw_score": 0.4200783967971802, "source": "flask", "row": 26, "chunk_id": "9431920b95ef4bbe7590589d3dc94faba3f249ce", "symbol_type": "method", "qualname": "Flask.make_response", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 1129, "end_line": 1269}, {"rank": 6, "score": 0.4122490882873535, "raw_score": 0.4122490882873535, "source": "docs", "row": 322, "chunk_id": "40c07df28aab4d663612c821e7f698c5809fb3a5", "symbol_type": "doc", "qualname": "testing.rst#JSON Data", "file_path": "d:\\499\\docs\\testing.rst", "start_line": 153, "end_line": 177}, {"rank": 7, "score": 0.4072456359863281, "raw_score": 0.4072456359863281, "source": "docs", "row": 283, "chunk_id": "ad64dd251fb0000925a3337f9f12a40b31f476a0", "symbol_type": "doc", "qualname": "quickstart.rst#About Responses", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 634, "end_line": 683}, {"rank": 8, "score": 0.39295893907546997, "raw_score": 0.39295893907546997, "source": "flask", "row": 162, "chunk_id": "28c74e5b50568d743fe626ba0e392063a45ba092", "symbol_type": "method", "qualname": "JSONProvider._prepare_response_obj", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\json\\provider.py", "start_line": 75, "end_line": 87}, {"rank": 9, "score": 0.3920288383960724, "raw_score": 0.3920288383960724, "source": "flask", "row": 211, "chunk_id": "0ba2eba887c6dc8461e6e61f26cfd9daffec65e0", "symbol_type": "method", "qualname": "TaggedJSONSerializer.dumps", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\json\\tag.py", "start_line": 321, "end_line": 323}, {"rank": 10, "score": 0.3910468816757202, "raw_score": 0.3910468816757202, "source": "flask", "row": 155, "chunk_id": "8b5c4c39a5e4b9968f072bf3cf1d2c8ec53d38cb", "symbol_type": "function", "qualname": "jsonify", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\json\\__init__.py", "start_line": 138, "end_line": 170}]}
{"query": "Consider supporting HOT reload with `hmr`? Hot Module Replacement has been existed in JavaScript ecosystem for a long time, but Python web applications are still using full reloads by default. To solve this situation, I implemented the hmr package, which does the fine-grained dependency tracking, on-demand reloading jobs. Here is a demo of what the results look like:                    flask.mov                   Obviously the a.py runs everytime in flask run --reload but reloads only when needed in hmr app.py. But everything else works fine (at least for this small demo) You may say that user should use lazy imports and cache expensive calculations themselves, but in fact not every function can be cached, and lazy imports may lead to ugly code style. This can be solved with on-demand hot reloading without overhead. So I believe this is the future. Although this is just a minimal demo, but I value hmr's potential in the Python ecosystem, and believe that with our efforts this is a reachable goal. TipYou can try the example above here with hmr app.py   About hmr, you can refer to its README for details.", "mode": "nl", "used_query": "Consider supporting HOT reload with `hmr`? Hot Module Replacement has been existed in JavaScript ecosystem for a long time, but Python web applications are still using full reloads by default. To solve this situation, I implemented the hmr package, which does the fine-grained dependency tracking, on-demand reloading jobs. Here is a demo of what the results look like:                    flask.mov                   Obviously the a.py runs everytime in flask run --reload but reloads only when needed in hmr app.py. But everything else works fine (at least for this small demo) You may say that user should use lazy imports and cache expensive calculations themselves, but in fact not every function can be cached, and lazy imports may lead to ugly code style. This can be solved with on-demand hot reloading without overhead. So I believe this is the future. Although this is just a minimal demo, but I value hmr's potential in the Python ecosystem, and believe that with our efforts this is a reachable goal. TipYou can try the example above here with hmr app.py   About hmr, you can refer to its README for details.", "gold_terms": ["adds", "huge", "risk", "weird", "bugs", "can", "add", "something", "like", "themselves", "their", "app", "they", "want", "really", "understand", "may", "never", "become", "default"], "results": [{"rank": 1, "score": 0.5934873819351196, "raw_score": 0.5934873819351196, "source": "docs", "row": 224, "chunk_id": "b8ba60a112ff513bbc44016e7bf2e8d2da12952b", "symbol_type": "doc", "qualname": "patterns\\lazyloading.rst#Lazily Loading Views", "file_path": "d:\\499\\docs\\patterns\\lazyloading.rst", "start_line": 2, "end_line": 17}, {"rank": 2, "score": 0.5662065148353577, "raw_score": 0.5662065148353577, "source": "docs", "row": 192, "chunk_id": "18f2cb1a8823484c743743f49355deb6c8476a45", "symbol_type": "doc", "qualname": "patterns\\caching.rst#Caching", "file_path": "d:\\499\\docs\\patterns\\caching.rst", "start_line": 2, "end_line": 16}, {"rank": 3, "score": 0.5324928164482117, "raw_score": 0.5324928164482117, "source": "flask", "row": 153, "chunk_id": "f7bd374a6e54fe45ae7fbe2d58286c5cf5237148", "symbol_type": "function", "qualname": "loads", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\json\\__init__.py", "start_line": 77, "end_line": 105}, {"rank": 4, "score": 0.5289857387542725, "raw_score": 0.5289857387542725, "source": "docs", "row": 9, "chunk_id": "ed3eba241917d57b514d27e353ec8ddbbf3be8a7", "symbol_type": "doc", "qualname": "api.rst#Application Globals", "file_path": "d:\\499\\docs\\api.rst", "start_line": 143, "end_line": 173}, {"rank": 5, "score": 0.5210675597190857, "raw_score": 0.5210675597190857, "source": "docs", "row": 225, "chunk_id": "25ee5502825f37cffc812679c1a87096e0e728d9", "symbol_type": "doc", "qualname": "patterns\\lazyloading.rst#Converting to Centralized URL Map", "file_path": "d:\\499\\docs\\patterns\\lazyloading.rst", "start_line": 20, "end_line": 51}, {"rank": 6, "score": 0.5203167200088501, "raw_score": 0.5203167200088501, "source": "flask", "row": 51, "chunk_id": "bb8b373c6e3748c380c1afe8fda418f0c16084d3", "symbol_type": "method", "qualname": "ScriptInfo.__init__", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\cli.py", "start_line": 305, "end_line": 331}, {"rank": 7, "score": 0.5131337642669678, "raw_score": 0.5131337642669678, "source": "flask", "row": 156, "chunk_id": "4e3038bdfbdf80915de18032addbe3441e6e5486", "symbol_type": "class", "qualname": "JSONProvider", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\json\\provider.py", "start_line": 19, "end_line": 105}, {"rank": 8, "score": 0.5116993188858032, "raw_score": 0.5116993188858032, "source": "docs", "row": 172, "chunk_id": "f4b14c45e315d68f17d421c4d80ff7cfb25656ac", "symbol_type": "doc", "qualname": "lifecycle.rst#How a Request is Handled", "file_path": "d:\\499\\docs\\lifecycle.rst", "start_line": 111, "end_line": 171}, {"rank": 9, "score": 0.5111437439918518, "raw_score": 0.5111437439918518, "source": "docs", "row": 226, "chunk_id": "7d5835da5a5dad40af31caaa718bbe8c8d535baf", "symbol_type": "doc", "qualname": "patterns\\lazyloading.rst#Loading Late", "file_path": "d:\\499\\docs\\patterns\\lazyloading.rst", "start_line": 54, "end_line": 109}, {"rank": 10, "score": 0.5075831413269043, "raw_score": 0.5075831413269043, "source": "flask", "row": 52, "chunk_id": "188aa932dc26b3fa3413072cd11031f8665c3389", "symbol_type": "method", "qualname": "ScriptInfo.load_app", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\cli.py", "start_line": 333, "end_line": 372}]}
{"query": "Why do I get so much complaint from pylance on Flask? I'm new to flask and is still learning how to use it. I found this simple example and pasted it in VS Code with Type Check in Strict mode. I starts to get bombarded with type issue in almost every single line of code I use flask. What is going on? How do I fix that? I'm using flask 3.1.0 and I have types-flask 1.1.6 installed.  It seems the fundamental issue is that Pylance doesn't know what jsonify will return, and it doesn't konw about the json attribute of request. Is there a way to fix this? The code itself seems to be running correctly. I want to avoid this issue while using strict type checking.", "mode": "nl", "used_query": "Why do I get so much complaint from pylance on Flask? I'm new to flask and is still learning how to use it. I found this simple example and pasted it in VS Code with Type Check in Strict mode. I starts to get bombarded with type issue in almost every single line of code I use flask. What is going on? How do I fix that? I'm using flask 3.1.0 and I have types-flask 1.1.6 installed.  It seems the fundamental issue is that Pylance doesn't know what jsonify will return, and it doesn't konw about the json attribute of request. Is there a way to fix this? The code itself seems to be running correctly. I want to avoid this issue while using strict type checking.", "gold_terms": ["realized", "types", "flask", "for", "old", "version", "only", "uninstalled", "and", "now", "the", "complaint", "goes", "down", "line", "request", "json", "still", "got", "type"], "results": [{"rank": 1, "score": 0.6706970930099487, "raw_score": 0.6706970930099487, "source": "flask", "row": 155, "chunk_id": "8b5c4c39a5e4b9968f072bf3cf1d2c8ec53d38cb", "symbol_type": "function", "qualname": "jsonify", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\json\\__init__.py", "start_line": 138, "end_line": 170}, {"rank": 2, "score": 0.6262622475624084, "raw_score": 0.6262622475624084, "source": "docs", "row": 388, "chunk_id": "3b4316b221219dcb0f5833e0f637b574de66c1b1", "symbol_type": "doc", "qualname": "web-security.rst#JSON Security", "file_path": "d:\\499\\docs\\web-security.rst", "start_line": 141, "end_line": 151}, {"rank": 3, "score": 0.6162950992584229, "raw_score": 0.6162950992584229, "source": "flask", "row": 163, "chunk_id": "c8ee5c7a4583259500fa04a9eac423649080e2f6", "symbol_type": "method", "qualname": "JSONProvider.response", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\json\\provider.py", "start_line": 89, "end_line": 105}, {"rank": 4, "score": 0.6071447134017944, "raw_score": 0.6071447134017944, "source": "flask", "row": 153, "chunk_id": "f7bd374a6e54fe45ae7fbe2d58286c5cf5237148", "symbol_type": "function", "qualname": "loads", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\json\\__init__.py", "start_line": 77, "end_line": 105}, {"rank": 5, "score": 0.6058968305587769, "raw_score": 0.6058968305587769, "source": "docs", "row": 221, "chunk_id": "9138ab7d0f126b83befa9c5d2ed02660763cae13", "symbol_type": "doc", "qualname": "patterns\\javascript.rst#Receiving JSON in Views", "file_path": "d:\\499\\docs\\patterns\\javascript.rst", "start_line": 244, "end_line": 261}, {"rank": 6, "score": 0.6056103706359863, "raw_score": 0.6056103706359863, "source": "flask", "row": 168, "chunk_id": "33d30b56cf8b44ee87e090a41e7e85600b622a4f", "symbol_type": "method", "qualname": "DefaultJSONProvider.response", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\json\\provider.py", "start_line": 189, "end_line": 215}, {"rank": 7, "score": 0.5965814590454102, "raw_score": 0.5965814590454102, "source": "flask", "row": 154, "chunk_id": "0d2ebe8ad134e755aaafbd0067a2d0aa215b6ed3", "symbol_type": "function", "qualname": "load", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\json\\__init__.py", "start_line": 108, "end_line": 135}, {"rank": 8, "score": 0.5869771242141724, "raw_score": 0.5869771242141724, "source": "flask", "row": 152, "chunk_id": "66c59e597bab748beac3b4958cd735edc4990b05", "symbol_type": "function", "qualname": "dump", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\json\\__init__.py", "start_line": 47, "end_line": 74}, {"rank": 9, "score": 0.5859335660934448, "raw_score": 0.5859335660934448, "source": "flask", "row": 151, "chunk_id": "0600b3e965906602129528674a9a09175ca2b891", "symbol_type": "function", "qualname": "dumps", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\json\\__init__.py", "start_line": 13, "end_line": 44}, {"rank": 10, "score": 0.5749809741973877, "raw_score": 0.5749809741973877, "source": "docs", "row": 134, "chunk_id": "8702048bc2762c717b5a7032bb6a43374a8cf951", "symbol_type": "doc", "qualname": "errorhandling.rst#Returning API Errors as JSON", "file_path": "d:\\499\\docs\\errorhandling.rst", "start_line": 435, "end_line": 510}]}
{"query": "Header Issue: Flask Server Not Receiving Custom Headers in Request (SECRET_KEY Issue) Title: Header Issue: Flask Server Not Receiving Custom Headers in Request (SECRET_KEY Issue) Description: Hello, I am experiencing an issue where my Flask server does not properly receive the SECRET_KEY header sent from the client (Postman, PowerShell, etc.). Despite configuring the Flask application with Flask-CORS and ensuring headers are sent from the client, the server consistently logs the received SECRET_KEY as None, resulting in a 403 Invalid SECRET_KEY response. I have tried multiple debugging approaches, but the issue persists. Below is the detailed information about the setup, code, and error logs. Environment: Operating System: Windows 10 Python Version: 3.11 Flask Version: 2.2.5 Flask-CORS Version: 3.0.10 dotenv Version: 1.0.0 Reproduction Steps: Set up the .env file in the project root directory with the following content: API_SECRET_KEY=mflow1546 Run the following Flask application: import os from flask import Flask, request, jsonify from flask_cors import CORS import logging from dotenv import load_dotenv Load .env file load_dotenv() Get SECRET_KEY from environment variables SECRET_KEY = os.getenv('API_SECRET_KEY', 'default_key') if not SECRET_KEY or SECRET_KEY == 'default_key': print(f\"Loaded SECRET_KEY from environment: {SECRET_KEY}\") raise ValueError(\"SECRET_KEY is not properly set.\") Initialize Flask app app = Flask(name) CORS(app, resources={r\"/\": {\"origins\": \"\"}}, supports_credentials=True, allow_headers=[\"Content-Type\", \"SECRET_KEY\"]) Configure logging logging.basicConfig(level=logging.DEBUG, format='%(asctime)s %(levelname)s: %(message)s') @app.route('/api/save', methods=['POST']) def save_data(): try: # Log all headers for debugging headers = dict(request.headers) logging.debug(f\"All Headers: {headers}\")     # Get SECRET_KEY from headers     request_secret = request.headers.get('SECRET_KEY')     logging.debug(f\"Received SECRET_KEY: {request_secret}\")      if request_secret != SECRET_KEY:         logging.error(\"Invalid SECRET_KEY in request.\")         return jsonify({\"message\": \"Invalid SECRET_KEY\", \"status\": \"error\"}), 403      # Validate Content-Type     content_type = request.headers.get('Content-Type', 'None')     logging.debug(f\"Received Content-Type: {content_type}\")      if not content_type or 'application/json' not in content_type:         logging.error(\"Invalid or missing Content-Type header.\")         return jsonify({\"message\": \"Invalid Content-Type. JSON expected.\", \"status\": \"error\"}), 415      # Parse JSON body     data = request.get_json(silent=True)     if not data:         logging.error(\"No JSON data received.\")         return jsonify({\"message\": \"No JSON data received\", \"status\": \"error\"}), 400      logging.info(\"Data processed successfully.\")     return jsonify({\"message\": \"Data received successfully!\", \"status\": \"success\", \"data\": data}), 200 except Exception as e:     logging.error(f\"Unexpected error: {str(e)}\")     return jsonify({\"message\": \"Internal server error\", \"status\": \"error\"}), 500  if name == 'main': print(f\"Loaded SECRET_KEY from .env: {SECRET_KEY}\") app.run(debug=True) Use the following Postman setup to send a POST request: URL: http://127.0.0.1:5000/api/save Method: POST Headers: SECRET_KEY: mflow1546 Content-Type: application/json Body (raw, JSON): { \"key\": \"your_key_value\", \"content\": \"This is a valid request\", \"title\": \"Sample Title\" } Alternatively, use the following PowerShell script to send the request: $headers = @{ \"SECRET_KEY\" = \"mflow1546\" \"Content-Type\" = \"application/json\" } $body = @\" { \"key\": \"your_key_value\", \"content\": \"This is a valid request\", \"title\": \"Sample Title\" } \"@ Invoke-RestMethod -Uri \"http://127.0.0.1:5000/api/save\" -Method POST -Headers $headers -Body $body Expected Behavior: The Flask server should receive the SECRET_KEY header correctly. The request should pass validation and return a 200 OK response with the message \"Data received successfully!\". Actual Behavior: The SECRET_KEY received by the server is always None (as logged by the Received SECRET_KEY log). The server consistently responds with a 403 Invalid SECRET_KEY error. Debugging Steps Tried: Verified the .env file is correctly loaded (the correct SECRET_KEY is printed at startup). Ensured the headers in Postman and PowerShell are set properly. Logged all headers received by the Flask server (custom headers like SECRET_KEY are not present). Used Flask-CORS with allow_headers=[\"Content-Type\", \"SECRET_KEY\"]. Tested with different HTTP clients (Postman, PowerShell, Python requests). Logs: Flask Server Logs: Loaded SECRET_KEY from .env: mflow1546 Loaded SECRET_KEY: mflow1546 2024-12-22 08:21:18,527 WARNING:  * Debugger is active! 2024-12-22 08:21:18,530 INFO:  * Debugger PIN: 181-191-701 2024-12-22 08:12:30,764 DEBUG: All Headers: {'Content-Type': 'application/json', 'User-Agent': 'PostmanRuntime/7.43.0', 'Accept': '/', 'Cache-Control': 'no-cache', 'Postman-Token': 'ff45eb20-073b-43d5-8d99-4c474bbe7ff0', 'Host': '127.0.0.1:5000', 'Accept-Encoding': 'gzip, deflate, br', 'Connection': 'keep-alive', 'Content-Length': '110'} 2024-12-22 08:12:30,765 DEBUG: Received SECRET_KEY: None 2024-12-22 08:12:30,766 ERROR: Invalid SECRET_KEY in request. Questions: Why is the SECRET_KEY header missing from the received headers? Is there an issue with Flask-CORS or how Flask processes custom headers? Are there additional configurations required to properly receive custom headers in Flask? Thank you for your time and assistance!", "mode": "nl", "used_query": "Header Issue: Flask Server Not Receiving Custom Headers in Request (SECRET_KEY Issue) Title: Header Issue: Flask Server Not Receiving Custom Headers in Request (SECRET_KEY Issue) Description: Hello, I am experiencing an issue where my Flask server does not properly receive the SECRET_KEY header sent from the client (Postman, PowerShell, etc.). Despite configuring the Flask application with Flask-CORS and ensuring headers are sent from the client, the server consistently logs the received SECRET_KEY as None, resulting in a 403 Invalid SECRET_KEY response. I have tried multiple debugging approaches, but the issue persists. Below is the detailed information about the setup, code, and error logs. Environment: Operating System: Windows 10 Python Version: 3.11 Flask Version: 2.2.5 Flask-CORS Version: 3.0.10 dotenv Version: 1.0.0 Reproduction Steps: Set up the .env file in the project root directory with the following content: API_SECRET_KEY=mflow1546 Run the following Flask application: import os from flask import Flask, request, jsonify from flask_cors import CORS import logging from dotenv import load_dotenv Load .env file load_dotenv() Get SECRET_KEY from environment variables SECRET_KEY = os.getenv('API_SECRET_KEY', 'default_key') if not SECRET_KEY or SECRET_KEY == 'default_key': print(f\"Loaded SECRET_KEY from environment: {SECRET_KEY}\") raise ValueError(\"SECRET_KEY is not properly set.\") Initialize Flask app app = Flask(name) CORS(app, resources={r\"/\": {\"origins\": \"\"}}, supports_credentials=True, allow_headers=[\"Content-Type\", \"SECRET_KEY\"]) Configure logging logging.basicConfig(level=logging.DEBUG, format='%(asctime)s %(levelname)s: %(message)s') @app.route('/api/save', methods=['POST']) def save_data(): try: # Log all headers for debugging headers = dict(request.headers) logging.debug(f\"All Headers: {headers}\")     # Get SECRET_KEY from headers     request_secret = request.headers.get('SECRET_KEY')     logging.debug(f\"Received SECRET_KEY: {request_secret}\")      if request_secret != SECRET_KEY:         logging.error(\"Invalid SECRET_KEY in request.\")         return jsonify({\"message\": \"Invalid SECRET_KEY\", \"status\": \"error\"}), 403      # Validate Content-Type     content_type = request.headers.get('Content-Type', 'None')     logging.debug(f\"Received Content-Type: {content_type}\")      if not content_type or 'application/json' not in content_type:         logging.error(\"Invalid or missing Content-Type header.\")         return jsonify({\"message\": \"Invalid Content-Type. JSON expected.\", \"status\": \"error\"}), 415      # Parse JSON body     data = request.get_json(silent=True)     if not data:         logging.error(\"No JSON data received.\")         return jsonify({\"message\": \"No JSON data received\", \"status\": \"error\"}), 400      logging.info(\"Data processed successfully.\")     return jsonify({\"message\": \"Data received successfully!\", \"status\": \"success\", \"data\": data}), 200 except Exception as e:     logging.error(f\"Unexpected error: {str(e)}\")     return jsonify({\"message\": \"Internal server error\", \"status\": \"error\"}), 500  if name == 'main': print(f\"Loaded SECRET_KEY from .env: {SECRET_KEY}\") app.run(debug=True) Use the following Postman setup to send a POST request: URL: http://127.0.0.1:5000/api/save Method: POST Headers: SECRET_KEY: mflow1546 Content-Type: application/json Body (raw, JSON): { \"key\": \"your_key_value\", \"content\": \"This is a valid request\", \"title\": \"Sample Title\" } Alternatively, use the following PowerShell script to send the request: $headers = @{ \"SECRET_KEY\" = \"mflow1546\" \"Content-Type\" = \"application/json\" } $body = @\" { \"key\": \"your_key_value\", \"content\": \"This is a valid request\", \"title\": \"Sample Title\" } \"@ Invoke-RestMethod -Uri \"http://127.0.0.1:5000/api/save\" -Method POST -Headers $headers -Body $body Expected Behavior: The Flask server should receive the SECRET_KEY header correctly. The request should pass validation and return a 200 OK response with the message \"Data received successfully!\". Actual Behavior: The SECRET_KEY received by the server is always None (as logged by the Received SECRET_KEY log). The server consistently responds with a 403 Invalid SECRET_KEY error. Debugging Steps Tried: Verified the .env file is correctly loaded (the correct SECRET_KEY is printed at startup). Ensured the headers in Postman and PowerShell are set properly. Logged all headers received by the Flask server (custom headers like SECRET_KEY are not present). Used Flask-CORS with allow_headers=[\"Content-Type\", \"SECRET_KEY\"]. Tested with different HTTP clients (Postman, PowerShell, Python requests). Logs: Flask Server Logs: Loaded SECRET_KEY from .env: mflow1546 Loaded SECRET_KEY: mflow1546 2024-12-22 08:21:18,527 WARNING:  * Debugger is active! 2024-12-22 08:21:18,530 INFO:  * Debugger PIN: 181-191-701 2024-12-22 08:12:30,764 DEBUG: All Headers: {'Content-Type': 'application/json', 'User-Agent': 'PostmanRuntime/7.43.0', 'Accept': '/', 'Cache-Control': 'no-cache', 'Postman-Token': 'ff45eb20-073b-43d5-8d99-4c474bbe7ff0', 'Host': '127.0.0.1:5000', 'Accept-Encoding': 'gzip, deflate, br', 'Connection': 'keep-alive', 'Content-Length': '110'} 2024-12-22 08:12:30,765 DEBUG: Received SECRET_KEY: None 2024-12-22 08:12:30,766 ERROR: Invalid SECRET_KEY in request. Questions: Why is the SECRET_KEY header missing from the received headers? Is there an issue with Flask-CORS or how Flask processes custom headers? Are there additional configurations required to properly receive custom headers in Flask? Thank you for your time and assistance!", "gold_terms": ["wrolen", "aren", "configuring", "properly", "are", "only", "allowing", "headers", "for", "app", "resources", "api", "origins", "supports_credentials", "allow_headers", "need", "the", "wildcards", "cors", "settings"], "results": [{"rank": 1, "score": 0.5412136316299438, "raw_score": 0.5412136316299438, "source": "flask", "row": 332, "chunk_id": "483562af31495ad3bb3f913971f9167782c08c61", "symbol_type": "method", "qualname": "SecureCookieSessionInterface.get_signing_serializer", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sessions.py", "start_line": 317, "end_line": 335}, {"rank": 2, "score": 0.5360754132270813, "raw_score": 0.5360754132270813, "source": "docs", "row": 394, "chunk_id": "12436a2ed1924123a36381e9296f5d2ab3e27074", "symbol_type": "doc", "qualname": "web-security.rst#Set-Cookie options", "file_path": "d:\\499\\docs\\web-security.rst", "start_line": 213, "end_line": 270}, {"rank": 3, "score": 0.5269429087638855, "raw_score": 0.5269429087638855, "source": "docs", "row": 16, "chunk_id": "d07f4fc95e5d6d972eea01c5fce8b381d03741dd", "symbol_type": "doc", "qualname": "api.rst#Useful Internals", "file_path": "d:\\499\\docs\\api.rst", "start_line": 291, "end_line": 322}, {"rank": 4, "score": 0.5223144888877869, "raw_score": 0.5223144888877869, "source": "flask", "row": 117, "chunk_id": "45e39c75627746e8d351af755ae300aeba86c26a", "symbol_type": "method", "qualname": "RequestContext.__init__", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\ctx.py", "start_line": 309, "end_line": 335}, {"rank": 5, "score": 0.518725574016571, "raw_score": 0.518725574016571, "source": "docs", "row": 388, "chunk_id": "3b4316b221219dcb0f5833e0f637b574de66c1b1", "symbol_type": "doc", "qualname": "web-security.rst#JSON Security", "file_path": "d:\\499\\docs\\web-security.rst", "start_line": 141, "end_line": 151}, {"rank": 6, "score": 0.5174591541290283, "raw_score": 0.5174591541290283, "source": "docs", "row": 221, "chunk_id": "9138ab7d0f126b83befa9c5d2ed02660763cae13", "symbol_type": "doc", "qualname": "patterns\\javascript.rst#Receiving JSON in Views", "file_path": "d:\\499\\docs\\patterns\\javascript.rst", "start_line": 244, "end_line": 261}, {"rank": 7, "score": 0.514724612236023, "raw_score": 0.514724612236023, "source": "docs", "row": 5, "chunk_id": "8ba361a240d1982b668a83f8eeff69174b353f72", "symbol_type": "doc", "qualname": "api.rst#Sessions", "file_path": "d:\\499\\docs\\api.rst", "start_line": 54, "end_line": 90}, {"rank": 8, "score": 0.5083693265914917, "raw_score": 0.5083693265914917, "source": "docs", "row": 285, "chunk_id": "a40424ac744b8ce63e6fd2e158f036a550e94031", "symbol_type": "doc", "qualname": "quickstart.rst#Sessions", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 722, "end_line": 781}, {"rank": 9, "score": 0.5010255575180054, "raw_score": 0.5010255575180054, "source": "docs", "row": 389, "chunk_id": "f7ec71927ecf5908bb1002715dd574088d9548dc", "symbol_type": "doc", "qualname": "web-security.rst#Security Headers", "file_path": "d:\\499\\docs\\web-security.rst", "start_line": 154, "end_line": 161}, {"rank": 10, "score": 0.49799951910972595, "raw_score": 0.49799951910972595, "source": "docs", "row": 342, "chunk_id": "0dd7350ba6ee78a419bd1df973140130572dcc64", "symbol_type": "doc", "qualname": "tutorial\\deploy.rst#Configure the Secret Key", "file_path": "d:\\499\\docs\\tutorial\\deploy.rst", "start_line": 52, "end_line": 77}]}
{"query": "app.run(debug=True)，会导致flask_sqlalchemy错误! 开启debug模式后，debug=Ture的时候，flask_sqlalchemy的with self.app.app_context()会重复执行。 例如我写入一条数据 {user:\"123\",name:\"youname\"}, 在debug模式下 with self.app.app_context() 会执行完写入完毕后，会重新执行一次，导致程序退出，提示重复写入！ 我以为是我代码问题，我检查了无数次，都无法找到我代码问题，最后关闭debug模式后，就可以正常使用。 复现办法： app.py: app.run(debug=True) model.py： pass userdb.py: with self.app.app_context(): new_user = userdbmodel(userdb)(user='11eee', name=input(\"input\") ) userdb.session.add(new_user) userdb.session.commit() 会出现两次input输入，之后会提示重复后程序停止。 目前只要把app.run(debug=True)改为app.run(debug=False)，例如： app.py: app.run(debug=False) 就只会执行一次，不会报错。", "mode": "nl", "used_query": "app.run(debug=True)，会导致flask_sqlalchemy错误! 开启debug模式后，debug=Ture的时候，flask_sqlalchemy的with self.app.app_context()会重复执行。 例如我写入一条数据 {user:\"123\",name:\"youname\"}, 在debug模式下 with self.app.app_context() 会执行完写入完毕后，会重新执行一次，导致程序退出，提示重复写入！ 我以为是我代码问题，我检查了无数次，都无法找到我代码问题，最后关闭debug模式后，就可以正常使用。 复现办法： app.py: app.run(debug=True) model.py： pass userdb.py: with self.app.app_context(): new_user = userdbmodel(userdb)(user='11eee', name=input(\"input\") ) userdb.session.add(new_user) userdb.session.commit() 会出现两次input输入，之后会提示重复后程序停止。 目前只要把app.run(debug=True)改为app.run(debug=False)，例如： app.py: app.run(debug=False) 就只会执行一次，不会报错。", "gold_terms": ["davidism", "asking", "why", "code", "running", "twice", "using", "the", "debugger", "runs", "reloader", "reloads", "very", "start", "set", "things", "executes", "reloaded", "and", "again"], "results": [{"rank": 1, "score": 0.6125771999359131, "raw_score": 0.6125771999359131, "source": "docs", "row": 239, "chunk_id": "9ee9e4ace90f971332a02c54d36ef9570ba774b9", "symbol_type": "doc", "qualname": "patterns\\sqlalchemy.rst#SQLAlchemy in Flask", "file_path": "d:\\499\\docs\\patterns\\sqlalchemy.rst", "start_line": 2, "end_line": 10}, {"rank": 2, "score": 0.6003382802009583, "raw_score": 0.6003382802009583, "source": "docs", "row": 241, "chunk_id": "acaffd0fc1aa4a14ec5eb8f40061bf0aa19e0eaa", "symbol_type": "doc", "qualname": "patterns\\sqlalchemy.rst#Declarative", "file_path": "d:\\499\\docs\\patterns\\sqlalchemy.rst", "start_line": 27, "end_line": 109}, {"rank": 3, "score": 0.5791209936141968, "raw_score": 0.5791209936141968, "source": "docs", "row": 189, "chunk_id": "6dabd0f5877ab25d406e418250a1ad64dd69c2c9", "symbol_type": "doc", "qualname": "patterns\\appfactories.rst#Factories & Extensions", "file_path": "d:\\499\\docs\\patterns\\appfactories.rst", "start_line": 56, "end_line": 85}, {"rank": 4, "score": 0.5719912052154541, "raw_score": 0.5719912052154541, "source": "docs", "row": 338, "chunk_id": "08484c2fb1736ce49318a044debe3fc94049cc3e", "symbol_type": "doc", "qualname": "tutorial\\database.rst#Register with the Application", "file_path": "d:\\499\\docs\\tutorial\\database.rst", "start_line": 157, "end_line": 193}, {"rank": 5, "score": 0.5650843381881714, "raw_score": 0.5650843381881714, "source": "docs", "row": 243, "chunk_id": "07373a40eeb008464228a5bb05b6b5a9cdeabe48", "symbol_type": "doc", "qualname": "patterns\\sqlalchemy.rst#SQL Abstraction Layer", "file_path": "d:\\499\\docs\\patterns\\sqlalchemy.rst", "start_line": 170, "end_line": 213}, {"rank": 6, "score": 0.5582318305969238, "raw_score": 0.5582318305969238, "source": "docs", "row": 365, "chunk_id": "d7d6da3e2b60989b4936bdd5bdeafc792a4a392a", "symbol_type": "doc", "qualname": "tutorial\\tests.rst#Database", "file_path": "d:\\499\\docs\\tutorial\\tests.rst", "start_line": 168, "end_line": 215}, {"rank": 7, "score": 0.5531530380249023, "raw_score": 0.5531530380249023, "source": "flask", "row": 51, "chunk_id": "bb8b373c6e3748c380c1afe8fda418f0c16084d3", "symbol_type": "method", "qualname": "ScriptInfo.__init__", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\cli.py", "start_line": 305, "end_line": 331}, {"rank": 8, "score": 0.5530952215194702, "raw_score": 0.5530952215194702, "source": "docs", "row": 24, "chunk_id": "a7e5533b3cf46084f6b873b7cb5cd524bd3b4a79", "symbol_type": "doc", "qualname": "appcontext.rst#Context During Setup", "file_path": "d:\\499\\docs\\appcontext.rst", "start_line": 43, "end_line": 73}, {"rank": 9, "score": 0.547048032283783, "raw_score": 0.547048032283783, "source": "docs", "row": 242, "chunk_id": "439e536ee72d657e02d5be217d9ba5ef516417eb", "symbol_type": "doc", "qualname": "patterns\\sqlalchemy.rst#Manual Object Relational Mapping", "file_path": "d:\\499\\docs\\patterns\\sqlalchemy.rst", "start_line": 112, "end_line": 167}, {"rank": 10, "score": 0.5454392433166504, "raw_score": 0.5454392433166504, "source": "flask", "row": 31, "chunk_id": "9bf3192f1f49ac3d73bdd359b5b56bbc8e4f3c30", "symbol_type": "method", "qualname": "Flask.app_context", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 1386, "end_line": 1405}]}
{"query": "using git submodule in flask From my main flask app.py I call a function in a file foo.py inside a git submodule. Starting flask fails sind it does not understand the imports there. I tried this workaround adding the git submodule folder to sys.path but didn't succeed. ├── app.py ├── git_submodule/ │   ├── foo.py │   ├── some_module/ What is the correct way to make the imports in git submodule accessable to flask?", "mode": "nl", "used_query": "using git submodule in flask From my main flask app.py I call a function in a file foo.py inside a git submodule. Starting flask fails sind it does not understand the imports there. I tried this workaround adding the git submodule folder to sys.path but didn't succeed. ├── app.py ├── git_submodule/ │   ├── foo.py │   ├── some_module/ What is the correct way to make the imports in git submodule accessable to flask?", "gold_terms": ["works", "sys", "path", "append", "don", "befoere", "imports"], "results": [{"rank": 1, "score": 0.6006091237068176, "raw_score": 0.6006091237068176, "source": "docs", "row": 352, "chunk_id": "4f6f18eb975bb6684f3b923ac07eff784b69aa35", "symbol_type": "doc", "qualname": "tutorial\\layout.rst#Project Layout", "file_path": "d:\\499\\docs\\tutorial\\layout.rst", "start_line": 2, "end_line": 110}, {"rank": 2, "score": 0.5885114669799805, "raw_score": 0.5885114669799805, "source": "docs", "row": 55, "chunk_id": "6edb5f466b19c2b87bfbdac87279b61cc31f58cc", "symbol_type": "doc", "qualname": "cli.rst#Open a Shell", "file_path": "d:\\499\\docs\\cli.rst", "start_line": 134, "end_line": 149}, {"rank": 3, "score": 0.5865899324417114, "raw_score": 0.5865899324417114, "source": "docs", "row": 75, "chunk_id": "173ccf506b3f5597139062640eea4df89584758f", "symbol_type": "doc", "qualname": "config.rst#Instance Folders", "file_path": "d:\\499\\docs\\config.rst", "start_line": 761, "end_line": 839}, {"rank": 4, "score": 0.5771213173866272, "raw_score": 0.5771213173866272, "source": "docs", "row": 138, "chunk_id": "257993a06c3a4d454dfd31af7d0ee58bc6e4a38a", "symbol_type": "doc", "qualname": "extensiondev.rst#Naming", "file_path": "d:\\499\\docs\\extensiondev.rst", "start_line": 26, "end_line": 46}, {"rank": 5, "score": 0.5698354244232178, "raw_score": 0.5698354244232178, "source": "docs", "row": 24, "chunk_id": "a7e5533b3cf46084f6b873b7cb5cd524bd3b4a79", "symbol_type": "doc", "qualname": "appcontext.rst#Context During Setup", "file_path": "d:\\499\\docs\\appcontext.rst", "start_line": 43, "end_line": 73}, {"rank": 6, "score": 0.5647768974304199, "raw_score": 0.5647768974304199, "source": "docs", "row": 189, "chunk_id": "6dabd0f5877ab25d406e418250a1ad64dd69c2c9", "symbol_type": "doc", "qualname": "patterns\\appfactories.rst#Factories & Extensions", "file_path": "d:\\499\\docs\\patterns\\appfactories.rst", "start_line": 56, "end_line": 85}, {"rank": 7, "score": 0.5641615986824036, "raw_score": 0.5641615986824036, "source": "docs", "row": 51, "chunk_id": "e70abab06484e05cc134f1a519904fa4c4b70dc5", "symbol_type": "doc", "qualname": "cli.rst#Application Discovery", "file_path": "d:\\499\\docs\\cli.rst", "start_line": 15, "end_line": 66}, {"rank": 8, "score": 0.5619968771934509, "raw_score": 0.5619968771934509, "source": "docs", "row": 346, "chunk_id": "06a360c3a3f9fe167724889a64648e5b26c3a559", "symbol_type": "doc", "qualname": "tutorial\\factory.rst#The Application Factory", "file_path": "d:\\499\\docs\\tutorial\\factory.rst", "start_line": 24, "end_line": 123}, {"rank": 9, "score": 0.5613633394241333, "raw_score": 0.5613633394241333, "source": "docs", "row": 147, "chunk_id": "fb5a75c02eb2abf68d21ce7fb7f71f7fb574f6fc", "symbol_type": "doc", "qualname": "extensions.rst#Using Extensions", "file_path": "d:\\499\\docs\\extensions.rst", "start_line": 18, "end_line": 37}, {"rank": 10, "score": 0.5585544109344482, "raw_score": 0.5585544109344482, "source": "docs", "row": 169, "chunk_id": "daa76bb80df5703fdefee189eac6329ad4a5a22d", "symbol_type": "doc", "qualname": "lifecycle.rst#Application Setup", "file_path": "d:\\499\\docs\\lifecycle.rst", "start_line": 11, "end_line": 62}]}
{"query": "I am using flask cli. How to callback after run() function? Literaturly, How??? flask cli take over the __main__. How am I supposed to run something that needs the main guard?", "mode": "nl", "used_query": "I am using flask cli. How to callback after run() function? Literaturly, How??? flask cli take over the __main__. How am I supposed to run something that needs the main guard?", "gold_terms": ["you", "elaborate", "what", "the", "intent", "code", "theres", "multiple", "approaches"], "results": [{"rank": 1, "score": 0.6079851984977722, "raw_score": 0.6079851984977722, "source": "flask", "row": 65, "chunk_id": "f2086f01c303d1474f7c26c4de4301b78ef2e06b", "symbol_type": "method", "qualname": "FlaskGroup.make_context", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\cli.py", "start_line": 665, "end_line": 684}, {"rank": 2, "score": 0.6032346487045288, "raw_score": 0.6032346487045288, "source": "flask", "row": 14, "chunk_id": "9f5f231ea03e1260df1c33a2812e08d4afc79a5b", "symbol_type": "method", "qualname": "Flask.test_cli_runner", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 727, "end_line": 742}, {"rank": 3, "score": 0.5988828539848328, "raw_score": 0.5988828539848328, "source": "flask", "row": 363, "chunk_id": "d953e53c02d8d7f47535682b641a916c4f81864c", "symbol_type": "class", "qualname": "FlaskCliRunner", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\testing.py", "start_line": 265, "end_line": 298}, {"rank": 4, "score": 0.5953506231307983, "raw_score": 0.5953506231307983, "source": "docs", "row": 62, "chunk_id": "81a3de023132aa6f8235dd56296f587e56fbcb6a", "symbol_type": "doc", "qualname": "cli.rst#Application Context", "file_path": "d:\\499\\docs\\cli.rst", "start_line": 422, "end_line": 442}, {"rank": 5, "score": 0.5798280239105225, "raw_score": 0.5798280239105225, "source": "flask", "row": 60, "chunk_id": "44475fae39f2c155f96c193b31bd7f9dbd0df3a3", "symbol_type": "class", "qualname": "FlaskGroup", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\cli.py", "start_line": 531, "end_line": 696}, {"rank": 6, "score": 0.5765348672866821, "raw_score": 0.5765348672866821, "source": "docs", "row": 325, "chunk_id": "de3bf1e0df018e0277079a6c6d691240f3ff46d5", "symbol_type": "doc", "qualname": "testing.rst#Running Commands with the CLI Runner", "file_path": "d:\\499\\docs\\testing.rst", "start_line": 246, "end_line": 273}, {"rank": 7, "score": 0.5625253915786743, "raw_score": 0.5625253915786743, "source": "flask", "row": 61, "chunk_id": "f40c9cc5dee89ab28ce3395baad7640e7d9cfe4b", "symbol_type": "method", "qualname": "FlaskGroup.__init__", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\cli.py", "start_line": 563, "end_line": 598}, {"rank": 8, "score": 0.5584413409233093, "raw_score": 0.5584413409233093, "source": "docs", "row": 53, "chunk_id": "7c6057c887265c80ccd7b81330d1dd730a8f2eab", "symbol_type": "doc", "qualname": "cli.rst#Debug Mode", "file_path": "d:\\499\\docs\\cli.rst", "start_line": 90, "end_line": 113}, {"rank": 9, "score": 0.5559189319610596, "raw_score": 0.5559189319610596, "source": "flask", "row": 12, "chunk_id": "05922660b6467436642c226aee8c17caea5fb6b3", "symbol_type": "method", "qualname": "Flask.run", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 546, "end_line": 667}, {"rank": 10, "score": 0.5551937222480774, "raw_score": 0.5551937222480774, "source": "docs", "row": 63, "chunk_id": "c486fde108ee93e6e175a8b561ec5d0aedf63679", "symbol_type": "doc", "qualname": "cli.rst#Plugins", "file_path": "d:\\499\\docs\\cli.rst", "start_line": 445, "end_line": 471}]}
{"query": "\"flask create-app app-name\" script I created a script called create-app. It can be used by running flask \"create-app demo-name\" in the terminal. It creates a simple react app with following directory structure: static ├───css ├───img └───js templates app.py config.py .gitignore README.md requirements.txt templates folder has index.html file and css folder has index.css file in it. app.py simply renders index.html. this script also initialises git. It will be a very nice way of setting up flask apps by a single command. I want to contribute this to official flask repo. How can I do that?", "mode": "nl", "used_query": "\"flask create-app app-name\" script I created a script called create-app. It can be used by running flask \"create-app demo-name\" in the terminal. It creates a simple react app with following directory structure: static ├───css ├───img └───js templates app.py config.py .gitignore README.md requirements.txt templates folder has index.html file and css folder has index.css file in it. app.py simply renders index.html. this script also initialises git. It will be a very nice way of setting up flask apps by a single command. I want to contribute this to official flask repo. How can I do that?", "gold_terms": ["tombohub", "how", "use", "script", "might", "fit", "better", "extension"], "results": [{"rank": 1, "score": 0.6365951299667358, "raw_score": 0.6365951299667358, "source": "docs", "row": 51, "chunk_id": "e70abab06484e05cc134f1a519904fa4c4b70dc5", "symbol_type": "doc", "qualname": "cli.rst#Application Discovery", "file_path": "d:\\499\\docs\\cli.rst", "start_line": 15, "end_line": 66}, {"rank": 2, "score": 0.6101025938987732, "raw_score": 0.6101025938987732, "source": "docs", "row": 352, "chunk_id": "4f6f18eb975bb6684f3b923ac07eff784b69aa35", "symbol_type": "doc", "qualname": "tutorial\\layout.rst#Project Layout", "file_path": "d:\\499\\docs\\tutorial\\layout.rst", "start_line": 2, "end_line": 110}, {"rank": 3, "score": 0.6051809787750244, "raw_score": 0.6051809787750244, "source": "docs", "row": 290, "chunk_id": "ee45d5f39a617a698ea1c65b8963ce9274952b48", "symbol_type": "doc", "qualname": "quickstart.rst#Deploying to a Web Server", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 856, "end_line": 858}, {"rank": 4, "score": 0.588436484336853, "raw_score": 0.588436484336853, "source": "flask", "row": 60, "chunk_id": "44475fae39f2c155f96c193b31bd7f9dbd0df3a3", "symbol_type": "class", "qualname": "FlaskGroup", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\cli.py", "start_line": 531, "end_line": 696}, {"rank": 5, "score": 0.5828291773796082, "raw_score": 0.5828291773796082, "source": "docs", "row": 190, "chunk_id": "35f326cbb96d9c9443fbf2f2b0fb84da93d3b9d1", "symbol_type": "doc", "qualname": "patterns\\appfactories.rst#Using Applications", "file_path": "d:\\499\\docs\\patterns\\appfactories.rst", "start_line": 88, "end_line": 105}, {"rank": 6, "score": 0.5761294364929199, "raw_score": 0.5761294364929199, "source": "docs", "row": 277, "chunk_id": "93490046e7d94f1c2e3315710787da5a5f8d27ba", "symbol_type": "doc", "qualname": "quickstart.rst#Static Files", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 336, "end_line": 348}, {"rank": 7, "score": 0.5748208165168762, "raw_score": 0.5748208165168762, "source": "flask", "row": 77, "chunk_id": "f0dde381d95fcbecd4ead09fb2ca6d8b93472b9c", "symbol_type": "function", "qualname": "shell_command", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\cli.py", "start_line": 1009, "end_line": 1053}, {"rank": 8, "score": 0.566639244556427, "raw_score": 0.566639244556427, "source": "docs", "row": 60, "chunk_id": "616117def12060892cb103439569db5c076f8226", "symbol_type": "doc", "qualname": "cli.rst#Custom Commands", "file_path": "d:\\499\\docs\\cli.rst", "start_line": 319, "end_line": 364}, {"rank": 9, "score": 0.5657206773757935, "raw_score": 0.5657206773757935, "source": "docs", "row": 346, "chunk_id": "06a360c3a3f9fe167724889a64648e5b26c3a559", "symbol_type": "doc", "qualname": "tutorial\\factory.rst#The Application Factory", "file_path": "d:\\499\\docs\\tutorial\\factory.rst", "start_line": 24, "end_line": 123}, {"rank": 10, "score": 0.5656130909919739, "raw_score": 0.5656130909919739, "source": "docs", "row": 64, "chunk_id": "25582660e1c7aabebeb8c2d347cbe87c772a0465", "symbol_type": "doc", "qualname": "cli.rst#Custom Scripts", "file_path": "d:\\499\\docs\\cli.rst", "start_line": 474, "end_line": 519}]}
{"query": "Stream response with AsyncGenerator I would need to stream data to the user via an endpoint through a function that returns an AsyncGenerator The idea is as follows: message_route = Blueprint('message_route', __name__, template_folder='templates')  @message_route.route('/message/<string:key>/<string:chat_uuid>', methods=['POST']) async def message(key, chat_uuid):         # [...] Other endpoint logic not helpful in resolving the issue      async def event_stream():         agent_handler = agent.run(input=content['message'])          # stream_events() return an AsyncGenerator[Event, None], so async is necessary         async for ev in agent_handler.stream_events():             if isinstance(ev, MessageOutputEvent):                 print(ev.message)                 yield ev.message         # wait for the process to finish before continuing         response = await agent_handler         print(response)      resp = make_response(event_stream())     resp.mimetype = \"text/event-stream\"     resp.set_cookie(key='user_uuid', samesite=\"none\", value=\"user_123\")     return resp, 200 To be able to handle requests with async/await I installed flask[async] (3.0.3) but when I add async to the message() function I get the error: TypeError: The view function did not return a valid response. The return type must be a string, dict, list, tuple with headers or status, Response instance, or WSGI callable, but it was a coroutine.", "mode": "nl", "used_query": "Stream response with AsyncGenerator I would need to stream data to the user via an endpoint through a function that returns an AsyncGenerator The idea is as follows: message_route = Blueprint('message_route', __name__, template_folder='templates')  @message_route.route('/message/<string:key>/<string:chat_uuid>', methods=['POST']) async def message(key, chat_uuid):         # [...] Other endpoint logic not helpful in resolving the issue      async def event_stream():         agent_handler = agent.run(input=content['message'])          # stream_events() return an AsyncGenerator[Event, None], so async is necessary         async for ev in agent_handler.stream_events():             if isinstance(ev, MessageOutputEvent):                 print(ev.message)                 yield ev.message         # wait for the process to finish before continuing         response = await agent_handler         print(response)      resp = make_response(event_stream())     resp.mimetype = \"text/event-stream\"     resp.set_cookie(key='user_uuid', samesite=\"none\", value=\"user_123\")     return resp, 200 To be able to handle requests with async/await I installed flask[async] (3.0.3) but when I add async to the message() function I get the error: TypeError: The view function did not return a valid response. The return type must be a string, dict, list, tuple with headers or status, Response instance, or WSGI callable, but it was a coroutine.", "gold_terms": ["any", "progress", "regarding", "issue", "encountered", "similar", "problem", "trying", "integrate", "the", "asynchronous", "streaming", "agent", "execution", "pydantic", "through", "version", "flask", "middleware", "caught"], "results": [{"rank": 1, "score": 0.6260108947753906, "raw_score": 0.6260108947753906, "source": "flask", "row": 348, "chunk_id": "3defb03b0e6e84e48d3cf3c615eb1374473097e7", "symbol_type": "function", "qualname": "_stream", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\templating.py", "start_line": 165, "end_line": 185}, {"rank": 2, "score": 0.5488430261611938, "raw_score": 0.5488430261611938, "source": "flask", "row": 138, "chunk_id": "98cf1787ccc0088c9211d12092cafa8790ca73d9", "symbol_type": "function", "qualname": "stream_with_context", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\helpers.py", "start_line": 63, "end_line": 143}, {"rank": 3, "score": 0.5330168008804321, "raw_score": 0.5330168008804321, "source": "docs", "row": 251, "chunk_id": "ddbffa9459d587f5a13ebae00a904a92aee9de6a", "symbol_type": "doc", "qualname": "patterns\\streaming.rst#Streaming with Context", "file_path": "d:\\499\\docs\\patterns\\streaming.rst", "start_line": 50, "end_line": 85}, {"rank": 4, "score": 0.5147573351860046, "raw_score": 0.5147573351860046, "source": "flask", "row": 144, "chunk_id": "51a4404ca5f792b054cd5564fe5fc5dae14aad34", "symbol_type": "function", "qualname": "flash", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\helpers.py", "start_line": 318, "end_line": 349}, {"rank": 5, "score": 0.5143148899078369, "raw_score": 0.5143148899078369, "source": "flask", "row": 136, "chunk_id": "ab3362ef784a2103493ebc982480d5943ff59021", "symbol_type": "function", "qualname": "stream_with_context", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\helpers.py", "start_line": 52, "end_line": 54}, {"rank": 6, "score": 0.49329450726509094, "raw_score": 0.49329450726509094, "source": "flask", "row": 137, "chunk_id": "b899b395a8f94217728fb14982a9303d65afd033", "symbol_type": "function", "qualname": "stream_with_context", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\helpers.py", "start_line": 58, "end_line": 60}, {"rank": 7, "score": 0.4787837266921997, "raw_score": 0.4787837266921997, "source": "docs", "row": 33, "chunk_id": "ac56dbb89b157e864d8da212992c8453a27e9186", "symbol_type": "doc", "qualname": "async-await.rst#When to use Quart instead", "file_path": "d:\\499\\docs\\async-await.rst", "start_line": 66, "end_line": 84}, {"rank": 8, "score": 0.47836777567863464, "raw_score": 0.47836777567863464, "source": "docs", "row": 149, "chunk_id": "f46211c4e8bc19b3e2f696667dca6611056d8a30", "symbol_type": "doc", "qualname": "gevent.rst#Async with Gevent", "file_path": "d:\\499\\docs\\gevent.rst", "start_line": 2, "end_line": 20}, {"rank": 9, "score": 0.474399209022522, "raw_score": 0.474399209022522, "source": "flask", "row": 350, "chunk_id": "14bbe26bff41faa5b46f4738dedfb0f1d56b2878", "symbol_type": "function", "qualname": "stream_template_string", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\templating.py", "start_line": 207, "end_line": 219}, {"rank": 10, "score": 0.4740179777145386, "raw_score": 0.4740179777145386, "source": "docs", "row": 17, "chunk_id": "975a14e5adcd8a15b4fc0e5b9ccfc04b4328b391", "symbol_type": "doc", "qualname": "api.rst#Signals", "file_path": "d:\\499\\docs\\api.rst", "start_line": 325, "end_line": 512}]}
{"query": "Flask+HTML autocomplete extensions for VS Code Greetings, Are there VS Code extensions that enable autocomplete for Flask+HTML? For example, when typing {% it turns into {% %}.", "mode": "nl", "used_query": "Flask+HTML autocomplete extensions for VS Code Greetings, Are there VS Code extensions that enable autocomplete for Flask+HTML? For example, when typing {% it turns into {% %}.", "gold_terms": ["what", "you", "looking", "for", "https", "marketplace", "visualstudio", "com", "items", "sugatoray", "jinja", "extension", "pack"], "results": [{"rank": 1, "score": 0.565690279006958, "raw_score": 0.565690279006958, "source": "docs", "row": 311, "chunk_id": "6987818864195d742dc774c64b512a4f95692813", "symbol_type": "doc", "qualname": "templating.rst#Jinja Setup", "file_path": "d:\\499\\docs\\templating.rst", "start_line": 16, "end_line": 29}, {"rank": 2, "score": 0.545832097530365, "raw_score": 0.545832097530365, "source": "docs", "row": 278, "chunk_id": "41660faaae172031611b75193e99aa002ba35d76", "symbol_type": "doc", "qualname": "quickstart.rst#Rendering Templates", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 351, "end_line": 447}, {"rank": 3, "score": 0.517117440700531, "raw_score": 0.517117440700531, "source": "docs", "row": 310, "chunk_id": "0b6ba4a4a2cdacee407fe0ce504b1008b71f20ce", "symbol_type": "doc", "qualname": "templating.rst#Templates", "file_path": "d:\\499\\docs\\templating.rst", "start_line": 2, "end_line": 13}, {"rank": 4, "score": 0.5087774991989136, "raw_score": 0.5087774991989136, "source": "docs", "row": 146, "chunk_id": "e6dc11aaecde9953053fb9e5ee4306d1d334519c", "symbol_type": "doc", "qualname": "extensions.rst#Finding Extensions", "file_path": "d:\\499\\docs\\extensions.rst", "start_line": 11, "end_line": 15}, {"rank": 5, "score": 0.48933884501457214, "raw_score": 0.48933884501457214, "source": "docs", "row": 271, "chunk_id": "3f4c35aa993725f9557f7ebf3271d1976f552b91", "symbol_type": "doc", "qualname": "quickstart.rst#HTML Escaping", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 129, "end_line": 152}, {"rank": 6, "score": 0.48700135946273804, "raw_score": 0.48700135946273804, "source": "docs", "row": 148, "chunk_id": "a04c0a04bc1ac6e10978cf3766ff077fe76a44c8", "symbol_type": "doc", "qualname": "extensions.rst#Building Extensions", "file_path": "d:\\499\\docs\\extensions.rst", "start_line": 40, "end_line": 48}, {"rank": 7, "score": 0.4752502739429474, "raw_score": 0.4752502739429474, "source": "docs", "row": 354, "chunk_id": "09f2063148c97d1cdf912b67e659b2c14a850b37", "symbol_type": "doc", "qualname": "tutorial\\static.rst#Static Files", "file_path": "d:\\499\\docs\\tutorial\\static.rst", "start_line": 2, "end_line": 72}, {"rank": 8, "score": 0.472882479429245, "raw_score": 0.472882479429245, "source": "docs", "row": 160, "chunk_id": "baa43f83a648d830e935b5d02b8c0fe11e43fb09", "symbol_type": "doc", "qualname": "installation.rst#Dependencies", "file_path": "d:\\499\\docs\\installation.rst", "start_line": 12, "end_line": 34}, {"rank": 9, "score": 0.46880626678466797, "raw_score": 0.46880626678466797, "source": "docs", "row": 356, "chunk_id": "27158e3239abec0913fc276b7dee2b604593c5b8", "symbol_type": "doc", "qualname": "tutorial\\templates.rst#Templates", "file_path": "d:\\499\\docs\\tutorial\\templates.rst", "start_line": 4, "end_line": 36}, {"rank": 10, "score": 0.4668431878089905, "raw_score": 0.4668431878089905, "source": "docs", "row": 154, "chunk_id": "5c61764df1218c3aa441416b0c8c6f78df40f6f8", "symbol_type": "doc", "qualname": "index.rst#Welcome to Flask", "file_path": "d:\\499\\docs\\index.rst", "start_line": 4, "end_line": 29}]}
{"query": "Error: No such command 'db'. OJ.zip (onlinejudge_env) kimi@KimideMacBook-Air OJ % flask db init  Error: While importing 'run', an ImportError was raised:  Traceback (most recent call last):   File \"/Users/kimi/OJ/onlinejudge_env/lib/python3.9/site-packages/flask/cli.py\", line 218, in locate_app     __import__(module_name)   File \"/Users/kimi/OJ/run.py\", line 3, in <module>     app = create_app()   File \"/Users/kimi/OJ/app/__init__.py\", line 25, in create_app     from app.auth import auth as auth_blueprint   File \"/Users/kimi/OJ/app/auth.py\", line 6, in <module>     from werkzeug.urls import url_parse ImportError: cannot import name 'url_parse' from 'werkzeug.urls' (/Users/kimi/OJ/onlinejudge_env/lib/python3.9/site-packages/werkzeug/urls.py)   Usage: flask [OPTIONS] COMMAND [ARGS]... Try 'flask --help' for help.  Error: No such command 'db'. (onlinejudge_env) kimi@KimideMacBook-Air OJ %", "mode": "nl", "used_query": "Error: No such command 'db'. OJ.zip (onlinejudge_env) kimi@KimideMacBook-Air OJ % flask db init  Error: While importing 'run', an ImportError was raised:  Traceback (most recent call last):   File \"/Users/kimi/OJ/onlinejudge_env/lib/python3.9/site-packages/flask/cli.py\", line 218, in locate_app     __import__(module_name)   File \"/Users/kimi/OJ/run.py\", line 3, in <module>     app = create_app()   File \"/Users/kimi/OJ/app/__init__.py\", line 25, in create_app     from app.auth import auth as auth_blueprint   File \"/Users/kimi/OJ/app/auth.py\", line 6, in <module>     from werkzeug.urls import url_parse ImportError: cannot import name 'url_parse' from 'werkzeug.urls' (/Users/kimi/OJ/onlinejudge_env/lib/python3.9/site-packages/werkzeug/urls.py)   Usage: flask [OPTIONS] COMMAND [ARGS]... Try 'flask --help' for help.  Error: No such command 'db'. (onlinejudge_env) kimi@KimideMacBook-Air OJ %", "gold_terms": ["init", "not", "flask", "commands", "should", "use", "click", "define", "custom", "https", "palletsprojects", "com", "cli", "url_parse", "removed", "werkzeug", "pallets", "urllib", "parse", "instead"], "results": [{"rank": 1, "score": 0.6210645437240601, "raw_score": 0.6210645437240601, "source": "docs", "row": 339, "chunk_id": "401ba5724bea5257891b9c8170605ef473e318ec", "symbol_type": "doc", "qualname": "tutorial\\database.rst#Initialize the Database File", "file_path": "d:\\499\\docs\\tutorial\\database.rst", "start_line": 196, "end_line": 219}, {"rank": 2, "score": 0.593926191329956, "raw_score": 0.593926191329956, "source": "docs", "row": 346, "chunk_id": "06a360c3a3f9fe167724889a64648e5b26c3a559", "symbol_type": "doc", "qualname": "tutorial\\factory.rst#The Application Factory", "file_path": "d:\\499\\docs\\tutorial\\factory.rst", "start_line": 24, "end_line": 123}, {"rank": 3, "score": 0.5867689847946167, "raw_score": 0.5867689847946167, "source": "docs", "row": 51, "chunk_id": "e70abab06484e05cc134f1a519904fa4c4b70dc5", "symbol_type": "doc", "qualname": "cli.rst#Application Discovery", "file_path": "d:\\499\\docs\\cli.rst", "start_line": 15, "end_line": 66}, {"rank": 4, "score": 0.5781375169754028, "raw_score": 0.5781375169754028, "source": "flask", "row": 51, "chunk_id": "bb8b373c6e3748c380c1afe8fda418f0c16084d3", "symbol_type": "method", "qualname": "ScriptInfo.__init__", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\cli.py", "start_line": 305, "end_line": 331}, {"rank": 5, "score": 0.5702256560325623, "raw_score": 0.5702256560325623, "source": "docs", "row": 55, "chunk_id": "6edb5f466b19c2b87bfbdac87279b61cc31f58cc", "symbol_type": "doc", "qualname": "cli.rst#Open a Shell", "file_path": "d:\\499\\docs\\cli.rst", "start_line": 134, "end_line": 149}, {"rank": 6, "score": 0.5693600177764893, "raw_score": 0.5693600177764893, "source": "docs", "row": 24, "chunk_id": "a7e5533b3cf46084f6b873b7cb5cd524bd3b4a79", "symbol_type": "doc", "qualname": "appcontext.rst#Context During Setup", "file_path": "d:\\499\\docs\\appcontext.rst", "start_line": 43, "end_line": 73}, {"rank": 7, "score": 0.567061185836792, "raw_score": 0.567061185836792, "source": "flask", "row": 37, "chunk_id": "efbec523b7e4d3e8df9e1040421353f09b23a59a", "symbol_type": "method", "qualname": "Blueprint.__init__", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\blueprints.py", "start_line": 19, "end_line": 53}, {"rank": 8, "score": 0.5617626905441284, "raw_score": 0.5617626905441284, "source": "docs", "row": 159, "chunk_id": "c916bf2a90d304338adda05defe498d0e1b9b21b", "symbol_type": "doc", "qualname": "installation.rst#Python Version", "file_path": "d:\\499\\docs\\installation.rst", "start_line": 6, "end_line": 9}, {"rank": 9, "score": 0.5596614480018616, "raw_score": 0.5596614480018616, "source": "flask", "row": 48, "chunk_id": "8c4189f9bfae0a6d8b5eb9eb9c1fb1005743727f", "symbol_type": "function", "qualname": "locate_app", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\cli.py", "start_line": 241, "end_line": 264}, {"rank": 10, "score": 0.5587080717086792, "raw_score": 0.5587080717086792, "source": "flask", "row": 5, "chunk_id": "c61715a41cf32cea221bf9769e1846f172e010bf", "symbol_type": "method", "qualname": "Flask.open_resource", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 330, "end_line": 361}]}
{"query": "Question about flask enum field， I've asked various AIs about this issue and nothing has been resolved, here's a request for help my model： class ApprovalStatus(PyEnum):     PENDING = 'pending'     APPROVED = 'approved'     REJECTED = 'rejected'   class Approval(db.Model):     id = db.Column(db.Integer, primary_key=True)     content_type = db.Column(db.String(50), nullable=False)     content_id = db.Column(db.Integer, nullable=False)     field_name = db.Column(db.String(50), nullable=False)     new_value = db.Column(db.Text, nullable=False)     status = db.Column(SQLAlchemyEnum(ApprovalStatus), default=ApprovalStatus.PENDING)      submitter_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)     submit_time = db.Column(db.DateTime, default=current_time)     reviewer_id = db.Column(db.Integer, db.ForeignKey('user.id'))     review_time = db.Column(db.DateTime, default=current_time)     review_comment = db.Column(db.Text)      submitter = db.relationship('User', foreign_keys=[submitter_id])     reviewer = db.relationship('User', foreign_keys=[reviewer_id])      __table_args__ = (UniqueConstraint('content_type', 'content_id'),)      @property     def content(self):         model = getattr(models, self.content_type)         return model.query.get(self.content_id) After running Flask, an error message is displayed. 024-09-09 09:13:05 +0800] [25093] [INFO] Booting worker with pid: 25093 [2024-09-09 09:13:13 +0800] [25093] [ERROR] Error handling request /zend/approval/ Traceback (most recent call last):   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/sql/sqltypes.py\", line 1619, in _object_value_for_elem     return self._object_lookup[elem]            ~~~~~~~~~~~~~~~~~~~^^^^^^ KeyError: 'pending'  The above exception was the direct cause of the following exception:  Traceback (most recent call last):   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/gunicorn/workers/sync.py\", line 134, in handle     self.handle_request(listener, req, client, addr)   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/gunicorn/workers/sync.py\", line 177, in handle_request     respiter = self.wsgi(environ, resp.start_response)                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask/app.py\", line 1498, in __call__     return self.wsgi_app(environ, start_response)            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask/app.py\", line 1476, in wsgi_app     response = self.handle_exception(e)                ^^^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask_cors/extension.py\", line 194, in wrapped_function     return cors_after_request(app.make_response(f(*args, **kwargs)))                                                 ^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask/app.py\", line 1473, in wsgi_app     response = self.full_dispatch_request()                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask/app.py\", line 882, in full_dispatch_request     rv = self.handle_user_exception(e)          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask_cors/extension.py\", line 194, in wrapped_function     return cors_after_request(app.make_response(f(*args, **kwargs)))                                                 ^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask/app.py\", line 880, in full_dispatch_request     rv = self.dispatch_request()          ^^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask/app.py\", line 865, in dispatch_request     return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask_admin/base.py\", line 69, in inner     return self._run_view(f, *args, **kwargs)            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask_admin/base.py\", line 369, in _run_view     return fn(self, *args, **kwargs)            ^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask_admin/model/base.py\", line 1980, in index_view     count, data = self.get_list(view_args.page, sort_column, view_args.sort_desc,                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask_admin/contrib/sqla/view.py\", line 1100, in get_list     query = query.all()             ^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/orm/query.py\", line 2673, in all     return self._iter().all()  # type: ignore            ^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/engine/result.py\", line 1769, in all     return self._allrows()            ^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/engine/result.py\", line 548, in _allrows     rows = self._fetchall_impl()            ^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/engine/result.py\", line 1676, in _fetchall_impl     return self._real_result._fetchall_impl()            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/engine/result.py\", line 2270, in _fetchall_impl     return list(self.iterator)            ^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/orm/loading.py\", line 219, in chunks     fetch = cursor._raw_all_rows()             ^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/engine/result.py\", line 541, in _raw_all_rows     return [make_row(row) for row in rows]            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/engine/result.py\", line 541, in <listcomp>     return [make_row(row) for row in rows]             ^^^^^^^^^^^^^   File \"lib/sqlalchemy/cyextension/resultproxy.pyx\", line 22, in sqlalchemy.cyextension.resultproxy.BaseRow.__init__   File \"lib/sqlalchemy/cyextension/resultproxy.pyx\", line 79, in sqlalchemy.cyextension.resultproxy._apply_processors   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/sql/sqltypes.py\", line 1739, in process     value = self._object_value_for_elem(value)             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/dialects/mysql/enumerated.py\", line 87, in _object_value_for_elem     return super()._object_value_for_elem(elem)            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/sql/sqltypes.py\", line 1621, in _object_value_for_elem     raise LookupError( LookupError: 'pending' is not among the defined enum values. Enum name: approvalstatus. Possible values: PENDING, APPROVED, REJECTED`", "mode": "nl", "used_query": "Question about flask enum field， I've asked various AIs about this issue and nothing has been resolved, here's a request for help my model： class ApprovalStatus(PyEnum):     PENDING = 'pending'     APPROVED = 'approved'     REJECTED = 'rejected'   class Approval(db.Model):     id = db.Column(db.Integer, primary_key=True)     content_type = db.Column(db.String(50), nullable=False)     content_id = db.Column(db.Integer, nullable=False)     field_name = db.Column(db.String(50), nullable=False)     new_value = db.Column(db.Text, nullable=False)     status = db.Column(SQLAlchemyEnum(ApprovalStatus), default=ApprovalStatus.PENDING)      submitter_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)     submit_time = db.Column(db.DateTime, default=current_time)     reviewer_id = db.Column(db.Integer, db.ForeignKey('user.id'))     review_time = db.Column(db.DateTime, default=current_time)     review_comment = db.Column(db.Text)      submitter = db.relationship('User', foreign_keys=[submitter_id])     reviewer = db.relationship('User', foreign_keys=[reviewer_id])      __table_args__ = (UniqueConstraint('content_type', 'content_id'),)      @property     def content(self):         model = getattr(models, self.content_type)         return model.query.get(self.content_id) After running Flask, an error message is displayed. 024-09-09 09:13:05 +0800] [25093] [INFO] Booting worker with pid: 25093 [2024-09-09 09:13:13 +0800] [25093] [ERROR] Error handling request /zend/approval/ Traceback (most recent call last):   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/sql/sqltypes.py\", line 1619, in _object_value_for_elem     return self._object_lookup[elem]            ~~~~~~~~~~~~~~~~~~~^^^^^^ KeyError: 'pending'  The above exception was the direct cause of the following exception:  Traceback (most recent call last):   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/gunicorn/workers/sync.py\", line 134, in handle     self.handle_request(listener, req, client, addr)   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/gunicorn/workers/sync.py\", line 177, in handle_request     respiter = self.wsgi(environ, resp.start_response)                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask/app.py\", line 1498, in __call__     return self.wsgi_app(environ, start_response)            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask/app.py\", line 1476, in wsgi_app     response = self.handle_exception(e)                ^^^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask_cors/extension.py\", line 194, in wrapped_function     return cors_after_request(app.make_response(f(*args, **kwargs)))                                                 ^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask/app.py\", line 1473, in wsgi_app     response = self.full_dispatch_request()                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask/app.py\", line 882, in full_dispatch_request     rv = self.handle_user_exception(e)          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask_cors/extension.py\", line 194, in wrapped_function     return cors_after_request(app.make_response(f(*args, **kwargs)))                                                 ^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask/app.py\", line 880, in full_dispatch_request     rv = self.dispatch_request()          ^^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask/app.py\", line 865, in dispatch_request     return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask_admin/base.py\", line 69, in inner     return self._run_view(f, *args, **kwargs)            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask_admin/base.py\", line 369, in _run_view     return fn(self, *args, **kwargs)            ^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask_admin/model/base.py\", line 1980, in index_view     count, data = self.get_list(view_args.page, sort_column, view_args.sort_desc,                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/flask_admin/contrib/sqla/view.py\", line 1100, in get_list     query = query.all()             ^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/orm/query.py\", line 2673, in all     return self._iter().all()  # type: ignore            ^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/engine/result.py\", line 1769, in all     return self._allrows()            ^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/engine/result.py\", line 548, in _allrows     rows = self._fetchall_impl()            ^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/engine/result.py\", line 1676, in _fetchall_impl     return self._real_result._fetchall_impl()            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/engine/result.py\", line 2270, in _fetchall_impl     return list(self.iterator)            ^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/orm/loading.py\", line 219, in chunks     fetch = cursor._raw_all_rows()             ^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/engine/result.py\", line 541, in _raw_all_rows     return [make_row(row) for row in rows]            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/engine/result.py\", line 541, in <listcomp>     return [make_row(row) for row in rows]             ^^^^^^^^^^^^^   File \"lib/sqlalchemy/cyextension/resultproxy.pyx\", line 22, in sqlalchemy.cyextension.resultproxy.BaseRow.__init__   File \"lib/sqlalchemy/cyextension/resultproxy.pyx\", line 79, in sqlalchemy.cyextension.resultproxy._apply_processors   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/sql/sqltypes.py\", line 1739, in process     value = self._object_value_for_elem(value)             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/dialects/mysql/enumerated.py\", line 87, in _object_value_for_elem     return super()._object_value_for_elem(elem)            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"/Users/nono/PythonStudy/flask/venv/lib/python3.11/site-packages/sqlalchemy/sql/sqltypes.py\", line 1621, in _object_value_for_elem     raise LookupError( LookupError: 'pending' is not among the defined enum values. Enum name: approvalstatus. Possible values: PENDING, APPROVED, REJECTED`", "gold_terms": ["Approval.query", "ApprovalStatus.PENDING", "Approval.submit_time", "ApprovalService.get_approval", "ApprovalService.has_pending_approval", "ApprovalStatus.APPROVED", "User.query", "ApprovalStatus.REJECTED", "nonozone", "approval_service", "models", "import", "utils", "current_time", "logging", "logger", "__name__", "class", "staticmethod", "def"], "results": [{"rank": 1, "score": 0.4296496510505676, "raw_score": 0.4296496510505676, "source": "docs", "row": 337, "chunk_id": "50ecba2f8db1255312a4f8edf1471ca8d4df0261", "symbol_type": "doc", "qualname": "tutorial\\database.rst#Create the Tables", "file_path": "d:\\499\\docs\\tutorial\\database.rst", "start_line": 89, "end_line": 154}, {"rank": 2, "score": 0.4201509654521942, "raw_score": 0.4201509654521942, "source": "docs", "row": 266, "chunk_id": "a261c3c3064ebdd47b3d21c5f89029750144948b", "symbol_type": "doc", "qualname": "patterns\\wtforms.rst#In the View", "file_path": "d:\\499\\docs\\patterns\\wtforms.rst", "start_line": 42, "end_line": 69}, {"rank": 3, "score": 0.40801841020584106, "raw_score": 0.40801841020584106, "source": "docs", "row": 332, "chunk_id": "bc87b2e94440afe289909b08dd896e6ddb1352db", "symbol_type": "doc", "qualname": "tutorial\\blog.rst#Update", "file_path": "d:\\499\\docs\\tutorial\\blog.rst", "start_line": 191, "end_line": 310}, {"rank": 4, "score": 0.3988204896450043, "raw_score": 0.3988204896450043, "source": "flask", "row": 377, "chunk_id": "17d7a93271b1c4ddd7d7d42afb3e3030f615072a", "symbol_type": "method", "qualname": "Request.max_form_parts", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\wrappers.py", "start_line": 120, "end_line": 140}, {"rank": 5, "score": 0.3976263999938965, "raw_score": 0.3976263999938965, "source": "docs", "row": 265, "chunk_id": "802ba757eeee50ccdf8027f962cd1d30a4476975", "symbol_type": "doc", "qualname": "patterns\\wtforms.rst#The Forms", "file_path": "d:\\499\\docs\\patterns\\wtforms.rst", "start_line": 25, "end_line": 39}, {"rank": 6, "score": 0.39200618863105774, "raw_score": 0.39200618863105774, "source": "docs", "row": 336, "chunk_id": "406ecff19e5ef52dfb57c8d1d9bf3709fd7a7338", "symbol_type": "doc", "qualname": "tutorial\\database.rst#Connect to the Database", "file_path": "d:\\499\\docs\\tutorial\\database.rst", "start_line": 25, "end_line": 86}, {"rank": 7, "score": 0.3856177031993866, "raw_score": 0.3856177031993866, "source": "docs", "row": 241, "chunk_id": "acaffd0fc1aa4a14ec5eb8f40061bf0aa19e0eaa", "symbol_type": "doc", "qualname": "patterns\\sqlalchemy.rst#Declarative", "file_path": "d:\\499\\docs\\patterns\\sqlalchemy.rst", "start_line": 27, "end_line": 109}, {"rank": 8, "score": 0.38158974051475525, "raw_score": 0.38158974051475525, "source": "docs", "row": 242, "chunk_id": "439e536ee72d657e02d5be217d9ba5ef516417eb", "symbol_type": "doc", "qualname": "patterns\\sqlalchemy.rst#Manual Object Relational Mapping", "file_path": "d:\\499\\docs\\patterns\\sqlalchemy.rst", "start_line": 112, "end_line": 167}, {"rank": 9, "score": 0.3808436691761017, "raw_score": 0.3808436691761017, "source": "docs", "row": 373, "chunk_id": "b88b0cde0b1229ae3d7ba33e75ba05a81f583f1a", "symbol_type": "doc", "qualname": "tutorial\\views.rst#Login", "file_path": "d:\\499\\docs\\tutorial\\views.rst", "start_line": 166, "end_line": 243}, {"rank": 10, "score": 0.3790183365345001, "raw_score": 0.3790183365345001, "source": "docs", "row": 240, "chunk_id": "c81cd6395848b1597798e2a3b1eceea9ca91eca1", "symbol_type": "doc", "qualname": "patterns\\sqlalchemy.rst#Flask-SQLAlchemy Extension", "file_path": "d:\\499\\docs\\patterns\\sqlalchemy.rst", "start_line": 13, "end_line": 24}]}
{"query": "Concurrent Request Processing Issue in Flask with Gunicorn and Gevent-Websocket on AWS Hi everyone, I hope you're doing well. I'm currently working on a Flask project where I'm utilizing flask_login, flask_sqlalchemy, and flask_socketio. The application is deployed on AWS Elastic Beanstalk using Gunicorn . web: gunicorn --worker-class geventwebsocket.gunicorn.workers.GeventWebSocketWorker -w 1 --timeout 340 --graceful-timeout 340 application:application I'm encountering an issue with request processing: when an I/O(database) operation is performed in one http request, other HTTP requests remain in the queue. According to the Flask-SocketIO documentation, increasing the -w (worker count) parameter beyond 1 is not suggested. Despite the application being load balanced , requests still get stuck in the queue. I understand that Flask operates as a WSGI server, but I am seeking a solution to enable concurrent request processing. I would greatly appreciate any suggestions or guidance on how to address this issue. Thank you!", "mode": "nl", "used_query": "Concurrent Request Processing Issue in Flask with Gunicorn and Gevent-Websocket on AWS Hi everyone, I hope you're doing well. I'm currently working on a Flask project where I'm utilizing flask_login, flask_sqlalchemy, and flask_socketio. The application is deployed on AWS Elastic Beanstalk using Gunicorn . web: gunicorn --worker-class geventwebsocket.gunicorn.workers.GeventWebSocketWorker -w 1 --timeout 340 --graceful-timeout 340 application:application I'm encountering an issue with request processing: when an I/O(database) operation is performed in one http request, other HTTP requests remain in the queue. According to the Flask-SocketIO documentation, increasing the -w (worker count) parameter beyond 1 is not suggested. Despite the application being load balanced , requests still get stuck in the queue. I understand that Flask operates as a WSGI server, but I am seeking a solution to enable concurrent request processing. I would greatly appreciate any suggestions or guidance on how to address this issue. Thank you!", "gold_terms": ["miguelgrinberg", "the", "documentation", "increasing", "worker", "count", "parameter", "beyond", "not", "suggested", "don", "understand", "how", "related", "problem", "are", "using", "gevent", "concurrency", "happens"], "results": [{"rank": 1, "score": 0.5997191667556763, "raw_score": 0.5997191667556763, "source": "docs", "row": 33, "chunk_id": "ac56dbb89b157e864d8da212992c8453a27e9186", "symbol_type": "doc", "qualname": "async-await.rst#When to use Quart instead", "file_path": "d:\\499\\docs\\async-await.rst", "start_line": 66, "end_line": 84}, {"rank": 2, "score": 0.5874665975570679, "raw_score": 0.5874665975570679, "source": "docs", "row": 31, "chunk_id": "fdff1edd3e9666d9b6b9f0d4c9a461e6417a3ab9", "symbol_type": "doc", "qualname": "async-await.rst#Performance", "file_path": "d:\\499\\docs\\async-await.rst", "start_line": 28, "end_line": 46}, {"rank": 3, "score": 0.5773905515670776, "raw_score": 0.5773905515670776, "source": "flask", "row": 20, "chunk_id": "473700e2ea48267590c7dd6e75f501ae1186b288", "symbol_type": "method", "qualname": "Flask.full_dispatch_request", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 904, "end_line": 920}, {"rank": 4, "score": 0.5656697750091553, "raw_score": 0.5656697750091553, "source": "flask", "row": 117, "chunk_id": "45e39c75627746e8d351af755ae300aeba86c26a", "symbol_type": "method", "qualname": "RequestContext.__init__", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\ctx.py", "start_line": 309, "end_line": 335}, {"rank": 5, "score": 0.5616968870162964, "raw_score": 0.5616968870162964, "source": "docs", "row": 385, "chunk_id": "997670d9e824d562b79a247044201d7b0fe24c5c", "symbol_type": "doc", "qualname": "web-security.rst#Resource Use", "file_path": "d:\\499\\docs\\web-security.rst", "start_line": 13, "end_line": 42}, {"rank": 6, "score": 0.5604308843612671, "raw_score": 0.5604308843612671, "source": "docs", "row": 87, "chunk_id": "e107086624d548cc53917b59c3f0cd426991e7ee", "symbol_type": "doc", "qualname": "deploying\\gevent.rst#gevent", "file_path": "d:\\499\\docs\\deploying\\gevent.rst", "start_line": 2, "end_line": 19}, {"rank": 7, "score": 0.55672287940979, "raw_score": 0.55672287940979, "source": "docs", "row": 301, "chunk_id": "a944be639a21c36fed361badc84b203d857b64b7", "symbol_type": "doc", "qualname": "shell.rst#Firing Before/After Request", "file_path": "d:\\499\\docs\\shell.rst", "start_line": 39, "end_line": 69}, {"rank": 8, "score": 0.5527969598770142, "raw_score": 0.5527969598770142, "source": "docs", "row": 150, "chunk_id": "90aee9e5e00cf4374efc596f49a351a4aa684b9f", "symbol_type": "doc", "qualname": "gevent.rst#Enabling gevent", "file_path": "d:\\499\\docs\\gevent.rst", "start_line": 23, "end_line": 62}, {"rank": 9, "score": 0.5451123714447021, "raw_score": 0.5451123714447021, "source": "docs", "row": 95, "chunk_id": "40d9a5c5a41afe66815266f41fdadb50e5899b7f", "symbol_type": "doc", "qualname": "deploying\\gunicorn.rst#Async with gevent", "file_path": "d:\\499\\docs\\deploying\\gunicorn.rst", "start_line": 97, "end_line": 116}, {"rank": 10, "score": 0.537108302116394, "raw_score": 0.537108302116394, "source": "docs", "row": 122, "chunk_id": "5a15fca0a9f5ebc8045161511b3edac905f90f49", "symbol_type": "doc", "qualname": "design.rst#Async/await and ASGI support", "file_path": "d:\\499\\docs\\design.rst", "start_line": 189, "end_line": 205}]}
{"query": "Flask using bytes instead of str during SecureCookieSessionInterface.save_session Hi everyone, I'm currently working with the latest versions of Flask, Werkzeug, and itsdangerous on Python 3.11.9 and encountered a TypeError related to string vs bytes where string is required for werkzeug. Here are the versions I am using: Flask==3.0.3 Flask-Login==0.6.3 itsdangerous==2.2.0 Werkzeug==3.0.3 Issue: When calling self.get_signing_serializer(app).dumps(dict(session)) [source: github], it returns a bytes object. Feeding this bytes value into response.set_cookie results in the following TypeError: TypeError: cannot use a string pattern on a bytes-like object Details:  get_signing_serializer returns URLSafeTimedSerializer, which is part of itsdangerous.  URLSafeTimedSerializer.dumps() returns bytes.   werkzeug==3.0.3 seems to expect string values for cookies starting from version 3.0.0. If you remove the # type: ignore[union-attr] comment, you should see that types are not handled correctly.  Steps Taken: Tried various combinations of Flask and itsdangerous versions to work with Werkzeug 3.0.3 but couldn't resolve the bytes issue. Using Werkzeug 3.0.3 is necessary due to security vulnerabilities in earlier versions. Full Traceback _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ /usr/local/lib/python3.11/site-packages/werkzeug/test.py:1162: in get     return self.open(*args, **kw) /usr/local/lib/python3.11/site-packages/flask/testing.py:235: in open     response = super().open( /usr/local/lib/python3.11/site-packages/werkzeug/test.py:1116: in open     response_parts = self.run_wsgi_app(request.environ, buffered=buffered) /usr/local/lib/python3.11/site-packages/werkzeug/test.py:988: in run_wsgi_app     rv = run_wsgi_app(self.application, environ, buffered=buffered) /usr/local/lib/python3.11/site-packages/werkzeug/test.py:1264: in run_wsgi_app     app_rv = app(environ, start_response) /usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/flask.py:89: in sentry_patched_wsgi_app     return SentryWsgiMiddleware(lambda *a, **kw: old_app(self, *a, **kw))( /usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/wsgi.py:115: in __call__     reraise(*_capture_exception(hub)) /usr/local/lib/python3.11/site-packages/sentry_sdk/_compat.py:115: in reraise     raise value /usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/wsgi.py:108: in __call__     rv = self.app( /usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/flask.py:89: in <lambda>     return SentryWsgiMiddleware(lambda *a, **kw: old_app(self, *a, **kw))( /usr/local/lib/python3.11/site-packages/flask/app.py:1498: in __call__     return self.wsgi_app(environ, start_response) /usr/local/lib/python3.11/site-packages/werkzeug/middleware/proxy_fix.py:183: in __call__     return self.app(environ, start_response) /usr/local/lib/python3.11/site-packages/flask/app.py:1476: in wsgi_app     response = self.handle_exception(e) /usr/local/lib/python3.11/site-packages/flask/app.py:1473: in wsgi_app     response = self.full_dispatch_request() /usr/local/lib/python3.11/site-packages/flask/app.py:883: in full_dispatch_request     return self.finalize_request(rv) /usr/local/lib/python3.11/site-packages/flask/app.py:904: in finalize_request     response = self.process_response(response) /usr/local/lib/python3.11/site-packages/flask/app.py:1284: in process_response     self.session_interface.save_session(self, ctx.session, response) /usr/local/lib/python3.11/site-packages/flask/sessions.py:369: in save_session     response.set_cookie( /usr/local/lib/python3.11/site-packages/werkzeug/sansio/response.py:227: in set_cookie     dump_cookie( _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _  key = 'session' value = b'eyJhbGciOiJIUzI1NiIsImlhdCI6MTcyMTc1MTMzNiwiZXhwIjoxNzIyMzU2MTM2fQ.eyJhdXRoIjoiZXlKaGJHY2lPaUpTVXpJMU5pSXNJblI1Y0NJN...RjWlJid09CUHpfa1oyREJ1cG9pWHZSMDFpUkFqVHhhM1p1NHdEYTlwS3c2blF6SHpKZDI5dyJ9.0dBgcYkw19mKkF4gAXvutd_z0MzA1eKBtbmh5JOXe5Q' max_age = None, expires = None, path = '/', domain = None, secure = True, httponly = False, sync_expires = True, max_size = 4093, samesite = None      def dump_cookie(         key: str,         value: str = \"\",         max_age: timedelta | int | None = None,         expires: str | datetime | int | float | None = None,         path: str | None = \"/\",         domain: str | None = None,         secure: bool = False,         httponly: bool = False,         sync_expires: bool = True,         max_size: int = 4093,         samesite: str | None = None,     ) -> str:         \"\"\"Create a Set-Cookie header without the ``Set-Cookie`` prefix.          The return value is usually restricted to ascii as the vast majority         of values are properly escaped, but that is no guarantee. It's         tunneled through latin1 as required by :pep:`3333`.          The return value is not ASCII safe if the key contains unicode         characters.  This is technically against the specification but         happens in the wild.  It's strongly recommended to not use         non-ASCII values for the keys.          :param max_age: should be a number of seconds, or `None` (default) if                         the cookie should last only as long as the client's                         browser session.  Additionally `timedelta` objects                         are accepted, too.         :param expires: should be a `datetime` object or unix timestamp.         :param path: limits the cookie to a given path, per default it will                      span the whole domain.         :param domain: Use this if you want to set a cross-domain cookie. For                        example, ``domain=\"example.com\"`` will set a cookie                        that is readable by the domain ``www.example.com``,                        ``foo.example.com`` etc. Otherwise, a cookie will only                        be readable by the domain that set it.         :param secure: The cookie will only be available via HTTPS         :param httponly: disallow JavaScript to access the cookie.  This is an                          extension to the cookie standard and probably not                          supported by all browsers.         :param charset: the encoding for string values.         :param sync_expires: automatically set expires if max_age is defined                              but expires not.         :param max_size: Warn if the final header value exceeds this size. The             default, 4093, should be safely `supported by most browsers             <cookie_>`_. Set to 0 to disable this check.         :param samesite: Limits the scope of the cookie such that it will             only be attached to requests if those requests are same-site.          .. _`cookie`: http://browsercookielimits.squawky.net/          .. versionchanged:: 3.0             Passing bytes, and the ``charset`` parameter, were removed.          .. versionchanged:: 2.3.3             The ``path`` parameter is ``/`` by default.          .. versionchanged:: 2.3.1             The value allows more characters without quoting.          .. versionchanged:: 2.3             ``localhost`` and other names without a dot are allowed for the domain. A             leading dot is ignored.          .. versionchanged:: 2.3             The ``path`` parameter is ``None`` by default.          .. versionchanged:: 1.0.0             The string ``'None'`` is accepted for ``samesite``.         \"\"\"         if path is not None:             # safe = https://url.spec.whatwg.org/#url-path-segment-string             # as well as percent for things that are already quoted             # excluding semicolon since it's part of the header syntax             path = quote(path, safe=\"%!$&'()*+,/:=@\")          if domain:             domain = domain.partition(\":\")[0].lstrip(\".\").encode(\"idna\").decode(\"ascii\")          if isinstance(max_age, timedelta):             max_age = int(max_age.total_seconds())          if expires is not None:             if not isinstance(expires, str):                 expires = http_date(expires)         elif max_age is not None and sync_expires:             expires = http_date(datetime.now(tz=timezone.utc).timestamp() + max_age)          if samesite is not None:             samesite = samesite.title()              if samesite not in {\"Strict\", \"Lax\", \"None\"}:                 raise ValueError(\"SameSite must be 'Strict', 'Lax', or 'None'.\")          # Quote value if it contains characters not allowed by RFC 6265. Slash-escape with         # three octal digits, which matches http.cookies, although the RFC suggests base64. >       if not _cookie_no_quote_re.fullmatch(value): E       TypeError: cannot use a string pattern on a bytes-like object  /usr/local/lib/python3.11/site-packages/werkzeug/http.py:1301: TypeError", "mode": "nl", "used_query": "Flask using bytes instead of str during SecureCookieSessionInterface.save_session Hi everyone, I'm currently working with the latest versions of Flask, Werkzeug, and itsdangerous on Python 3.11.9 and encountered a TypeError related to string vs bytes where string is required for werkzeug. Here are the versions I am using: Flask==3.0.3 Flask-Login==0.6.3 itsdangerous==2.2.0 Werkzeug==3.0.3 Issue: When calling self.get_signing_serializer(app).dumps(dict(session)) [source: github], it returns a bytes object. Feeding this bytes value into response.set_cookie results in the following TypeError: TypeError: cannot use a string pattern on a bytes-like object Details:  get_signing_serializer returns URLSafeTimedSerializer, which is part of itsdangerous.  URLSafeTimedSerializer.dumps() returns bytes.   werkzeug==3.0.3 seems to expect string values for cookies starting from version 3.0.0. If you remove the # type: ignore[union-attr] comment, you should see that types are not handled correctly.  Steps Taken: Tried various combinations of Flask and itsdangerous versions to work with Werkzeug 3.0.3 but couldn't resolve the bytes issue. Using Werkzeug 3.0.3 is necessary due to security vulnerabilities in earlier versions. Full Traceback _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ /usr/local/lib/python3.11/site-packages/werkzeug/test.py:1162: in get     return self.open(*args, **kw) /usr/local/lib/python3.11/site-packages/flask/testing.py:235: in open     response = super().open( /usr/local/lib/python3.11/site-packages/werkzeug/test.py:1116: in open     response_parts = self.run_wsgi_app(request.environ, buffered=buffered) /usr/local/lib/python3.11/site-packages/werkzeug/test.py:988: in run_wsgi_app     rv = run_wsgi_app(self.application, environ, buffered=buffered) /usr/local/lib/python3.11/site-packages/werkzeug/test.py:1264: in run_wsgi_app     app_rv = app(environ, start_response) /usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/flask.py:89: in sentry_patched_wsgi_app     return SentryWsgiMiddleware(lambda *a, **kw: old_app(self, *a, **kw))( /usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/wsgi.py:115: in __call__     reraise(*_capture_exception(hub)) /usr/local/lib/python3.11/site-packages/sentry_sdk/_compat.py:115: in reraise     raise value /usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/wsgi.py:108: in __call__     rv = self.app( /usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/flask.py:89: in <lambda>     return SentryWsgiMiddleware(lambda *a, **kw: old_app(self, *a, **kw))( /usr/local/lib/python3.11/site-packages/flask/app.py:1498: in __call__     return self.wsgi_app(environ, start_response) /usr/local/lib/python3.11/site-packages/werkzeug/middleware/proxy_fix.py:183: in __call__     return self.app(environ, start_response) /usr/local/lib/python3.11/site-packages/flask/app.py:1476: in wsgi_app     response = self.handle_exception(e) /usr/local/lib/python3.11/site-packages/flask/app.py:1473: in wsgi_app     response = self.full_dispatch_request() /usr/local/lib/python3.11/site-packages/flask/app.py:883: in full_dispatch_request     return self.finalize_request(rv) /usr/local/lib/python3.11/site-packages/flask/app.py:904: in finalize_request     response = self.process_response(response) /usr/local/lib/python3.11/site-packages/flask/app.py:1284: in process_response     self.session_interface.save_session(self, ctx.session, response) /usr/local/lib/python3.11/site-packages/flask/sessions.py:369: in save_session     response.set_cookie( /usr/local/lib/python3.11/site-packages/werkzeug/sansio/response.py:227: in set_cookie     dump_cookie( _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _  key = 'session' value = b'eyJhbGciOiJIUzI1NiIsImlhdCI6MTcyMTc1MTMzNiwiZXhwIjoxNzIyMzU2MTM2fQ.eyJhdXRoIjoiZXlKaGJHY2lPaUpTVXpJMU5pSXNJblI1Y0NJN...RjWlJid09CUHpfa1oyREJ1cG9pWHZSMDFpUkFqVHhhM1p1NHdEYTlwS3c2blF6SHpKZDI5dyJ9.0dBgcYkw19mKkF4gAXvutd_z0MzA1eKBtbmh5JOXe5Q' max_age = None, expires = None, path = '/', domain = None, secure = True, httponly = False, sync_expires = True, max_size = 4093, samesite = None      def dump_cookie(         key: str,         value: str = \"\",         max_age: timedelta | int | None = None,         expires: str | datetime | int | float | None = None,         path: str | None = \"/\",         domain: str | None = None,         secure: bool = False,         httponly: bool = False,         sync_expires: bool = True,         max_size: int = 4093,         samesite: str | None = None,     ) -> str:         \"\"\"Create a Set-Cookie header without the ``Set-Cookie`` prefix.          The return value is usually restricted to ascii as the vast majority         of values are properly escaped, but that is no guarantee. It's         tunneled through latin1 as required by :pep:`3333`.          The return value is not ASCII safe if the key contains unicode         characters.  This is technically against the specification but         happens in the wild.  It's strongly recommended to not use         non-ASCII values for the keys.          :param max_age: should be a number of seconds, or `None` (default) if                         the cookie should last only as long as the client's                         browser session.  Additionally `timedelta` objects                         are accepted, too.         :param expires: should be a `datetime` object or unix timestamp.         :param path: limits the cookie to a given path, per default it will                      span the whole domain.         :param domain: Use this if you want to set a cross-domain cookie. For                        example, ``domain=\"example.com\"`` will set a cookie                        that is readable by the domain ``www.example.com``,                        ``foo.example.com`` etc. Otherwise, a cookie will only                        be readable by the domain that set it.         :param secure: The cookie will only be available via HTTPS         :param httponly: disallow JavaScript to access the cookie.  This is an                          extension to the cookie standard and probably not                          supported by all browsers.         :param charset: the encoding for string values.         :param sync_expires: automatically set expires if max_age is defined                              but expires not.         :param max_size: Warn if the final header value exceeds this size. The             default, 4093, should be safely `supported by most browsers             <cookie_>`_. Set to 0 to disable this check.         :param samesite: Limits the scope of the cookie such that it will             only be attached to requests if those requests are same-site.          .. _`cookie`: http://browsercookielimits.squawky.net/          .. versionchanged:: 3.0             Passing bytes, and the ``charset`` parameter, were removed.          .. versionchanged:: 2.3.3             The ``path`` parameter is ``/`` by default.          .. versionchanged:: 2.3.1             The value allows more characters without quoting.          .. versionchanged:: 2.3             ``localhost`` and other names without a dot are allowed for the domain. A             leading dot is ignored.          .. versionchanged:: 2.3             The ``path`` parameter is ``None`` by default.          .. versionchanged:: 1.0.0             The string ``'None'`` is accepted for ``samesite``.         \"\"\"         if path is not None:             # safe = https://url.spec.whatwg.org/#url-path-segment-string             # as well as percent for things that are already quoted             # excluding semicolon since it's part of the header syntax             path = quote(path, safe=\"%!$&'()*+,/:=@\")          if domain:             domain = domain.partition(\":\")[0].lstrip(\".\").encode(\"idna\").decode(\"ascii\")          if isinstance(max_age, timedelta):             max_age = int(max_age.total_seconds())          if expires is not None:             if not isinstance(expires, str):                 expires = http_date(expires)         elif max_age is not None and sync_expires:             expires = http_date(datetime.now(tz=timezone.utc).timestamp() + max_age)          if samesite is not None:             samesite = samesite.title()              if samesite not in {\"Strict\", \"Lax\", \"None\"}:                 raise ValueError(\"SameSite must be 'Strict', 'Lax', or 'None'.\")          # Quote value if it contains characters not allowed by RFC 6265. Slash-escape with         # three octal digits, which matches http.cookies, although the RFC suggests base64. >       if not _cookie_no_quote_re.fullmatch(value): E       TypeError: cannot use a string pattern on a bytes-like object  /usr/local/lib/python3.11/site-packages/werkzeug/http.py:1301: TypeError", "gold_terms": ["davidism", "can", "reproduce", "the", "information", "provided", "request", "saves", "session", "data", "does", "not", "raise", "error", "shown", "returns", "string", "bytes", "sure", "include"], "results": [{"rank": 1, "score": 0.7053427696228027, "raw_score": 0.7053427696228027, "source": "flask", "row": 331, "chunk_id": "518bfe5b60d30c5ac4ccca9ba5e8482e02fec526", "symbol_type": "class", "qualname": "SecureCookieSessionInterface", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sessions.py", "start_line": 298, "end_line": 399}, {"rank": 2, "score": 0.6689308881759644, "raw_score": 0.6689308881759644, "source": "flask", "row": 332, "chunk_id": "483562af31495ad3bb3f913971f9167782c08c61", "symbol_type": "method", "qualname": "SecureCookieSessionInterface.get_signing_serializer", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sessions.py", "start_line": 317, "end_line": 335}, {"rank": 3, "score": 0.6544884443283081, "raw_score": 0.6544884443283081, "source": "flask", "row": 333, "chunk_id": "cae28cc81c66b2f2d18aee592bf82ef4b2e0c405", "symbol_type": "method", "qualname": "SecureCookieSessionInterface.open_session", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sessions.py", "start_line": 337, "end_line": 349}, {"rank": 4, "score": 0.5889508724212646, "raw_score": 0.5889508724212646, "source": "flask", "row": 309, "chunk_id": "374d8984d30bc846b16a090bed2d9f9c8dd55d8c", "symbol_type": "class", "qualname": "SecureCookieSession", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sessions.py", "start_line": 52, "end_line": 94}, {"rank": 5, "score": 0.5775930881500244, "raw_score": 0.5775930881500244, "source": "flask", "row": 334, "chunk_id": "05e70400f6f69e3dde05f05351cd4c654b8527e2", "symbol_type": "method", "qualname": "SecureCookieSessionInterface.save_session", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sessions.py", "start_line": 351, "end_line": 399}, {"rank": 6, "score": 0.5673383474349976, "raw_score": 0.5673383474349976, "source": "flask", "row": 325, "chunk_id": "434da2d42af5c5b43350650b75a055b5f9374d6e", "symbol_type": "method", "qualname": "SessionInterface.get_cookie_partitioned", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sessions.py", "start_line": 229, "end_line": 235}, {"rank": 7, "score": 0.5653138160705566, "raw_score": 0.5653138160705566, "source": "flask", "row": 321, "chunk_id": "15e2fbb1efb7aa2cc8a54abd17c8e1ce4b01d330", "symbol_type": "method", "qualname": "SessionInterface.get_cookie_path", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sessions.py", "start_line": 201, "end_line": 207}, {"rank": 8, "score": 0.5615389943122864, "raw_score": 0.5615389943122864, "source": "flask", "row": 323, "chunk_id": "b095683def6a0eec3502f2de2a5a603d3c842799", "symbol_type": "method", "qualname": "SessionInterface.get_cookie_secure", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sessions.py", "start_line": 216, "end_line": 220}, {"rank": 9, "score": 0.553438127040863, "raw_score": 0.553438127040863, "source": "flask", "row": 319, "chunk_id": "735155810100328434582b7c9113615cd4f264b1", "symbol_type": "method", "qualname": "SessionInterface.get_cookie_name", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sessions.py", "start_line": 185, "end_line": 187}, {"rank": 10, "score": 0.5490466356277466, "raw_score": 0.5490466356277466, "source": "flask", "row": 385, "chunk_id": "4c7ffd07096fd2a38dd7309e6f20d20fe704f990", "symbol_type": "method", "qualname": "Response.max_cookie_size", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\wrappers.py", "start_line": 247, "end_line": 257}]}
{"query": "Encountering Jinja2 SyntaxError after adding another css file I've been encountering this confusing error; which is Jinja2.exceptions.TemplateSyntaxError: expected token ',', got 'string'. This only happened after I added another css file to my html script. But previously, it worked fine. Here are the previous errors i've encountered regarding this issue: <link rel=\"icon\" href=\"{{ url_for('static', filename='images/favicon.png') }}\"> jinja2.exceptions.TemplateSyntaxError: expected token ',', got 'static'     <li onclick=\"redirectUser('/homepage')\">Home</li> jinja2.exceptions.TemplateSyntaxError: expected token ',', got 'string'  Environment:  Python version: 3.12.4 Flask version: 3.0.3", "mode": "nl", "used_query": "Encountering Jinja2 SyntaxError after adding another css file I've been encountering this confusing error; which is Jinja2.exceptions.TemplateSyntaxError: expected token ',', got 'string'. This only happened after I added another css file to my html script. But previously, it worked fine. Here are the previous errors i've encountered regarding this issue: <link rel=\"icon\" href=\"{{ url_for('static', filename='images/favicon.png') }}\"> jinja2.exceptions.TemplateSyntaxError: expected token ',', got 'static'     <li onclick=\"redirectUser('/homepage')\">Home</li> jinja2.exceptions.TemplateSyntaxError: expected token ',', got 'string'  Environment:  Python version: 3.12.4 Flask version: 3.0.3", "gold_terms": ["the", "full", "template", "double", "check", "you", "don", "typographical", "quotes", "instead", "standard", "didn", "properly", "close", "some", "previous", "tag"], "results": [{"rank": 1, "score": 0.6871053576469421, "raw_score": 0.6871053576469421, "source": "docs", "row": 354, "chunk_id": "09f2063148c97d1cdf912b67e659b2c14a850b37", "symbol_type": "doc", "qualname": "tutorial\\static.rst#Static Files", "file_path": "d:\\499\\docs\\tutorial\\static.rst", "start_line": 2, "end_line": 72}, {"rank": 2, "score": 0.6539827585220337, "raw_score": 0.6539827585220337, "source": "docs", "row": 202, "chunk_id": "99f37bff59c3a0eb5a8a3bf2065b2319b1577065", "symbol_type": "doc", "qualname": "patterns\\favicon.rst#Adding a favicon", "file_path": "d:\\499\\docs\\patterns\\favicon.rst", "start_line": 2, "end_line": 50}, {"rank": 3, "score": 0.6400870084762573, "raw_score": 0.6400870084762573, "source": "docs", "row": 386, "chunk_id": "f9c5c9f24b8ebf409b7431876e6ee124b89c59e0", "symbol_type": "doc", "qualname": "web-security.rst#Cross-Site Scripting (XSS)", "file_path": "d:\\499\\docs\\web-security.rst", "start_line": 45, "end_line": 101}, {"rank": 4, "score": 0.5968819260597229, "raw_score": 0.5968819260597229, "source": "docs", "row": 311, "chunk_id": "6987818864195d742dc774c64b512a4f95692813", "symbol_type": "doc", "qualname": "templating.rst#Jinja Setup", "file_path": "d:\\499\\docs\\templating.rst", "start_line": 16, "end_line": 29}, {"rank": 5, "score": 0.5962090492248535, "raw_score": 0.5962090492248535, "source": "docs", "row": 132, "chunk_id": "cf852e1ef3a0110d010936a35648f1e22ef52936", "symbol_type": "doc", "qualname": "errorhandling.rst#Further Examples", "file_path": "d:\\499\\docs\\errorhandling.rst", "start_line": 334, "end_line": 389}, {"rank": 6, "score": 0.590933084487915, "raw_score": 0.590933084487915, "source": "docs", "row": 356, "chunk_id": "27158e3239abec0913fc276b7dee2b604593c5b8", "symbol_type": "doc", "qualname": "tutorial\\templates.rst#Templates", "file_path": "d:\\499\\docs\\tutorial\\templates.rst", "start_line": 4, "end_line": 36}, {"rank": 7, "score": 0.5818080306053162, "raw_score": 0.5818080306053162, "source": "docs", "row": 357, "chunk_id": "aa063cd439b9df5cb810d38c01e2903e52904ff5", "symbol_type": "doc", "qualname": "tutorial\\templates.rst#The Base Layout", "file_path": "d:\\499\\docs\\tutorial\\templates.rst", "start_line": 39, "end_line": 100}, {"rank": 8, "score": 0.5808523893356323, "raw_score": 0.5808523893356323, "source": "docs", "row": 277, "chunk_id": "93490046e7d94f1c2e3315710787da5a5f8d27ba", "symbol_type": "doc", "qualname": "quickstart.rst#Static Files", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 336, "end_line": 348}, {"rank": 9, "score": 0.5528435111045837, "raw_score": 0.5528435111045837, "source": "flask", "row": 7, "chunk_id": "e611ef2592e61ab0a6af35ffdcf2360f04187d56", "symbol_type": "method", "qualname": "Flask.create_jinja_environment", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 385, "end_line": 423}, {"rank": 10, "score": 0.5514020323753357, "raw_score": 0.5514020323753357, "source": "flask", "row": 222, "chunk_id": "dc995c73ac8ca7543a6c1befe5a96ed88d5b6a12", "symbol_type": "method", "qualname": "App.jinja_env", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "start_line": 470, "end_line": 477}]}
{"query": "Flask socketio server crashes after a few days, ran out of ideas to fix it for the past few months i've been running a socketio server for my multiplayer game. it seems to work alright, only after a day or two to crash with these errors : [2024-06-18 14:55:02 +0300] [250979] [INFO] Handling signal: int [2024-06-18 14:55:02 +0300] [250981] [ERROR] Exception in worker process Traceback (most recent call last):   File \"/usr/lib/python3.8/ssl.py\", line 1019, in _create     self.getpeername() OSError: [Errno 107] Transport endpoint is not connected   During handling of the above exception, another exception occurred:   Traceback (most recent call last):   File \"/usr/local/lib/python3.8/dist-packages/gunicorn/arbiter.py\", line 609, in spawn_worker     worker.init_process()   File \"/usr/local/lib/python3.8/dist-packages/gunicorn/workers/geventlet.py\", line 143, in init_process     super().init_process()   File \"/usr/local/lib/python3.8/dist-packages/gunicorn/workers/base.py\", line 142, in init_process     self.run()   File \"/usr/local/lib/python3.8/dist-packages/gunicorn/workers/geventlet.py\", line 182, in run     a.wait()   File \"/usr/local/lib/python3.8/dist-packages/eventlet/greenthread.py\", line 225, in wait     return self._exit_event.wait()   File \"/usr/local/lib/python3.8/dist-packages/eventlet/event.py\", line 131, in wait     current.throw(*self._exc)   File \"/usr/local/lib/python3.8/dist-packages/eventlet/greenthread.py\", line 265, in main     result = function(*args, **kwargs)   File \"/usr/local/lib/python3.8/dist-packages/gunicorn/workers/geventlet.py\", line 83, in _eventlet_serve     conn, addr = sock.accept()   File \"/usr/local/lib/python3.8/dist-packages/eventlet/greenio/base.py\", line 228, in accept     self._trampoline(fd, read=True, timeout=self.gettimeout(), timeout_exc=_timeout_exc)   File \"/usr/local/lib/python3.8/dist-packages/eventlet/greenio/base.py\", line 206, in _trampoline     return trampoline(fd, read=read, write=write, timeout=timeout,   File \"/usr/local/lib/python3.8/dist-packages/eventlet/hubs/__init__.py\", line 157, in trampoline     return hub.switch()   File \"/usr/local/lib/python3.8/dist-packages/eventlet/hubs/hub.py\", line 310, in switch     return self.greenlet.switch()   File \"/usr/local/lib/python3.8/dist-packages/gunicorn/workers/geventlet.py\", line 102, in _eventlet_stop     client.wait()   File \"/usr/local/lib/python3.8/dist-packages/eventlet/greenthread.py\", line 225, in wait     return self._exit_event.wait()   File \"/usr/local/lib/python3.8/dist-packages/eventlet/event.py\", line 131, in wait     current.throw(*self._exc)   File \"/usr/local/lib/python3.8/dist-packages/eventlet/greenthread.py\", line 265, in main     result = function(*args, **kwargs)   File \"/usr/local/lib/python3.8/dist-packages/gunicorn/workers/geventlet.py\", line 156, in handle     client = ssl_wrap_socket(client, self.cfg)   File \"/usr/local/lib/python3.8/dist-packages/gunicorn/sock.py\", line 229, in ssl_wrap_socket     return ssl_context(conf).wrap_socket(sock,   File \"/usr/local/lib/python3.8/dist-packages/eventlet/green/ssl.py\", line 436, in wrap_socket     return GreenSSLSocket(sock, *a, _context=self, **kw)   File \"/usr/local/lib/python3.8/dist-packages/eventlet/green/ssl.py\", line 65, in __new__     ret = _original_sslsocket._create(   File \"/usr/lib/python3.8/ssl.py\", line 1031, in _create     notconn_pre_handshake_data = self.recv(1)   File \"/usr/lib/python3.8/ssl.py\", line 1257, in recv     return super().recv(buflen, flags) ConnectionResetError: [Errno 104] Connection reset by peer  Here is the server code, most likely it crashes on disconnection: https://pastebin.com/tSCS1d6a I'm running it with gunicorn, but the same used to hapen when i ran it like a normal flask app. This is on ubuntu. once the process is stopped and restarted, it works again fine, only to repeat after a few days again. I've tried running the whole thing with gunicorn using this command : gunicorn --workers 1 --worker-class eventlet --bind 0.0.0.0:5000 --certfile=/etc/ssl/chained.pem --keyfile=/etc/ssl/private/private-unencrypted.key --error-logfile ./error.txt --access-logfile ./access.txt RequestManager:app I've tried logging when the crash happens, seems to be on disconnection, but really not sure, cant pin point exactly. Tried a few other things, basically ran out of ideas, nothing seems to fix it.", "mode": "nl", "used_query": "Flask socketio server crashes after a few days, ran out of ideas to fix it for the past few months i've been running a socketio server for my multiplayer game. it seems to work alright, only after a day or two to crash with these errors : [2024-06-18 14:55:02 +0300] [250979] [INFO] Handling signal: int [2024-06-18 14:55:02 +0300] [250981] [ERROR] Exception in worker process Traceback (most recent call last):   File \"/usr/lib/python3.8/ssl.py\", line 1019, in _create     self.getpeername() OSError: [Errno 107] Transport endpoint is not connected   During handling of the above exception, another exception occurred:   Traceback (most recent call last):   File \"/usr/local/lib/python3.8/dist-packages/gunicorn/arbiter.py\", line 609, in spawn_worker     worker.init_process()   File \"/usr/local/lib/python3.8/dist-packages/gunicorn/workers/geventlet.py\", line 143, in init_process     super().init_process()   File \"/usr/local/lib/python3.8/dist-packages/gunicorn/workers/base.py\", line 142, in init_process     self.run()   File \"/usr/local/lib/python3.8/dist-packages/gunicorn/workers/geventlet.py\", line 182, in run     a.wait()   File \"/usr/local/lib/python3.8/dist-packages/eventlet/greenthread.py\", line 225, in wait     return self._exit_event.wait()   File \"/usr/local/lib/python3.8/dist-packages/eventlet/event.py\", line 131, in wait     current.throw(*self._exc)   File \"/usr/local/lib/python3.8/dist-packages/eventlet/greenthread.py\", line 265, in main     result = function(*args, **kwargs)   File \"/usr/local/lib/python3.8/dist-packages/gunicorn/workers/geventlet.py\", line 83, in _eventlet_serve     conn, addr = sock.accept()   File \"/usr/local/lib/python3.8/dist-packages/eventlet/greenio/base.py\", line 228, in accept     self._trampoline(fd, read=True, timeout=self.gettimeout(), timeout_exc=_timeout_exc)   File \"/usr/local/lib/python3.8/dist-packages/eventlet/greenio/base.py\", line 206, in _trampoline     return trampoline(fd, read=read, write=write, timeout=timeout,   File \"/usr/local/lib/python3.8/dist-packages/eventlet/hubs/__init__.py\", line 157, in trampoline     return hub.switch()   File \"/usr/local/lib/python3.8/dist-packages/eventlet/hubs/hub.py\", line 310, in switch     return self.greenlet.switch()   File \"/usr/local/lib/python3.8/dist-packages/gunicorn/workers/geventlet.py\", line 102, in _eventlet_stop     client.wait()   File \"/usr/local/lib/python3.8/dist-packages/eventlet/greenthread.py\", line 225, in wait     return self._exit_event.wait()   File \"/usr/local/lib/python3.8/dist-packages/eventlet/event.py\", line 131, in wait     current.throw(*self._exc)   File \"/usr/local/lib/python3.8/dist-packages/eventlet/greenthread.py\", line 265, in main     result = function(*args, **kwargs)   File \"/usr/local/lib/python3.8/dist-packages/gunicorn/workers/geventlet.py\", line 156, in handle     client = ssl_wrap_socket(client, self.cfg)   File \"/usr/local/lib/python3.8/dist-packages/gunicorn/sock.py\", line 229, in ssl_wrap_socket     return ssl_context(conf).wrap_socket(sock,   File \"/usr/local/lib/python3.8/dist-packages/eventlet/green/ssl.py\", line 436, in wrap_socket     return GreenSSLSocket(sock, *a, _context=self, **kw)   File \"/usr/local/lib/python3.8/dist-packages/eventlet/green/ssl.py\", line 65, in __new__     ret = _original_sslsocket._create(   File \"/usr/lib/python3.8/ssl.py\", line 1031, in _create     notconn_pre_handshake_data = self.recv(1)   File \"/usr/lib/python3.8/ssl.py\", line 1257, in recv     return super().recv(buflen, flags) ConnectionResetError: [Errno 104] Connection reset by peer  Here is the server code, most likely it crashes on disconnection: https://pastebin.com/tSCS1d6a I'm running it with gunicorn, but the same used to hapen when i ran it like a normal flask app. This is on ubuntu. once the process is stopped and restarted, it works again fine, only to repeat after a few days again. I've tried running the whole thing with gunicorn using this command : gunicorn --workers 1 --worker-class eventlet --bind 0.0.0.0:5000 --certfile=/etc/ssl/chained.pem --keyfile=/etc/ssl/private/private-unencrypted.key --error-logfile ./error.txt --access-logfile ./access.txt RequestManager:app I've tried logging when the crash happens, seems to be on disconnection, but really not sure, cant pin point exactly. Tried a few other things, basically ran out of ideas, nothing seems to fix it.", "gold_terms": ["miguelgrinberg", "likely", "issue", "eventlet", "implementation", "isn", "much", "can", "done", "since", "not", "well", "maintained", "anymore", "try", "switching", "gevent"], "results": [{"rank": 1, "score": 0.6311138868331909, "raw_score": 0.6311138868331909, "source": "docs", "row": 296, "chunk_id": "ee584989051aa4550258d45bc09fe70085ea7013", "symbol_type": "doc", "qualname": "server.rst#Address already in use", "file_path": "d:\\499\\docs\\server.rst", "start_line": 38, "end_line": 81}, {"rank": 2, "score": 0.5739816427230835, "raw_score": 0.5739816427230835, "source": "docs", "row": 287, "chunk_id": "bc682ee3609a2936c4ea696a22dacab8d0d57289", "symbol_type": "doc", "qualname": "quickstart.rst#Logging", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 800, "end_line": 827}, {"rank": 3, "score": 0.5540814995765686, "raw_score": 0.5540814995765686, "source": "docs", "row": 124, "chunk_id": "9cd88f65edeb7f40e4d83398974810dbb4ae1e08", "symbol_type": "doc", "qualname": "errorhandling.rst#Handling Application Errors", "file_path": "d:\\499\\docs\\errorhandling.rst", "start_line": 2, "end_line": 28}, {"rank": 4, "score": 0.5406676530838013, "raw_score": 0.5406676530838013, "source": "docs", "row": 297, "chunk_id": "4d96a8ee446c573ce01df12d98ed3564b8b1649d", "symbol_type": "doc", "qualname": "server.rst#Deferred Errors on Reload", "file_path": "d:\\499\\docs\\server.rst", "start_line": 84, "end_line": 95}, {"rank": 5, "score": 0.5071492195129395, "raw_score": 0.5071492195129395, "source": "docs", "row": 53, "chunk_id": "7c6057c887265c80ccd7b81330d1dd730a8f2eab", "symbol_type": "doc", "qualname": "cli.rst#Debug Mode", "file_path": "d:\\499\\docs\\cli.rst", "start_line": 90, "end_line": 113}, {"rank": 6, "score": 0.5036072134971619, "raw_score": 0.5036072134971619, "source": "docs", "row": 130, "chunk_id": "e5ee69f66081dd9a463bc8a457cab1461a41f412", "symbol_type": "doc", "qualname": "errorhandling.rst#Unhandled Exceptions", "file_path": "d:\\499\\docs\\errorhandling.rst", "start_line": 238, "end_line": 256}, {"rank": 7, "score": 0.500977635383606, "raw_score": 0.500977635383606, "source": "flask", "row": 117, "chunk_id": "45e39c75627746e8d351af755ae300aeba86c26a", "symbol_type": "method", "qualname": "RequestContext.__init__", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\ctx.py", "start_line": 309, "end_line": 335}, {"rank": 8, "score": 0.4918456971645355, "raw_score": 0.4918456971645355, "source": "docs", "row": 52, "chunk_id": "378f31bce2d5c7ccd01d92e6eca860abf7766c18", "symbol_type": "doc", "qualname": "cli.rst#Run the Development Server", "file_path": "d:\\499\\docs\\cli.rst", "start_line": 69, "end_line": 87}, {"rank": 9, "score": 0.4886534810066223, "raw_score": 0.4886534810066223, "source": "docs", "row": 308, "chunk_id": "538a593ffb72d08cd947d1a2a57c19dca08e1131", "symbol_type": "doc", "qualname": "signals.rst#Signals and Flask's Request Context", "file_path": "d:\\499\\docs\\signals.rst", "start_line": 145, "end_line": 151}, {"rank": 10, "score": 0.48793402314186096, "raw_score": 0.48793402314186096, "source": "docs", "row": 93, "chunk_id": "4a3db41fd1376fb8d2ec5837b8abd6d3d71f7b8d", "symbol_type": "doc", "qualname": "deploying\\gunicorn.rst#Running", "file_path": "d:\\499\\docs\\deploying\\gunicorn.rst", "start_line": 40, "end_line": 72}]}
{"query": "Add support to enable asyncio REPL in `flask shell` command As flask and sqlalchemy have async support now, add support to enable asyncio REPL in flask shell command would be more convienient to test async code. Like python3 -m asyncio enables asyncio REPL, something like flask shell --async would make sense. What do you think?", "mode": "nl", "used_query": "Add support to enable asyncio REPL in `flask shell` command As flask and sqlalchemy have async support now, add support to enable asyncio REPL in flask shell command would be more convienient to test async code. Like python3 -m asyncio enables asyncio REPL, something like flask shell --async would make sense. What do you think?", "gold_terms": ["davidism", "how", "about", "the", "suggestion"], "results": [{"rank": 1, "score": 0.7229510545730591, "raw_score": 0.7229510545730591, "source": "docs", "row": 35, "chunk_id": "ecaab2df20aa28e0fe92572ac0cc8c360def1b9e", "symbol_type": "doc", "qualname": "async-await.rst#Other event loops", "file_path": "d:\\499\\docs\\async-await.rst", "start_line": 115, "end_line": 119}, {"rank": 2, "score": 0.6915391087532043, "raw_score": 0.6915391087532043, "source": "docs", "row": 151, "chunk_id": "8af2ad148a652cdef480f4ff2f16dad7de13e5d0", "symbol_type": "doc", "qualname": "gevent.rst#Combining with ``async``/``await``", "file_path": "d:\\499\\docs\\gevent.rst", "start_line": 65, "end_line": 101}, {"rank": 3, "score": 0.6821528673171997, "raw_score": 0.6821528673171997, "source": "docs", "row": 149, "chunk_id": "f46211c4e8bc19b3e2f696667dca6611056d8a30", "symbol_type": "doc", "qualname": "gevent.rst#Async with Gevent", "file_path": "d:\\499\\docs\\gevent.rst", "start_line": 2, "end_line": 20}, {"rank": 4, "score": 0.6698242425918579, "raw_score": 0.6698242425918579, "source": "docs", "row": 31, "chunk_id": "fdff1edd3e9666d9b6b9f0d4c9a461e6417a3ab9", "symbol_type": "doc", "qualname": "async-await.rst#Performance", "file_path": "d:\\499\\docs\\async-await.rst", "start_line": 28, "end_line": 46}, {"rank": 5, "score": 0.6649860143661499, "raw_score": 0.6649860143661499, "source": "docs", "row": 122, "chunk_id": "5a15fca0a9f5ebc8045161511b3edac905f90f49", "symbol_type": "doc", "qualname": "design.rst#Async/await and ASGI support", "file_path": "d:\\499\\docs\\design.rst", "start_line": 189, "end_line": 205}, {"rank": 6, "score": 0.6609654426574707, "raw_score": 0.6609654426574707, "source": "docs", "row": 32, "chunk_id": "d5b386bff847181b638984d32cfdd7bba4b20523", "symbol_type": "doc", "qualname": "async-await.rst#Background tasks", "file_path": "d:\\499\\docs\\async-await.rst", "start_line": 49, "end_line": 63}, {"rank": 7, "score": 0.6393939256668091, "raw_score": 0.6393939256668091, "source": "docs", "row": 33, "chunk_id": "ac56dbb89b157e864d8da212992c8453a27e9186", "symbol_type": "doc", "qualname": "async-await.rst#When to use Quart instead", "file_path": "d:\\499\\docs\\async-await.rst", "start_line": 66, "end_line": 84}, {"rank": 8, "score": 0.6274859309196472, "raw_score": 0.6274859309196472, "source": "flask", "row": 23, "chunk_id": "e2a8992d470f2f5d8aeb032069775543b6c8bedd", "symbol_type": "method", "qualname": "Flask.ensure_sync", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 966, "end_line": 978}, {"rank": 9, "score": 0.6239305138587952, "raw_score": 0.6239305138587952, "source": "docs", "row": 34, "chunk_id": "6785926419c0830535569cfd1a8a51fd86300fd2", "symbol_type": "doc", "qualname": "async-await.rst#Extensions", "file_path": "d:\\499\\docs\\async-await.rst", "start_line": 87, "end_line": 112}, {"rank": 10, "score": 0.6176617741584778, "raw_score": 0.6176617741584778, "source": "flask", "row": 24, "chunk_id": "29a5cbda72520e166e68f5b57bc15bfc7f15ef36", "symbol_type": "method", "qualname": "Flask.async_to_sync", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 980, "end_line": 1001}]}
{"query": "Optimisation in deployment I'm seeking optimization strategies for a Flask-based face recognition app using YOLO and DeepFace libraries. The app works fine on localhost but consistently hits memory limits on free-tier hosting services. What are the best practices to reduce memory usage in Flask apps with ML models? Looking for specific optimizations for resource-constrained platforms.", "mode": "nl", "used_query": "Optimisation in deployment I'm seeking optimization strategies for a Flask-based face recognition app using YOLO and DeepFace libraries. The app works fine on localhost but consistently hits memory limits on free-tier hosting services. What are the best practices to reduce memory usage in Flask apps with ML models? Looking for specific optimizations for resource-constrained platforms.", "gold_terms": ["using", "free", "hosting", "for", "and", "other", "compute", "heavy", "deployment", "would", "probably", "good", "idea", "sounds", "pretty", "much", "like", "case", "how", "optimize"], "results": [{"rank": 1, "score": 0.4654504060745239, "raw_score": 0.4654504060745239, "source": "docs", "row": 385, "chunk_id": "997670d9e824d562b79a247044201d7b0fe24c5c", "symbol_type": "doc", "qualname": "web-security.rst#Resource Use", "file_path": "d:\\499\\docs\\web-security.rst", "start_line": 13, "end_line": 42}, {"rank": 2, "score": 0.4635310173034668, "raw_score": 0.4635310173034668, "source": "docs", "row": 98, "chunk_id": "c3a73398d9e0ddebab835d00f33d11aa7c8b1121", "symbol_type": "doc", "qualname": "deploying\\index.rst#Hosting Platforms", "file_path": "d:\\499\\docs\\deploying\\index.rst", "start_line": 58, "end_line": 78}, {"rank": 3, "score": 0.45931339263916016, "raw_score": 0.45931339263916016, "source": "flask", "row": 375, "chunk_id": "aa7a37acd24116cf44872f6bc255ad4c5f589748", "symbol_type": "method", "qualname": "Request.max_form_memory_size", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\wrappers.py", "start_line": 93, "end_line": 113}, {"rank": 4, "score": 0.4098014235496521, "raw_score": 0.4098014235496521, "source": "docs", "row": 192, "chunk_id": "18f2cb1a8823484c743743f49355deb6c8476a45", "symbol_type": "doc", "qualname": "patterns\\caching.rst#Caching", "file_path": "d:\\499\\docs\\patterns\\caching.rst", "start_line": 2, "end_line": 16}, {"rank": 5, "score": 0.3769795298576355, "raw_score": 0.3769795298576355, "source": "docs", "row": 224, "chunk_id": "b8ba60a112ff513bbc44016e7bf2e8d2da12952b", "symbol_type": "doc", "qualname": "patterns\\lazyloading.rst#Lazily Loading Views", "file_path": "d:\\499\\docs\\patterns\\lazyloading.rst", "start_line": 2, "end_line": 17}, {"rank": 6, "score": 0.37210613489151, "raw_score": 0.37210613489151, "source": "docs", "row": 31, "chunk_id": "fdff1edd3e9666d9b6b9f0d4c9a461e6417a3ab9", "symbol_type": "doc", "qualname": "async-await.rst#Performance", "file_path": "d:\\499\\docs\\async-await.rst", "start_line": 28, "end_line": 46}, {"rank": 7, "score": 0.3682534396648407, "raw_score": 0.3682534396648407, "source": "docs", "row": 206, "chunk_id": "23c8923abb60b32b20d10843fdd1d0aa5dc0ce00", "symbol_type": "doc", "qualname": "patterns\\fileuploads.rst#Improving Uploads", "file_path": "d:\\499\\docs\\patterns\\fileuploads.rst", "start_line": 129, "end_line": 159}, {"rank": 8, "score": 0.35819873213768005, "raw_score": 0.35819873213768005, "source": "flask", "row": 376, "chunk_id": "b8777aec823ef8bb6d7b4459cb4690e9d1965abf", "symbol_type": "method", "qualname": "Request.max_form_memory_size", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\wrappers.py", "start_line": 116, "end_line": 117}, {"rank": 9, "score": 0.3581386208534241, "raw_score": 0.3581386208534241, "source": "docs", "row": 91, "chunk_id": "0c989282d37f066698328534d061d8c702f6a6b6", "symbol_type": "doc", "qualname": "deploying\\gunicorn.rst#Gunicorn", "file_path": "d:\\499\\docs\\deploying\\gunicorn.rst", "start_line": 2, "end_line": 19}, {"rank": 10, "score": 0.357683002948761, "raw_score": 0.357683002948761, "source": "docs", "row": 185, "chunk_id": "49b134f9ebbd20f7619b7b7925f523ecd470636d", "symbol_type": "doc", "qualname": "patterns\\appdispatch.rst#Dispatch by Subdomain", "file_path": "d:\\499\\docs\\patterns\\appdispatch.rst", "start_line": 61, "end_line": 131}]}
{"query": "Flask ready command is there any command to just type and create a basic flask app that show hello world or any thing like npm does?", "mode": "nl", "used_query": "Flask ready command is there any command to just type and create a basic flask app that show hello world or any thing like npm does?", "gold_terms": ["https", "github", "com", "pallets", "flask", "tab", "readme", "file", "simple", "example", "need", "for", "command", "generate"], "results": [{"rank": 1, "score": 0.6628580093383789, "raw_score": 0.6628580093383789, "source": "docs", "row": 268, "chunk_id": "32265fe033821f6fd6d33f0a542c4c317cae882f", "symbol_type": "doc", "qualname": "quickstart.rst#Quickstart", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 2, "end_line": 6}, {"rank": 2, "score": 0.6145097017288208, "raw_score": 0.6145097017288208, "source": "docs", "row": 290, "chunk_id": "ee45d5f39a617a698ea1c65b8963ce9274952b48", "symbol_type": "doc", "qualname": "quickstart.rst#Deploying to a Web Server", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 856, "end_line": 858}, {"rank": 3, "score": 0.6138128042221069, "raw_score": 0.6138128042221069, "source": "docs", "row": 55, "chunk_id": "6edb5f466b19c2b87bfbdac87279b61cc31f58cc", "symbol_type": "doc", "qualname": "cli.rst#Open a Shell", "file_path": "d:\\499\\docs\\cli.rst", "start_line": 134, "end_line": 149}, {"rank": 4, "score": 0.6068016290664673, "raw_score": 0.6068016290664673, "source": "docs", "row": 160, "chunk_id": "baa43f83a648d830e935b5d02b8c0fe11e43fb09", "symbol_type": "doc", "qualname": "installation.rst#Dependencies", "file_path": "d:\\499\\docs\\installation.rst", "start_line": 12, "end_line": 34}, {"rank": 5, "score": 0.6058582663536072, "raw_score": 0.6058582663536072, "source": "docs", "row": 347, "chunk_id": "71c79746b9867c6dbabab9891171822061b61f5e", "symbol_type": "doc", "qualname": "tutorial\\factory.rst#Run The Application", "file_path": "d:\\499\\docs\\tutorial\\factory.rst", "start_line": 126, "end_line": 162}, {"rank": 6, "score": 0.6047861576080322, "raw_score": 0.6047861576080322, "source": "docs", "row": 269, "chunk_id": "b8d264939f986dd785aa678ba5bdd6772ecf3dc9", "symbol_type": "doc", "qualname": "quickstart.rst#A Minimal Application", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 9, "end_line": 85}, {"rank": 7, "score": 0.6044795513153076, "raw_score": 0.6044795513153076, "source": "docs", "row": 154, "chunk_id": "5c61764df1218c3aa441416b0c8c6f78df40f6f8", "symbol_type": "doc", "qualname": "index.rst#Welcome to Flask", "file_path": "d:\\499\\docs\\index.rst", "start_line": 4, "end_line": 29}, {"rank": 8, "score": 0.5951293110847473, "raw_score": 0.5951293110847473, "source": "docs", "row": 295, "chunk_id": "e4f18a20b4a1164e02b26ae2409b163bd9dce51a", "symbol_type": "doc", "qualname": "server.rst#Command Line", "file_path": "d:\\499\\docs\\server.rst", "start_line": 19, "end_line": 35}, {"rank": 9, "score": 0.5859420299530029, "raw_score": 0.5859420299530029, "source": "docs", "row": 51, "chunk_id": "e70abab06484e05cc134f1a519904fa4c4b70dc5", "symbol_type": "doc", "qualname": "cli.rst#Application Discovery", "file_path": "d:\\499\\docs\\cli.rst", "start_line": 15, "end_line": 66}, {"rank": 10, "score": 0.582420289516449, "raw_score": 0.582420289516449, "source": "docs", "row": 353, "chunk_id": "3a18481600be3203bf2e73986e305292c8eb71d5", "symbol_type": "doc", "qualname": "tutorial\\next.rst#Keep Developing!", "file_path": "d:\\499\\docs\\tutorial\\next.rst", "start_line": 2, "end_line": 38}]}
{"query": "Clarify semantics of app context Thanks for building Flask! I'm one of the maintainers of https://github.com/google/mesop which is a Python UI framework built on Flask. Mesop uses g to maintain request-specific context (essentially the UI data for the current request), see call site example I read through the Flask docs and am not 100% sure whether this is an appropriate use of g. From https://flask.palletsprojects.com/en/3.0.x/api/#flask.g:  This is a good place to store resources during a request. For example, a before_request function could load a user object from a session id, then set g.user to be used in the view function.  This makes it sound like g is suitable as I'm trying to store information about the current request.  From https://flask.palletsprojects.com/en/3.0.x/appcontext/:  Flask automatically pushes an application context when handling a request  This suggests that an application context is always created inside the scope of a request. However, https://flask.palletsprojects.com/en/3.0.x/api/#flask.ctx.AppContext states:  An app context is created and pushed at the beginning of each request if one is not already active  This seems to suggest an application context is not always created inside the scope of a request. These two docs seem to contradict one another (or perhaps I'm mis-reading it). Any clarification would be helpful.  One of the complexities with our use case is that other developers are building on top of Mesop and could create app contexts, and I want to make sure that when I'm binding a value to g, it's to a local-specific app context and not some more global app context that persists across requests.", "mode": "nl", "used_query": "Clarify semantics of app context Thanks for building Flask! I'm one of the maintainers of https://github.com/google/mesop which is a Python UI framework built on Flask. Mesop uses g to maintain request-specific context (essentially the UI data for the current request), see call site example I read through the Flask docs and am not 100% sure whether this is an appropriate use of g. From https://flask.palletsprojects.com/en/3.0.x/api/#flask.g:  This is a good place to store resources during a request. For example, a before_request function could load a user object from a session id, then set g.user to be used in the view function.  This makes it sound like g is suitable as I'm trying to store information about the current request.  From https://flask.palletsprojects.com/en/3.0.x/appcontext/:  Flask automatically pushes an application context when handling a request  This suggests that an application context is always created inside the scope of a request. However, https://flask.palletsprojects.com/en/3.0.x/api/#flask.ctx.AppContext states:  An app context is created and pushed at the beginning of each request if one is not already active  This seems to suggest an application context is not always created inside the scope of a request. These two docs seem to contradict one another (or perhaps I'm mis-reading it). Any clarification would be helpful.  One of the complexities with our use case is that other developers are building on top of Mesop and could create app contexts, and I want to make sure that when I'm binding a value to g, it's to a local-specific app context and not some more global app context that persists across requests.", "gold_terms": ["davidism", "makes", "sound", "like", "suitable", "trying", "store", "information", "about", "the", "current", "request", "appropriate", "place", "per", "data", "extensions", "recommend", "using", "prefix"], "results": [{"rank": 1, "score": 0.718816339969635, "raw_score": 0.718816339969635, "source": "docs", "row": 9, "chunk_id": "ed3eba241917d57b514d27e353ec8ddbbf3be8a7", "symbol_type": "doc", "qualname": "api.rst#Application Globals", "file_path": "d:\\499\\docs\\api.rst", "start_line": 143, "end_line": 173}, {"rank": 2, "score": 0.7147520184516907, "raw_score": 0.7147520184516907, "source": "flask", "row": 107, "chunk_id": "32c789be2111e119757d9e206232be026a0831ee", "symbol_type": "function", "qualname": "copy_current_request_context", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\ctx.py", "start_line": 155, "end_line": 193}, {"rank": 3, "score": 0.69933021068573, "raw_score": 0.69933021068573, "source": "docs", "row": 300, "chunk_id": "0214abd7810c5ea8f57db9d9c1f42781339e6f50", "symbol_type": "doc", "qualname": "shell.rst#Creating a Request Context", "file_path": "d:\\499\\docs\\shell.rst", "start_line": 14, "end_line": 36}, {"rank": 4, "score": 0.6815147399902344, "raw_score": 0.6815147399902344, "source": "docs", "row": 28, "chunk_id": "d46cb22899d3684efcd3ef0f962c8af554355cae", "symbol_type": "doc", "qualname": "appcontext.rst#How the Context Works", "file_path": "d:\\499\\docs\\appcontext.rst", "start_line": 170, "end_line": 186}, {"rank": 5, "score": 0.6795021295547485, "raw_score": 0.6795021295547485, "source": "flask", "row": 31, "chunk_id": "9bf3192f1f49ac3d73bdd359b5b56bbc8e4f3c30", "symbol_type": "method", "qualname": "Flask.app_context", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 1386, "end_line": 1405}, {"rank": 6, "score": 0.6765525341033936, "raw_score": 0.6765525341033936, "source": "docs", "row": 26, "chunk_id": "cb02893fa7cd6c34657e299cbc40dbccc8548625", "symbol_type": "doc", "qualname": "appcontext.rst#Visibility of the Context", "file_path": "d:\\499\\docs\\appcontext.rst", "start_line": 116, "end_line": 142}, {"rank": 7, "score": 0.6658064126968384, "raw_score": 0.6658064126968384, "source": "docs", "row": 121, "chunk_id": "b43ac3f6c157ea171f5881d3563c8ef59655088c", "symbol_type": "doc", "qualname": "design.rst#Context Locals", "file_path": "d:\\499\\docs\\design.rst", "start_line": 173, "end_line": 186}, {"rank": 8, "score": 0.665446400642395, "raw_score": 0.665446400642395, "source": "flask", "row": 110, "chunk_id": "c6bd06a4228ee1a36ea4cf812254f29cd756fc90", "symbol_type": "class", "qualname": "AppContext", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\ctx.py", "start_line": 238, "end_line": 284}, {"rank": 9, "score": 0.6614675521850586, "raw_score": 0.6614675521850586, "source": "flask", "row": 116, "chunk_id": "715a991d5fe825b518d951270a4d8c14473662b2", "symbol_type": "class", "qualname": "RequestContext", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\ctx.py", "start_line": 287, "end_line": 449}, {"rank": 10, "score": 0.6613208055496216, "raw_score": 0.6613208055496216, "source": "docs", "row": 22, "chunk_id": "f8dd91a297c6172877e258fde6e4d1188369dd14", "symbol_type": "doc", "qualname": "appcontext.rst#The App and Request Context", "file_path": "d:\\499\\docs\\appcontext.rst", "start_line": 2, "end_line": 14}]}
{"query": "FLASK==3.0.3/ Werkzeug==3.0.0 Cannot import name 'url_quote' from 'werkzeug.urls' I keep getting the error:  Cannot import name 'url_quote' from 'werkzeug.urls'. I'm using python 3.12 I've tried the following combinations with no success: Flask==3.0.3 Werkzeug==3.0.0 Flask==2.2.2 Werkzeug==2.2.2 Flask == 2.0.1 Werkzeug==2.2.2 flask>=2.0 Werkzeug>=2.0 flask==2.01 Werkzeug==2.2.2 Please Help!", "mode": "nl", "used_query": "FLASK==3.0.3/ Werkzeug==3.0.0 Cannot import name 'url_quote' from 'werkzeug.urls' I keep getting the error:  Cannot import name 'url_quote' from 'werkzeug.urls'. I'm using python 3.12 I've tried the following combinations with no success: Flask==3.0.3 Werkzeug==3.0.0 Flask==2.2.2 Werkzeug==2.2.2 Flask == 2.0.1 Werkzeug==2.2.2 flask>=2.0 Werkzeug>=2.0 flask==2.01 Werkzeug==2.2.2 Please Help!", "gold_terms": ["davidism", "sure", "include", "minimal", "reproducible", "example", "including", "the", "full", "traceback", "you", "get", "error", "latest", "versions", "and", "not", "problem", "likely", "coming"], "results": [{"rank": 1, "score": 0.5112437605857849, "raw_score": 0.5112437605857849, "source": "docs", "row": 159, "chunk_id": "c916bf2a90d304338adda05defe498d0e1b9b21b", "symbol_type": "doc", "qualname": "installation.rst#Python Version", "file_path": "d:\\499\\docs\\installation.rst", "start_line": 6, "end_line": 9}, {"rank": 2, "score": 0.5091540813446045, "raw_score": 0.5091540813446045, "source": "docs", "row": 275, "chunk_id": "18525e4abf62011742a626cdc5bff3e9e69c4dff", "symbol_type": "doc", "qualname": "quickstart.rst#URL Building", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 238, "end_line": 291}, {"rank": 3, "score": 0.49240973591804504, "raw_score": 0.49240973591804504, "source": "docs", "row": 138, "chunk_id": "257993a06c3a4d454dfd31af7d0ee58bc6e4a38a", "symbol_type": "doc", "qualname": "extensiondev.rst#Naming", "file_path": "d:\\499\\docs\\extensiondev.rst", "start_line": 26, "end_line": 46}, {"rank": 4, "score": 0.491792768239975, "raw_score": 0.491792768239975, "source": "docs", "row": 257, "chunk_id": "63a7d675aae7727083cf4aa4e02c02193fb0b878", "symbol_type": "doc", "qualname": "patterns\\urlprocessors.rst#Internationalized Application URLs", "file_path": "d:\\499\\docs\\patterns\\urlprocessors.rst", "start_line": 17, "end_line": 96}, {"rank": 5, "score": 0.4838917553424835, "raw_score": 0.4838917553424835, "source": "flask", "row": 2, "chunk_id": "c423e295e7bf68c8d02a7cc0eb2d833f1a143969", "symbol_type": "method", "qualname": "Flask.__init__", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 226, "end_line": 279}, {"rank": 6, "score": 0.4823198616504669, "raw_score": 0.4823198616504669, "source": "docs", "row": 258, "chunk_id": "5edc3854bc6e299995a238306701c413b39ab299", "symbol_type": "doc", "qualname": "patterns\\urlprocessors.rst#Internationalized Blueprint URLs", "file_path": "d:\\499\\docs\\patterns\\urlprocessors.rst", "start_line": 99, "end_line": 126}, {"rank": 7, "score": 0.48082152009010315, "raw_score": 0.48082152009010315, "source": "flask", "row": 49, "chunk_id": "f50cd701612495d569c579c17a2b8eb9aabe6857", "symbol_type": "function", "qualname": "get_version", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\cli.py", "start_line": 267, "end_line": 280}, {"rank": 8, "score": 0.47645309567451477, "raw_score": 0.47645309567451477, "source": "flask", "row": 62, "chunk_id": "a73988ed626172b3de845c440c16f38334d8d609", "symbol_type": "method", "qualname": "FlaskGroup._load_plugin_commands", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\cli.py", "start_line": 600, "end_line": 615}, {"rank": 9, "score": 0.47033968567848206, "raw_score": 0.47033968567848206, "source": "flask", "row": 364, "chunk_id": "b83d2c9e4c0596eab5ff4660d4af20139e5a19a4", "symbol_type": "method", "qualname": "FlaskCliRunner.__init__", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\testing.py", "start_line": 271, "end_line": 273}, {"rank": 10, "score": 0.4666600227355957, "raw_score": 0.4666600227355957, "source": "docs", "row": 350, "chunk_id": "e1501ae4282754b42df1981c17f67bca4ad0a2ed", "symbol_type": "doc", "qualname": "tutorial\\install.rst#Describe the Project", "file_path": "d:\\499\\docs\\tutorial\\install.rst", "start_line": 28, "end_line": 51}]}
{"query": "Accessing and `flask.g` and `flask.current_app` in a `threading.Thread` I loop over a list and start a Thread. I don’t have access to flask.app and flask.g in the function executed by the Thread. I tried to pass app as a parameter with no success. Any idea? from flask import current_app as app  def my_function(app):   with app.app_context():         app.logger.info(\"Lorem ipsum\")  def enqueue_my_function(queue, app):     for chunk in my_function(app):         queue.put(chunk)     queue.put(None)  # ... Thread(target=enqueue_my_function, args=(queue, app)).start() I got this error:  RuntimeError: Working outside of application context. This typically means that you attempted to use functionality that needed the current application. To solve this, set up an application context with app.app_context(). See the documentation for more information.  I have read the documentation but still don’t understand the issue.", "mode": "nl", "used_query": "Accessing and `flask.g` and `flask.current_app` in a `threading.Thread` I loop over a list and start a Thread. I don’t have access to flask.app and flask.g in the function executed by the Thread. I tried to pass app as a parameter with no success. Any idea? from flask import current_app as app  def my_function(app):   with app.app_context():         app.logger.info(\"Lorem ipsum\")  def enqueue_my_function(queue, app):     for chunk in my_function(app):         queue.put(chunk)     queue.put(None)  # ... Thread(target=enqueue_my_function, args=(queue, app)).start() I got this error:  RuntimeError: Working outside of application context. This typically means that you attempted to use functionality that needed the current application. To solve this, set up an application context with app.app_context(). See the documentation for more information.  I have read the documentation but still don’t understand the issue.", "gold_terms": ["app", "_get_current_object", "instead", "current_app", "proxy", "thread", "local", "course", "won", "work", "accessed", "different", "aliasing", "and", "having", "function", "arg", "named", "well", "not"], "results": [{"rank": 1, "score": 0.644349992275238, "raw_score": 0.644349992275238, "source": "flask", "row": 31, "chunk_id": "9bf3192f1f49ac3d73bdd359b5b56bbc8e4f3c30", "symbol_type": "method", "qualname": "Flask.app_context", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 1386, "end_line": 1405}, {"rank": 2, "score": 0.6158590316772461, "raw_score": 0.6158590316772461, "source": "flask", "row": 65, "chunk_id": "f2086f01c303d1474f7c26c4de4301b78ef2e06b", "symbol_type": "method", "qualname": "FlaskGroup.make_context", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\cli.py", "start_line": 665, "end_line": 684}, {"rank": 3, "score": 0.5842093229293823, "raw_score": 0.5842093229293823, "source": "flask", "row": 110, "chunk_id": "c6bd06a4228ee1a36ea4cf812254f29cd756fc90", "symbol_type": "class", "qualname": "AppContext", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\ctx.py", "start_line": 238, "end_line": 284}, {"rank": 4, "score": 0.5799224972724915, "raw_score": 0.5799224972724915, "source": "docs", "row": 28, "chunk_id": "d46cb22899d3684efcd3ef0f962c8af554355cae", "symbol_type": "doc", "qualname": "appcontext.rst#How the Context Works", "file_path": "d:\\499\\docs\\appcontext.rst", "start_line": 170, "end_line": 186}, {"rank": 5, "score": 0.5796087980270386, "raw_score": 0.5796087980270386, "source": "flask", "row": 63, "chunk_id": "e204da37ebd24267a28ec1af53838c5f545bde0e", "symbol_type": "method", "qualname": "FlaskGroup.get_command", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\cli.py", "start_line": 617, "end_line": 642}, {"rank": 6, "score": 0.5715488791465759, "raw_score": 0.5715488791465759, "source": "docs", "row": 24, "chunk_id": "a7e5533b3cf46084f6b873b7cb5cd524bd3b4a79", "symbol_type": "doc", "qualname": "appcontext.rst#Context During Setup", "file_path": "d:\\499\\docs\\appcontext.rst", "start_line": 43, "end_line": 73}, {"rank": 7, "score": 0.5712661743164062, "raw_score": 0.5712661743164062, "source": "docs", "row": 121, "chunk_id": "b43ac3f6c157ea171f5881d3563c8ef59655088c", "symbol_type": "doc", "qualname": "design.rst#Context Locals", "file_path": "d:\\499\\docs\\design.rst", "start_line": 173, "end_line": 186}, {"rank": 8, "score": 0.5705642700195312, "raw_score": 0.5705642700195312, "source": "docs", "row": 26, "chunk_id": "cb02893fa7cd6c34657e299cbc40dbccc8548625", "symbol_type": "doc", "qualname": "appcontext.rst#Visibility of the Context", "file_path": "d:\\499\\docs\\appcontext.rst", "start_line": 116, "end_line": 142}, {"rank": 9, "score": 0.5686662793159485, "raw_score": 0.5686662793159485, "source": "flask", "row": 217, "chunk_id": "d8e1e548b0d74489e38636dd026adf46eb04032a", "symbol_type": "class", "qualname": "App", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "start_line": 59, "end_line": 964}, {"rank": 10, "score": 0.5624068975448608, "raw_score": 0.5624068975448608, "source": "docs", "row": 23, "chunk_id": "6f77919e51e6a19501f93f16ac94f08827e28d64", "symbol_type": "doc", "qualname": "appcontext.rst#Purpose of the Context", "file_path": "d:\\499\\docs\\appcontext.rst", "start_line": 17, "end_line": 40}]}
{"query": "Potential bad practice with secret key in tutorial example So, while looking at the tutorial, I noticed something odd: The page describing the secret key (https://flask.palletsprojects.com/en/3.0.x/config/#SECRET_KEY) says to not commit the secret key, but the tutorial puts the secret key in init.py, which is almost certainly gonna be commited.", "mode": "nl", "used_query": "Potential bad practice with secret key in tutorial example So, while looking at the tutorial, I noticed something odd: The page describing the secret key (https://flask.palletsprojects.com/en/3.0.x/config/#SECRET_KEY) says to not commit the secret key, but the tutorial puts the secret key in init.py, which is almost certainly gonna be commited.", "gold_terms": ["and", "per", "tradition", "think", "solution", "mere", "seconds", "after", "publishing", "question", "doesn", "really", "matter", "commited", "long", "the", "repo", "fully", "private", "you"], "results": [{"rank": 1, "score": 0.6062754392623901, "raw_score": 0.6062754392623901, "source": "docs", "row": 342, "chunk_id": "0dd7350ba6ee78a419bd1df973140130572dcc64", "symbol_type": "doc", "qualname": "tutorial\\deploy.rst#Configure the Secret Key", "file_path": "d:\\499\\docs\\tutorial\\deploy.rst", "start_line": 52, "end_line": 77}, {"rank": 2, "score": 0.5562065243721008, "raw_score": 0.5562065243721008, "source": "docs", "row": 66, "chunk_id": "1af46f9e0d144354ec6d066663eb27d53c5f6e3d", "symbol_type": "doc", "qualname": "config.rst#Configuration Handling", "file_path": "d:\\499\\docs\\config.rst", "start_line": 2, "end_line": 20}, {"rank": 3, "score": 0.5503069162368774, "raw_score": 0.5503069162368774, "source": "flask", "row": 332, "chunk_id": "483562af31495ad3bb3f913971f9167782c08c61", "symbol_type": "method", "qualname": "SecureCookieSessionInterface.get_signing_serializer", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sessions.py", "start_line": 317, "end_line": 335}, {"rank": 4, "score": 0.5058127641677856, "raw_score": 0.5058127641677856, "source": "docs", "row": 285, "chunk_id": "a40424ac744b8ce63e6fd2e158f036a550e94031", "symbol_type": "doc", "qualname": "quickstart.rst#Sessions", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 722, "end_line": 781}, {"rank": 5, "score": 0.48802638053894043, "raw_score": 0.48802638053894043, "source": "docs", "row": 5, "chunk_id": "8ba361a240d1982b668a83f8eeff69174b353f72", "symbol_type": "doc", "qualname": "api.rst#Sessions", "file_path": "d:\\499\\docs\\api.rst", "start_line": 54, "end_line": 90}, {"rank": 6, "score": 0.48163527250289917, "raw_score": 0.48163527250289917, "source": "docs", "row": 67, "chunk_id": "17462d178f1f4ced8d2d768ff3c462c0fdba3c0e", "symbol_type": "doc", "qualname": "config.rst#Configuration Basics", "file_path": "d:\\499\\docs\\config.rst", "start_line": 23, "end_line": 43}, {"rank": 7, "score": 0.477504163980484, "raw_score": 0.477504163980484, "source": "docs", "row": 210, "chunk_id": "7759d2dd99fb63306acc8abfa97428316d5f0744", "symbol_type": "doc", "qualname": "patterns\\flashing.rst#Simple Flashing", "file_path": "d:\\499\\docs\\patterns\\flashing.rst", "start_line": 15, "end_line": 89}, {"rank": 8, "score": 0.44546008110046387, "raw_score": 0.44546008110046387, "source": "flask", "row": 361, "chunk_id": "4bd022487b138746a39d12dc7ac7626f87038427", "symbol_type": "method", "qualname": "FlaskClient.__enter__", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\testing.py", "start_line": 249, "end_line": 253}, {"rank": 9, "score": 0.44427961111068726, "raw_score": 0.44427961111068726, "source": "flask", "row": 316, "chunk_id": "b57df4a39960c9ab68703424b773d6cee46d7920", "symbol_type": "class", "qualname": "SessionInterface", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sessions.py", "start_line": 114, "end_line": 284}, {"rank": 10, "score": 0.4362921714782715, "raw_score": 0.4362921714782715, "source": "flask", "row": 331, "chunk_id": "518bfe5b60d30c5ac4ccca9ba5e8482e02fec526", "symbol_type": "class", "qualname": "SecureCookieSessionInterface", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sessions.py", "start_line": 298, "end_line": 399}]}
{"query": "Rendering templates documentation edit I am working through the quickstart guide and testing out templates, and this code snippet confused me a bit: from flask import render_template  @app.route('/hello/') @app.route('/hello/<name>') def hello(name=None):     return render_template('hello.html', name=name) I wasn't sure why name=name was necessary. I learned that the first name is referring to the variable in the referenced html file: <!doctype html> <title>Hello from Flask</title> {% if name %}   <h1>Hello {{ name }}!</h1> {% else %}   <h1>Hello, World!</h1> {% endif %} This may be trivial, but since it confused me, I thought it might of confused others. I wanted to suggest something like this: @app.route(\"/hello/\") @app.route('/hello/<name>') def hello(name=None):     return render_template('hello.html', person=name) with the html file looking like this: <!doctype html> <title>Hello from Flask</title> {% if person %}   <h1>Hello {{ person }}!</h1> {% else %}   <h1>Hello, World!</h1> {% endif %} I think this helps differentiate the variable in the html file from the url variable. Let me know your thoughts. 😄", "mode": "nl", "used_query": "Rendering templates documentation edit I am working through the quickstart guide and testing out templates, and this code snippet confused me a bit: from flask import render_template  @app.route('/hello/') @app.route('/hello/<name>') def hello(name=None):     return render_template('hello.html', name=name) I wasn't sure why name=name was necessary. I learned that the first name is referring to the variable in the referenced html file: <!doctype html> <title>Hello from Flask</title> {% if name %}   <h1>Hello {{ name }}!</h1> {% else %}   <h1>Hello, World!</h1> {% endif %} This may be trivial, but since it confused me, I thought it might of confused others. I wanted to suggest something like this: @app.route(\"/hello/\") @app.route('/hello/<name>') def hello(name=None):     return render_template('hello.html', person=name) with the html file looking like this: <!doctype html> <title>Hello from Flask</title> {% if person %}   <h1>Hello {{ person }}!</h1> {% else %}   <h1>Hello, World!</h1> {% endif %} I think this helps differentiate the variable in the html file from the url variable. Let me know your thoughts. 😄", "gold_terms": ["davidism", "sense", "did", "you", "want", "make"], "results": [{"rank": 1, "score": 0.6881821751594543, "raw_score": 0.6881821751594543, "source": "flask", "row": 346, "chunk_id": "e351586ae65a21b1e22af5a270a3f86b39ca7f76", "symbol_type": "function", "qualname": "render_template", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\templating.py", "start_line": 138, "end_line": 150}, {"rank": 2, "score": 0.6411237120628357, "raw_score": 0.6411237120628357, "source": "docs", "row": 262, "chunk_id": "e7ada88a704079511a50b0c65d44167c0c3ae5df", "symbol_type": "doc", "qualname": "patterns\\viewdecorators.rst#Templating Decorator", "file_path": "d:\\499\\docs\\patterns\\viewdecorators.rst", "start_line": 104, "end_line": 154}, {"rank": 3, "score": 0.6283003091812134, "raw_score": 0.6283003091812134, "source": "docs", "row": 356, "chunk_id": "27158e3239abec0913fc276b7dee2b604593c5b8", "symbol_type": "doc", "qualname": "tutorial\\templates.rst#Templates", "file_path": "d:\\499\\docs\\tutorial\\templates.rst", "start_line": 4, "end_line": 36}, {"rank": 4, "score": 0.6169435977935791, "raw_score": 0.6169435977935791, "source": "docs", "row": 39, "chunk_id": "2f392c7f16d974dc397281032ba69ec80f5966e4", "symbol_type": "doc", "qualname": "blueprints.rst#My First Blueprint", "file_path": "d:\\499\\docs\\blueprints.rst", "start_line": 57, "end_line": 82}, {"rank": 5, "score": 0.6130531430244446, "raw_score": 0.6130531430244446, "source": "docs", "row": 278, "chunk_id": "41660faaae172031611b75193e99aa002ba35d76", "symbol_type": "doc", "qualname": "quickstart.rst#Rendering Templates", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 351, "end_line": 447}, {"rank": 6, "score": 0.6089675426483154, "raw_score": 0.6089675426483154, "source": "flask", "row": 347, "chunk_id": "e0abb03199cf3ed22e829042d98f4bf84f0b0c15", "symbol_type": "function", "qualname": "render_template_string", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\templating.py", "start_line": 153, "end_line": 162}, {"rank": 7, "score": 0.6056561470031738, "raw_score": 0.6056561470031738, "source": "docs", "row": 269, "chunk_id": "b8d264939f986dd785aa678ba5bdd6772ecf3dc9", "symbol_type": "doc", "qualname": "quickstart.rst#A Minimal Application", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 9, "end_line": 85}, {"rank": 8, "score": 0.6039997339248657, "raw_score": 0.6039997339248657, "source": "flask", "row": 139, "chunk_id": "2dfc5506835c0e29fedb2d69a219ff0373f24665", "symbol_type": "function", "qualname": "make_response", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\helpers.py", "start_line": 146, "end_line": 192}, {"rank": 9, "score": 0.6013126373291016, "raw_score": 0.6013126373291016, "source": "flask", "row": 349, "chunk_id": "aa7eca1418812afd79bcfefb95b8318615445f39", "symbol_type": "function", "qualname": "stream_template", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\templating.py", "start_line": 188, "end_line": 204}, {"rank": 10, "score": 0.5970944762229919, "raw_score": 0.5970944762229919, "source": "docs", "row": 311, "chunk_id": "6987818864195d742dc774c64b512a4f95692813", "symbol_type": "doc", "qualname": "templating.rst#Jinja Setup", "file_path": "d:\\499\\docs\\templating.rst", "start_line": 16, "end_line": 29}]}
{"query": "Support for jinja alternatives I suppose this have low chances to happen, but that might be fun to discuss though. I stumbled upon Armin Ronacher's minijinja project, that is a rewrite in Rust. The project announce to be kinda compatible with jinja  MiniJinja attempts a reasonably high level of compatibility with Jinja2, but it does not try to achieve this at all costs  I have noticed that jinja is sometimes the performance bottleneck, notably in unit tests, so the Rust rewrite looks appealing. Flask has a hard dependency towards jinja at the moment, but that would be awesome if it provided some kind of interface that could be filled either by jinja or minijinja. I suppose this would require a lot of work making the code generic, and I am not sure what would be the performance benefit in production environments, but that would be cool :) What do you think?", "mode": "nl", "used_query": "Support for jinja alternatives I suppose this have low chances to happen, but that might be fun to discuss though. I stumbled upon Armin Ronacher's minijinja project, that is a rewrite in Rust. The project announce to be kinda compatible with jinja  MiniJinja attempts a reasonably high level of compatibility with Jinja2, but it does not try to achieve this at all costs  I have noticed that jinja is sometimes the performance bottleneck, notably in unit tests, so the Rust rewrite looks appealing. Flask has a hard dependency towards jinja at the moment, but that would be awesome if it provided some kind of interface that could be filled either by jinja or minijinja. I suppose this would require a lot of work making the code generic, and I am not sure what would be the performance benefit in production environments, but that would be cool :) What do you think?", "gold_terms": ["davidism", "actually", "been", "thinking", "about", "for", "long", "time", "especially", "while", "was", "doing", "work", "last", "year", "move", "things", "like", "redirect", "and"], "results": [{"rank": 1, "score": 0.6320971250534058, "raw_score": 0.6320971250534058, "source": "docs", "row": 119, "chunk_id": "9fe7f246f4176762892a568e4eb8b269237d119f", "symbol_type": "doc", "qualname": "design.rst#One Template Engine", "file_path": "d:\\499\\docs\\design.rst", "start_line": 97, "end_line": 131}, {"rank": 2, "score": 0.5848748683929443, "raw_score": 0.5848748683929443, "source": "docs", "row": 310, "chunk_id": "0b6ba4a4a2cdacee407fe0ce504b1008b71f20ce", "symbol_type": "doc", "qualname": "templating.rst#Templates", "file_path": "d:\\499\\docs\\templating.rst", "start_line": 2, "end_line": 13}, {"rank": 3, "score": 0.5714852213859558, "raw_score": 0.5714852213859558, "source": "flask", "row": 7, "chunk_id": "e611ef2592e61ab0a6af35ffdcf2360f04187d56", "symbol_type": "method", "qualname": "Flask.create_jinja_environment", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 385, "end_line": 423}, {"rank": 4, "score": 0.5624944567680359, "raw_score": 0.5624944567680359, "source": "docs", "row": 314, "chunk_id": "fd13ff4b299856822476f1181bba24f08c16a634", "symbol_type": "doc", "qualname": "templating.rst#Registering Filters, Tests, and Globals", "file_path": "d:\\499\\docs\\templating.rst", "start_line": 141, "end_line": 191}, {"rank": 5, "score": 0.5421156287193298, "raw_score": 0.5421156287193298, "source": "docs", "row": 253, "chunk_id": "7aef91b2fbe92cd9e0955f2e3ad10b4de5e293d5", "symbol_type": "doc", "qualname": "patterns\\templateinheritance.rst#Template Inheritance", "file_path": "d:\\499\\docs\\patterns\\templateinheritance.rst", "start_line": 2, "end_line": 10}, {"rank": 6, "score": 0.5373106002807617, "raw_score": 0.5373106002807617, "source": "docs", "row": 154, "chunk_id": "5c61764df1218c3aa441416b0c8c6f78df40f6f8", "symbol_type": "doc", "qualname": "index.rst#Welcome to Flask", "file_path": "d:\\499\\docs\\index.rst", "start_line": 4, "end_line": 29}, {"rank": 7, "score": 0.5268699526786804, "raw_score": 0.5268699526786804, "source": "docs", "row": 311, "chunk_id": "6987818864195d742dc774c64b512a4f95692813", "symbol_type": "doc", "qualname": "templating.rst#Jinja Setup", "file_path": "d:\\499\\docs\\templating.rst", "start_line": 16, "end_line": 29}, {"rank": 8, "score": 0.5111614465713501, "raw_score": 0.5111614465713501, "source": "docs", "row": 312, "chunk_id": "a754d70a3bd281cac6bb7ae163f63f87b3d0de45", "symbol_type": "doc", "qualname": "templating.rst#Standard Context", "file_path": "d:\\499\\docs\\templating.rst", "start_line": 32, "end_line": 97}, {"rank": 9, "score": 0.5034230947494507, "raw_score": 0.5034230947494507, "source": "docs", "row": 160, "chunk_id": "baa43f83a648d830e935b5d02b8c0fe11e43fb09", "symbol_type": "doc", "qualname": "installation.rst#Dependencies", "file_path": "d:\\499\\docs\\installation.rst", "start_line": 12, "end_line": 34}, {"rank": 10, "score": 0.49606049060821533, "raw_score": 0.49606049060821533, "source": "flask", "row": 275, "chunk_id": "8e0ec1897600e6fbc6e4ac95b19400cb38009677", "symbol_type": "class", "qualname": "Scaffold", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "start_line": 52, "end_line": 698}]}
{"query": "How to get request's path with parameter not substituted? Hello, I hope your day is going well. I'm working with Flask endpoints that have parameters, e.g. @app.route(\"/prefix/<param>\", methods=[\"GET\"]). Suppose param can be a string. I'm looking for a way to access a current route's parametrized path, i.e. /prefix/<param>, not /prefix/abc. How can I do that? What would request.path return? Thank you.", "mode": "nl", "used_query": "How to get request's path with parameter not substituted? Hello, I hope your day is going well. I'm working with Flask endpoints that have parameters, e.g. @app.route(\"/prefix/<param>\", methods=[\"GET\"]). Suppose param can be a string. I'm looking for a way to access a current route's parametrized path, i.e. /prefix/<param>, not /prefix/abc. How can I do that? What would request.path return? Thank you.", "gold_terms": ["davidism", "request", "url_rul", "contains", "the", "matched", "object", "https", "werkzeug", "palletsprojects", "com", "routing"], "results": [{"rank": 1, "score": 0.6177868843078613, "raw_score": 0.6177868843078613, "source": "flask", "row": 140, "chunk_id": "2c28428d21c93787734ea32bd8841a8913bbac5b", "symbol_type": "function", "qualname": "url_for", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\helpers.py", "start_line": 195, "end_line": 246}, {"rank": 2, "score": 0.5880258679389954, "raw_score": 0.5880258679389954, "source": "docs", "row": 19, "chunk_id": "a695150ab80429420b93aaa65773c3ae5290c3e4", "symbol_type": "doc", "qualname": "api.rst#URL Route Registrations", "file_path": "d:\\499\\docs\\api.rst", "start_line": 530, "end_line": 638}, {"rank": 3, "score": 0.5856825113296509, "raw_score": 0.5856825113296509, "source": "flask", "row": 25, "chunk_id": "c4c7c245f4b73f8fcff8da307b57b288f69b477d", "symbol_type": "method", "qualname": "Flask.url_for", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 1003, "end_line": 1127}, {"rank": 4, "score": 0.5728756785392761, "raw_score": 0.5728756785392761, "source": "docs", "row": 272, "chunk_id": "7d1019f76b38b9cdbbb008c08f4b1fa63c4496b3", "symbol_type": "doc", "qualname": "quickstart.rst#Routing", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 155, "end_line": 172}, {"rank": 5, "score": 0.5713660717010498, "raw_score": 0.5713660717010498, "source": "flask", "row": 291, "chunk_id": "5459d1828a8ff0c86a4589cf51f5570b17081caa", "symbol_type": "method", "qualname": "Scaffold.route", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "start_line": 336, "end_line": 365}, {"rank": 6, "score": 0.5376443862915039, "raw_score": 0.5376443862915039, "source": "flask", "row": 292, "chunk_id": "7babe777293f2a8cca496c96ddc8706eede1c771", "symbol_type": "method", "qualname": "Scaffold.add_url_rule", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\scaffold.py", "start_line": 368, "end_line": 433}, {"rank": 7, "score": 0.5355588793754578, "raw_score": 0.5355588793754578, "source": "flask", "row": 233, "chunk_id": "aa6e127f5bc80dd25610dae68a6cf424845b75e2", "symbol_type": "method", "qualname": "App.add_url_rule", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "start_line": 605, "end_line": 661}, {"rank": 8, "score": 0.5329008102416992, "raw_score": 0.5329008102416992, "source": "flask", "row": 124, "chunk_id": "db094e0b9eca5a80f0e76be1578b2eaea04c2e4f", "symbol_type": "method", "qualname": "RequestContext.__repr__", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\ctx.py", "start_line": 445, "end_line": 449}, {"rank": 9, "score": 0.5310322046279907, "raw_score": 0.5310322046279907, "source": "docs", "row": 257, "chunk_id": "63a7d675aae7727083cf4aa4e02c02193fb0b878", "symbol_type": "doc", "qualname": "patterns\\urlprocessors.rst#Internationalized Application URLs", "file_path": "d:\\499\\docs\\patterns\\urlprocessors.rst", "start_line": 17, "end_line": 96}, {"rank": 10, "score": 0.5292782783508301, "raw_score": 0.5292782783508301, "source": "flask", "row": 372, "chunk_id": "09f37e17fa8339f46a595a3965f217d0ba50f69f", "symbol_type": "class", "qualname": "Request", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\wrappers.py", "start_line": 18, "end_line": 219}]}
{"query": "Unable to silence logging messages Im getting ~15 of:  127.0.0.1 - - [16/Mar/2024 12:10:13] \"POST / HTTP/1.1\" 200 -  in the terminal when Im running a Dash application. server = flask.Flask(__name__) app = dash.Dash(     __name__,     server=server,     external_stylesheets=[dbc.themes.BOOTSTRAP],     meta_tags=[         {\"name\": \"viewport\", \"content\": \"width=device-width, initial-scale=1\"}     ], )  (https://github.com/AlexKurek/srt-py/blob/master/srt/dashboard/app.py#L53) How do I silence them? I have found a lot of methods, e.g. Disable console messages in Flask server, but none of them worked. My guess is that since they worked in previous versions of Flask - could this be a regression? Environment:  Python version: 3.11 Flask version: 3.0.2", "mode": "nl", "used_query": "Unable to silence logging messages Im getting ~15 of:  127.0.0.1 - - [16/Mar/2024 12:10:13] \"POST / HTTP/1.1\" 200 -  in the terminal when Im running a Dash application. server = flask.Flask(__name__) app = dash.Dash(     __name__,     server=server,     external_stylesheets=[dbc.themes.BOOTSTRAP],     meta_tags=[         {\"name\": \"viewport\", \"content\": \"width=device-width, initial-scale=1\"}     ], )  (https://github.com/AlexKurek/srt-py/blob/master/srt/dashboard/app.py#L53) How do I silence them? I have found a lot of methods, e.g. Disable console messages in Flask server, but none of them worked. My guess is that since they worked in previous versions of Flask - could this be a regression? Environment:  Python version: 3.11 Flask version: 3.0.2", "gold_terms": ["codespearhead", "jtrip", "the", "application", "server", "doing", "logging", "which", "wsgi", "are", "you", "using", "see", "how", "limit", "tried", "silence", "level", "resolves", "issue"], "results": [{"rank": 1, "score": 0.6121103763580322, "raw_score": 0.6121103763580322, "source": "docs", "row": 287, "chunk_id": "bc682ee3609a2936c4ea696a22dacab8d0d57289", "symbol_type": "doc", "qualname": "quickstart.rst#Logging", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 800, "end_line": 827}, {"rank": 2, "score": 0.5846428275108337, "raw_score": 0.5846428275108337, "source": "flask", "row": 221, "chunk_id": "5fe8320f7fc9c7430b83b0dc0cf9a69a1894f558", "symbol_type": "method", "qualname": "App.logger", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "start_line": 443, "end_line": 467}, {"rank": 3, "score": 0.580997884273529, "raw_score": 0.580997884273529, "source": "flask", "row": 134, "chunk_id": "63db3c63eb844efcaf3eae34b35ecc7b558cf471", "symbol_type": "function", "qualname": "get_debug_flag", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\helpers.py", "start_line": 28, "end_line": 33}, {"rank": 4, "score": 0.5759087800979614, "raw_score": 0.5759087800979614, "source": "docs", "row": 53, "chunk_id": "7c6057c887265c80ccd7b81330d1dd730a8f2eab", "symbol_type": "doc", "qualname": "cli.rst#Debug Mode", "file_path": "d:\\499\\docs\\cli.rst", "start_line": 90, "end_line": 113}, {"rank": 5, "score": 0.575613260269165, "raw_score": 0.575613260269165, "source": "flask", "row": 69, "chunk_id": "3ab8b20264e0770e4174bef46bd5c41a7679a93c", "symbol_type": "function", "qualname": "show_server_banner", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\cli.py", "start_line": 774, "end_line": 785}, {"rank": 6, "score": 0.5735602378845215, "raw_score": 0.5735602378845215, "source": "docs", "row": 176, "chunk_id": "4efedcdafd1d1c71c90a3051d60fd223352012ba", "symbol_type": "doc", "qualname": "logging.rst#Removing the Default Handler", "file_path": "d:\\499\\docs\\logging.rst", "start_line": 70, "end_line": 79}, {"rank": 7, "score": 0.5707352161407471, "raw_score": 0.5707352161407471, "source": "flask", "row": 18, "chunk_id": "88bbad3e43d6d66bf08330bdfc3846ee0592fccf", "symbol_type": "method", "qualname": "Flask.log_exception", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 864, "end_line": 877}, {"rank": 8, "score": 0.5643131136894226, "raw_score": 0.5643131136894226, "source": "docs", "row": 173, "chunk_id": "8218f038803ca6014814850e18cd01f4d9dec5e4", "symbol_type": "doc", "qualname": "logging.rst#Logging", "file_path": "d:\\499\\docs\\logging.rst", "start_line": 2, "end_line": 25}, {"rank": 9, "score": 0.5499672293663025, "raw_score": 0.5499672293663025, "source": "flask", "row": 215, "chunk_id": "6e023e4429a8ec6db84f2c69d5775ec9364a3423", "symbol_type": "function", "qualname": "create_logger", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\logging.py", "start_line": 58, "end_line": 79}, {"rank": 10, "score": 0.5427566766738892, "raw_score": 0.5427566766738892, "source": "docs", "row": 175, "chunk_id": "7694aeb491b2c39d0ac91418fe7458cdb82cc427", "symbol_type": "doc", "qualname": "logging.rst#Default Configuration", "file_path": "d:\\499\\docs\\logging.rst", "start_line": 60, "end_line": 67}]}
{"query": "Does Flask suffer of the problem of useless order by on some ORM prefetches ? Hello, Recently I found a problem with Django and submitted a patch in a PR: https://code.djangoproject.com/ticket/35309 django/django#17984 I also developped a work-around for old versions of Django: https://github.com/LLyaudet/django-monkey-patches/blob/main/src/django_monkey_patches/django__orm__prefetch_without_useless_order_by.py I don't know yet Flask details. The idea is just that some models can have a default ordering (I assume this functionality is present in Flask also). And that some ORM may still add this ordering in the SQL query whilst it is not needed because only a single object will be prefetched per instance of the original result set. On very big prefetches I noticed a gain of 10 - 15 %, since the rest of the DB query is mainly an index scan. #ClimateChangeBrake Can someone please dump the queries of such prefetches and see if the bug is present in Flask ? If so submitting a PR should not be too hard. I will try to help. But right now, I start by warning the frameworks ORM I am aware of :) Best regards, Laurent Lyaudet", "mode": "nl", "used_query": "Does Flask suffer of the problem of useless order by on some ORM prefetches ? Hello, Recently I found a problem with Django and submitted a patch in a PR: https://code.djangoproject.com/ticket/35309 django/django#17984 I also developped a work-around for old versions of Django: https://github.com/LLyaudet/django-monkey-patches/blob/main/src/django_monkey_patches/django__orm__prefetch_without_useless_order_by.py I don't know yet Flask details. The idea is just that some models can have a default ordering (I assume this functionality is present in Flask also). And that some ORM may still add this ordering in the SQL query whilst it is not needed because only a single object will be prefetched per instance of the original result set. On very big prefetches I noticed a gain of 10 - 15 %, since the rest of the DB query is mainly an index scan. #ClimateChangeBrake Can someone please dump the queries of such prefetches and see if the bug is present in Flask ? If so submitting a PR should not be too hard. I will try to help. But right now, I start by warning the frameworks ORM I am aware of :) Best regards, Laurent Lyaudet", "gold_terms": ["does", "not", "contain", "probably", "question", "ordering", "all", "default", "whatever", "order", "the", "gives", "you", "and", "use", "order_by", "create", "level"], "results": [{"rank": 1, "score": 0.48298895359039307, "raw_score": 0.48298895359039307, "source": "flask", "row": 27, "chunk_id": "fc04b2d3a88118c3b5de34b26c1e275c3303e82d", "symbol_type": "method", "qualname": "Flask.preprocess_request", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 1271, "end_line": 1296}, {"rank": 2, "score": 0.4710460901260376, "raw_score": 0.4710460901260376, "source": "flask", "row": 272, "chunk_id": "6191cddbe7cb97660d4272b5315e9df7db50b0ec", "symbol_type": "method", "qualname": "Blueprint.app_url_value_preprocessor", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "start_line": 613, "end_line": 622}, {"rank": 3, "score": 0.46817660331726074, "raw_score": 0.46817660331726074, "source": "docs", "row": 123, "chunk_id": "94c2427bde16839b0ed5e4c2139f9df3c96ff219", "symbol_type": "doc", "qualname": "design.rst#What Flask is, What Flask is Not", "file_path": "d:\\499\\docs\\design.rst", "start_line": 208, "end_line": 229}, {"rank": 4, "score": 0.46222054958343506, "raw_score": 0.46222054958343506, "source": "flask", "row": 20, "chunk_id": "473700e2ea48267590c7dd6e75f501ae1186b288", "symbol_type": "method", "qualname": "Flask.full_dispatch_request", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 904, "end_line": 920}, {"rank": 5, "score": 0.46200257539749146, "raw_score": 0.46200257539749146, "source": "docs", "row": 239, "chunk_id": "9ee9e4ace90f971332a02c54d36ef9570ba774b9", "symbol_type": "doc", "qualname": "patterns\\sqlalchemy.rst#SQLAlchemy in Flask", "file_path": "d:\\499\\docs\\patterns\\sqlalchemy.rst", "start_line": 2, "end_line": 10}, {"rank": 6, "score": 0.4613286256790161, "raw_score": 0.4613286256790161, "source": "flask", "row": 267, "chunk_id": "d0e25a3bd2b4e073ff754483036396a315715c1b", "symbol_type": "method", "qualname": "Blueprint.before_app_request", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\blueprints.py", "start_line": 554, "end_line": 561}, {"rank": 7, "score": 0.45867717266082764, "raw_score": 0.45867717266082764, "source": "docs", "row": 192, "chunk_id": "18f2cb1a8823484c743743f49355deb6c8476a45", "symbol_type": "doc", "qualname": "patterns\\caching.rst#Caching", "file_path": "d:\\499\\docs\\patterns\\caching.rst", "start_line": 2, "end_line": 16}, {"rank": 8, "score": 0.4440177381038666, "raw_score": 0.4440177381038666, "source": "docs", "row": 252, "chunk_id": "68527413c64da978356dd835ff5cd413c6b84016", "symbol_type": "doc", "qualname": "patterns\\subclassing.rst#Subclassing Flask", "file_path": "d:\\499\\docs\\patterns\\subclassing.rst", "start_line": 2, "end_line": 17}, {"rank": 9, "score": 0.44339317083358765, "raw_score": 0.44339317083358765, "source": "docs", "row": 213, "chunk_id": "e235ce7063009d26a8beb4c1869692c6dce400ad", "symbol_type": "doc", "qualname": "patterns\\index.rst#Patterns for Flask", "file_path": "d:\\499\\docs\\patterns\\index.rst", "start_line": 2, "end_line": 40}, {"rank": 10, "score": 0.43808913230895996, "raw_score": 0.43808913230895996, "source": "docs", "row": 385, "chunk_id": "997670d9e824d562b79a247044201d7b0fe24c5c", "symbol_type": "doc", "qualname": "web-security.rst#Resource Use", "file_path": "d:\\499\\docs\\web-security.rst", "start_line": 13, "end_line": 42}]}
{"query": "KeyError-  KeyError: 'name' Traceback (most recent call last): File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\flask\\app.py\", line 2213, in call return self.wsgi_app(environ, start_response) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\flask\\app.py\", line 2193, in wsgi_app response = self.handle_exception(e) ^^^^^^^^^^^^^^^^^^^^^^^^ File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\flask\\app.py\", line 2190, in wsgi_app response = self.full_dispatch_request() ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\flask\\app.py\", line 1486, in full_dispatch_request rv = self.handle_user_exception(e) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\flask\\app.py\", line 1484, in full_dispatch_request rv = self.dispatch_request() ^^^^^^^^^^^^^^^^^^^^^^^ File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\flask\\app.py\", line 1469, in dispatch_request return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File \"d:\\root\\main.py\", line 73, in dashboard if session['name']: ^^^^^^^^^^^^^^^^ File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\flask\\sessions.py\", line 79, in getitem return super().getitem(key) ^^^^^^^^^^^^^^^^^^^^^^^^ KeyError: 'name @app.route('/dashboard/') def dashboard():     if session['name']:         return render_template('dashboard.html')              return redirect('/login')", "mode": "nl", "used_query": "KeyError-  KeyError: 'name' Traceback (most recent call last): File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\flask\\app.py\", line 2213, in call return self.wsgi_app(environ, start_response) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\flask\\app.py\", line 2193, in wsgi_app response = self.handle_exception(e) ^^^^^^^^^^^^^^^^^^^^^^^^ File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\flask\\app.py\", line 2190, in wsgi_app response = self.full_dispatch_request() ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\flask\\app.py\", line 1486, in full_dispatch_request rv = self.handle_user_exception(e) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\flask\\app.py\", line 1484, in full_dispatch_request rv = self.dispatch_request() ^^^^^^^^^^^^^^^^^^^^^^^ File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\flask\\app.py\", line 1469, in dispatch_request return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File \"d:\\root\\main.py\", line 73, in dashboard if session['name']: ^^^^^^^^^^^^^^^^ File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\flask\\sessions.py\", line 79, in getitem return super().getitem(key) ^^^^^^^^^^^^^^^^^^^^^^^^ KeyError: 'name @app.route('/dashboard/') def dashboard():     if session['name']:         return render_template('dashboard.html')              return redirect('/login')", "gold_terms": ["davidism", "common", "problem", "unrelated", "you", "not", "sure", "key", "name", "dict", "session", "should", "use", "check", "get", "which", "return", "rather", "than", "error"], "results": [{"rank": 1, "score": 0.6585335731506348, "raw_score": 0.6585335731506348, "source": "flask", "row": 34, "chunk_id": "b7e02446548217dced3f45ac401c3c15882e4d7d", "symbol_type": "method", "qualname": "Flask.wsgi_app", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 1479, "end_line": 1527}, {"rank": 2, "score": 0.6409414410591125, "raw_score": 0.6409414410591125, "source": "flask", "row": 217, "chunk_id": "d8e1e548b0d74489e38636dd026adf46eb04032a", "symbol_type": "class", "qualname": "App", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "start_line": 59, "end_line": 964}, {"rank": 3, "score": 0.6325151920318604, "raw_score": 0.6325151920318604, "source": "docs", "row": 101, "chunk_id": "14e555849e748a78223340e1bc6ada4bd238c410", "symbol_type": "doc", "qualname": "deploying\\mod_wsgi.rst#Running", "file_path": "d:\\499\\docs\\deploying\\mod_wsgi.rst", "start_line": 43, "end_line": 76}, {"rank": 4, "score": 0.6273453235626221, "raw_score": 0.6273453235626221, "source": "flask", "row": 35, "chunk_id": "391c659be1f74afdd0355c289e3478c46cb744fd", "symbol_type": "method", "qualname": "Flask.__call__", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 1529, "end_line": 1536}, {"rank": 5, "score": 0.6270419359207153, "raw_score": 0.6270419359207153, "source": "flask", "row": 1, "chunk_id": "c77125a1db681ef277cc41ff81832fc28a2878b3", "symbol_type": "class", "qualname": "Flask", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 81, "end_line": 1536}, {"rank": 6, "score": 0.6256121397018433, "raw_score": 0.6256121397018433, "source": "docs", "row": 269, "chunk_id": "b8d264939f986dd785aa678ba5bdd6772ecf3dc9", "symbol_type": "doc", "qualname": "quickstart.rst#A Minimal Application", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 9, "end_line": 85}, {"rank": 7, "score": 0.6205276250839233, "raw_score": 0.6205276250839233, "source": "flask", "row": 51, "chunk_id": "bb8b373c6e3748c380c1afe8fda418f0c16084d3", "symbol_type": "method", "qualname": "ScriptInfo.__init__", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\cli.py", "start_line": 305, "end_line": 331}, {"rank": 8, "score": 0.619083046913147, "raw_score": 0.619083046913147, "source": "flask", "row": 117, "chunk_id": "45e39c75627746e8d351af755ae300aeba86c26a", "symbol_type": "method", "qualname": "RequestContext.__init__", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\ctx.py", "start_line": 309, "end_line": 335}, {"rank": 9, "score": 0.6170486807823181, "raw_score": 0.6170486807823181, "source": "docs", "row": 51, "chunk_id": "e70abab06484e05cc134f1a519904fa4c4b70dc5", "symbol_type": "doc", "qualname": "cli.rst#Application Discovery", "file_path": "d:\\499\\docs\\cli.rst", "start_line": 15, "end_line": 66}, {"rank": 10, "score": 0.5927751660346985, "raw_score": 0.5927751660346985, "source": "flask", "row": 65, "chunk_id": "f2086f01c303d1474f7c26c4de4301b78ef2e06b", "symbol_type": "method", "qualname": "FlaskGroup.make_context", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\cli.py", "start_line": 665, "end_line": 684}]}
{"query": "AttributeError: AttributeError: 'str' object has no attribute 'decode' Traceback (most recent call last):   File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\flask\\app.py\", line 2213, in __call__     return self.wsgi_app(environ, start_response)            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\flask\\app.py\", line 2193, in wsgi_app     response = self.handle_exception(e)                ^^^^^^^^^^^^^^^^^^^^^^^^   File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\flask\\app.py\", line 2190, in wsgi_app     response = self.full_dispatch_request()                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\flask\\app.py\", line 1486, in full_dispatch_request     rv = self.handle_user_exception(e)          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\flask\\app.py\", line 1484, in full_dispatch_request     rv = self.dispatch_request()          ^^^^^^^^^^^^^^^^^^^^^^^   File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\flask\\app.py\", line 1469, in dispatch_request     return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"d:\\root\\main.py\", line 56, in register     New_User = User(email=email, name=name, password=password)                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"<string>\", line 4, in __init__   File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\sqlalchemy\\orm\\state.py\", line 566, in _initialize_instance     with util.safe_reraise():   File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\sqlalchemy\\util\\langhelpers.py\", line 147, in __exit__     raise exc_value.with_traceback(exc_tb)   File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\sqlalchemy\\orm\\state.py\", line 564, in _initialize_instance     manager.original_init(*mixed[1:], **kwargs)   File \"d:\\root\\main.py\", line 20, in __init__     self.password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt(password.decode('utf-8')))                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^ AttributeError: 'str' object has no attribute 'decode'  Code: from flask import * from flask_sqlalchemy import SQLAlchemy import bcrypt  app = Flask(__name__)  app.config['SQLALCHEMY_DATABASE_URI'] ='sqlite:///database.db'  db = SQLAlchemy(app) app.secret_key = 'server_secret'  class User(db.Model):     id = db.Column(db.Integer, primary_key=True)     name = db.Column(db.String(100), nullable=False)      email = db.Column(db.String(100), unique=True)     password = db.Column(db.String(100))      def __init__(self, email, password, name):         self.name = name         self.email = email         self.password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt(password.decode('utf-8')))     def check_password(self, password):         return bcrypt.checkpw(password.encode('utf-8'), self.password.encode('utf-8'))  with app.app_context():     db.create_all()   @app.route('/') def home():     return render_template('index.html')  @app.route('/about/') def about():     return render_template('about.html')  @app.route('/login/', methods=['POST', 'GET']) def login():     if request.method == 'POST':         email = request.form['email']         password = request.form['password']          user = User.query.filter_by(email=email).first()         if user and user.check_password(password):             return redirect(url_for('dashboard'))         else:             return redirect(url_for('login'), error='Invalid password or email')  @app.route('/register/', methods=['POST', 'GET']) def register():     if request.method == 'POST':         name = request.form['name']         email = request.form['email']         password = request.form['password']          New_User = User(email=email, name=name, password=password)         db.session.add(New_User)         db.session.commit()          return redirect(url_for('login'))          return render_template('register.html')  app.run(debug=True, port=5500)", "mode": "nl", "used_query": "AttributeError: AttributeError: 'str' object has no attribute 'decode' Traceback (most recent call last):   File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\flask\\app.py\", line 2213, in __call__     return self.wsgi_app(environ, start_response)            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\flask\\app.py\", line 2193, in wsgi_app     response = self.handle_exception(e)                ^^^^^^^^^^^^^^^^^^^^^^^^   File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\flask\\app.py\", line 2190, in wsgi_app     response = self.full_dispatch_request()                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\flask\\app.py\", line 1486, in full_dispatch_request     rv = self.handle_user_exception(e)          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\flask\\app.py\", line 1484, in full_dispatch_request     rv = self.dispatch_request()          ^^^^^^^^^^^^^^^^^^^^^^^   File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\flask\\app.py\", line 1469, in dispatch_request     return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"d:\\root\\main.py\", line 56, in register     New_User = User(email=email, name=name, password=password)                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File \"<string>\", line 4, in __init__   File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\sqlalchemy\\orm\\state.py\", line 566, in _initialize_instance     with util.safe_reraise():   File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\sqlalchemy\\util\\langhelpers.py\", line 147, in __exit__     raise exc_value.with_traceback(exc_tb)   File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\sqlalchemy\\orm\\state.py\", line 564, in _initialize_instance     manager.original_init(*mixed[1:], **kwargs)   File \"d:\\root\\main.py\", line 20, in __init__     self.password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt(password.decode('utf-8')))                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^ AttributeError: 'str' object has no attribute 'decode'  Code: from flask import * from flask_sqlalchemy import SQLAlchemy import bcrypt  app = Flask(__name__)  app.config['SQLALCHEMY_DATABASE_URI'] ='sqlite:///database.db'  db = SQLAlchemy(app) app.secret_key = 'server_secret'  class User(db.Model):     id = db.Column(db.Integer, primary_key=True)     name = db.Column(db.String(100), nullable=False)      email = db.Column(db.String(100), unique=True)     password = db.Column(db.String(100))      def __init__(self, email, password, name):         self.name = name         self.email = email         self.password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt(password.decode('utf-8')))     def check_password(self, password):         return bcrypt.checkpw(password.encode('utf-8'), self.password.encode('utf-8'))  with app.app_context():     db.create_all()   @app.route('/') def home():     return render_template('index.html')  @app.route('/about/') def about():     return render_template('about.html')  @app.route('/login/', methods=['POST', 'GET']) def login():     if request.method == 'POST':         email = request.form['email']         password = request.form['password']          user = User.query.filter_by(email=email).first()         if user and user.check_password(password):             return redirect(url_for('dashboard'))         else:             return redirect(url_for('login'), error='Invalid password or email')  @app.route('/register/', methods=['POST', 'GET']) def register():     if request.method == 'POST':         name = request.form['name']         email = request.form['email']         password = request.form['password']          New_User = User(email=email, name=name, password=password)         db.session.add(New_User)         db.session.commit()          return redirect(url_for('login'))          return render_template('register.html')  app.run(debug=True, port=5500)", "gold_terms": ["want", "encode", "and", "not", "decode"], "results": [{"rank": 1, "score": 0.6174537539482117, "raw_score": 0.6174537539482117, "source": "flask", "row": 34, "chunk_id": "b7e02446548217dced3f45ac401c3c15882e4d7d", "symbol_type": "method", "qualname": "Flask.wsgi_app", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 1479, "end_line": 1527}, {"rank": 2, "score": 0.612994909286499, "raw_score": 0.612994909286499, "source": "flask", "row": 51, "chunk_id": "bb8b373c6e3748c380c1afe8fda418f0c16084d3", "symbol_type": "method", "qualname": "ScriptInfo.__init__", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\cli.py", "start_line": 305, "end_line": 331}, {"rank": 3, "score": 0.6073482036590576, "raw_score": 0.6073482036590576, "source": "flask", "row": 35, "chunk_id": "391c659be1f74afdd0355c289e3478c46cb744fd", "symbol_type": "method", "qualname": "Flask.__call__", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 1529, "end_line": 1536}, {"rank": 4, "score": 0.5996242165565491, "raw_score": 0.5996242165565491, "source": "flask", "row": 117, "chunk_id": "45e39c75627746e8d351af755ae300aeba86c26a", "symbol_type": "method", "qualname": "RequestContext.__init__", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\ctx.py", "start_line": 309, "end_line": 335}, {"rank": 5, "score": 0.5956447124481201, "raw_score": 0.5956447124481201, "source": "docs", "row": 101, "chunk_id": "14e555849e748a78223340e1bc6ada4bd238c410", "symbol_type": "doc", "qualname": "deploying\\mod_wsgi.rst#Running", "file_path": "d:\\499\\docs\\deploying\\mod_wsgi.rst", "start_line": 43, "end_line": 76}, {"rank": 6, "score": 0.5907596349716187, "raw_score": 0.5907596349716187, "source": "flask", "row": 360, "chunk_id": "f49b6a78bf160db5c2ffb21b5963c932655cb3e4", "symbol_type": "method", "qualname": "FlaskClient.open", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\testing.py", "start_line": 204, "end_line": 247}, {"rank": 7, "score": 0.5886000394821167, "raw_score": 0.5886000394821167, "source": "flask", "row": 217, "chunk_id": "d8e1e548b0d74489e38636dd026adf46eb04032a", "symbol_type": "class", "qualname": "App", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "start_line": 59, "end_line": 964}, {"rank": 8, "score": 0.5831215381622314, "raw_score": 0.5831215381622314, "source": "flask", "row": 37, "chunk_id": "efbec523b7e4d3e8df9e1040421353f09b23a59a", "symbol_type": "method", "qualname": "Blueprint.__init__", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\blueprints.py", "start_line": 19, "end_line": 53}, {"rank": 9, "score": 0.5810899138450623, "raw_score": 0.5810899138450623, "source": "docs", "row": 24, "chunk_id": "a7e5533b3cf46084f6b873b7cb5cd524bd3b4a79", "symbol_type": "doc", "qualname": "appcontext.rst#Context During Setup", "file_path": "d:\\499\\docs\\appcontext.rst", "start_line": 43, "end_line": 73}, {"rank": 10, "score": 0.5801418423652649, "raw_score": 0.5801418423652649, "source": "flask", "row": 356, "chunk_id": "0f6b63ff5afbec686edf764081c663f331538646", "symbol_type": "method", "qualname": "FlaskClient.__init__", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\testing.py", "start_line": 125, "end_line": 133}]}
{"query": "How to avoid duplicate threads in debug mode Issue Description I have a similar issue as #5307 and I also understand the arguments related to threads in web applications. In my case of a web server for controlling Raspberry Pi cameras raspiCamSrv, there are several threads under control of the web app, like live stream, video recording, etc. These threads use the Picamera2 library which starts its own threads. This is normally not an issue because these threads are started by users from the Web UI after the Flask server has started. Now, I have added a motion capture feature, which is also running in an own thread and users want this feature to be automatically started with the server, for example after the device has been rebooted. Currently, I start this thread in the app factory create_app(). And, as in #5307, the thread is started again when I start Flask with the --debug option. I do not seem to have the possibility from my own code to detect whether these threads are already active. The classes from which these threads are started and which hold their references, seem to be initialized again, although they are singletons. Question I am not considering this as a bug. My question is whether there is a possibility in create_app(), to know that the app is being recreated on behalf of the autoloader. Environment:  Python version: 3.11.2 Flask version: 3.0.0 Wekzeug version: 3.0.1", "mode": "nl", "used_query": "How to avoid duplicate threads in debug mode Issue Description I have a similar issue as #5307 and I also understand the arguments related to threads in web applications. In my case of a web server for controlling Raspberry Pi cameras raspiCamSrv, there are several threads under control of the web app, like live stream, video recording, etc. These threads use the Picamera2 library which starts its own threads. This is normally not an issue because these threads are started by users from the Web UI after the Flask server has started. Now, I have added a motion capture feature, which is also running in an own thread and users want this feature to be automatically started with the server, for example after the device has been rebooted. Currently, I start this thread in the app factory create_app(). And, as in #5307, the thread is started again when I start Flask with the --debug option. I do not seem to have the possibility from my own code to detect whether these threads are already active. The classes from which these threads are started and which hold their references, seem to be initialized again, although they are singletons. Question I am not considering this as a bug. My question is whether there is a possibility in create_app(), to know that the app is being recreated on behalf of the autoloader. Environment:  Python version: 3.11.2 Flask version: 3.0.0 Wekzeug version: 3.0.1", "gold_terms": ["davidism", "not", "is_running_from_reloader", "https", "werkzeug", "palletsprojects", "com", "serving", "only", "something", "the", "first", "time", "dev", "server", "starts", "and", "reloads", "signag", "for"], "results": [{"rank": 1, "score": 0.4886022210121155, "raw_score": 0.4886022210121155, "source": "flask", "row": 65, "chunk_id": "f2086f01c303d1474f7c26c4de4301b78ef2e06b", "symbol_type": "method", "qualname": "FlaskGroup.make_context", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\cli.py", "start_line": 665, "end_line": 684}, {"rank": 2, "score": 0.4721131920814514, "raw_score": 0.4721131920814514, "source": "flask", "row": 229, "chunk_id": "7cd63dd765a74952bf58b4eaef1cd789fb817105", "symbol_type": "method", "qualname": "App.debug", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\sansio\\app.py", "start_line": 550, "end_line": 560}, {"rank": 3, "score": 0.46885377168655396, "raw_score": 0.46885377168655396, "source": "flask", "row": 110, "chunk_id": "c6bd06a4228ee1a36ea4cf812254f29cd756fc90", "symbol_type": "class", "qualname": "AppContext", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\ctx.py", "start_line": 238, "end_line": 284}, {"rank": 4, "score": 0.45203471183776855, "raw_score": 0.45203471183776855, "source": "flask", "row": 20, "chunk_id": "473700e2ea48267590c7dd6e75f501ae1186b288", "symbol_type": "method", "qualname": "Flask.full_dispatch_request", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\app.py", "start_line": 904, "end_line": 920}, {"rank": 5, "score": 0.44771072268486023, "raw_score": 0.44771072268486023, "source": "docs", "row": 80, "chunk_id": "052d72a8c45997b6522e3a638f947301febf9102", "symbol_type": "doc", "qualname": "debugging.rst#External Debuggers", "file_path": "d:\\499\\docs\\debugging.rst", "start_line": 61, "end_line": 99}, {"rank": 6, "score": 0.4475659132003784, "raw_score": 0.4475659132003784, "source": "flask", "row": 118, "chunk_id": "6c7ab9154194a68a478567858b23dab80de72354", "symbol_type": "method", "qualname": "RequestContext.copy", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\ctx.py", "start_line": 337, "end_line": 355}, {"rank": 7, "score": 0.44220679998397827, "raw_score": 0.44220679998397827, "source": "docs", "row": 270, "chunk_id": "5f8c8a591bc479a1686302aca6a8081f98d2b952", "symbol_type": "doc", "qualname": "quickstart.rst#Debug Mode", "file_path": "d:\\499\\docs\\quickstart.rst", "start_line": 88, "end_line": 126}, {"rank": 8, "score": 0.4412540793418884, "raw_score": 0.4412540793418884, "source": "docs", "row": 122, "chunk_id": "5a15fca0a9f5ebc8045161511b3edac905f90f49", "symbol_type": "doc", "qualname": "design.rst#Async/await and ASGI support", "file_path": "d:\\499\\docs\\design.rst", "start_line": 189, "end_line": 205}, {"rank": 9, "score": 0.4407135248184204, "raw_score": 0.4407135248184204, "source": "flask", "row": 69, "chunk_id": "3ab8b20264e0770e4174bef46bd5c41a7679a93c", "symbol_type": "function", "qualname": "show_server_banner", "file_path": "d:\\499\\src\\flask-3.1.2\\flask-3.1.2\\src\\flask\\cli.py", "start_line": 774, "end_line": 785}, {"rank": 10, "score": 0.43575969338417053, "raw_score": 0.43575969338417053, "source": "docs", "row": 26, "chunk_id": "cb02893fa7cd6c34657e299cbc40dbccc8548625", "symbol_type": "doc", "qualname": "appcontext.rst#Visibility of the Context", "file_path": "d:\\499\\docs\\appcontext.rst", "start_line": 116, "end_line": 142}]}
