id,repo,issue_number,title,text,url,created_at
1,pallets/flask,5902,Improve alt text for Debug Mode interactive debugger image (accessibility),"Improve alt text for Debug Mode interactive debugger image (accessibility) In the Flask documentation section [‚ÄúDebug Mode‚Äù](https://flask.palletsprojects.com/en/stable/quickstart/#debug-mode), there is an image demonstrating the interactive debugger with the following markup: ``` <img alt=""The interactive debugger in action.""      class=""screenshot align-center""      src=""../_images/debugger.png"">   ``` The alt text is very generic and does not clearly describe the content or purpose of the image. For users who rely on screen readers, the current alt text does not convey that this is a Flask error page shown in the browser This makes the documentation less accessible for users with visual impairments and does not fully meet the intent of WCAG 1.1.1 (Non-text Content)  **Suggested improvement** Replace the existing alt text with something more descriptive, for example: ‚ÄúFlask debug mode error page showing a Python traceback and an interactive debugger panel in the browser",https://github.com/pallets/flask/issues/5902,2026-01-26T14:27:03+00:00
2,pallets/flask,5901,Flask's blueprint's render templates rendering another blueprint's folder's html file !!!,"Flask's blueprint's render templates rendering another blueprint's folder's html file !!! I was learning Flask & Web Application making. I am getting the problem when i am return the render templates of a html file  in blueprint i am getting another blueprint's html file.  I am sharing the screenshots here below and say what is the problem here.  <img width=""1366"" height=""768"" alt=""Image"" src=""https://github.com/user-attachments/assets/1eeb056a-b53a-434b-ae46-e7e7712a448f"" /> See here in the render template at line 33, i wish it will render the `checking.html` file which is present in the `general_bp`'s folder.  <img width=""1366"" height=""768"" alt=""Image"" src=""https://github.com/user-attachments/assets/f5e491bc-b5b0-43f5-aa9a-0517197f2e79"" />  <img width=""1366"" height=""768"" alt=""Image"" src=""https://github.com/user-attachments/assets/1dd4ac18-26d5-4f9f-b587-a6f7256c60a1"" />  See here is the two `checking.html` file in different folder, but as i send the first image which should render the checking.html in the `general` folder it is rendering the `auth/checking.html` file.  <img width=""1366"" height=""768"" alt=""Image"" src=""https://github.com/user-attachments/assets/ad73f9b2-7e6e-4a9f-859d-6ead96b846eb"" /> As you see when i open the `/checking` route it is always giving the `auth>checking.html` file.  I am not understanding why this is happening. is this any problem or i make any mistake here which cause the problem. Or anything i am doing wrong when i am in the `routes.py` file  what the wrong, maybe in different blueprint's folder i have same file name so why it is taking another file üò¢  what you can see any problem here?  Please try to give a solution to this.   Environment: Linux > Ubuntu(Xubuntu)  UV Python 3.14.0  <img width=""587"" height=""475"" alt=""Image"" src=""https://github.com/user-attachments/assets/17f49e54-707d-4c36-8616-b31e897a51ca"" />",https://github.com/pallets/flask/issues/5901,2026-01-26T04:48:05+00:00
3,pallets/flask,5897,package detection fails with namespace package in editable mode,"package detection fails with namespace package in editable mode Given a package which uses namespace packaging and has been installed using ""editable installs"", Flask's scaffold (specifically `_find_package_path`) will error if the name passed to `Flask(...)` is the package name rather than a sub-module.  This affects cases where the name is the name of the package (and thus potentially not actually the `__name__`) though also happens when using `__name__` and the app is defined within a `__init__.py` in the root of the namespaced package.  Notably the issue only appears when importing the app elsewhere -- running from a python process launched at the parent of the namespace package tree hides this.  Example project: ``` ‚îú‚îÄ‚îÄ flask-app ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ setup.py ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ sr ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ comp ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ http ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ __init__.pyi ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ __init__.pyi ‚îî‚îÄ‚îÄ run.py ``` The `__init__.pyi` files are empty and shouldn't be needed, however are present in my original project as typing markers.  ```python # run.py print("""") print(""run.py"") print("""")  from sr.comp.http import app  print("""") print(""/run.py"") print("""") ``` ```python # flask-app/sr/comp/http/__init__.py from flask import Flask  print(""app = Flask(__name__)"") app = Flask(__name__)  # reproduces when defined in __init__.py  print(""app = Flask('sr.comp.http')"") app = Flask(""sr.comp.http"")  # reproduces when defined in e.g: server.py and `app` is re-exported via __init__.py # this latter case was my original case  @app.route(""/"") def hello():     return ""Hello, World!"" ```  <details> <summary><code>flask-app/setup.py</code></summary>  ``` python # flask-app/setup.py from setuptools import find_namespace_packages, setup  setup(     name='sr.comp.http',     packages=find_namespace_packages(include=['sr.*']),     namespace_packages=['sr', 'sr.comp'],     install_requires=[         'Flask >=2.2',     ], ) ```  </details>  The error is: ``` Traceback (most recent call last):   File ""/home/peter/play/flask-play/run.py"", line 6, in <module>     from sr.comp.http import app   File ""/home/peter/play/flask-play/flask-app/sr/comp/http/__init__.py"", line 5, in <module>     app = Flask(__name__)           ^^^^^^^^^^^^^^^   File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/app.py"", line 239, in __init__     super().__init__(   File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/sansio/app.py"", line 304, in __init__     instance_path = self.auto_find_instance_path()                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/sansio/app.py"", line 518, in auto_find_instance_path     prefix, package_path = find_package(self.import_name)                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/sansio/scaffold.py"", line 783, in find_package     package_path = _find_package_path(import_name)                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/sansio/scaffold.py"", line 748, in _find_package_path     search_location = next(                       ^^^^^ StopIteration ```  I've been testing this by running the following to compare against a non-editable install: ``` shell pip install flask-app/ && python run.py && pip install -e flask-app/ && python run.py ```  I've also made some modifications to `flask/sansio/scaffold.py` to debug, which provides some insight. It looks like the issue is to do with whether or not the `package_path` is found to be relative to the `package_spec.submodule_search_locations`.  <details> <summary><code>scaffold.py</code> diff</summary>  ```diff @@ -708,7 +708,10 @@    def _find_package_path(import_name: str) -> str:      """"""Find the path that contains the package or module."""""" +    print() +    print(f""_find_package_path({import_name=})"")      root_mod_name, _, _ = import_name.partition(""."") +    print(f""_find_package_path: {root_mod_name=}"")        try:          root_spec = importlib.util.find_spec(root_mod_name) @@ -721,18 +724,27 @@          #    - the module name was invalid          #    - the module name is __main__          #    - we raised `ValueError` due to `root_spec` being `None` +        print(""CWD"")          return os.getcwd()        if root_spec.submodule_search_locations:          if root_spec.origin is None or root_spec.origin == ""namespace"":              # namespace package              package_spec = importlib.util.find_spec(import_name) +            print(f""{package_spec=}"")                if package_spec is not None and package_spec.submodule_search_locations:                  # Pick the path in the namespace that contains the submodule.                  package_path = pathlib.Path(                      os.path.commonpath(package_spec.submodule_search_locations)                  ) +                print(f""{package_path=}"") +                search_locations=[ +                    location +                    for location in root_spec.submodule_search_locations +                    if package_path.is_relative_to(location) +                ] +                print(f""{search_locations=}"")                  search_location = next(                      location                      for location in root_spec.submodule_search_locations @@ -740,14 +752,18 @@                  )              else:                  # Pick the first path. +                print(""Picking the first path"")                  search_location = root_spec.submodule_search_locations[0]   +            print(f""{os.path.dirname(search_location)=}"")              return os.path.dirname(search_location)          else:              # package with __init__.py +            print(f""package with __init__.py: {os.path.dirname(os.path.dirname(root_spec.origin))=}"")              return os.path.dirname(os.path.dirname(root_spec.origin))      else:          # module +        print(f""module: {os.path.dirname(root_spec.origin)=}"")          return os.path.dirname(root_spec.origin)  # type: ignore[type-var, return-value]     ```  </details>  <details> <summary>Full output (with scaffold printing)</summary>  ``` Processing ./flask-app   Installing build dependencies ... done   Getting requirements to build wheel ... done   Preparing metadata (pyproject.toml) ... done Requirement already satisfied: Flask>=2.2 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from sr.comp.http==0.0.0) (3.1.2) Requirement already satisfied: blinker>=1.9.0 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (1.9.0) Requirement already satisfied: click>=8.1.3 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (8.3.1) Requirement already satisfied: itsdangerous>=2.2.0 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (2.2.0) Requirement already satisfied: jinja2>=3.1.2 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (3.1.6) Requirement already satisfied: markupsafe>=2.1.1 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (3.0.3) Requirement already satisfied: werkzeug>=3.1.0 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (3.1.5) Building wheels for collected packages: sr.comp.http   Building wheel for sr.comp.http (pyproject.toml) ... done   Created wheel for sr.comp.http: filename=sr_comp_http-0.0.0-py3-none-any.whl size=2244 sha256=3f8b9ef6c2be19dfe215b2c753e08eba17f1d351d8990a453ee57f25b6554bad   Stored in directory: /home/peter/.cache/pip/wheels/cd/9c/02/1c78322e6692d753ef839820d853e11679311f30eec26b3432 Successfully built sr.comp.http Installing collected packages: sr.comp.http   Attempting uninstall: sr.comp.http     Found existing installation: sr.comp.http 0.0.0     Uninstalling sr.comp.http-0.0.0:       Successfully uninstalled sr.comp.http-0.0.0 Successfully installed sr.comp.http-0.0.0  run.py  app = Flask(__name__)  _find_package_path(import_name='sr.comp.http') _find_package_path: root_mod_name='sr' package_spec=ModuleSpec(name='sr.comp.http', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7b2244ea6c50>, origin='/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/sr/comp/http/__init__.py', submodule_search_locations=['/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/sr/comp/http']) package_path=PosixPath('/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/sr/comp/http') search_locations=['/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/sr'] os.path.dirname(search_location)='/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages' app = Flask('sr.comp.http')  _find_package_path(import_name='sr.comp.http') _find_package_path: root_mod_name='sr' package_spec=ModuleSpec(name='sr.comp.http', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7b2244ea6c50>, origin='/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/sr/comp/http/__init__.py', submodule_search_locations=['/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/sr/comp/http']) package_path=PosixPath('/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/sr/comp/http') search_locations=['/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/sr'] os.path.dirname(search_location)='/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages'  /run.py  Obtaining file:///home/peter/play/flask-play/flask-app   Installing build dependencies ... done   Checking if build backend supports build_editable ... done   Getting requirements to build editable ... done   Preparing editable metadata (pyproject.toml) ... done Requirement already satisfied: Flask>=2.2 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from sr.comp.http==0.0.0) (3.1.2) Requirement already satisfied: blinker>=1.9.0 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (1.9.0) Requirement already satisfied: click>=8.1.3 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (8.3.1) Requirement already satisfied: itsdangerous>=2.2.0 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (2.2.0) Requirement already satisfied: jinja2>=3.1.2 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (3.1.6) Requirement already satisfied: markupsafe>=2.1.1 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (3.0.3) Requirement already satisfied: werkzeug>=3.1.0 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (3.1.5) Building wheels for collected packages: sr.comp.http   Building editable for sr.comp.http (pyproject.toml) ... done   Created wheel for sr.comp.http: filename=sr_comp_http-0.0.0-0.editable-py3-none-any.whl size=3459 sha256=a216bf634bddcae47327c746fe989a8a4115384810f305d565bb098311dbaeaa   Stored in directory: /tmp/pip-ephem-wheel-cache-6dk2qx5_/wheels/cd/9c/02/1c78322e6692d753ef839820d853e11679311f30eec26b3432 Successfully built sr.comp.http Installing collected packages: sr.comp.http   Attempting uninstall: sr.comp.http     Found existing installation: sr.comp.http 0.0.0     Uninstalling sr.comp.http-0.0.0:       Successfully uninstalled sr.comp.http-0.0.0 Successfully installed sr.comp.http-0.0.0  run.py  app = Flask(__name__)  _find_package_path(import_name='sr.comp.http') _find_package_path: root_mod_name='sr' package_spec=ModuleSpec(name='sr.comp.http', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7e0760a89f90>, origin='/home/peter/play/flask-play/flask-app/sr/comp/http/__init__.py', submodule_search_locations=['/home/peter/play/flask-play/flask-app/sr/comp/http']) package_path=PosixPath('/home/peter/play/flask-play/flask-app/sr/comp/http') search_locations=[] Traceback (most recent call last):   File ""/home/peter/play/flask-play/run.py"", line 6, in <module>     from sr.comp.http import app   File ""/home/peter/play/flask-play/flask-app/sr/comp/http/__init__.py"", line 5, in <module>     app = Flask(__name__)           ^^^^^^^^^^^^^^^   File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/app.py"", line 239, in __init__     super().__init__(   File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/sansio/app.py"", line 304, in __init__     instance_path = self.auto_find_instance_path()                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/sansio/app.py"", line 518, in auto_find_instance_path     prefix, package_path = find_package(self.import_name)                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/sansio/scaffold.py"", line 783, in find_package     package_path = _find_package_path(import_name)                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/sansio/scaffold.py"", line 748, in _find_package_path     search_location = next(                       ^^^^^ StopIteration  ```  </details>   Environment:  - Python version: 3.11 (and others) - Flask version: 3.1.2, also 2.x",https://github.com/pallets/flask/issues/5897,2026-01-24T19:34:47+00:00
4,pallets/flask,5887,Add explicit support for async teardown_request handlers,"Add explicit support for async teardown_request handlers ### Summary  At the moment, `teardown_request` handlers in Flask are synchronous and cannot be defined as async functions. This makes it harder for apps that depend on async cleanup logic (e.g., closing async DB connections or awaiting async tasks) to integrate cleanly with Flask‚Äôs request lifecycle.  ### Problem  When users attempt to define an async teardown handler like:  ```python @app.teardown_request async def cleanup_async_resources(response):     await close_async_connections() ```  Flask does not await it and treats it as a regular function, leading to unawaited coroutine warnings and the async cleanup not running as intended.  ### Proposed Solution Make teardown handlers awaitable - if a handler is declared async, Flask should await it during the teardown phase.  ### Example ```python @app.teardown_request async def cleanup_async_resources(response):     await some_async_cleanup()  # should be awaited before response is finalized ```  ### Motivation Better async integration support as more frameworks and applications adopt async patterns. This would make Flask‚Äôs async support more complete and intuitive.  ### Environment  ```python Flask version: (e.g., 3.2.x) Python version: 3.9+ ```  Async libs used: Any  ### Thanks!",https://github.com/pallets/flask/issues/5887,2026-01-13T07:40:27+00:00
5,pallets/flask,5881,asgiref fails with gevent patching,"asgiref fails with gevent patching When `gevent.monkey.patch_all()` is used, `async def` functions fail when multiple concurrent requests are sent. asgiref gives the error `RuntimeError: You cannot use AsyncToSync in the same thread as an async event loop - just await the async function directly.`. This suggests that somehow, gevent is causing a running loop to be visible across threads.  `example.py`:  ```python # /// script # requires-python = ""~=3.14.0"" # dependencies = [ #     ""flask[async]"", #     ""gevent"", # ] # # [tool.uv] # exclude-newer = ""2026-01-05T00:00:00Z"" # # [tool.uv.sources] # flask = { path = ""."", editable = true } # ///  import gevent.monkey gevent.monkey.patch_all()  import asyncio  from flask import Flask  app = Flask(__name__)  @app.get(""/"") async def hello_world():     await asyncio.sleep(0.5)     return f""Hello, World!"" ```  ``` uv run --with-requirements example.py flask -A example.py run ```  `load.py`:  ```python # /// script # requires-python = ""~=3.14.0"" # dependencies = [ #     ""httpx"", # ] # # [tool.uv] # exclude-newer = ""2026-01-05"" # ///  import asyncio import httpx  async def get(i, client: httpx.AsyncClient):     r = await client.get(""http://127.0.0.1:5000"")     print(i, await r.aread())  async def main():     async with httpx.AsyncClient() as client, asyncio.TaskGroup() as group:         for i in range(50):             group.create_task(get(i, client))  asyncio.run(main()) ```  ``` uv run load.py ```  Continues #5817 with more details.",https://github.com/pallets/flask/issues/5881,2026-01-05T18:52:04+00:00
6,pallets/flask,5870,Teardown handler chain exception handling,"Teardown handler chain exception handling Flask executes registered teardown handlers (used for closing DB connections, releasing locks, etc.) in a chain. The do_teardown_request method which is supposed to make these teardown requests does not wrap individual handlers in a try/except block. If one handler raises an exception, the loop terminates immediately, and all subsequent handlers are skipped, this can lead to the application to skip critical cleanup routines if a non critical one fails.  Sample reproduction code ```python import threading import time import requests from flask import Flask  app = Flask(__name__)  #a simulation of a limited resource pool mock_db_connections = 0  @app.route('/') def index():     global mock_db_connections     mock_db_connections = mock_db_connections + 1     return ""Request Processed""  #simulating a critical teardown handler which is supposed to free resources from the db @app.teardown_request def critical_db_close(exc):     global mock_db_connections     mock_db_connections = mock_db_connections - 1  #teardown handler which can crash @app.teardown_request def buggy_extension(exc):     raise Exception(""Crash in buggy extension!"")  def run_server():     #just for clearner output     import logging     log = logging.getLogger('werkzeug')     log.setLevel(logging.ERROR)     app.logger.disabled = True          app.run(port=5000, threaded=True)  def verify_bug():          print(f""Initial DB Connections: {mock_db_connections}"")          try:         requests.get('http://127.0.0.1:5000/')     except Exception:         pass      #wait time to ensure teardown has happened in the other thread     time.sleep(1)          print(f""Final DB Connections: {mock_db_connections}"")          if mock_db_connections > 0:         print(""Teardown Chain Broken"")     else:         print(""Failed to reproduce"")  server_thread = threading.Thread(target=run_server, daemon=True) server_thread.start() verify_bug() ```",https://github.com/pallets/flask/issues/5870,2025-12-24T15:27:55+00:00
7,pallets/flask,5863,Modern CSRF Protection Using `Sec-Fetch-Site` Header,"Modern CSRF Protection Using `Sec-Fetch-Site` Header Flask's documentation states that CSRF protection requires a form validation framework (which Flask doesn't provide), necessitating one-time tokens stored in cookies and transmitted with form data. However, modern browsers now support `Sec-Fetch-Site` headers, making token-based CSRF protection unnecessary. Rails just merged this approach in [rails/rails#56350](https://github.com/rails/rails/pull/56350). Flask should offer a similar modern solution‚Äîbut in a more Flask-like way: as a simple argument to `@app.route()`.  ## Current State  From Flask's security documentation:  > ""Why does Flask not do that for you? The ideal place for this to happen is the form validation framework, which does not exist in Flask.""  This was written when CSRF tokens were the only viable protection mechanism. That's no longer true. And with header-based protection, no form validation framework is needed‚Äîjust a simple check before dispatching to the view.  ## The Modern Approach  The `Sec-Fetch-Site` header is a [Fetch Metadata Request Header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Site) that modern browsers send automatically. It indicates the relationship between the request origin and the target origin:  - `same-origin`: Request from the same origin (same scheme, host, and port) - `same-site`: Request from the same site but different origin - `cross-site`: Request from a completely different site - `none`: User-initiated navigation (typing URL, bookmark, etc.)  For state-changing requests (POST, PUT, DELETE, PATCH), we can simply reject requests where `Sec-Fetch-Site` is `cross-site`. No tokens needed.  **Browser Support:** All modern browsers (Chrome 76+, Firefox 90+, Safari 16.4+, Edge 79+) - [caniuse.com/mdn-http_headers_sec-fetch-site](https://caniuse.com/mdn-http_headers_sec-fetch-site)  ## Why This Matters  Token-based CSRF has significant operational pain:  1. **Caching conflicts**: Cached pages contain stale tokens ‚Üí false positives 2. **Session expiry edge cases**: Token/session mismatch after timeout 3. **SPA complexity**: Managing token refresh in JavaScript applications 4. **Multi-tab issues**: Tokens invalidated when user opens multiple tabs  Header-based protection eliminates all of these.  ## Proposed Flask Implementation  Rather than adding another extension, this should be a first-class citizen in Flask's routing. The implementation is simple enough that it belongs in core‚Äîjust an argument to `@app.route()`:  ```python from flask import Flask  app = Flask(__name__) app.config['CSRF_TRUSTED_ORIGINS'] = ['https://accounts.google.com']  # Protected by default for state-changing methods @app.route('/api/data', methods=['POST']) def create_data():     return {'status': 'ok'}  # Explicitly disable for webhooks that use signature verification @app.route('/webhooks/stripe', methods=['POST'], csrf=False) def stripe_webhook():     return {'received': True}  # GET requests are never protected (no state change) @app.route('/api/data', methods=['GET']) def get_data():     return {'data': []} ```  ## Configuration  ```python # Default configuration in Flask CSRF_ENABLED = True                    # Global kill switch CSRF_TRUSTED_ORIGINS = []              # Allow cross-origin from these origins CSRF_PROTECTED_METHODS = {'POST', 'PUT', 'PATCH', 'DELETE'} ```  Note: Unlike my earlier draft, `same-site` requests are **rejected by default**. This is intentional‚Äîdifferent subdomains often have different trust levels (e.g., `marketing.example.com` vs `admin.example.com`). If you need same-site requests, add the specific origin to `CSRF_TRUSTED_ORIGINS`.   ## Questions for Maintainers  1. **Default On vs Off**: Should CSRF protection be on by default for state-changing methods (proposed), or require explicit `csrf=True`?  2. **Same-site Policy**: The algorithm rejects `same-site` requests by default (per Filippo Valsorda's guidance). Should there be a config option to relax this, or is explicit `CSRF_TRUSTED_ORIGINS` sufficient?  3. **Werkzeug Level**: Should the core check logic live in Werkzeug so other frameworks (Bottle, etc.) can use it?  ## References  - [MDN: Sec-Fetch-Site](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Site) - [web.dev: Fetch Metadata](https://web.dev/articles/fetch-metadata) - [Rails PR #56350](https://github.com/rails/rails/pull/56350) - Rails implementation (merged Dec 2025) - [Rack Issue #2367](https://github.com/rack/rack/issues/2367) - Rack-level discussion - [Go proposal: CrossOriginForgeryHandler](https://github.com/golang/go/issues/73626) - [Blog from go author](https://words.filippo.io/csrf/) - [OWASP Fetch Metadata positioning](https://github.com/OWASP/CheatSheetSeries/pull/1875)  ## Willingness to Implement  I'm prepared to submit a PR implementing this. The change is small and self-contained.",https://github.com/pallets/flask/issues/5863,2025-12-15T16:29:24+00:00
8,pallets/flask,5861,Proposal: CLI command to validate API endpoints by making test requests,"Proposal: CLI command to validate API endpoints by making test requests ### Motivation  When working on Flask applications with many API endpoints, it is sometimes useful to quickly check whether all registered routes can be accessed without raising unexpected errors (e.g. unhandled exceptions, 500 errors).  At the moment, developers typically need to write custom scripts or tests to perform this kind of basic validation. Providing an opt-in CLI command could help improve developer experience, especially during local development.  ### Proposal  Introduce an optional Flask CLI command (for example, `flask check-endpoints`) that iterates over registered routes and makes test requests using Flask‚Äôs test client.  The goal would not be full correctness testing, but a lightweight sanity check to detect obvious runtime errors.  Possible initial scope: - Only routes with simple methods (e.g. GET by default) - Skip routes with required path parameters - Report endpoints that raise exceptions or return 5xx responses - Development-only usage  ### Design considerations  - The command should be fully opt-in and not affect existing behavior. - No network requests; use Flask‚Äôs built-in test client. - Keep output simple and readable (similar to `flask routes`). - Advanced features (custom payloads, auth, etc.) could be out of scope initially.  ### Open questions  - Should this live as a core CLI command or as an optional extension? - How should endpoints with required parameters or authentication be handled? - Should the command fail on the first error or report all failures?  Feedback on the general direction and scope would be appreciated before starting an implementation.",https://github.com/pallets/flask/issues/5861,2025-12-13T10:43:23+00:00
9,pallets/flask,5851,Add Copy-to-Clipboard button for code examples in documentation,"Add Copy-to-Clipboard button for code examples in documentation ### Feature Request: Add copy button to code blocks in documentation  #### Problem  Many pages in the Flask documentation contain multi-line code snippets, but there is no built-in way to copy the entire block with one click. Users currently need to manually select text, which is slower and error-prone.  #### Proposed Solution  Add a small ""Copy"" button to each `div.highlight` element using a small JavaScript file included via Sphinx.  - Implemented using the native Clipboard API (no external library) - Minimal UI impact - Applied only to docs frontend, not core package  #### Motivation & Benefits  - Easier copy-paste for beginners following tutorials - Consistent with other frameworks (FastAPI, Django, Click docs, etc.) - Improves developer experience without affecting core Flask code  #### Status  I have already implemented a working version locally and can submit a PR once approved.  Let me know if this is useful and if I should proceed with a pull request.",https://github.com/pallets/flask/issues/5851,2025-11-21T08:56:06+00:00
10,pallets/flask,5848,Add copy-to-clipboard button for code blocks in Flask documentation.,"Add copy-to-clipboard button for code blocks in Flask documentation. ### Description  I propose to add a ""copy to clipboard"" button next to all code blocks in the Flask documentation. This will allow users to easily copy example code or command-line snippets with a single click instead of manually selecting the text. This feature greatly improves usability and convenience, especially on mobile devices.  Flask documentation uses Sphinx for static site generation, and there is an existing Sphinx extension called [sphinx-copybutton](https://sphinx-copybutton.readthedocs.io/en/latest/) that provides this functionality out of the box. It can be enabled by simply adding it to the `extensions` list in the Sphinx `conf.py` file.   This extension also supports stripping common prompts (like `>>>`, `$`) from copied content, making the copied snippets cleaner.  ### Problem this resolves  Currently, users have to manually select and copy code blocks, which can be error-prone and inconvenient. Adding a copy button makes the process faster and less error-prone.  ### Additional notes  - The change is additive and does not affect existing documentation content or structure. - This enhancement aligns Flask docs with modern documentation practices seen in many popular projects.  I am happy to implement this feature and create a pull request once the issue is approved.",https://github.com/pallets/flask/issues/5848,2025-11-19T07:09:10+00:00
11,pallets/flask,5839,"Really, I can't close connection???","Really, I can't close connection??? Jesus Christ, what kind of library doesn‚Äôt allow forcefully closing a connection? Even after returning or using abort, it still continues to process data in the background. This is disappointing, there‚Äôs no way, for example, to forcefully stop a file upload after checking its header. It will still continue to process the remaining 100 GB of the file.  ``` @app.route('/upload', methods=['POST']) def upload_file():     print(1)     return ""wtf"", 400 # still continues to process data ```",https://github.com/pallets/flask/issues/5839,2025-10-30T21:35:46+00:00
12,pallets/flask,5836,Test failures with click 8.3.1,"Test failures with click 8.3.1 Click 8.3.1 was [tagged](https://github.com/pallets/click/releases/tag/8.3.1) but not released on PyPI. Running flask's test suite with that version results in ``` ============================= test session starts ============================== platform linux -- Python 3.13.8, pytest-8.4.2, pluggy-1.6.0 rootdir: /build/flask-3.1.2 configfile: pyproject.toml testpaths: tests collected 490 items                                                              tests/test_appctx.py ..............                                      [  2%] tests/test_async.py ........                                             [  4%] tests/test_basic.py .................................................... [ 15%] ........................................................................ [ 29%] ......                                                                   [ 31%] tests/test_blueprints.py ............................................... [ 40%] .............                                                            [ 43%] tests/test_cli.py ...................................................F.. [ 54%] ...F                                                                     [ 55%] tests/test_config.py ...................                                 [ 58%] tests/test_converters.py ..                                              [ 59%] tests/test_helpers.py ...................................                [ 66%] tests/test_instance_config.py .......                                    [ 67%] tests/test_json.py ...............................                       [ 74%] tests/test_json_tag.py ..............                                    [ 77%] tests/test_logging.py ......                                             [ 78%] tests/test_regression.py .                                               [ 78%] tests/test_reqctx.py .......ss.....                                      [ 81%] tests/test_request.py ...                                                [ 82%] tests/test_session_interface.py .                                        [ 82%] tests/test_signals.py .......                                            [ 83%] tests/test_subclassing.py .                                              [ 83%] tests/test_templating.py ................................                [ 90%] tests/test_testing.py .........................                          [ 95%] tests/test_user_error_handler.py .........                               [ 97%] tests/test_views.py .............                                        [100%]  =================================== FAILURES =================================== ______________________________ test_run_cert_path ______________________________      def test_run_cert_path():         # no key         with pytest.raises(click.BadParameter):             run_command.make_context(""run"", [""--cert"", __file__])              # no cert >       with pytest.raises(click.BadParameter):              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E       Failed: DID NOT RAISE <class 'click.exceptions.BadParameter'>   tests/test_cli.py:590: Failed __________________________ test_run_exclude_patterns ___________________________      def test_run_exclude_patterns(): >       ctx = run_command.make_context(""run"", [""--exclude-patterns"", __file__])               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   tests/test_cli.py:701:  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _  /nix/store/53y968aagcaaq46hq3rg2a3mmxwmzvm1-python3.13-click-8.3.1/lib/python3.13/site-packages/click/core.py:1216: in make_context     self.parse_args(ctx, args)         args       = []         ctx        = <click.core.Context object at 0x7ffff4c02b10>         extra      = {}         info_name  = 'run'         parent     = None         self       = <Command run> /nix/store/53y968aagcaaq46hq3rg2a3mmxwmzvm1-python3.13-click-8.3.1/lib/python3.13/site-packages/click/core.py:1227: in parse_args     _, args = param.handle_parse_result(ctx, opts, args)               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^         _          = 5000         args       = []         ctx        = <click.core.Context object at 0x7ffff4c02b10>         opts       = {'exclude_patterns': '/build/flask-3.1.2/tests/test_cli.py'}         param      = <Option key>         param_order = [<Option exclude_patterns>]         parser     = <click.parser._OptionParser object at 0x7ffff4b08bd0>         self       = <Command run> /nix/store/53y968aagcaaq46hq3rg2a3mmxwmzvm1-python3.13-click-8.3.1/lib/python3.13/site-packages/click/core.py:2548: in handle_parse_result     value = self.process_value(ctx, value)             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^         args       = []         ctx        = <click.core.Context object at 0x7ffff4c02b10>         opts       = {'exclude_patterns': '/build/flask-3.1.2/tests/test_cli.py'}         self       = <Option key>         source     = <ParameterSource.DEFAULT: 3>         value      = Sentinel.UNSET /nix/store/53y968aagcaaq46hq3rg2a3mmxwmzvm1-python3.13-click-8.3.1/lib/python3.13/site-packages/click/core.py:3283: in process_value     return super().process_value(ctx, value)            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^         __class__  = <class 'click.core.Option'>         ctx        = <click.core.Context object at 0x7ffff4c02b10>         self       = <Option key>         value      = Sentinel.UNSET /nix/store/53y968aagcaaq46hq3rg2a3mmxwmzvm1-python3.13-click-8.3.1/lib/python3.13/site-packages/click/core.py:2443: in process_value     value = self.callback(ctx, self, value)             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^         ctx        = <click.core.Context object at 0x7ffff4c02b10>         self       = <Option key>         value      = None _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _   ctx = <click.core.Context object at 0x7ffff4c02b10>, param = <Option key> value = None      def _validate_key(ctx: click.Context, param: click.Parameter, value: t.Any) -> t.Any:         """"""The ``--key`` option must be specified when ``--cert`` is a file.         Modifies the ``cert`` param to be a ``(cert, key)`` pair if needed.         """"""         cert = ctx.params.get(""cert"")         is_adhoc = cert == ""adhoc""              try:             import ssl         except ImportError:             is_context = False         else:             is_context = isinstance(cert, ssl.SSLContext)              if value is not None:             if is_adhoc:                 raise click.BadParameter(                     'When ""--cert"" is ""adhoc"", ""--key"" is not used.', ctx, param                 )                  if is_context:                 raise click.BadParameter(                     'When ""--cert"" is an SSLContext object, ""--key"" is not used.',                     ctx,                     param,                 )                  if not cert:                 raise click.BadParameter('""--cert"" must also be specified.', ctx, param)                  ctx.params[""cert""] = cert, value              else:             if cert and not (is_adhoc or is_context): >               raise click.BadParameter('Required when using ""--cert"".', ctx, param) E               click.exceptions.BadParameter: Required when using ""--cert"".  cert       = Sentinel.UNSET ctx        = <click.core.Context object at 0x7ffff4c02b10> is_adhoc   = False is_context = False param      = <Option key> ssl        = <module 'ssl' from '/nix/store/cfapjd2rvqrpry4grb0kljnp8bvnvfxz-python3-3.13.8/lib/python3.13/ssl.py'> value      = None  /nix/store/12gfdjrf93rixvjrkj9pbfy5349q3j4m-python3.13-flask-3.1.2/lib/python3.13/site-packages/flask/cli.py:870: BadParameter =========================== short test summary info ============================ FAILED tests/test_cli.py::test_run_cert_path - Failed: DID NOT RAISE <class 'click.exceptions.BadParameter'> FAILED tests/test_cli.py::test_run_exclude_patterns - click.exceptions.BadParameter: Required when using ""--cert"". ================== 2 failed, 486 passed, 2 skipped in 13.73s =================== ```",https://github.com/pallets/flask/issues/5836,2025-10-25T20:08:38+00:00
13,pallets/flask,5825,Document 415 on the receiving json section,"Document 415 on the receiving json section Documentation on ""json"" request throwing a 415 as well as 400.    The problem text is on https://flask.palletsprojects.com/en/stable/patterns/javascript/#receiving-json-in-views  > Receiving JSON in Views >  > Use the [json](https://flask.palletsprojects.com/en/stable/api/#flask.Request.json) property of the [request](https://flask.palletsprojects.com/en/stable/api/#flask.request) object to decode the request‚Äôs body as JSON. If the body is not valid JSON, or the Content-Type header is not set to application/json, a 400 Bad Request error will be raised  I believe you want to indicate that it's a 415 instead of 400 when the Content-Type header doesn't match as it's done on https://flask.palletsprojects.com/en/stable/api/#flask.Request.json  400 is still valid for when the body isn't json (even though the content-type is json).  So maybe something like this ?   > Receiving JSON in Views > > Use the [json](https://flask.palletsprojects.com/en/stable/api/#flask.Request.json) property of the [request](https://flask.palletsprojects.com/en/stable/api/#flask.request) object to decode the request‚Äôs body as JSON. If the body is not valid JSON, a 400 Bad Request error will be raised.  If the Content-Type header is not set to application/json, a 415 Unsupported Media Type error will be raised  Environment:  - Python version: N/A - Flask version: latest doc    This is in no way a bug, but it's for being aligned everywhere in your doc :).  I'm just trying to make things better, I love the product ! thanks for the great work you've done !",https://github.com/pallets/flask/issues/5825,2025-10-07T15:41:58+00:00
14,pallets/flask,5819,Enrich Flask‚Äôs public API type hints using typing.Annotated with Doc metadata,"Enrich Flask‚Äôs public API type hints using typing.Annotated with Doc metadata ## Feature Request  ### Summary  Enhance selected public Flask APIs (for example `add_url_rule` and `route`) by adding `typing.Annotated` with `Doc` metadata **and `Literal` types for HTTP methods** to provide richer IDE assistance and stronger static type checking.  ### Example  ```python from typing import Annotated, Literal from typing_extensions import Doc  # Strict HTTP method type for auto-complete and validation Method = Literal[""GET"", ""POST"", ""PUT"", ""DELETE"", ""PATCH"", ""OPTIONS"", ""HEAD""]  def add_url_rule(     rule: Annotated[str, Doc(""URL path such as '/home' or '/api/items/<int:id>'"")],     *,     methods: Annotated[list[Method], Doc(""Allowed HTTP methods, e.g. ['GET', 'POST']"")],     ... ) -> None:     ... ```  ### Benefits  * **Better editor/IDE hints and documentation** for route paths and HTTP methods. * **Static validation of HTTP verbs** so type checkers catch typos like `""GEET""`. * **Backward compatible** with existing type checkers and runtime behavior (`typing_extensions.Annotated` and `Literal` are supported across Python versions Flask supports).  ### Questions for Maintainers  * Would you accept `Annotated` + `Doc` and `Literal` types in public API signatures? * If yes, should I begin with a small pilot (e.g., only `add_url_rule`) before expanding to other decorators such as `route`?",https://github.com/pallets/flask/issues/5819,2025-09-21T05:31:27+00:00
15,pallets/flask,5817,asyncio is not compatible with gevent,"asyncio is not compatible with gevent See #5256  async-await: <https://flask.palletsprojects.com/en/stable/async-await/>  > Using async with greenlet > When using gevent or eventlet to serve an application or patch the runtime, greenlet>=1.0 is required. When using PyPy, PyPy>=7.3.7 is required.  Flask uses asgiref, which is not compatible with gevent: <https://github.com/django/asgiref/issues/443>   BTW: ASGI: <https://flask.palletsprojects.com/en/stable/deploying/asgi/>  > The asgiref [WsgiToAsgi](https://github.com/django/asgiref#wsgi-to-asgi-adapter) adapter is recommended as it integrates with the event loop used for Flask‚Äôs [Using async and await](https://flask.palletsprojects.com/en/stable/async-await/#async-await) support.  This makes it seem like the event loop integration means a single worker could process multiple requests concurently, which it can't, the worker will block on `await`.  ---  I'm not the only one that found this the hard way: [Flask, Gunicorn, Gevent and Asyncio Don't Mix](https://github.com/moogah/flask-gunicorn-gevent-asyncio/blob/29be08051cd663fa68d982f27232d2a5215a399c/README.md)",https://github.com/pallets/flask/issues/5817,2025-09-16T12:28:32+00:00
16,pallets/flask,5816,deprecate `should_ignore_error`,"deprecate `should_ignore_error` This was added in f1918093ac70d589a4d67af0d77140734c06c13d as part of the original code to keep the context around for use in the debugger, tests, etc. It was not part of a PR, and there's no linked issue or explanation on why it was added.  The intention seems to be to allow ignoring certain errors during debugging, so that cleanup is still run immediately. That's not how context preservation works anymore.  It also causes the exception to not be passed to teardown handlers, but there doesn't seem to be any reason to hide that, and handlers can already choose what to do if they're passed an error.  The method is only documented in the API, not in any other pages. There's no test for it. I have a feeling this isn't used. It results in an extra function call every single request, only to always return false. This can be deprecated then removed.",https://github.com/pallets/flask/issues/5816,2025-09-14T16:38:15+00:00
17,pallets/flask,5815,pass context internally instead of using contextvars,"pass context internally instead of using contextvars Currently, there are a bunch of different methods on the `Flask` class that run to dispatch each request. Many of these access `request` and other context proxies. We should update them to pass the `AppContext` everywhere instead. This is more convenient after #5812 with only one context object instead of two. As @pgjones pointed out in #5229, not having to access the contextvar is a significant speedup to ASGI Quart, although it doesn't appear to affect WSGI Flask as much. Perhaps if we were serving with greenlets and so contexts were switching more, it would be more noticeable in Flask too.  The obvious problem is that it is a breaking change to the signatures of all these methods. I'm unsure how many methods are affected, but I'm also unsure how many projects are even subclassing `Flask` to override any of the methods. The fact that the methods are public seems unintentional, compared to the much more common ways of configuring and customizing an app.  We could continue to support both signatures, showing a deprecation warning for the old one, by adding some detection to `Flask.__init__`. This would add some amount of time during app setup, but wouldn't affect runtime performance of the app.  ---  Another idea I had for the future was to have `@route` and other decorators inspect the signature of the decorated function, to allow injecting `request`, `app`, etc. if users would rather use that pattern than import the proxies. Having the request object directly available in all the dispatch methods would make this more straightforward. User code would be able to choose what pattern they want, the current proxy pattern would never be deprecated for user code.",https://github.com/pallets/flask/issues/5815,2025-09-13T18:19:56+00:00
18,pallets/flask,5804,3.1.2 regression: `stream_with_context` triggers `teardown_request()` calls before response generation,"3.1.2 regression: `stream_with_context` triggers `teardown_request()` calls before response generation <!-- This issue tracker is a tool to address bugs in Flask itself. Please use GitHub Discussions or the Pallets Discord for questions about your own code.  Replace this comment with a clear outline of what the bug is. -->  <!-- Describe how to replicate the bug.  Include a minimal reproducible example that demonstrates the bug. Include the full traceback if there was an exception. -->  <!-- Describe the expected behavior that should have happened but didn't. --> Hello,  I believe the changes to `stream_with_context()` in https://github.com/pallets/flask/pull/5799/commits/9822a0351574790cb66c652fcc396ad7aa2b09d8 introduced a bug where the `teardown_request()` callables are invoked too early in the request/response lifecycle (and actually invoked twice, before generating the response and a second time after the end of the request). Take the following example:  ```python # flask_teardown_stream_with_context.py from flask import Flask, g, stream_with_context   def _teardown_request(_):     print(""do_teardown_request() called"")     g.pop(""hello"")   app = Flask(__name__)  app.teardown_request(_teardown_request)   @app.get(""/stream"") def streamed_response():     g.hello = ""world""      def generate():         print(""Starting to generate response"")         yield f""<p>Hello {g.hello} !</p>""      return stream_with_context(generate())   app.run(debug=True) ```  In 3.1.1:  ``` % /tmp/venv/bin/flask --version            Python 3.13.7 Flask 3.1.1 Werkzeug 3.1.3 % /tmp/venv/bin/python flask_teardown_stream_with_context.py  [‚Ä¶] Starting to generate response 127.0.0.1 - - [01/Sep/2025 16:07:05] ""GET /stream HTTP/1.1"" 200 - do_teardown_request() called ```  In 3.1.2:  ``` % /tmp/venv/bin/flask --version                              Python 3.13.7 Flask 3.1.2 Werkzeug 3.1.3 % /tmp/venv/bin/python flask_teardown_stream_with_context.py do_teardown_request() called Starting to generate response do_teardown_request() called Debugging middleware caught exception in streamed response at a point where response headers were already sent. Traceback (most recent call last):   File ""/tmp/venv/lib/python3.13/site-packages/flask/helpers.py"", line 132, in generator     yield from gen   File ""/tmp/flask_teardown_stream_with_context.py"", line 21, in generate     yield f""<p>Hello {g.hello} !</p>""                       ^^^^^^^   File ""/tmp/venv/lib/python3.13/site-packages/flask/ctx.py"", line 56, in __getattr__     raise AttributeError(name) from None AttributeError: hello  During handling of the above exception, another exception occurred:  Traceback (most recent call last):   File ""/tmp/venv/lib/python3.13/site-packages/werkzeug/wsgi.py"", line 256, in __next__     return self._next()            ~~~~~~~~~~^^   File ""/tmp/venv/lib/python3.13/site-packages/werkzeug/wrappers/response.py"", line 32, in _iter_encoded     for item in iterable:                 ^^^^^^^^   File ""/tmp/venv/lib/python3.13/site-packages/flask/helpers.py"", line 130, in generator     with app_ctx, req_ctx:                   ^^^^^^^   File ""/tmp/venv/lib/python3.13/site-packages/flask/ctx.py"", line 443, in __exit__     self.pop(exc_value)     ~~~~~~~~^^^^^^^^^^^   File ""/tmp/venv/lib/python3.13/site-packages/flask/ctx.py"", line 410, in pop     self.app.do_teardown_request(exc)     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^   File ""/tmp/venv/lib/python3.13/site-packages/flask/app.py"", line 1356, in do_teardown_request     self.ensure_sync(func)(exc)     ~~~~~~~~~~~~~~~~~~~~~~^^^^^   File ""/tmp/flask_teardown_stream_with_context.py"", line 7, in _teardown_request     g.pop(""hello"")     ~~~~~^^^^^^^^^   File ""/tmp/venv/lib/python3.13/site-packages/flask/ctx.py"", line 88, in pop     return self.__dict__.pop(name)            ~~~~~~~~~~~~~~~~~^^^^^^ KeyError: 'hello' 127.0.0.1 - - [01/Sep/2025 16:09:35] ""GET /stream HTTP/1.1"" 200 - ```  Specifically,  ``` do_teardown_request() called Starting to generate response do_teardown_request() called ```  So `_teardown_request()` is called before flask start to iterate on the response generator.  This is a simplified version of our own code; I'm not sure we can actually expect `g` to still be available during response generators, but given it worked in 3.1.1 and the phrasing / intent of `teardown_request()`, I'd expect it not to be called before the response is actually generated. Note also that removing the code which causes the error, i.e. the `g` access, and keeping just the `print()` for debugging, will still show `_teardown_request()` being called twice.  It's not obvious to me where exactly the bug is triggered. Adding a `traceback.print_stack()` call to `_teardown_request()`: * in 3.1.1, the only call, once the request is done, is triggered by https://github.com/pallets/flask/blob/7fff56f5172c48b6f3aedf17ee14ef5c2533dfd1/src/flask/helpers.py#L115 ‚áí https://github.com/pallets/flask/blob/330123258e8c3dc391cbe55ab1ed94891ca83af3/src/flask/ctx.py#L443  * in 3.1.2, the (new) first call before entering the response generator is triggered by https://github.com/pallets/flask/blob/330123258e8c3dc391cbe55ab1ed94891ca83af3/src/flask/app.py#L1527 ; the second is similar to 3.1.1, i.e. https://github.com/pallets/flask/blob/330123258e8c3dc391cbe55ab1ed94891ca83af3/src/flask/helpers.py#L130 ‚áí https://github.com/pallets/flask/blob/330123258e8c3dc391cbe55ab1ed94891ca83af3/src/flask/ctx.py#L443  Environment:  - Python version: 3.13 - Flask version: 3.1.2",https://github.com/pallets/flask/issues/5804,2025-09-01T14:24:02+00:00
19,pallets/flask,5803,`flask.testing` misleadingly appears to import `TestResponse`,"`flask.testing` misleadingly appears to import `TestResponse` `testing.py` contains the following: ```python if t.TYPE_CHECKING:  # pragma: no cover     from werkzeug.test import TestResponse ``` As such, any IDE or static checker will consider this to be valid code: ```python import flask.testing as _flask_test  def my_test_helper(flask_test_client: _flask_test.FlaskClient) -> _flask_test.TestResponse:     ... ```  However, at runtime, this code will fail, because `TestResponse` is not actually imported into the `flask.testing` namespace.  Possible solutions: - Move `from werkzeug.test import TestResponse` outside the `if t.TYPE_CHECKING` block; you're already importing `werkzeug.test` in that file anyway - Remove `from werkzeug.test import TestResponse` entirely and replace `TestResponse` with `werkzeug.test.TestResponse` in type-hints - Change `from werkzeug.test import TestResponse` to `from werkzeug.test import TestResponse as _TestResponse`; the leading underscore signals marks the import as private, at which point it doesn't matter if its really imported or not because nobody should be using it from outside the file",https://github.com/pallets/flask/issues/5803,2025-08-30T01:20:49+00:00
20,pallets/flask,5792,Test,Test <!-- This issue tracker is a tool to address bugs in Flask itself. Please use GitHub Discussions or the Pallets Discord for questions about your own code.  Replace this comment with a clear outline of what the bug is. -->  <!-- Describe how to replicate the bug.  Include a minimal reproducible example that demonstrates the bug. Include the full traceback if there was an exception. -->  <!-- Describe the expected behavior that should have happened but didn't. -->  Environment:  - Python version: - Flask version:,https://github.com/pallets/flask/issues/5792,2025-08-03T03:15:59+00:00
21,pallets/flask,5786,Session is not updated on redirect target endpoint in tests,"Session is not updated on redirect target endpoint in tests Hello team. During writing tests, I noticed a strange session behavior.  I want to verify that after a redirect, the target location sets valid session properties, and it seems like in tests, the session properties when following redirects are not saved/exposed to the test environment.  Here's an example: ```python import pytest from flask import Flask, redirect, session  @pytest.fixture def app():     app = Flask(__name__)     app.debug = True     app.secret_key = 'test_secret'  # noqa: S105 ‚Äì fake secret key for testing purposes      @app.get('/redirect')     def do_redirect():         print(""Redirecting to target endpoint"", flush=True)         session[""redirected""] = ""true""         return redirect('/target', 302)      @app.get('/target')     def target():         print(""Target endpoint reached"", flush=True)         session['foo'] = 'bar'         return 'Target', 200      return app  @pytest.fixture() def client(app):     return app.test_client()  def test_session(client):     with client:         response = client.get(""/redirect"", follow_redirects=True)          print(f""Session after a redirect: {session.items()}"", flush=True)         assert response.status_code == 200         assert response.data == b""Target""          assert session.get(""redirected"") == ""true""         assert session.get('foo') == 'bar'          client.get(""/target"", follow_redirects=True)         assert session.get('foo') == 'bar'         assert response.data == b""Target""         print(f""Session after a direct request: {session.items()}"", flush=True) ```  The test fails on the first assertion `assert session.get('foo') == 'bar'`.  If I comment it out, the test output is the following:  ``` Redirecting to the target endpoint Target endpoint reached Session after a redirect: dict_items([('redirected', 'true')]) Target endpoint reached Session after a direct request: dict_items([('foo', 'bar'), ('redirected', 'true')]) ```  **IMPORTANT**: The described behavior is not reproduced when running the application with the real HTTP requests.  Environment:  - Python version: 3.13 - Flask version: 3.10",https://github.com/pallets/flask/issues/5786,2025-07-30T09:18:04+00:00
22,pallets/flask,5784,"Add a ""Scroll to Top"" Button for Long Documentation Pages","Add a ""Scroll to Top"" Button for Long Documentation Pages Some pages in the Flask documentation‚Äîsuch as [API](https://flask.palletsprojects.com/en/stable/api/) and [Configuration Handling](https://flask.palletsprojects.com/en/stable/config/)‚Äîare very long, requiring users to manually scroll all the way back up to access the top navigation links.  Adding a persistent ""Scroll to Top"" button (e.g. fixed to the bottom-left corner) would enhance usability by making navigation easier for users reading on smaller screens or mobile devices. This is a common accessibility and UX pattern on many documentation sites and could improve the overall reading experience.  This proposal does not affect Flask‚Äôs core library‚Äîit‚Äôs a suggestion for the documentation site UI only. I‚Äôm happy to help with a pull request if the maintainers are open to the addition.",https://github.com/pallets/flask/issues/5784,2025-07-28T22:48:31+00:00
23,pallets/flask,5776,Looser type annotations for send_file() path_or_file argument,"Looser type annotations for send_file() path_or_file argument `path_or_file` argument of `flask.helpers.send_file` is typed as `os.PathLike[t.AnyStr] | str | t.BinaryIO`. This prevents passing some objects that are `t.IO[bytes]`, but not `t.BinaryIO`. The underlying`werkzeug.utils.send_file` already allows `t.IO[bytes]` due to pallets/werkzeug#2209 since version 2.0.2.   Reproduction: ```python from tempfile import NamedTemporaryFile from typing import IO  from flask.helpers import send_file   # The return type cannot be ""BinaryIO"" because ""NamedTemporaryFile"" is incompatible with it according to Mypy. def some_function() -> IO[bytes]:     file = NamedTemporaryFile()     ...     return file   file = some_function() send_file(file) ```  Raises the following exception with Mypy 1.16.1. ``` error: Argument 1 to ""send_file"" has incompatible type ""IO[bytes]""; expected ""PathLike[str] | str | BinaryIO""  [arg-type] ```  I could simply change the return value of `some_function` to `_TemporaryFileWrapper[bytes]` or cast it to `BinaryIO`. However, I would like to allow `t.IO[bytes]`.  Side note: `_TemporaryFileWrapper[bytes]` conforms to `PathLike[str]` due to python/typeshed#7840. That is why it is accepted by `flask.helpers.send_file`.  Allowing `t.IO[bytes]` would be backwards compatible change as all `t.BinaryIO` are also `t.IO[bytes]`. [Mypy Playground](https://mypy-play.net/?mypy=latest&python=3.10&gist=4d7e2a43a847df9d332f5b7daba7a9fe)  Environment:  - Python version: 3.12.11 - Flask version: 3.1.1",https://github.com/pallets/flask/issues/5776,2025-07-16T09:06:28+00:00
24,pallets/flask,5774,`stream_with_context` does not work with async routes,"`stream_with_context` does not work with async routes Consider this trivial route + test in `app.py`:  ```python import flask from flask import Flask from flask import Response  import pytest  app = Flask(__name__)   @app.route(""/foo"") async def foo():     def gen():         yield ""bar""      return Response(flask.stream_with_context(gen()))   def test_foo():     with app.test_client() as client:         client.get(""/foo"") ```  With the following `requirements.txt`:  ``` flask[async]==3.1.1 pytest==8.4.1 werkzeug==3.1.3 ```  Running `pytest app.py` results in:  ``` ============================= test session starts ============================== platform darwin -- Python 3.12.11, pytest-8.4.1, pluggy-1.6.0 rootdir: /private/tmp/stream_with_context collected 1 item  app.py F                                                                 [100%]  =================================== FAILURES =================================== ___________________________________ test_foo ___________________________________      def test_foo():         with app.test_client() as client: >           client.get(""/foo"")  app.py:20: _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ venv/lib/python3.12/site-packages/werkzeug/test.py:1162: in get     return self.open(*args, **kw)            ^^^^^^^^^^^^^^^^^^^^^^ venv/lib/python3.12/site-packages/flask/testing.py:235: in open     response = super().open( venv/lib/python3.12/site-packages/werkzeug/test.py:1116: in open     response_parts = self.run_wsgi_app(request.environ, buffered=buffered)                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ venv/lib/python3.12/site-packages/werkzeug/test.py:988: in run_wsgi_app     rv = run_wsgi_app(self.application, environ, buffered=buffered)          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ venv/lib/python3.12/site-packages/werkzeug/test.py:1264: in run_wsgi_app     app_rv = app(environ, start_response)              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ venv/lib/python3.12/site-packages/flask/app.py:1536: in __call__     return self.wsgi_app(environ, start_response)            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ venv/lib/python3.12/site-packages/flask/app.py:1527: in wsgi_app     ctx.pop(error) _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _  self = <RequestContext 'http://localhost/foo' [GET] of app>, exc = None      def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore         """"""Pops the request context and unbinds it by doing that.  This will         also trigger the execution of functions registered by the         :meth:`~flask.Flask.teardown_request` decorator.          .. versionchanged:: 0.9            Added the `exc` argument.         """"""         clear_request = len(self._cv_tokens) == 1          try:             if clear_request:                 if exc is _sentinel:                     exc = sys.exc_info()[1]                 self.app.do_teardown_request(exc)                  request_close = getattr(self.request, ""close"", None)                 if request_close is not None:                     request_close()         finally:             ctx = _cv_request.get()             token, app_ctx = self._cv_tokens.pop() >           _cv_request.reset(token) E           ValueError: <Token var=<ContextVar name='flask.request_ctx' at 0x103cd9a30> at 0x104b23a40> was created in a different Context  venv/lib/python3.12/site-packages/flask/ctx.py:418: ValueError =========================== short test summary info ============================ FAILED app.py::test_foo - ValueError: <Token var=<ContextVar name='flask.request_ctx' at 0x103cd9a30>... ============================== 1 failed in 0.11s =============================== ```  Similarly, `python -m flask run` and then `curl http://127.0.0.1:5000/foo` results in:  ``` 127.0.0.1 - - [15/Jul/2025 13:40:14] ""GET /foo HTTP/1.1"" 500 - Error on request: Traceback (most recent call last):   File ""/private/tmp/stream_with_context/venv/lib/python3.12/site-packages/werkzeug/serving.py"", line 370, in run_wsgi     execute(self.server.app)   File ""/private/tmp/stream_with_context/venv/lib/python3.12/site-packages/werkzeug/serving.py"", line 331, in execute     application_iter = app(environ, start_response)                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File ""/private/tmp/stream_with_context/venv/lib/python3.12/site-packages/flask/app.py"", line 1536, in __call__     return self.wsgi_app(environ, start_response)            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   File ""/private/tmp/stream_with_context/venv/lib/python3.12/site-packages/flask/app.py"", line 1527, in wsgi_app     ctx.pop(error)   File ""/private/tmp/stream_with_context/venv/lib/python3.12/site-packages/flask/ctx.py"", line 418, in pop     _cv_request.reset(token) ValueError: <Token var=<ContextVar name='flask.request_ctx' at 0x1029ccea0> at 0x1049e1980> was created in a different Context ```  If the route is defined `def foo():` without `async`, then this works without issue.  Or if we remove `stream_with_context` and just `return Response(gen())`, also works.  But the combination of `async` + `stream_with_context` fails.  There's also no issue with e.g. flask 2.1.0; I believe this was introduced in flask 2.2.0, specifically by #4682.  Environment:  - Python version: 3.12.11 - Flask version: 3.1.1",https://github.com/pallets/flask/issues/5774,2025-07-15T21:08:57+00:00
25,pallets/flask,5768,Flask documentation website does not support dark mode,"Flask documentation website does not support dark mode **Describe the issue** The official Flask documentation at https://flask.palletsprojects.com currently does not support dark mode. For many developers, especially those working at night or with light sensitivity, this can create accessibility and eye strain issues.  **Expected behavior** It would be helpful if the documentation site could support an optional dark theme, either by detecting system preferences (prefers-color-scheme) or allowing manual switching.  **Additional context** Many popular frameworks like:  - Django - FastAPI - Pydantic - Typer have added dark mode support in their docs, improving readability and user comfort.",https://github.com/pallets/flask/issues/5768,2025-07-09T10:11:48+00:00
26,pallets/flask,5766,Tt,"Tt <!-- Replace this comment with a description of what the feature should do. Include details such as links to relevant specs or previous discussions. -->  <!-- Replace this comment with an example of the problem which this feature would resolve. Is this problem solvable without changes to Flask, such as by subclassing or using an extension? -->",https://github.com/pallets/flask/issues/5766,2025-07-06T15:33:57+00:00
27,pallets/flask,5763,document that `request.full_path` leaves query string percent encoded,"document that `request.full_path` leaves query string percent encoded WHAT IS THE BUG?  `request.full_path` is documented as *‚ÄúRequested path as unicode, including the query string.‚Äù*   However, Werkzeug URL-unquotes only the **path** (before ‚Äú?‚Äù); the **query string** is returned **raw**.   Code that searches or whitelists on `full_path` can therefore be bypassed by percent-encoding a slash inside a parameter.  ----------------------------------------------------------------------------------------------------------------  HOW TO REPLICATE  ``` ```python from flask import Flask, request app = Flask(__name__)  @app.route(""/show_picture"") def show_picture():     # na√Øve traversal filter     if ""../"" in request.full_path:         return ""Blocked"", 400     return f""full_path = {request.full_path}"", 200  # run:  flask --app poc run   # bypass: ""../"" hidden as ""%2F"" curl ""http://127.0.0.1:5000/show_picture?img=..%2F..%2Fetc%2Fpasswd"" Result ‚Üí 200 OK; the filter misses the traversal because ../ appears as ..%2F. ```  ----------------------------------------------------------------------------------------------------------------   EXPECTED BEHAVIOR Documentation (and the full_path docstring) should warn clearly:  ""Only the portion before ‚Äú?‚Äù is URL-unquoted. The query string is returned raw; unquote it manually (e.g. urllib.parse.unquote_plus) before using it for validation or filtering.""  Without that notice, filters like  if ""../"" in request.full_path:     ... if request.full_path.startswith(""/admin""):     ...  can be bypassed with %2F inside the query string.  ----------------------------------------------------------------------------------------------------------------  Python version: 3.12.3  Flask version: 2.3.3  Werkzeug version: 3.1.3  OS: Ubuntu 24.04 LTS  ----------------------------------------------------------------------------------------------------------------  Acknowledgements Discovery: Jefferson Gozanels GHomez Proof-of-concept & report: Sebasti√°n Alba Vives",https://github.com/pallets/flask/issues/5763,2025-06-23T02:47:18+00:00
28,pallets/flask,5756,404 Flask cannot find /security/login API,"404 Flask cannot find /security/login API We are using airflow 2.8.4, and recently we upgrade it to 2.10.5  ### Environment for Airflow 2.8.4  - Python version: 3.10 - Flask version:   ``` Flask-AppBuilder==4.3.11 Flask-Babel==2.0.0 Flask-Bcrypt==1.0.1 Flask-Caching==2.1.0 Flask-JWT-Extended==4.6.0 Flask-Limiter==3.5.1 Flask-Login==0.6.3 Flask-SQLAlchemy==2.5.1 Flask-Session==0.5.0 Flask-WTF==1.2.1 Flask==2.2.5 ```  Call /security/login API:  <img width=""1541"" alt=""Image"" src=""https://github.com/user-attachments/assets/ef976819-1ac1-4bd6-b84b-3ceab844a998"" />   ### Environment for Airflow 2.10.5  - Python version: 3.10 - Flask version:   ``` Flask-AppBuilder==4.5.2 Flask-Babel==2.0.0 Flask-Bcrypt==1.0.1 Flask-Caching==2.3.0 Flask-JWT-Extended==4.7.1 Flask-Limiter==3.10.1 Flask-Login==0.6.3 Flask-SQLAlchemy==2.5.1 Flask-Session==0.5.0 Flask-WTF==1.2.2 Flask==2.2.5 ```  Call /security/login API:  <img width=""1552"" alt=""Image"" src=""https://github.com/user-attachments/assets/e6ca32db-cb56-49e6-a266-8edb82e8d0b2"" />   Error Log: ``` {   ""detail"": ""The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again."",   ""status"": 404,   ""title"": ""Not Found"",   ""type"": ""about:blank"" } ```  /security/login API in  Flask-AppBuilder==4.5.2  https://github.com/dpgaspar/Flask-AppBuilder/blob/v4.5.2/flask_appbuilder/security/api.py#L32  /security/login API in  Flask-AppBuilder==4.3.11  https://github.com/dpgaspar/Flask-AppBuilder/blob/v4.3.11/flask_appbuilder/security/api.py#L32",https://github.com/pallets/flask/issues/5756,2025-06-09T18:18:08+00:00
29,pallets/flask,5751,"Typing mismatch between Flask and Werkzeug ""Response"" objects","Typing mismatch between Flask and Werkzeug ""Response"" objects There is an odd typing issue where Werkzeug `Response` != Flask `Response`. Please see below:  ```python from flask import Response, redirect, url_for  def foo() -> Response:     return redirect(url_for(""some.route"")) ```  This example returns:  ``` basedpyright: Type ""Response"" is not assignable to return type ""Response""                                 ¬†¬†""werkzeug.wrappers.response.Response"" is not assignable to ""flask.wrappers.Response"" [reportReturnType] ```  Environment:  - Python version: 3.13 - Flask version: 3.1.1",https://github.com/pallets/flask/issues/5751,2025-06-03T06:07:09+00:00
30,pallets/flask,5746,MAX_FORM_MEMORY_SIZE not being picked up correctly,"MAX_FORM_MEMORY_SIZE not being picked up correctly ## ISSUE Setting app.config[""MAX_FORM_MEMORY_SIZE""] = VALUE does not have any effect on the actual configuration and the default 500000 bytes from werkzeug request is stilled used   ## REPLICATION Setup a minimum flask project  app = Flask(__name__) app.config[""MAX_FORM_MEMORY_SIZE""] = 1024 * 1024 * 1024  print(app.request_class.max_form_memory_size)  ## MISSBEHAVIOUR I would expect if I set the MAX FORM MEMORY SIZE in my config it is properly applied and I can send requests with a content length appropriate to the setting but flask defaults to 500kb  Environment:  - Python version:  3.11 - Flask version: 2.3.3",https://github.com/pallets/flask/issues/5746,2025-05-27T13:03:43+00:00
31,pallets/flask,5745,Model Context Protocol (MCP) Support for Flask,"Model Context Protocol (MCP) Support for Flask ## Feature Request: Model Context Protocol (MCP) Support for Flask  ### Description  This feature request proposes adding native support for the Model Context Protocol (MCP) to Flask. MCP is an open protocol that enables secure connections between host applications and AI model providers, allowing for standardized communication patterns in AI-powered applications.  **Key aspects of MCP integration would include:** - Built-in MCP server capabilities for Flask applications - Middleware for handling MCP message routing - Authentication and authorization mechanisms for MCP connections - WebSocket and HTTP transport support as per MCP specification - Integration with Flask's existing request/response cycle  **Relevant links:** - [Model Context Protocol Specification](https://modelcontextprotocol.io/introduction) - [MCP GitHub Repository](https://github.com/modelcontextprotocol/python-sdk)  ### Problem Statement  Currently, developers who want to build AI-powered Flask applications that communicate via MCP must implement the protocol manually or rely on third-party libraries. This creates several challenges:  1. **Boilerplate Code**: Developers need to write significant boilerplate to handle MCP message formatting, routing, and transport 2. **Inconsistent Implementation**: Without standardized Flask integration, different projects implement MCP differently 3. **Security Concerns**: Manual implementation may miss important security considerations built into the MCP spec 4. **Maintenance Overhead**: Keeping custom MCP implementations up-to-date with protocol changes  **Example use case:** A Flask application serving as an AI assistant backend needs to: - Accept MCP connections from client applications - Handle tool calls and resource requests - Maintain secure, authenticated sessions - Process streaming responses  Currently, this requires extensive custom code that could be standardized.  ### Proposed Solution  Add Flask-MCP as either a core extension or built-in functionality that provides:  ```python from flask import Flask from flask_mcp import MCPServer  app = Flask(__name__) mcp = MCPServer(app)  @mcp.tool(""get_weather"") def get_weather(location: str) -> str:     # Tool implementation     return f""Weather in {location}""  @mcp.resource(""user_preferences"") def get_user_prefs():     # Resource implementation     return {""theme"": ""dark""} ```  This would make Flask a first-class citizen in the MCP ecosystem alongside other frameworks.  ### Alternative Approaches  While this could be implemented as a third-party extension (and some exist), native Flask support would: - Ensure better integration with Flask's ecosystem - Provide official maintenance and security updates   - Encourage broader MCP adoption in Python web development - Offer performance optimizations through deeper Flask integration  What do you think?  üöÄ",https://github.com/pallets/flask/issues/5745,2025-05-25T03:21:12+00:00
32,pallets/flask,5738,Allow multiple template folders for large projects,Allow multiple template folders for large projects Jinja2 supports multiple search paths for templates so Flask should do the same. This will allow template inheriting without copying files.   https://github.com/pallets/jinja/blob/main/src/jinja2/loaders.py#L190,https://github.com/pallets/flask/issues/5738,2025-05-20T10:48:36+00:00
33,pallets/flask,5729,The `template_filter` decorator doesn't work if you don't pass an argument,"The `template_filter` decorator doesn't work if you don't pass an argument ## What's the issue?  You can use `template_filter` as a decorator, but it only registers the filter if you write an explicit name or an empty set of parentheses. If you call it without parens, the filter doesn't get registered.  It's a small difference and can be confusing.  ## Minimal example  Consider the following program:  ```python from flask import Flask, render_template_string   app = Flask(__name__)   @app.template_filter def double(x):     return x * 2   @app.route(""/"") def index():     return render_template_string(""2 times 2 is {{ 2 | double }}"") ```  If you run this app (`flask run --port 8008 --debug`) and then open it in your browser (`http://localhost:8008`) you'll get an error:  ``` jinja2.exceptions.TemplateAssertionError: No filter named 'double'. ```  This is confusing, and it took me a while to realise the missing parentheses in `app.template_filter` were at fault.  ## Suggested fix  I think it would be helpful if the decorator either:  * Supported being called without parentheses, or * Printed an explicit warning if called this way, e.g. `Did you use 'template_filter' as a decorator without parentheses? You need to call it with 'template_filter()'`  This is caught by type checkers, but not everybody type checks their Python and the error message is less obvious:  ``` Argument 1 to ""template_filter"" of ""App"" has incompatible type ""Callable[[Any], Any]""; expected ""str | None"" ```  I've had a look at the relevant code, and I'd be happy to provide a patch if you think this is a useful change.  ## Environment  - Python version: Python 3.11.11 - Flask version: Flask 3.1.0",https://github.com/pallets/flask/issues/5729,2025-05-12T08:33:00+00:00
34,pallets/flask,5726,Adding Architecture Diagram Contribution,Adding Architecture Diagram Contribution Hello maintainers! I've created an architecture diagram that visualizes Flask's core components and their relationships. This visualization could help new contributors understand the codebase structure and assist users in grasping Flask's high-level architecture.  ![Image](https://github.com/user-attachments/assets/143025cf-6094-4c19-93f5-ac06bfa59738)  [Flask Architecture Diagram on Kloudfarm.io](https://app.kloudfarm.io/share/379c2674f0b240c387a5135690c8f01c8c18a988878e99846fb36ea18ad7e1ef) The diagram shows: - Core Flask classes and relationships - Request/response lifecycle - Extension integration points - Blueprint organization  I'd be happy to:  1. Submit a PR to add this to documentation 2. Provide different file formats 3. Create more focused diagrams of specific subsystems  Would this be a helpful addition to the project? Open to any feedback or suggestions. Thanks!,https://github.com/pallets/flask/issues/5726,2025-05-10T16:22:17+00:00
35,pallets/flask,5721,Ihmuukin_ai,Ihmuukin_ai <!-- This issue tracker is a tool to address bugs in Flask itself. Please use GitHub Discussions or the Pallets Discord for questions about your own code.  Replace this comment with a clear outline of what the bug is. -->  <!-- Describe how to replicate the bug.  Include a minimal reproducible example that demonstrates the bug. Include the full traceback if there was an exception. -->  <!-- Describe the expected behavior that should have happened but didn't. -->  Environment:  - Python version: - Flask version:,https://github.com/pallets/flask/issues/5721,2025-04-22T11:37:28+00:00
36,pallets/flask,5711,close resources before reload (option --reload),"close resources before reload (option --reload) I have a Flask application that establishes connections to multiple SQLite databases.  When the local development server (werkzeug) is started with option ``--reload`` the connections are not closed on reload, since Python 3.13 this is also logged with a [ResourceWarning](https://docs.python.org/3/whatsnew/3.13.html#sqlite3):      ResourceWarning: unclosed database in <sqlite3.Connection object at ...>  Since the application (since each thread) establishes various DB connections, the (debug) log is flooded with such warnings during development.  I am aware that the DB connectors can be closed when the context is [torn down](https://flask.palletsprojects.com/en/stable/patterns/sqlite3/), but this is not desired. The DB connections should be open over the entire lifetime of the server (thread).  And the problem is not limited to sqlite3, in general, it would be better to close resources before reloading the modules.  Is there perhaps a hook or another chance with which it would be possible to close open resources?   -----  *I placed it here as a feature-request .. may we better move this issue to werkzeug?*",https://github.com/pallets/flask/issues/5711,2025-04-09T14:00:37+00:00
37,pallets/flask,5709,Reference cycle caused by exception handling,"Reference cycle caused by exception handling A reference cycle is introduced by Flask's exception handling mechanism. Specifically, the exception object retains a reference to the stack frame, which in turn holds a reference back to the exception. This creates a reference cycle between the traceback and the exception instance.  This becomes particularly problematic in applications where the garbage collector is disabled (gc.disable()). Even when the GC is enabled, this cycle puts unnecessary pressure on memory management.  The issue originates from the following line in the Flask source code: https://github.com/pallets/flask/blob/9225f8bb28d291b1610c8a58e3233aa6bbdc1808/src/flask/app.py#L1507  The fix is simple: the reference to the exception object should be explicitly released once it is no longer needed.  A minimal reproducible example demonstrating this issue can be found here: üëâ https://github.com/tomasz-pankowski/exception-memory-leak/tree/main  Environment:  - Python version: any - Flask version: 3.1.0 (earlier ones too)",https://github.com/pallets/flask/issues/5709,2025-04-06T08:05:19+00:00
38,pallets/flask,5692,'pkgutil.get_loader' is removed from Python 3.14,"'pkgutil.get_loader' is removed from Python 3.14 Per What's new in Python 3.14: > Remove deprecated pkgutil.get_loader() and pkgutil.find_loader(). These had previously raised a DeprecationWarning since Python 3.12. (Contributed by B√©n√©dikt Tran in gh-97850.)  It manifests in flask's tests:   ``` ______________ ERROR at setup of test_prefix_package_paths[True] _______________  request = <SubRequest 'limit_loader' for <Function test_prefix_package_paths[True]>> monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f1fe6cb9b70>      @pytest.fixture(params=(True, False))     def limit_loader(request, monkeypatch):         """"""Patch pkgutil.get_loader to give loader without get_filename or archive.              This provides for tests where a system has custom loaders, e.g. Google App         Engine's HardenedModulesHook, which have neither the `get_filename` method         nor the `archive` attribute.              This fixture will run the testcase twice, once with and once without the         limitation/mock.         """"""         if not request.param:             return              class LimitedLoader:             def __init__(self, loader):                 self.loader = loader                  def __getattr__(self, name):                 if name in {""archive"", ""get_filename""}:                     raise AttributeError(f""Mocking a loader which does not have {name!r}."")                 return getattr(self.loader, name)      >       old_get_loader = pkgutil.get_loader E       AttributeError: module 'pkgutil' has no attribute 'get_loader'  ERROR tests/test_instance_config.py::test_installed_module_paths[True] - Attr... ERROR tests/test_instance_config.py::test_installed_package_paths[True] - Att... ERROR tests/test_instance_config.py::test_prefix_package_paths[True] - Attrib... ```  Run the tests with Python 3.14  Environment:  - Python version: 3.14.0a6 - Flask version: 3.1.0",https://github.com/pallets/flask/issues/5692,2025-03-19T11:08:53+00:00
39,pallets/flask,5691,flask.__init__.__getattr__ can hide typing errors,"flask.__init__.__getattr__ can hide typing errors admittedly this is a bit of an edge case -- but perhaps if the `__getattr__` pattern is implemented next time for deprecations this can be taken into consideration!  I have an unfortunately-named bit in my webapp called ""flash"" and I've used flask for years and my fingers tend to typo one as the other.  I had a file like this (simplified!):  ```python import flask  flask.FlashMessage ```  which is obviously wrong -- flask doesn't have a `FlashMessage`!  but it was passing mypy due to `def __getattr__(name: str) -> t.Any:` in `__init__.py`  it _might_ be better to guard that behind a `if not t.TYPE_CHECKING: ...` block such that mypy doesn't pick that up and lead to misleading results  not a big deal though and I see that the `__getattr__`  is already removed in mainline  another idea would be to use `@overload` on `__getattr__` such that it only allows the particular Literals? but it looks like mypy doesn't even support that so nevermind! https://github.com/python/mypy/issues/8203#issuecomment-1670344931   Environment:  - Python version: 3.13.1 - Flask version: 3.1.0",https://github.com/pallets/flask/issues/5691,2025-03-08T16:56:50+00:00
40,pallets/flask,5689,Is flask still being maintained?,"Is flask still being maintained? Is flask still being maintained, I see the git was updated 2 month back, can I still use flask for my new project?",https://github.com/pallets/flask/issues/5689,2025-03-04T11:47:03+00:00
41,pallets/flask,5688,Error using sample code in favicon documentation,"Error using sample code in favicon documentation The code sample gives the assert `view_func is not None, ""expected view func if endpoint is not provided.""`.  Documentation in question: https://flask.palletsprojects.com/en/stable/patterns/favicon/  Sample code in question: ``` app.add_url_rule('/favicon.ico',                  redirect_to=url_for('static', filename='favicon.ico')) ```",https://github.com/pallets/flask/issues/5688,2025-03-02T06:04:51+00:00
42,pallets/flask,5686,Inaccurate documentation for adding a favicon redirect,"Inaccurate documentation for adding a favicon redirect The code sample in the existing documentation on how to redirect a favicon request assumes that add_url_rule takes a parameter named redirect_to. It does not.  Documentation in question: https://flask.palletsprojects.com/en/stable/patterns/favicon/  Sample code in question: ``` app.add_url_rule('/favicon.ico',                  redirect_to=url_for('static', filename='favicon.ico')) ```",https://github.com/pallets/flask/issues/5686,2025-03-02T05:29:12+00:00
43,pallets/flask,5679,How to solve,"How to solve ```python response = {         ""status"": ""ok"",         ""message"": ""Success"",         ""response"": url     }     return jsonify(response) ```  In this getting output like this   ```json {""message"": ""success"", ""response"": url, ""status"": ""old""} ```  How to solve that getting incorrect output  I need this like  ``` {         ""status"": ""ok"",         ""message"": ""Success"",         ""response"": url     } ```  How to solve",https://github.com/pallets/flask/issues/5679,2025-02-18T09:21:49+00:00
44,pallets/flask,5676,Admin endpoint seems to be reserved,"Admin endpoint seems to be reserved ```python @app.route(""/admin/<password>/<int:page>"", methods=[""GET""]) def admin(password: str, page: int = 1) -> Any:     print(page)     files, total = [], 2     return render_template(""admin.html"", files=files, password=password, total=total) ```  This fails when page is 1,2,3 or 8.  At least. it might fail in more cases.  If page is 4 or 5, 9,  etc, it works.  By works I mean, it uses the actual argument instead of the default: 1  I'm guessing the admin endpoint is being reserved in some way, but should it?  If I replace 'admin' to 'pok' for example:  `@app.route(""/pok/<password>/<int:page>"", methods=[""GET""])`  Then it works as expected.   Environment:  - Python version: 3.13.1 - Flask version: 3.1.0",https://github.com/pallets/flask/issues/5676,2025-02-08T04:41:55+00:00
45,pallets/flask,5673,Custom commands not listed,"Custom commands not listed When I run the `flask` command by itself I get help output with all of my custom commands listed. But when I run `flask --help` I get the help output with only the built-in flask commands (`routes`, `run`, `shell`). I am using the `FLASK_APP` environment variable to load the app.  I would think I should get the same help output (showing my custom commands) whether or not I add the `--help` parameter?  Environment:  - Python 3.12.2 - Flask 3.1.0",https://github.com/pallets/flask/issues/5673,2025-01-28T06:57:24+00:00
46,pallets/flask,5670,"int route converters are actually uint, but not documented as such","int route converters are actually uint, but not documented as such In #2643, a user noted that flask routes with an `int` converter only accepts unsigned integers.  I'll summarize a few different opinions and options in that thread: 1. a user can create their own converter that accepts unsigned integers, or modifies the existing converter (but only on their codebase). An example code snippet was provided in the issue. 2. The user's report could be treated as a bug in the `int` converter, so the fix would be to modify the flask `int` converter to accept the other ~50% of legitimate integers. Assumptions were made about which part of the integer space most people would use. Concerns were raised about how users may be relying on this bug, and that it should not be fixed for fear of breaking said users. 3. The user's report could be treated as a bug in the documentation, so a presumed fix would be to amend [the documentation](https://flask.palletsprojects.com/en/stable/api/#url-route-registrations) which currently states ""The following converters are available: [...] `int`: accepts integers""; it could be changed to ""`int`: accepts _unsigned_ integers"".  My expectation would have been that either option 2 or 3 would be selected, but instead it appears that the issue was locked to further comment and no further action was taken. So, the documentation is still at odds with the behavior of flask vs the math and computer science definition of integer. I'm not wedded to either solution, but would the pallets team be open to implementing a fix in either direction?  Thank you, -Andrew",https://github.com/pallets/flask/issues/5670,2025-01-13T04:57:35+00:00
47,pallets/flask,5669,ok,"ok <!-- Replace this comment with a description of what the feature should do. Include details such as links to relevant specs or previous discussions. -->  <!-- Replace this comment with an example of the problem which this feature would resolve. Is this problem solvable without changes to Flask, such as by subclassing or using an extension? -->",https://github.com/pallets/flask/issues/5669,2025-01-10T14:36:15+00:00
48,pallets/flask,5667,Consider supporting HOT reload with `hmr`?,"Consider supporting HOT reload with `hmr`? Hot Module Replacement has been existed in JavaScript ecosystem for a long time, but Python web applications are still using full reloads by default.  To solve this situation, I implemented the `hmr` package, which does the fine-grained dependency tracking, on-demand reloading jobs. Here is a demo of what the results look like:  https://github.com/user-attachments/assets/7937d1c2-ed41-4f38-be18-9cc29b9961a1  Obviously the `a.py` runs everytime in `flask run --reload` but reloads only when needed in `hmr app.py`. But everything else works fine (at least for this small demo)  You may say that user should use lazy imports and cache expensive calculations themselves, but in fact not every function can be cached, and lazy imports may lead to ugly code style. This can be solved with on-demand hot reloading without overhead. So I believe this is the future.  Although this is just a minimal demo, but I value hmr's potential in the Python ecosystem, and believe that with our efforts this is a reachable goal.  > [!TIP] > You can try the example above [here](https://github.com/promplate/hmr/tree/readme/examples/flask) with `hmr app.py`  ---  About `hmr`, you can refer to its [README](https://github.com/promplate/hmr) for details.",https://github.com/pallets/flask/issues/5667,2025-01-10T08:58:37+00:00
49,pallets/flask,5666,intersphinx broken for flask.Flask.cli,"intersphinx broken for flask.Flask.cli https://flask.palletsprojects.com/en/stable/api/#flask.Flask.cli has a type of `Group`, but it doesn't link to further docs.",https://github.com/pallets/flask/issues/5666,2025-01-03T18:51:42+00:00
50,pallets/flask,5662,Containerization,Containerization Hello  team I am planning to containerized the entire flask framework using docker so whenever user needs to work on the project they can able to run entire framework just by running docker container so can i work on this feature.,https://github.com/pallets/flask/issues/5662,2024-12-29T12:29:29+00:00
