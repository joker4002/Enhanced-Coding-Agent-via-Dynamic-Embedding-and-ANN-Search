chunk_id,file_path,symbol_type,name,qualname,start_line,end_line,docstring,code,code_truncated
808629067c359c34f451d7730f7cc68ff7501353,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,function,_make_timedelta,_make_timedelta,74,78,,"def _make_timedelta(value: timedelta | int | None) -> timedelta | None:
    if value is None or isinstance(value, timedelta):
        return value

    return timedelta(seconds=value)",False
c77125a1db681ef277cc41ff81832fc28a2878b3,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,class,Flask,Flask,81,1536,"The flask object implements a WSGI application and acts as the central
object.  It is passed the name of the module or package of the
application.  Once it is created it will act as a central registry for
the view functions, the URL rules, template configuration and much more.

The name of the package is used to resolve resources from inside the
package or the folder the module is contained in depending on if the
package parameter resolves to an actual python package (a folder with
an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).

For more information about resource loading, see :func:`open_resource`.

Usually you create a :class:`Flask` instance in your main module or
in the :file:`__init__.py` file of your package like this::

    from flask import Flask
    app = Flask(__name__)

.. admonition:: About the First Parameter

    The idea of the first parameter is to give Flask an idea of what
    belongs to your application.  This name is used to find resources
    on the filesystem, can be used by extensions to improve debugging
    information and a lot more.

    So it's important what you provide there.  If you are using a single
    module, `__name__` is always the correct value.  If you however are
    using a package, it's usually recommended to hardcode the name of
    your package there.

    For example if your application is defined in :file:`yourapplication/app.py`
    you should create it with one of the two versions below::

        app = Flask('yourapplication')
        app = Flask(__name__.split('.')[0])

    Why is that?  The application will work even with `__name__`, thanks
    to how resources are looked up.  However it will make debugging more
    painful.  Certain extensions can make assumptions based on the
    import name of your application.  For example the Flask-SQLAlchemy
    extension will look for the code in your application that triggered
    an SQL query in debug mode.  If the import name is not properly set
    up, that debugging information is lost.  (For example it would only
    pick up SQL queries in `yourapplication.app` and not
    `yourapplication.views.frontend`)

.. versionadded:: 0.7
   The `static_url_path`, `static_folder`, and `template_folder`
   parameters were added.

.. versionadded:: 0.8
   The `instance_path` and `instance_relative_config` parameters were
   added.

.. versionadded:: 0.11
   The `root_path` parameter was added.

.. versionadded:: 1.0
   The ``host_matching`` and ``static_host`` parameters were added.

.. versionadded:: 1.0
   The ``subdomain_matching`` parameter was added. Subdomain
   matching needs to be enabled manually now. Setting
   :data:`SERVER_NAME` does not implicitly enable it.

:param import_name: the name of the application package
:param static_url_path: can be used to specify a different path for the
                        static files on the web.  Defaults to the name
                        of the `static_folder` folder.
:param static_folder: The folder with static files that is served at
    ``static_url_path``. Relative to the application ``root_path``
    or an absolute path. Defaults to ``'static'``.
:param static_host: the host to use when adding the static route.
    Defaults to None. Required when using ``host_matching=True``
    with a ``static_folder`` configured.
:param host_matching: set ``url_map.host_matching`` attribute.
    Defaults to False.
:param subdomain_matching: consider the subdomain relative to
    :data:`SERVER_NAME` when matching routes. Defaults to False.
:param template_folder: the folder that contains the templates that should
                        be used by the application.  Defaults to
                        ``'templates'`` folder in the root path of the
                        application.
:param instance_path: An alternative instance path for the application.
                      By default the folder ``'instance'`` next to the
                      package or module is assumed to be the instance
                      path.
:param instance_relative_config: if set to ``True`` relative filenames
                                 for loading the config are assumed to
                                 be relative to the instance path instead
                                 of the application root.
:param root_path: The path to the root of the application files.
    This should only be set manually when it can't be detected
    automatically, such as for namespace packages.","class Flask(App):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the :file:`__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)

    .. admonition:: About the First Parameter

        The idea of the first parameter is to give Flask an idea of what
        belongs to your application.  This name is used to find resources
        on the filesystem, can be used by extensions to improve debugging
        information and a lot more.

        So it's important what you provide there.  If you are using a single
        module, `__name__` is always the correct value.  If you however are
        using a package, it's usually recommended to hardcode the name of
        your package there.

        For example if your application is defined in :file:`yourapplication/app.py`
        you should create it with one of the two versions below::

            app = Flask('yourapplication')
            app = Flask(__name__.split('.')[0])

        Why is that?  The application will work even with `__name__`, thanks
        to how resources are looked up.  However it will make debugging more
        painful.  Certain extensions can make assumptions based on the
        import name of your application.  For example the Flask-SQLAlchemy
        extension will look for the code in your application that triggered
        an SQL query in debug mode.  If the import name is not properly set
        up, that debugging information is lost.  (For example it would only
        pick up SQL queries in `yourapplication.app` and not
        `yourapplication.views.frontend`)

    .. versionadded:: 0.7
       The `static_url_path`, `static_folder`, and `template_folder`
       parameters were added.

    .. versionadded:: 0.8
       The `instance_path` and `instance_relative_config` parameters were
       added.

    .. versionadded:: 0.11
       The `root_path` parameter was added.

    .. versionadded:: 1.0
       The ``host_matching`` and ``static_host`` parameters were added.

    .. versionadded:: 1.0
       The ``subdomain_matching`` parameter was added. Subdomain
       matching needs to be enabled manually now. Setting
       :data:`SERVER_NAME` does not implicitly enable it.

    :param import_name: the name of the application package
    :param static_url_path: can be used to specify a different path for the
                            static files on the web.  Defaults to the name
                            of the `static_folder` folder.
    :param static_folder: The folder with static files that is served at
        ``static_url_path``. Relative to the application ``root_path``
        or an absolute path. Defaults to ``'static'``.
    :param static_host: the host to use when adding the static route.
        Defaults to None. Required when using ``host_matching=True``
        with a ``static_folder`` configured.
    :param host_matching: set ``url_map.host_matching`` attribute.
        Defaults to False.
    :param subdomain_matching: consider the subdomain relative to
        :data:`SERVER_NAME` when matching routes. Defaults to False.
    :param template_folder: the folder that contains the templates that should
                            be used by the application.  Defaults to
                            ``'templates'`` folder in the root path of the
                            application.
    :param instance_path: An alternative instance path for the application.
                          By default the folder ``'instance'`` next to the
                          package or module is assumed to be the instance
                          path.
    :param instance_relative_config: if set to ``True`` relative filenames
                                     for loading the config are assumed to
                                     be relative to the instance path instead
                                     of the application root.
    :param root_path: The path to the root of the application files.
        This should only be set manually when it can't be detected
        automatically, such as for namespace packages.
    """"""

    default_config = ImmutableDict(
        {
            ""DEBUG"": None,
            ""TESTING"": False,
            ""PROPAGATE_EXCEPTIONS"": None,
            ""SECRET_KEY"": None,
            ""SECRET_KEY_FALLBACKS"": None,
            ""PERMANENT_SESSION_LIFETIME"": timedelta(days=31),
            ""USE_X_SENDFILE"": False,
            ""TRUSTED_HOSTS"": None,
            ""SERVER_NAME"": None,
            ""APPLICATION_ROOT"": ""/"",
            ""SESSION_COOKIE_NAME"": ""session"",
            ""SESSION_COOKIE_DOMAIN"": None,
            ""SESSION_COOKIE_PATH"": None,
            ""SESSION_COOKIE_HTTPONLY"": True,
            ""SESSION_COOKIE_SECURE"": False,
            ""SESSION_COOKIE_PARTITIONED"": False,
            ""SESSION_COOKIE_SAMESITE"": None,
            ""SESSION_REFRESH_EACH_REQUEST"": True,
            ""MAX_CONTENT_LENGTH"": None,
            ""MAX_FORM_MEMORY_SIZE"": 500_000,
            ""MAX_FORM_PARTS"": 1_000,
            ""SEND_FILE_MAX_AGE_DEFAULT"": None,
            ""TRAP_BAD_REQUEST_ERRORS"": None,
            ""TRAP_HTTP_EXCEPTIONS"": False,
            ""EXPLAIN_TEMPLATE_LOADING"": False,
            ""PREFERRED_URL_SCHEME"": ""http"",
            ""TEMPLATES_AUTO_RELOAD"": None,
            ""MAX_COOKIE_SIZE"": 4093,
            ""PROVIDE_AUTOMATIC_OPTIONS"": True,
        }
    )

    #: The class that is used for request objects.  See :class:`~flask.Request`
    #: for more information.
    request_class: type[Request] = Request

    #: The class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class: type[Response] = Response

    #: the session interface to use.  By default an instance of
    #: :class:`~flask.sessions.SecureCookieSessionInterface` is used here.
    #:
    #: .. versionadded:: 0.8
    session_interface: SessionInterface = SecureCookieSessionInterface()

    def __init__(
        self,
        import_name: str,
        static_url_path: str | None = None,
        static_folder: str | os.PathLike[str] | None = ""static"",
        static_host: str | None = None,
        host_matching: bool = False,
        subdomain_matching: bool = False,
        template_folder: str | os.PathLike[str] | None = ""templates"",
        instance_path: str | None = None,
        instance_relative_config: bool = False,
        root_path: str | None = None,
    ):
        super().__init__(
            import_name=import_name,
            static_url_path=static_url_path,
            static_folder=static_folder,
            static_host=static_host,
            host_matching=host_matching,
            subdomain_matching=subdomain_matching,
            template_folder=template_folder,
            instance_path=instance_path,
            instance_relative_config=instance_relative_config,
            root_path=root_path,
        )

        #: The Click command group for registering CLI commands for this
        #: object. The commands are available from the ``flask`` command
        #: once the application has been discovered and blueprints have
        #: been registered.
        self.cli = cli.AppGroup()

        # Set the name of the Click group in case s
...<truncated>...
",True
c423e295e7bf68c8d02a7cc0eb2d833f1a143969,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,__init__,Flask.__init__,226,279,,"    def __init__(
        self,
        import_name: str,
        static_url_path: str | None = None,
        static_folder: str | os.PathLike[str] | None = ""static"",
        static_host: str | None = None,
        host_matching: bool = False,
        subdomain_matching: bool = False,
        template_folder: str | os.PathLike[str] | None = ""templates"",
        instance_path: str | None = None,
        instance_relative_config: bool = False,
        root_path: str | None = None,
    ):
        super().__init__(
            import_name=import_name,
            static_url_path=static_url_path,
            static_folder=static_folder,
            static_host=static_host,
            host_matching=host_matching,
            subdomain_matching=subdomain_matching,
            template_folder=template_folder,
            instance_path=instance_path,
            instance_relative_config=instance_relative_config,
            root_path=root_path,
        )

        #: The Click command group for registering CLI commands for this
        #: object. The commands are available from the ``flask`` command
        #: once the application has been discovered and blueprints have
        #: been registered.
        self.cli = cli.AppGroup()

        # Set the name of the Click group in case someone wants to add
        # the app's commands to another CLI tool.
        self.cli.name = self.name

        # Add a static route using the provided static_url_path, static_host,
        # and static_folder if there is a configured static_folder.
        # Note we do this without checking if static_folder exists.
        # For one, it might be created while the server is running (e.g. during
        # development). Also, Google App Engine stores static files somewhere
        if self.has_static_folder:
            assert bool(static_host) == host_matching, (
                ""Invalid static_host/host_matching combination""
            )
            # Use a weakref to avoid creating a reference cycle between the app
            # and the view function (see #3761).
            self_ref = weakref.ref(self)
            self.add_url_rule(
                f""{self.static_url_path}/<path:filename>"",
                endpoint=""static"",
                host=static_host,
                view_func=lambda **kw: self_ref().send_static_file(**kw),  # type: ignore # noqa: B950
            )",False
7ed3163e62dc47435697e83110e6bd4d52b15476,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,get_send_file_max_age,Flask.get_send_file_max_age,281,306,"Used by :func:`send_file` to determine the ``max_age`` cache
value for a given file path if it wasn't passed.

By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from
the configuration of :data:`~flask.current_app`. This defaults
to ``None``, which tells the browser to use conditional requests
instead of a timed cache, which is usually preferable.

Note this is a duplicate of the same method in the Flask
class.

.. versionchanged:: 2.0
    The default configuration is ``None`` instead of 12 hours.

.. versionadded:: 0.9","    def get_send_file_max_age(self, filename: str | None) -> int | None:
        """"""Used by :func:`send_file` to determine the ``max_age`` cache
        value for a given file path if it wasn't passed.

        By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from
        the configuration of :data:`~flask.current_app`. This defaults
        to ``None``, which tells the browser to use conditional requests
        instead of a timed cache, which is usually preferable.

        Note this is a duplicate of the same method in the Flask
        class.

        .. versionchanged:: 2.0
            The default configuration is ``None`` instead of 12 hours.

        .. versionadded:: 0.9
        """"""
        value = current_app.config[""SEND_FILE_MAX_AGE_DEFAULT""]

        if value is None:
            return None

        if isinstance(value, timedelta):
            return int(value.total_seconds())

        return value  # type: ignore[no-any-return]",False
c489d69714a72cefb058fb26c8d8d988653fbce5,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,send_static_file,Flask.send_static_file,308,328,"The view function used to serve files from
:attr:`static_folder`. A route is automatically registered for
this view at :attr:`static_url_path` if :attr:`static_folder` is
set.

Note this is a duplicate of the same method in the Flask
class.

.. versionadded:: 0.5","    def send_static_file(self, filename: str) -> Response:
        """"""The view function used to serve files from
        :attr:`static_folder`. A route is automatically registered for
        this view at :attr:`static_url_path` if :attr:`static_folder` is
        set.

        Note this is a duplicate of the same method in the Flask
        class.

        .. versionadded:: 0.5

        """"""
        if not self.has_static_folder:
            raise RuntimeError(""'static_folder' must be set to serve static_files."")

        # send_file only knows to call get_send_file_max_age on the app,
        # call it here so it works for blueprints too.
        max_age = self.get_send_file_max_age(filename)
        return send_from_directory(
            t.cast(str, self.static_folder), filename, max_age=max_age
        )",False
c61715a41cf32cea221bf9769e1846f172e010bf,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,open_resource,Flask.open_resource,330,361,"Open a resource file relative to :attr:`root_path` for reading.

For example, if the file ``schema.sql`` is next to the file
``app.py`` where the ``Flask`` app is defined, it can be opened
with:

.. code-block:: python

    with app.open_resource(""schema.sql"") as f:
        conn.executescript(f.read())

:param resource: Path to the resource relative to :attr:`root_path`.
:param mode: Open the file in this mode. Only reading is supported,
    valid values are ``""r""`` (or ``""rt""``) and ``""rb""``.
:param encoding: Open the file with this encoding when opening in text
    mode. This is ignored when opening in binary mode.

.. versionchanged:: 3.1
    Added the ``encoding`` parameter.","    def open_resource(
        self, resource: str, mode: str = ""rb"", encoding: str | None = None
    ) -> t.IO[t.AnyStr]:
        """"""Open a resource file relative to :attr:`root_path` for reading.

        For example, if the file ``schema.sql`` is next to the file
        ``app.py`` where the ``Flask`` app is defined, it can be opened
        with:

        .. code-block:: python

            with app.open_resource(""schema.sql"") as f:
                conn.executescript(f.read())

        :param resource: Path to the resource relative to :attr:`root_path`.
        :param mode: Open the file in this mode. Only reading is supported,
            valid values are ``""r""`` (or ``""rt""``) and ``""rb""``.
        :param encoding: Open the file with this encoding when opening in text
            mode. This is ignored when opening in binary mode.

        .. versionchanged:: 3.1
            Added the ``encoding`` parameter.
        """"""
        if mode not in {""r"", ""rt"", ""rb""}:
            raise ValueError(""Resources can only be opened for reading."")

        path = os.path.join(self.root_path, resource)

        if mode == ""rb"":
            return open(path, mode)  # pyright: ignore

        return open(path, mode, encoding=encoding)",False
79243aee3765a588be50ca9e36ae60777870cbf6,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,open_instance_resource,Flask.open_instance_resource,363,383,"Open a resource file relative to the application's instance folder
:attr:`instance_path`. Unlike :meth:`open_resource`, files in the
instance folder can be opened for writing.

:param resource: Path to the resource relative to :attr:`instance_path`.
:param mode: Open the file in this mode.
:param encoding: Open the file with this encoding when opening in text
    mode. This is ignored when opening in binary mode.

.. versionchanged:: 3.1
    Added the ``encoding`` parameter.","    def open_instance_resource(
        self, resource: str, mode: str = ""rb"", encoding: str | None = ""utf-8""
    ) -> t.IO[t.AnyStr]:
        """"""Open a resource file relative to the application's instance folder
        :attr:`instance_path`. Unlike :meth:`open_resource`, files in the
        instance folder can be opened for writing.

        :param resource: Path to the resource relative to :attr:`instance_path`.
        :param mode: Open the file in this mode.
        :param encoding: Open the file with this encoding when opening in text
            mode. This is ignored when opening in binary mode.

        .. versionchanged:: 3.1
            Added the ``encoding`` parameter.
        """"""
        path = os.path.join(self.instance_path, resource)

        if ""b"" in mode:
            return open(path, mode)

        return open(path, mode, encoding=encoding)",False
e611ef2592e61ab0a6af35ffdcf2360f04187d56,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,create_jinja_environment,Flask.create_jinja_environment,385,423,"Create the Jinja environment based on :attr:`jinja_options`
and the various Jinja-related methods of the app. Changing
:attr:`jinja_options` after this will have no effect. Also adds
Flask-related globals and filters to the environment.

.. versionchanged:: 0.11
   ``Environment.auto_reload`` set in accordance with
   ``TEMPLATES_AUTO_RELOAD`` configuration option.

.. versionadded:: 0.5","    def create_jinja_environment(self) -> Environment:
        """"""Create the Jinja environment based on :attr:`jinja_options`
        and the various Jinja-related methods of the app. Changing
        :attr:`jinja_options` after this will have no effect. Also adds
        Flask-related globals and filters to the environment.

        .. versionchanged:: 0.11
           ``Environment.auto_reload`` set in accordance with
           ``TEMPLATES_AUTO_RELOAD`` configuration option.

        .. versionadded:: 0.5
        """"""
        options = dict(self.jinja_options)

        if ""autoescape"" not in options:
            options[""autoescape""] = self.select_jinja_autoescape

        if ""auto_reload"" not in options:
            auto_reload = self.config[""TEMPLATES_AUTO_RELOAD""]

            if auto_reload is None:
                auto_reload = self.debug

            options[""auto_reload""] = auto_reload

        rv = self.jinja_environment(self, **options)
        rv.globals.update(
            url_for=self.url_for,
            get_flashed_messages=get_flashed_messages,
            config=self.config,
            # request, session and g are normally added with the
            # context processor for efficiency reasons but for imported
            # templates we also want the proxies in there.
            request=request,
            session=session,
            g=g,
        )
        rv.policies[""json.dumps_function""] = self.json.dumps
        return rv",False
9814c6e54a863271a5616cede686dba496ba2ce1,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,create_url_adapter,Flask.create_url_adapter,425,476,"Creates a URL adapter for the given request. The URL adapter
is created at a point where the request context is not yet set
up so the request is passed explicitly.

.. versionchanged:: 3.1
    If :data:`SERVER_NAME` is set, it does not restrict requests to
    only that domain, for both ``subdomain_matching`` and
    ``host_matching``.

.. versionchanged:: 1.0
    :data:`SERVER_NAME` no longer implicitly enables subdomain
    matching. Use :attr:`subdomain_matching` instead.

.. versionchanged:: 0.9
   This can be called outside a request when the URL adapter is created
   for an application context.

.. versionadded:: 0.6","    def create_url_adapter(self, request: Request | None) -> MapAdapter | None:
        """"""Creates a URL adapter for the given request. The URL adapter
        is created at a point where the request context is not yet set
        up so the request is passed explicitly.

        .. versionchanged:: 3.1
            If :data:`SERVER_NAME` is set, it does not restrict requests to
            only that domain, for both ``subdomain_matching`` and
            ``host_matching``.

        .. versionchanged:: 1.0
            :data:`SERVER_NAME` no longer implicitly enables subdomain
            matching. Use :attr:`subdomain_matching` instead.

        .. versionchanged:: 0.9
           This can be called outside a request when the URL adapter is created
           for an application context.

        .. versionadded:: 0.6
        """"""
        if request is not None:
            if (trusted_hosts := self.config[""TRUSTED_HOSTS""]) is not None:
                request.trusted_hosts = trusted_hosts

            # Check trusted_hosts here until bind_to_environ does.
            request.host = get_host(request.environ, request.trusted_hosts)  # pyright: ignore
            subdomain = None
            server_name = self.config[""SERVER_NAME""]

            if self.url_map.host_matching:
                # Don't pass SERVER_NAME, otherwise it's used and the actual
                # host is ignored, which breaks host matching.
                server_name = None
            elif not self.subdomain_matching:
                # Werkzeug doesn't implement subdomain matching yet. Until then,
                # disable it by forcing the current subdomain to the default, or
                # the empty string.
                subdomain = self.url_map.default_subdomain or """"

            return self.url_map.bind_to_environ(
                request.environ, server_name=server_name, subdomain=subdomain
            )

        # Need at least SERVER_NAME to match/build outside a request.
        if self.config[""SERVER_NAME""] is not None:
            return self.url_map.bind(
                self.config[""SERVER_NAME""],
                script_name=self.config[""APPLICATION_ROOT""],
                url_scheme=self.config[""PREFERRED_URL_SCHEME""],
            )

        return None",False
7a4280a5e1bcb934ccb2ddf399d35cb79827c7c1,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,raise_routing_exception,Flask.raise_routing_exception,478,504,"Intercept routing exceptions and possibly do something else.

In debug mode, intercept a routing redirect and replace it with
an error if the body will be discarded.

With modern Werkzeug this shouldn't occur, since it now uses a
308 status which tells the browser to resend the method and
body.

.. versionchanged:: 2.1
    Don't intercept 307 and 308 redirects.

:meta private:
:internal:","    def raise_routing_exception(self, request: Request) -> t.NoReturn:
        """"""Intercept routing exceptions and possibly do something else.

        In debug mode, intercept a routing redirect and replace it with
        an error if the body will be discarded.

        With modern Werkzeug this shouldn't occur, since it now uses a
        308 status which tells the browser to resend the method and
        body.

        .. versionchanged:: 2.1
            Don't intercept 307 and 308 redirects.

        :meta private:
        :internal:
        """"""
        if (
            not self.debug
            or not isinstance(request.routing_exception, RequestRedirect)
            or request.routing_exception.code in {307, 308}
            or request.method in {""GET"", ""HEAD"", ""OPTIONS""}
        ):
            raise request.routing_exception  # type: ignore[misc]

        from .debughelpers import FormDataRoutingRedirect

        raise FormDataRoutingRedirect(request)",False
a6c1a726e74b54d45339f1de4e7e54b7f29b4692,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,update_template_context,Flask.update_template_context,506,532,"Update the template context with some commonly used variables.
This injects request, session, config and g into the template
context as well as everything template context processors want
to inject.  Note that the as of Flask 0.6, the original values
in the context will not be overridden if a context processor
decides to return a value with the same key.

:param context: the context as a dictionary that is updated in place
                to add extra variables.","    def update_template_context(self, context: dict[str, t.Any]) -> None:
        """"""Update the template context with some commonly used variables.
        This injects request, session, config and g into the template
        context as well as everything template context processors want
        to inject.  Note that the as of Flask 0.6, the original values
        in the context will not be overridden if a context processor
        decides to return a value with the same key.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        names: t.Iterable[str | None] = (None,)

        # A template may be rendered outside a request context.
        if request:
            names = chain(names, reversed(request.blueprints))

        # The values passed to render_template take precedence. Keep a
        # copy to re-apply after all context functions.
        orig_ctx = context.copy()

        for name in names:
            if name in self.template_context_processors:
                for func in self.template_context_processors[name]:
                    context.update(self.ensure_sync(func)())

        context.update(orig_ctx)",False
6f5ee51db4cc3bb8e6ae64306754465d6096bd55,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,make_shell_context,Flask.make_shell_context,534,544,"Returns the shell context for an interactive shell for this
application.  This runs all the registered shell context
processors.

.. versionadded:: 0.11","    def make_shell_context(self) -> dict[str, t.Any]:
        """"""Returns the shell context for an interactive shell for this
        application.  This runs all the registered shell context
        processors.

        .. versionadded:: 0.11
        """"""
        rv = {""app"": self, ""g"": g}
        for processor in self.shell_context_processors:
            rv.update(processor())
        return rv",False
05922660b6467436642c226aee8c17caea5fb6b3,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,run,Flask.run,546,667,"Runs the application on a local development server.

Do not use ``run()`` in a production setting. It is not intended to
meet security and performance requirements for a production server.
Instead, see :doc:`/deploying/index` for WSGI server recommendations.

If the :attr:`debug` flag is set the server will automatically reload
for code changes and show a debugger in case an exception happened.

If you want to run the application in debug mode, but disable the
code execution on the interactive debugger, you can pass
``use_evalex=False`` as parameter.  This will keep the debugger's
traceback screen active, but disable code execution.

It is not recommended to use this function for development with
automatic reloading as this is badly supported.  Instead you should
be using the :command:`flask` command line script's ``run`` support.

.. admonition:: Keep in Mind

   Flask will suppress any server error with a generic error page
   unless it is in debug mode.  As such to enable just the
   interactive debugger without the code reloading, you have to
   invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``.
   Setting ``use_debugger`` to ``True`` without being in debug mode
   won't catch any exceptions because there won't be any to
   catch.

:param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to
    have the server available externally as well. Defaults to
    ``'127.0.0.1'`` or the host in the ``SERVER_NAME`` config variable
    if present.
:param port: the port of the webserver. Defaults to ``5000`` or the
    port defined in the ``SERVER_NAME`` config variable if present.
:param debug: if given, enable or disable debug mode. See
    :attr:`debug`.
:param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`
    files to set environment variables. Will also change the working
    directory to the directory containing the first file found.
:param options: the options to be forwarded to the underlying Werkzeug
    server. See :func:`werkzeug.serving.run_simple` for more
    information.

.. versionchanged:: 1.0
    If installed, python-dotenv will be used to load environment
    variables from :file:`.env` and :file:`.flaskenv` files.

    The :envvar:`FLASK_DEBUG` environment variable will override :attr:`debug`.

    Threaded mode is enabled by default.

.. versionchanged:: 0.10
    The default port is now picked from the ``SERVER_NAME``
    variable.","    def run(
        self,
        host: str | None = None,
        port: int | None = None,
        debug: bool | None = None,
        load_dotenv: bool = True,
        **options: t.Any,
    ) -> None:
        """"""Runs the application on a local development server.

        Do not use ``run()`` in a production setting. It is not intended to
        meet security and performance requirements for a production server.
        Instead, see :doc:`/deploying/index` for WSGI server recommendations.

        If the :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        If you want to run the application in debug mode, but disable the
        code execution on the interactive debugger, you can pass
        ``use_evalex=False`` as parameter.  This will keep the debugger's
        traceback screen active, but disable code execution.

        It is not recommended to use this function for development with
        automatic reloading as this is badly supported.  Instead you should
        be using the :command:`flask` command line script's ``run`` support.

        .. admonition:: Keep in Mind

           Flask will suppress any server error with a generic error page
           unless it is in debug mode.  As such to enable just the
           interactive debugger without the code reloading, you have to
           invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``.
           Setting ``use_debugger`` to ``True`` without being in debug mode
           won't catch any exceptions because there won't be any to
           catch.

        :param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to
            have the server available externally as well. Defaults to
            ``'127.0.0.1'`` or the host in the ``SERVER_NAME`` config variable
            if present.
        :param port: the port of the webserver. Defaults to ``5000`` or the
            port defined in the ``SERVER_NAME`` config variable if present.
        :param debug: if given, enable or disable debug mode. See
            :attr:`debug`.
        :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`
            files to set environment variables. Will also change the working
            directory to the directory containing the first file found.
        :param options: the options to be forwarded to the underlying Werkzeug
            server. See :func:`werkzeug.serving.run_simple` for more
            information.

        .. versionchanged:: 1.0
            If installed, python-dotenv will be used to load environment
            variables from :file:`.env` and :file:`.flaskenv` files.

            The :envvar:`FLASK_DEBUG` environment variable will override :attr:`debug`.

            Threaded mode is enabled by default.

        .. versionchanged:: 0.10
            The default port is now picked from the ``SERVER_NAME``
            variable.
        """"""
        # Ignore this call so that it doesn't start another server if
        # the 'flask run' command is used.
        if os.environ.get(""FLASK_RUN_FROM_CLI"") == ""true"":
            if not is_running_from_reloader():
                click.secho(
                    "" * Ignoring a call to 'app.run()' that would block""
                    "" the current 'flask' CLI command.\n""
                    ""   Only call 'app.run()' in an 'if __name__ ==""
                    ' ""__main__""\' guard.',
                    fg=""red"",
                )

            return

        if get_load_dotenv(load_dotenv):
            cli.load_dotenv()

            # if set, env var overrides existing value
            if ""FLASK_DEBUG"" in os.environ:
                self.debug = get_debug_flag()

        # debug passed to method overrides all other sources
        if debug is not None:
            self.debug = bool(debug)

        server_name = self.config.get(""SERVER_NAME"")
        sn_host = sn_port = None

        if server_name:
            sn_host, _, sn_port = server_name.partition("":"")

        if not host:
            if sn_host:
                host = sn_host
            else:
                host = ""127.0.0.1""

        if port or port == 0:
            port = int(port)
        elif sn_port:
            port = int(sn_port)
        else:
            port = 5000

        options.setdefault(""use_reloader"", self.debug)
        options.setdefault(""use_debugger"", self.debug)
        options.setdefault(""threaded"", True)

        cli.show_server_banner(self.debug, self.name)

        from werkzeug.serving import run_simple

        try:
            run_simple(t.cast(str, host), port, self, **options)
        finally:
            # reset the first request information if the development server
            # reset normally.  This makes it possible to restart the server
            # without reloader and that stuff from an interactive shell.
            self._got_first_request = False",False
3f1cdfd211540b7cae8f38853af5273c3831487d,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,test_client,Flask.test_client,669,725,"Creates a test client for this application.  For information
about unit testing head over to :doc:`/testing`.

Note that if you are testing for assertions or exceptions in your
application code, you must set ``app.testing = True`` in order for the
exceptions to propagate to the test client.  Otherwise, the exception
will be handled by the application (not visible to the test client) and
the only indication of an AssertionError or other exception will be a
500 status code response to the test client.  See the :attr:`testing`
attribute.  For example::

    app.testing = True
    client = app.test_client()

The test client can be used in a ``with`` block to defer the closing down
of the context until the end of the ``with`` block.  This is useful if
you want to access the context locals for testing::

    with app.test_client() as c:
        rv = c.get('/?vodka=42')
        assert request.args['vodka'] == '42'

Additionally, you may pass optional keyword arguments that will then
be passed to the application's :attr:`test_client_class` constructor.
For example::

    from flask.testing import FlaskClient

    class CustomClient(FlaskClient):
        def __init__(self, *args, **kwargs):
            self._authentication = kwargs.pop(""authentication"")
            super(CustomClient,self).__init__( *args, **kwargs)

    app.test_client_class = CustomClient
    client = app.test_client(authentication='Basic ....')

See :class:`~flask.testing.FlaskClient` for more information.

.. versionchanged:: 0.4
   added support for ``with`` block usage for the client.

.. versionadded:: 0.7
   The `use_cookies` parameter was added as well as the ability
   to override the client to be used by setting the
   :attr:`test_client_class` attribute.

.. versionchanged:: 0.11
   Added `**kwargs` to support passing additional keyword arguments to
   the constructor of :attr:`test_client_class`.","    def test_client(self, use_cookies: bool = True, **kwargs: t.Any) -> FlaskClient:
        """"""Creates a test client for this application.  For information
        about unit testing head over to :doc:`/testing`.

        Note that if you are testing for assertions or exceptions in your
        application code, you must set ``app.testing = True`` in order for the
        exceptions to propagate to the test client.  Otherwise, the exception
        will be handled by the application (not visible to the test client) and
        the only indication of an AssertionError or other exception will be a
        500 status code response to the test client.  See the :attr:`testing`
        attribute.  For example::

            app.testing = True
            client = app.test_client()

        The test client can be used in a ``with`` block to defer the closing down
        of the context until the end of the ``with`` block.  This is useful if
        you want to access the context locals for testing::

            with app.test_client() as c:
                rv = c.get('/?vodka=42')
                assert request.args['vodka'] == '42'

        Additionally, you may pass optional keyword arguments that will then
        be passed to the application's :attr:`test_client_class` constructor.
        For example::

            from flask.testing import FlaskClient

            class CustomClient(FlaskClient):
                def __init__(self, *args, **kwargs):
                    self._authentication = kwargs.pop(""authentication"")
                    super(CustomClient,self).__init__( *args, **kwargs)

            app.test_client_class = CustomClient
            client = app.test_client(authentication='Basic ....')

        See :class:`~flask.testing.FlaskClient` for more information.

        .. versionchanged:: 0.4
           added support for ``with`` block usage for the client.

        .. versionadded:: 0.7
           The `use_cookies` parameter was added as well as the ability
           to override the client to be used by setting the
           :attr:`test_client_class` attribute.

        .. versionchanged:: 0.11
           Added `**kwargs` to support passing additional keyword arguments to
           the constructor of :attr:`test_client_class`.
        """"""
        cls = self.test_client_class
        if cls is None:
            from .testing import FlaskClient as cls
        return cls(  # type: ignore
            self, self.response_class, use_cookies=use_cookies, **kwargs
        )",False
9f5f231ea03e1260df1c33a2812e08d4afc79a5b,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,test_cli_runner,Flask.test_cli_runner,727,742,"Create a CLI runner for testing CLI commands.
See :ref:`testing-cli`.

Returns an instance of :attr:`test_cli_runner_class`, by default
:class:`~flask.testing.FlaskCliRunner`. The Flask app object is
passed as the first argument.

.. versionadded:: 1.0","    def test_cli_runner(self, **kwargs: t.Any) -> FlaskCliRunner:
        """"""Create a CLI runner for testing CLI commands.
        See :ref:`testing-cli`.

        Returns an instance of :attr:`test_cli_runner_class`, by default
        :class:`~flask.testing.FlaskCliRunner`. The Flask app object is
        passed as the first argument.

        .. versionadded:: 1.0
        """"""
        cls = self.test_cli_runner_class

        if cls is None:
            from .testing import FlaskCliRunner as cls

        return cls(self, **kwargs)  # type: ignore",False
c3746396fb3747062ec6a24f9a99d3f56fceb528,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,handle_http_exception,Flask.handle_http_exception,744,777,"Handles an HTTP exception.  By default this will invoke the
registered error handlers and fall back to returning the
exception as response.

.. versionchanged:: 1.0.3
    ``RoutingException``, used internally for actions such as
     slash redirects during routing, is not passed to error
     handlers.

.. versionchanged:: 1.0
    Exceptions are looked up by code *and* by MRO, so
    ``HTTPException`` subclasses can be handled with a catch-all
    handler for the base ``HTTPException``.

.. versionadded:: 0.3","    def handle_http_exception(
        self, e: HTTPException
    ) -> HTTPException | ft.ResponseReturnValue:
        """"""Handles an HTTP exception.  By default this will invoke the
        registered error handlers and fall back to returning the
        exception as response.

        .. versionchanged:: 1.0.3
            ``RoutingException``, used internally for actions such as
             slash redirects during routing, is not passed to error
             handlers.

        .. versionchanged:: 1.0
            Exceptions are looked up by code *and* by MRO, so
            ``HTTPException`` subclasses can be handled with a catch-all
            handler for the base ``HTTPException``.

        .. versionadded:: 0.3
        """"""
        # Proxy exceptions don't have error codes.  We want to always return
        # those unchanged as errors
        if e.code is None:
            return e

        # RoutingExceptions are used internally to trigger routing
        # actions, such as slash redirects raising RequestRedirect. They
        # are not raised or handled in user code.
        if isinstance(e, RoutingException):
            return e

        handler = self._find_error_handler(e, request.blueprints)
        if handler is None:
            return e
        return self.ensure_sync(handler)(e)  # type: ignore[no-any-return]",False
c447a98bc3f8d8c104d9c90f301e7f4519b16bc0,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,handle_user_exception,Flask.handle_user_exception,779,809,"This method is called whenever an exception occurs that
should be handled. A special case is :class:`~werkzeug
.exceptions.HTTPException` which is forwarded to the
:meth:`handle_http_exception` method. This function will either
return a response value or reraise the exception with the same
traceback.

.. versionchanged:: 1.0
    Key errors raised from request data like ``form`` show the
    bad key in debug mode rather than a generic bad request
    message.

.. versionadded:: 0.7","    def handle_user_exception(
        self, e: Exception
    ) -> HTTPException | ft.ResponseReturnValue:
        """"""This method is called whenever an exception occurs that
        should be handled. A special case is :class:`~werkzeug
        .exceptions.HTTPException` which is forwarded to the
        :meth:`handle_http_exception` method. This function will either
        return a response value or reraise the exception with the same
        traceback.

        .. versionchanged:: 1.0
            Key errors raised from request data like ``form`` show the
            bad key in debug mode rather than a generic bad request
            message.

        .. versionadded:: 0.7
        """"""
        if isinstance(e, BadRequestKeyError) and (
            self.debug or self.config[""TRAP_BAD_REQUEST_ERRORS""]
        ):
            e.show_exception = True

        if isinstance(e, HTTPException) and not self.trap_http_exception(e):
            return self.handle_http_exception(e)

        handler = self._find_error_handler(e, request.blueprints)

        if handler is None:
            raise

        return self.ensure_sync(handler)(e)  # type: ignore[no-any-return]",False
407803e8e585924fcfd1670d11e6a858cccc3454,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,handle_exception,Flask.handle_exception,811,862,"Handle an exception that did not have an error handler
associated with it, or that was raised from an error handler.
This always causes a 500 ``InternalServerError``.

Always sends the :data:`got_request_exception` signal.

If :data:`PROPAGATE_EXCEPTIONS` is ``True``, such as in debug
mode, the error will be re-raised so that the debugger can
display it. Otherwise, the original exception is logged, and
an :exc:`~werkzeug.exceptions.InternalServerError` is returned.

If an error handler is registered for ``InternalServerError`` or
``500``, it will be used. For consistency, the handler will
always receive the ``InternalServerError``. The original
unhandled exception is available as ``e.original_exception``.

.. versionchanged:: 1.1.0
    Always passes the ``InternalServerError`` instance to the
    handler, setting ``original_exception`` to the unhandled
    error.

.. versionchanged:: 1.1.0
    ``after_request`` functions and other finalization is done
    even for the default 500 response when there is no handler.

.. versionadded:: 0.3","    def handle_exception(self, e: Exception) -> Response:
        """"""Handle an exception that did not have an error handler
        associated with it, or that was raised from an error handler.
        This always causes a 500 ``InternalServerError``.

        Always sends the :data:`got_request_exception` signal.

        If :data:`PROPAGATE_EXCEPTIONS` is ``True``, such as in debug
        mode, the error will be re-raised so that the debugger can
        display it. Otherwise, the original exception is logged, and
        an :exc:`~werkzeug.exceptions.InternalServerError` is returned.

        If an error handler is registered for ``InternalServerError`` or
        ``500``, it will be used. For consistency, the handler will
        always receive the ``InternalServerError``. The original
        unhandled exception is available as ``e.original_exception``.

        .. versionchanged:: 1.1.0
            Always passes the ``InternalServerError`` instance to the
            handler, setting ``original_exception`` to the unhandled
            error.

        .. versionchanged:: 1.1.0
            ``after_request`` functions and other finalization is done
            even for the default 500 response when there is no handler.

        .. versionadded:: 0.3
        """"""
        exc_info = sys.exc_info()
        got_request_exception.send(self, _async_wrapper=self.ensure_sync, exception=e)
        propagate = self.config[""PROPAGATE_EXCEPTIONS""]

        if propagate is None:
            propagate = self.testing or self.debug

        if propagate:
            # Re-raise if called with an active exception, otherwise
            # raise the passed in exception.
            if exc_info[1] is e:
                raise

            raise e

        self.log_exception(exc_info)
        server_error: InternalServerError | ft.ResponseReturnValue
        server_error = InternalServerError(original_exception=e)
        handler = self._find_error_handler(server_error, request.blueprints)

        if handler is not None:
            server_error = self.ensure_sync(handler)(server_error)

        return self.finalize_request(server_error, from_error_handler=True)",False
88bbad3e43d6d66bf08330bdfc3846ee0592fccf,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,log_exception,Flask.log_exception,864,877,"Logs an exception.  This is called by :meth:`handle_exception`
if debugging is disabled and right before the handler is called.
The default implementation logs the exception as error on the
:attr:`logger`.

.. versionadded:: 0.8","    def log_exception(
        self,
        exc_info: (tuple[type, BaseException, TracebackType] | tuple[None, None, None]),
    ) -> None:
        """"""Logs an exception.  This is called by :meth:`handle_exception`
        if debugging is disabled and right before the handler is called.
        The default implementation logs the exception as error on the
        :attr:`logger`.

        .. versionadded:: 0.8
        """"""
        self.logger.error(
            f""Exception on {request.path} [{request.method}]"", exc_info=exc_info
        )",False
8b87a4e1a58f943631590f4d7b468e10db78cdc7,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,dispatch_request,Flask.dispatch_request,879,902,"Does the request dispatching.  Matches the URL and returns the
return value of the view or error handler.  This does not have to
be a response object.  In order to convert the return value to a
proper response object, call :func:`make_response`.

.. versionchanged:: 0.7
   This no longer does the exception handling, this code was
   moved to the new :meth:`full_dispatch_request`.","    def dispatch_request(self) -> ft.ResponseReturnValue:
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.

        .. versionchanged:: 0.7
           This no longer does the exception handling, this code was
           moved to the new :meth:`full_dispatch_request`.
        """"""
        req = request_ctx.request
        if req.routing_exception is not None:
            self.raise_routing_exception(req)
        rule: Rule = req.url_rule  # type: ignore[assignment]
        # if we provide automatic options for this URL and the
        # request came with the OPTIONS method, reply automatically
        if (
            getattr(rule, ""provide_automatic_options"", False)
            and req.method == ""OPTIONS""
        ):
            return self.make_default_options_response()
        # otherwise dispatch to the handler for that endpoint
        view_args: dict[str, t.Any] = req.view_args  # type: ignore[assignment]
        return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]",False
473700e2ea48267590c7dd6e75f501ae1186b288,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,full_dispatch_request,Flask.full_dispatch_request,904,920,"Dispatches the request and on top of that performs request
pre and postprocessing as well as HTTP exception catching and
error handling.

.. versionadded:: 0.7","    def full_dispatch_request(self) -> Response:
        """"""Dispatches the request and on top of that performs request
        pre and postprocessing as well as HTTP exception catching and
        error handling.

        .. versionadded:: 0.7
        """"""
        self._got_first_request = True

        try:
            request_started.send(self, _async_wrapper=self.ensure_sync)
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
        except Exception as e:
            rv = self.handle_user_exception(e)
        return self.finalize_request(rv)",False
f56a0005a69d6a9d38bb278aa9ac4c07846934fb,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,finalize_request,Flask.finalize_request,922,951,"Given the return value from a view function this finalizes
the request by converting it into a response and invoking the
postprocessing functions.  This is invoked for both normal
request dispatching as well as error handlers.

Because this means that it might be called as a result of a
failure a special safe mode is available which can be enabled
with the `from_error_handler` flag.  If enabled, failures in
response processing will be logged and otherwise ignored.

:internal:","    def finalize_request(
        self,
        rv: ft.ResponseReturnValue | HTTPException,
        from_error_handler: bool = False,
    ) -> Response:
        """"""Given the return value from a view function this finalizes
        the request by converting it into a response and invoking the
        postprocessing functions.  This is invoked for both normal
        request dispatching as well as error handlers.

        Because this means that it might be called as a result of a
        failure a special safe mode is available which can be enabled
        with the `from_error_handler` flag.  If enabled, failures in
        response processing will be logged and otherwise ignored.

        :internal:
        """"""
        response = self.make_response(rv)
        try:
            response = self.process_response(response)
            request_finished.send(
                self, _async_wrapper=self.ensure_sync, response=response
            )
        except Exception:
            if not from_error_handler:
                raise
            self.logger.exception(
                ""Request finalizing failed with an error while handling an error""
            )
        return response",False
2059076d98321d193cde3c4ed1a01f27d0fb22e4,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,make_default_options_response,Flask.make_default_options_response,953,964,"This method is called to create the default ``OPTIONS`` response.
This can be changed through subclassing to change the default
behavior of ``OPTIONS`` responses.

.. versionadded:: 0.7","    def make_default_options_response(self) -> Response:
        """"""This method is called to create the default ``OPTIONS`` response.
        This can be changed through subclassing to change the default
        behavior of ``OPTIONS`` responses.

        .. versionadded:: 0.7
        """"""
        adapter = request_ctx.url_adapter
        methods = adapter.allowed_methods()  # type: ignore[union-attr]
        rv = self.response_class()
        rv.allow.update(methods)
        return rv",False
e2a8992d470f2f5d8aeb032069775543b6c8bedd,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,ensure_sync,Flask.ensure_sync,966,978,"Ensure that the function is synchronous for WSGI workers.
Plain ``def`` functions are returned as-is. ``async def``
functions are wrapped to run and wait for the response.

Override this method to change how the app runs async views.

.. versionadded:: 2.0","    def ensure_sync(self, func: t.Callable[..., t.Any]) -> t.Callable[..., t.Any]:
        """"""Ensure that the function is synchronous for WSGI workers.
        Plain ``def`` functions are returned as-is. ``async def``
        functions are wrapped to run and wait for the response.

        Override this method to change how the app runs async views.

        .. versionadded:: 2.0
        """"""
        if iscoroutinefunction(func):
            return self.async_to_sync(func)

        return func",False
29a5cbda72520e166e68f5b57bc15bfc7f15ef36,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,async_to_sync,Flask.async_to_sync,980,1001,"Return a sync function that will run the coroutine function.

.. code-block:: python

    result = app.async_to_sync(func)(*args, **kwargs)

Override this method to change how the app converts async code
to be synchronously callable.

.. versionadded:: 2.0","    def async_to_sync(
        self, func: t.Callable[..., t.Coroutine[t.Any, t.Any, t.Any]]
    ) -> t.Callable[..., t.Any]:
        """"""Return a sync function that will run the coroutine function.

        .. code-block:: python

            result = app.async_to_sync(func)(*args, **kwargs)

        Override this method to change how the app converts async code
        to be synchronously callable.

        .. versionadded:: 2.0
        """"""
        try:
            from asgiref.sync import async_to_sync as asgiref_async_to_sync
        except ImportError:
            raise RuntimeError(
                ""Install Flask with the 'async' extra in order to use async views.""
            ) from None

        return asgiref_async_to_sync(func)",False
c4c7c245f4b73f8fcff8da307b57b288f69b477d,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,url_for,Flask.url_for,1003,1127,"Generate a URL to the given endpoint with the given values.

This is called by :func:`flask.url_for`, and can be called
directly as well.

An *endpoint* is the name of a URL rule, usually added with
:meth:`@app.route() <route>`, and usually the same name as the
view function. A route defined in a :class:`~flask.Blueprint`
will prepend the blueprint's name separated by a ``.`` to the
endpoint.

In some cases, such as email messages, you want URLs to include
the scheme and domain, like ``https://example.com/hello``. When
not in an active request, URLs will be external by default, but
this requires setting :data:`SERVER_NAME` so Flask knows what
domain to use. :data:`APPLICATION_ROOT` and
:data:`PREFERRED_URL_SCHEME` should also be configured as
needed. This config is only used when not in an active request.

Functions can be decorated with :meth:`url_defaults` to modify
keyword arguments before the URL is built.

If building fails for some reason, such as an unknown endpoint
or incorrect values, the app's :meth:`handle_url_build_error`
method is called. If that returns a string, that is returned,
otherwise a :exc:`~werkzeug.routing.BuildError` is raised.

:param endpoint: The endpoint name associated with the URL to
    generate. If this starts with a ``.``, the current blueprint
    name (if any) will be used.
:param _anchor: If given, append this as ``#anchor`` to the URL.
:param _method: If given, generate the URL associated with this
    method for the endpoint.
:param _scheme: If given, the URL will have this scheme if it
    is external.
:param _external: If given, prefer the URL to be internal
    (False) or require it to be external (True). External URLs
    include the scheme and domain. When not in an active
    request, URLs are external by default.
:param values: Values to use for the variable parts of the URL
    rule. Unknown keys are appended as query string arguments,
    like ``?a=b&c=d``.

.. versionadded:: 2.2
    Moved from ``flask.url_for``, which calls this method.","    def url_for(
        self,
        /,
        endpoint: str,
        *,
        _anchor: str | None = None,
        _method: str | None = None,
        _scheme: str | None = None,
        _external: bool | None = None,
        **values: t.Any,
    ) -> str:
        """"""Generate a URL to the given endpoint with the given values.

        This is called by :func:`flask.url_for`, and can be called
        directly as well.

        An *endpoint* is the name of a URL rule, usually added with
        :meth:`@app.route() <route>`, and usually the same name as the
        view function. A route defined in a :class:`~flask.Blueprint`
        will prepend the blueprint's name separated by a ``.`` to the
        endpoint.

        In some cases, such as email messages, you want URLs to include
        the scheme and domain, like ``https://example.com/hello``. When
        not in an active request, URLs will be external by default, but
        this requires setting :data:`SERVER_NAME` so Flask knows what
        domain to use. :data:`APPLICATION_ROOT` and
        :data:`PREFERRED_URL_SCHEME` should also be configured as
        needed. This config is only used when not in an active request.

        Functions can be decorated with :meth:`url_defaults` to modify
        keyword arguments before the URL is built.

        If building fails for some reason, such as an unknown endpoint
        or incorrect values, the app's :meth:`handle_url_build_error`
        method is called. If that returns a string, that is returned,
        otherwise a :exc:`~werkzeug.routing.BuildError` is raised.

        :param endpoint: The endpoint name associated with the URL to
            generate. If this starts with a ``.``, the current blueprint
            name (if any) will be used.
        :param _anchor: If given, append this as ``#anchor`` to the URL.
        :param _method: If given, generate the URL associated with this
            method for the endpoint.
        :param _scheme: If given, the URL will have this scheme if it
            is external.
        :param _external: If given, prefer the URL to be internal
            (False) or require it to be external (True). External URLs
            include the scheme and domain. When not in an active
            request, URLs are external by default.
        :param values: Values to use for the variable parts of the URL
            rule. Unknown keys are appended as query string arguments,
            like ``?a=b&c=d``.

        .. versionadded:: 2.2
            Moved from ``flask.url_for``, which calls this method.
        """"""
        req_ctx = _cv_request.get(None)

        if req_ctx is not None:
            url_adapter = req_ctx.url_adapter
            blueprint_name = req_ctx.request.blueprint

            # If the endpoint starts with ""."" and the request matches a
            # blueprint, the endpoint is relative to the blueprint.
            if endpoint[:1] == ""."":
                if blueprint_name is not None:
                    endpoint = f""{blueprint_name}{endpoint}""
                else:
                    endpoint = endpoint[1:]

            # When in a request, generate a URL without scheme and
            # domain by default, unless a scheme is given.
            if _external is None:
                _external = _scheme is not None
        else:
            app_ctx = _cv_app.get(None)

            # If called by helpers.url_for, an app context is active,
            # use its url_adapter. Otherwise, app.url_for was called
            # directly, build an adapter.
            if app_ctx is not None:
                url_adapter = app_ctx.url_adapter
            else:
                url_adapter = self.create_url_adapter(None)

            if url_adapter is None:
                raise RuntimeError(
                    ""Unable to build URLs outside an active request""
                    "" without 'SERVER_NAME' configured. Also configure""
                    "" 'APPLICATION_ROOT' and 'PREFERRED_URL_SCHEME' as""
                    "" needed.""
                )

            # When outside a request, generate a URL with scheme and
            # domain by default.
            if _external is None:
                _external = True

        # It is an error to set _scheme when _external=False, in order
        # to avoid accidental insecure URLs.
        if _scheme is not None and not _external:
            raise ValueError(""When specifying '_scheme', '_external' must be True."")

        self.inject_url_defaults(endpoint, values)

        try:
            rv = url_adapter.build(  # type: ignore[union-attr]
                endpoint,
                values,
                method=_method,
                url_scheme=_scheme,
                force_external=_external,
            )
        except BuildError as error:
            values.update(
                _anchor=_anchor, _method=_method, _scheme=_scheme, _external=_external
            )
            return self.handle_url_build_error(error, endpoint, values)

        if _anchor is not None:
            _anchor = _url_quote(_anchor, safe=""%!#$&'()*+,/:;=?@"")
            rv = f""{rv}#{_anchor}""

        return rv",False
9431920b95ef4bbe7590589d3dc94faba3f249ce,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,make_response,Flask.make_response,1129,1269,"Convert the return value from a view function to an instance of
:attr:`response_class`.

:param rv: the return value from the view function. The view function
    must return a response. Returning ``None``, or the view ending
    without returning, is not allowed. The following types are allowed
    for ``view_rv``:

    ``str``
        A response object is created with the string encoded to UTF-8
        as the body.

    ``bytes``
        A response object is created with the bytes as the body.

    ``dict``
        A dictionary that will be jsonify'd before being returned.

    ``list``
        A list that will be jsonify'd before being returned.

    ``generator`` or ``iterator``
        A generator that returns ``str`` or ``bytes`` to be
        streamed as the response.

    ``tuple``
        Either ``(body, status, headers)``, ``(body, status)``, or
        ``(body, headers)``, where ``body`` is any of the other types
        allowed here, ``status`` is a string or an integer, and
        ``headers`` is a dictionary or a list of ``(key, value)``
        tuples. If ``body`` is a :attr:`response_class` instance,
        ``status`` overwrites the exiting value and ``headers`` are
        extended.

    :attr:`response_class`
        The object is returned unchanged.

    other :class:`~werkzeug.wrappers.Response` class
        The object is coerced to :attr:`response_class`.

    :func:`callable`
        The function is called as a WSGI application. The result is
        used to create a response object.

.. versionchanged:: 2.2
    A generator will be converted to a streaming response.
    A list will be converted to a JSON response.

.. versionchanged:: 1.1
    A dict will be converted to a JSON response.

.. versionchanged:: 0.9
   Previously a tuple was interpreted as the arguments for the
   response object.","    def make_response(self, rv: ft.ResponseReturnValue) -> Response:
        """"""Convert the return value from a view function to an instance of
        :attr:`response_class`.

        :param rv: the return value from the view function. The view function
            must return a response. Returning ``None``, or the view ending
            without returning, is not allowed. The following types are allowed
            for ``view_rv``:

            ``str``
                A response object is created with the string encoded to UTF-8
                as the body.

            ``bytes``
                A response object is created with the bytes as the body.

            ``dict``
                A dictionary that will be jsonify'd before being returned.

            ``list``
                A list that will be jsonify'd before being returned.

            ``generator`` or ``iterator``
                A generator that returns ``str`` or ``bytes`` to be
                streamed as the response.

            ``tuple``
                Either ``(body, status, headers)``, ``(body, status)``, or
                ``(body, headers)``, where ``body`` is any of the other types
                allowed here, ``status`` is a string or an integer, and
                ``headers`` is a dictionary or a list of ``(key, value)``
                tuples. If ``body`` is a :attr:`response_class` instance,
                ``status`` overwrites the exiting value and ``headers`` are
                extended.

            :attr:`response_class`
                The object is returned unchanged.

            other :class:`~werkzeug.wrappers.Response` class
                The object is coerced to :attr:`response_class`.

            :func:`callable`
                The function is called as a WSGI application. The result is
                used to create a response object.

        .. versionchanged:: 2.2
            A generator will be converted to a streaming response.
            A list will be converted to a JSON response.

        .. versionchanged:: 1.1
            A dict will be converted to a JSON response.

        .. versionchanged:: 0.9
           Previously a tuple was interpreted as the arguments for the
           response object.
        """"""

        status: int | None = None
        headers: HeadersValue | None = None

        # unpack tuple returns
        if isinstance(rv, tuple):
            len_rv = len(rv)

            # a 3-tuple is unpacked directly
            if len_rv == 3:
                rv, status, headers = rv  # type: ignore[misc]
            # decide if a 2-tuple has status or headers
            elif len_rv == 2:
                if isinstance(rv[1], (Headers, dict, tuple, list)):
                    rv, headers = rv  # pyright: ignore
                else:
                    rv, status = rv  # type: ignore[assignment,misc]
            # other sized tuples are not allowed
            else:
                raise TypeError(
                    ""The view function did not return a valid response tuple.""
                    "" The tuple must have the form (body, status, headers),""
                    "" (body, status), or (body, headers).""
                )

        # the body must not be None
        if rv is None:
            raise TypeError(
                f""The view function for {request.endpoint!r} did not""
                "" return a valid response. The function either returned""
                "" None or ended without a return statement.""
            )

        # make sure the body is an instance of the response class
        if not isinstance(rv, self.response_class):
            if isinstance(rv, (str, bytes, bytearray)) or isinstance(rv, cabc.Iterator):
                # let the response class set the status and headers instead of
                # waiting to do it manually, so that the class can handle any
                # special logic
                rv = self.response_class(
                    rv,  # pyright: ignore
                    status=status,
                    headers=headers,  # type: ignore[arg-type]
                )
                status = headers = None
            elif isinstance(rv, (dict, list)):
                rv = self.json.response(rv)
            elif isinstance(rv, BaseResponse) or callable(rv):
                # evaluate a WSGI callable, or coerce a different response
                # class to the correct type
                try:
                    rv = self.response_class.force_type(
                        rv,  # type: ignore[arg-type]
                        request.environ,
                    )
                except TypeError as e:
                    raise TypeError(
                        f""{e}\nThe view function did not return a valid""
                        "" response. The return type must be a string,""
                        "" dict, list, tuple with headers or status,""
                        "" Response instance, or WSGI callable, but it""
                        f"" was a {type(rv).__name__}.""
                    ).with_traceback(sys.exc_info()[2]) from None
            else:
                raise TypeError(
                    ""The view function did not return a valid""
                    "" response. The return type must be a string,""
                    "" dict, list, tuple with headers or status,""
                    "" Response instance, or WSGI callable, but it was a""
                    f"" {type(rv).__name__}.""
                )

        rv = t.cast(Response, rv)
        # prefer the status if it was provided
        if status is not None:
            if isinstance(status, (str, bytes, bytearray)):
                rv.status = status
            else:
                rv.status_code = status

        # extend existing headers with provided headers
        if headers:
            rv.headers.update(headers)

        return rv",False
fc04b2d3a88118c3b5de34b26c1e275c3303e82d,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,preprocess_request,Flask.preprocess_request,1271,1296,"Called before the request is dispatched. Calls
:attr:`url_value_preprocessors` registered with the app and the
current blueprint (if any). Then calls :attr:`before_request_funcs`
registered with the app and the blueprint.

If any :meth:`before_request` handler returns a non-None value, the
value is handled as if it was the return value from the view, and
further request handling is stopped.","    def preprocess_request(self) -> ft.ResponseReturnValue | None:
        """"""Called before the request is dispatched. Calls
        :attr:`url_value_preprocessors` registered with the app and the
        current blueprint (if any). Then calls :attr:`before_request_funcs`
        registered with the app and the blueprint.

        If any :meth:`before_request` handler returns a non-None value, the
        value is handled as if it was the return value from the view, and
        further request handling is stopped.
        """"""
        names = (None, *reversed(request.blueprints))

        for name in names:
            if name in self.url_value_preprocessors:
                for url_func in self.url_value_preprocessors[name]:
                    url_func(request.endpoint, request.view_args)

        for name in names:
            if name in self.before_request_funcs:
                for before_func in self.before_request_funcs[name]:
                    rv = self.ensure_sync(before_func)()

                    if rv is not None:
                        return rv  # type: ignore[no-any-return]

        return None",False
ff5ae1bee42aedf2be1ad937e9a68f41fb7487bd,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,process_response,Flask.process_response,1298,1324,"Can be overridden in order to modify the response object
before it's sent to the WSGI server.  By default this will
call all the :meth:`after_request` decorated functions.

.. versionchanged:: 0.5
   As of Flask 0.5 the functions registered for after request
   execution are called in reverse order of registration.

:param response: a :attr:`response_class` object.
:return: a new response object or the same, has to be an
         instance of :attr:`response_class`.","    def process_response(self, response: Response) -> Response:
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        .. versionchanged:: 0.5
           As of Flask 0.5 the functions registered for after request
           execution are called in reverse order of registration.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        ctx = request_ctx._get_current_object()  # type: ignore[attr-defined]

        for func in ctx._after_request_functions:
            response = self.ensure_sync(func)(response)

        for name in chain(request.blueprints, (None,)):
            if name in self.after_request_funcs:
                for func in reversed(self.after_request_funcs[name]):
                    response = self.ensure_sync(func)(response)

        if not self.session_interface.is_null_session(ctx.session):
            self.session_interface.save_session(self, ctx.session, response)

        return response",False
74186adebd1957f9aafdd89b31c4b92a2303f966,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,do_teardown_request,Flask.do_teardown_request,1326,1358,"Called after the request is dispatched and the response is
returned, right before the request context is popped.

This calls all functions decorated with
:meth:`teardown_request`, and :meth:`Blueprint.teardown_request`
if a blueprint handled the request. Finally, the
:data:`request_tearing_down` signal is sent.

This is called by
:meth:`RequestContext.pop() <flask.ctx.RequestContext.pop>`,
which may be delayed during testing to maintain access to
resources.

:param exc: An unhandled exception raised while dispatching the
    request. Detected from the current exception information if
    not passed. Passed to each teardown function.

.. versionchanged:: 0.9
    Added the ``exc`` argument.","    def do_teardown_request(
        self,
        exc: BaseException | None = _sentinel,  # type: ignore[assignment]
    ) -> None:
        """"""Called after the request is dispatched and the response is
        returned, right before the request context is popped.

        This calls all functions decorated with
        :meth:`teardown_request`, and :meth:`Blueprint.teardown_request`
        if a blueprint handled the request. Finally, the
        :data:`request_tearing_down` signal is sent.

        This is called by
        :meth:`RequestContext.pop() <flask.ctx.RequestContext.pop>`,
        which may be delayed during testing to maintain access to
        resources.

        :param exc: An unhandled exception raised while dispatching the
            request. Detected from the current exception information if
            not passed. Passed to each teardown function.

        .. versionchanged:: 0.9
            Added the ``exc`` argument.
        """"""
        if exc is _sentinel:
            exc = sys.exc_info()[1]

        for name in chain(request.blueprints, (None,)):
            if name in self.teardown_request_funcs:
                for func in reversed(self.teardown_request_funcs[name]):
                    self.ensure_sync(func)(exc)

        request_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)",False
4e2468caf58c41fe6e2f230b8bad4bc767c38fb9,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,do_teardown_appcontext,Flask.do_teardown_appcontext,1360,1384,"Called right before the application context is popped.

When handling a request, the application context is popped
after the request context. See :meth:`do_teardown_request`.

This calls all functions decorated with
:meth:`teardown_appcontext`. Then the
:data:`appcontext_tearing_down` signal is sent.

This is called by
:meth:`AppContext.pop() <flask.ctx.AppContext.pop>`.

.. versionadded:: 0.9","    def do_teardown_appcontext(
        self,
        exc: BaseException | None = _sentinel,  # type: ignore[assignment]
    ) -> None:
        """"""Called right before the application context is popped.

        When handling a request, the application context is popped
        after the request context. See :meth:`do_teardown_request`.

        This calls all functions decorated with
        :meth:`teardown_appcontext`. Then the
        :data:`appcontext_tearing_down` signal is sent.

        This is called by
        :meth:`AppContext.pop() <flask.ctx.AppContext.pop>`.

        .. versionadded:: 0.9
        """"""
        if exc is _sentinel:
            exc = sys.exc_info()[1]

        for func in reversed(self.teardown_appcontext_funcs):
            self.ensure_sync(func)(exc)

        appcontext_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)",False
9bf3192f1f49ac3d73bdd359b5b56bbc8e4f3c30,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,app_context,Flask.app_context,1386,1405,"Create an :class:`~flask.ctx.AppContext`. Use as a ``with``
block to push the context, which will make :data:`current_app`
point at this application.

An application context is automatically pushed by
:meth:`RequestContext.push() <flask.ctx.RequestContext.push>`
when handling a request, and when running a CLI command. Use
this to manually create a context outside of these situations.

::

    with app.app_context():
        init_db()

See :doc:`/appcontext`.

.. versionadded:: 0.9","    def app_context(self) -> AppContext:
        """"""Create an :class:`~flask.ctx.AppContext`. Use as a ``with``
        block to push the context, which will make :data:`current_app`
        point at this application.

        An application context is automatically pushed by
        :meth:`RequestContext.push() <flask.ctx.RequestContext.push>`
        when handling a request, and when running a CLI command. Use
        this to manually create a context outside of these situations.

        ::

            with app.app_context():
                init_db()

        See :doc:`/appcontext`.

        .. versionadded:: 0.9
        """"""
        return AppContext(self)",False
8180e93eef91b61f96d50f069390b5499023f375,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,request_context,Flask.request_context,1407,1421,"Create a :class:`~flask.ctx.RequestContext` representing a
WSGI environment. Use a ``with`` block to push the context,
which will make :data:`request` point at this request.

See :doc:`/reqcontext`.

Typically you should not call this from your own code. A request
context is automatically pushed by the :meth:`wsgi_app` when
handling a request. Use :meth:`test_request_context` to create
an environment and context instead of this method.

:param environ: a WSGI environment","    def request_context(self, environ: WSGIEnvironment) -> RequestContext:
        """"""Create a :class:`~flask.ctx.RequestContext` representing a
        WSGI environment. Use a ``with`` block to push the context,
        which will make :data:`request` point at this request.

        See :doc:`/reqcontext`.

        Typically you should not call this from your own code. A request
        context is automatically pushed by the :meth:`wsgi_app` when
        handling a request. Use :meth:`test_request_context` to create
        an environment and context instead of this method.

        :param environ: a WSGI environment
        """"""
        return RequestContext(self, environ)",False
8b9fe7c34961c9613b61969815e63efac42c863c,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,test_request_context,Flask.test_request_context,1423,1477,"Create a :class:`~flask.ctx.RequestContext` for a WSGI
environment created from the given values. This is mostly useful
during testing, where you may want to run a function that uses
request data without dispatching a full request.

See :doc:`/reqcontext`.

Use a ``with`` block to push the context, which will make
:data:`request` point at the request for the created
environment. ::

    with app.test_request_context(...):
        generate_report()

When using the shell, it may be easier to push and pop the
context manually to avoid indentation. ::

    ctx = app.test_request_context(...)
    ctx.push()
    ...
    ctx.pop()

Takes the same arguments as Werkzeug's
:class:`~werkzeug.test.EnvironBuilder`, with some defaults from
the application. See the linked Werkzeug docs for most of the
available arguments. Flask-specific behavior is listed here.

:param path: URL path being requested.
:param base_url: Base URL where the app is being served, which
    ``path`` is relative to. If not given, built from
    :data:`PREFERRED_URL_SCHEME`, ``subdomain``,
    :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.
:param subdomain: Subdomain name to append to
    :data:`SERVER_NAME`.
:param url_scheme: Scheme to use instead of
    :data:`PREFERRED_URL_SCHEME`.
:param data: The request body, either as a string or a dict of
    form keys and values.
:param json: If given, this is serialized as JSON and passed as
    ``data``. Also defaults ``content_type`` to
    ``application/json``.
:param args: other positional arguments passed to
    :class:`~werkzeug.test.EnvironBuilder`.
:param kwargs: other keyword arguments passed to
    :class:`~werkzeug.test.EnvironBuilder`.","    def test_request_context(self, *args: t.Any, **kwargs: t.Any) -> RequestContext:
        """"""Create a :class:`~flask.ctx.RequestContext` for a WSGI
        environment created from the given values. This is mostly useful
        during testing, where you may want to run a function that uses
        request data without dispatching a full request.

        See :doc:`/reqcontext`.

        Use a ``with`` block to push the context, which will make
        :data:`request` point at the request for the created
        environment. ::

            with app.test_request_context(...):
                generate_report()

        When using the shell, it may be easier to push and pop the
        context manually to avoid indentation. ::

            ctx = app.test_request_context(...)
            ctx.push()
            ...
            ctx.pop()

        Takes the same arguments as Werkzeug's
        :class:`~werkzeug.test.EnvironBuilder`, with some defaults from
        the application. See the linked Werkzeug docs for most of the
        available arguments. Flask-specific behavior is listed here.

        :param path: URL path being requested.
        :param base_url: Base URL where the app is being served, which
            ``path`` is relative to. If not given, built from
            :data:`PREFERRED_URL_SCHEME`, ``subdomain``,
            :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.
        :param subdomain: Subdomain name to append to
            :data:`SERVER_NAME`.
        :param url_scheme: Scheme to use instead of
            :data:`PREFERRED_URL_SCHEME`.
        :param data: The request body, either as a string or a dict of
            form keys and values.
        :param json: If given, this is serialized as JSON and passed as
            ``data``. Also defaults ``content_type`` to
            ``application/json``.
        :param args: other positional arguments passed to
            :class:`~werkzeug.test.EnvironBuilder`.
        :param kwargs: other keyword arguments passed to
            :class:`~werkzeug.test.EnvironBuilder`.
        """"""
        from .testing import EnvironBuilder

        builder = EnvironBuilder(self, *args, **kwargs)

        try:
            return self.request_context(builder.get_environ())
        finally:
            builder.close()",False
b7e02446548217dced3f45ac401c3c15882e4d7d,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,wsgi_app,Flask.wsgi_app,1479,1527,"The actual WSGI application. This is not implemented in
:meth:`__call__` so that middlewares can be applied without
losing a reference to the app object. Instead of doing this::

    app = MyMiddleware(app)

It's a better idea to do this instead::

    app.wsgi_app = MyMiddleware(app.wsgi_app)

Then you still have the original application object around and
can continue to call methods on it.

.. versionchanged:: 0.7
    Teardown events for the request and app contexts are called
    even if an unhandled error occurs. Other events may not be
    called depending on when an error occurs during dispatch.
    See :ref:`callbacks-and-errors`.

:param environ: A WSGI environment.
:param start_response: A callable accepting a status code,
    a list of headers, and an optional exception context to
    start the response.","    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """"""The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.

        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """"""
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
                response = self.handle_exception(e)
            except:  # noqa: B001
                error = sys.exc_info()[1]
                raise
            return response(environ, start_response)
        finally:
            if ""werkzeug.debug.preserve_context"" in environ:
                environ[""werkzeug.debug.preserve_context""](_cv_app.get())
                environ[""werkzeug.debug.preserve_context""](_cv_request.get())

            if error is not None and self.should_ignore_error(error):
                error = None

            ctx.pop(error)",False
391c659be1f74afdd0355c289e3478c46cb744fd,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\app.py,method,__call__,Flask.__call__,1529,1536,"The WSGI server calls the Flask application object as the
WSGI application. This calls :meth:`wsgi_app`, which can be
wrapped to apply middleware.","    def __call__(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """"""The WSGI server calls the Flask application object as the
        WSGI application. This calls :meth:`wsgi_app`, which can be
        wrapped to apply middleware.
        """"""
        return self.wsgi_app(environ, start_response)",False
92514cc935b11499a1c611f76f20bcab3a73a43c,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\blueprints.py,class,Blueprint,Blueprint,18,128,,"class Blueprint(SansioBlueprint):
    def __init__(
        self,
        name: str,
        import_name: str,
        static_folder: str | os.PathLike[str] | None = None,
        static_url_path: str | None = None,
        template_folder: str | os.PathLike[str] | None = None,
        url_prefix: str | None = None,
        subdomain: str | None = None,
        url_defaults: dict[str, t.Any] | None = None,
        root_path: str | None = None,
        cli_group: str | None = _sentinel,  # type: ignore
    ) -> None:
        super().__init__(
            name,
            import_name,
            static_folder,
            static_url_path,
            template_folder,
            url_prefix,
            subdomain,
            url_defaults,
            root_path,
            cli_group,
        )

        #: The Click command group for registering CLI commands for this
        #: object. The commands are available from the ``flask`` command
        #: once the application has been discovered and blueprints have
        #: been registered.
        self.cli = AppGroup()

        # Set the name of the Click group in case someone wants to add
        # the app's commands to another CLI tool.
        self.cli.name = self.name

    def get_send_file_max_age(self, filename: str | None) -> int | None:
        """"""Used by :func:`send_file` to determine the ``max_age`` cache
        value for a given file path if it wasn't passed.

        By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from
        the configuration of :data:`~flask.current_app`. This defaults
        to ``None``, which tells the browser to use conditional requests
        instead of a timed cache, which is usually preferable.

        Note this is a duplicate of the same method in the Flask
        class.

        .. versionchanged:: 2.0
            The default configuration is ``None`` instead of 12 hours.

        .. versionadded:: 0.9
        """"""
        value = current_app.config[""SEND_FILE_MAX_AGE_DEFAULT""]

        if value is None:
            return None

        if isinstance(value, timedelta):
            return int(value.total_seconds())

        return value  # type: ignore[no-any-return]

    def send_static_file(self, filename: str) -> Response:
        """"""The view function used to serve files from
        :attr:`static_folder`. A route is automatically registered for
        this view at :attr:`static_url_path` if :attr:`static_folder` is
        set.

        Note this is a duplicate of the same method in the Flask
        class.

        .. versionadded:: 0.5

        """"""
        if not self.has_static_folder:
            raise RuntimeError(""'static_folder' must be set to serve static_files."")

        # send_file only knows to call get_send_file_max_age on the app,
        # call it here so it works for blueprints too.
        max_age = self.get_send_file_max_age(filename)
        return send_from_directory(
            t.cast(str, self.static_folder), filename, max_age=max_age
        )

    def open_resource(
        self, resource: str, mode: str = ""rb"", encoding: str | None = ""utf-8""
    ) -> t.IO[t.AnyStr]:
        """"""Open a resource file relative to :attr:`root_path` for reading. The
        blueprint-relative equivalent of the app's :meth:`~.Flask.open_resource`
        method.

        :param resource: Path to the resource relative to :attr:`root_path`.
        :param mode: Open the file in this mode. Only reading is supported,
            valid values are ``""r""`` (or ``""rt""``) and ``""rb""``.
        :param encoding: Open the file with this encoding when opening in text
            mode. This is ignored when opening in binary mode.

        .. versionchanged:: 3.1
            Added the ``encoding`` parameter.
        """"""
        if mode not in {""r"", ""rt"", ""rb""}:
            raise ValueError(""Resources can only be opened for reading."")

        path = os.path.join(self.root_path, resource)

        if mode == ""rb"":
            return open(path, mode)  # pyright: ignore

        return open(path, mode, encoding=encoding)",False
efbec523b7e4d3e8df9e1040421353f09b23a59a,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\blueprints.py,method,__init__,Blueprint.__init__,19,53,,"    def __init__(
        self,
        name: str,
        import_name: str,
        static_folder: str | os.PathLike[str] | None = None,
        static_url_path: str | None = None,
        template_folder: str | os.PathLike[str] | None = None,
        url_prefix: str | None = None,
        subdomain: str | None = None,
        url_defaults: dict[str, t.Any] | None = None,
        root_path: str | None = None,
        cli_group: str | None = _sentinel,  # type: ignore
    ) -> None:
        super().__init__(
            name,
            import_name,
            static_folder,
            static_url_path,
            template_folder,
            url_prefix,
            subdomain,
            url_defaults,
            root_path,
            cli_group,
        )

        #: The Click command group for registering CLI commands for this
        #: object. The commands are available from the ``flask`` command
        #: once the application has been discovered and blueprints have
        #: been registered.
        self.cli = AppGroup()

        # Set the name of the Click group in case someone wants to add
        # the app's commands to another CLI tool.
        self.cli.name = self.name",False
c8305ce1ba2a7a34f2382f3aef5aae18ddf041f4,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\blueprints.py,method,get_send_file_max_age,Blueprint.get_send_file_max_age,55,80,"Used by :func:`send_file` to determine the ``max_age`` cache
value for a given file path if it wasn't passed.

By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from
the configuration of :data:`~flask.current_app`. This defaults
to ``None``, which tells the browser to use conditional requests
instead of a timed cache, which is usually preferable.

Note this is a duplicate of the same method in the Flask
class.

.. versionchanged:: 2.0
    The default configuration is ``None`` instead of 12 hours.

.. versionadded:: 0.9","    def get_send_file_max_age(self, filename: str | None) -> int | None:
        """"""Used by :func:`send_file` to determine the ``max_age`` cache
        value for a given file path if it wasn't passed.

        By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from
        the configuration of :data:`~flask.current_app`. This defaults
        to ``None``, which tells the browser to use conditional requests
        instead of a timed cache, which is usually preferable.

        Note this is a duplicate of the same method in the Flask
        class.

        .. versionchanged:: 2.0
            The default configuration is ``None`` instead of 12 hours.

        .. versionadded:: 0.9
        """"""
        value = current_app.config[""SEND_FILE_MAX_AGE_DEFAULT""]

        if value is None:
            return None

        if isinstance(value, timedelta):
            return int(value.total_seconds())

        return value  # type: ignore[no-any-return]",False
7bbaac0ef0c9600e8a8310bea496e6d1af4d92b9,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\blueprints.py,method,send_static_file,Blueprint.send_static_file,82,102,"The view function used to serve files from
:attr:`static_folder`. A route is automatically registered for
this view at :attr:`static_url_path` if :attr:`static_folder` is
set.

Note this is a duplicate of the same method in the Flask
class.

.. versionadded:: 0.5","    def send_static_file(self, filename: str) -> Response:
        """"""The view function used to serve files from
        :attr:`static_folder`. A route is automatically registered for
        this view at :attr:`static_url_path` if :attr:`static_folder` is
        set.

        Note this is a duplicate of the same method in the Flask
        class.

        .. versionadded:: 0.5

        """"""
        if not self.has_static_folder:
            raise RuntimeError(""'static_folder' must be set to serve static_files."")

        # send_file only knows to call get_send_file_max_age on the app,
        # call it here so it works for blueprints too.
        max_age = self.get_send_file_max_age(filename)
        return send_from_directory(
            t.cast(str, self.static_folder), filename, max_age=max_age
        )",False
648cd7018e738e1972067caa943ceb49f84acdef,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\blueprints.py,method,open_resource,Blueprint.open_resource,104,128,"Open a resource file relative to :attr:`root_path` for reading. The
blueprint-relative equivalent of the app's :meth:`~.Flask.open_resource`
method.

:param resource: Path to the resource relative to :attr:`root_path`.
:param mode: Open the file in this mode. Only reading is supported,
    valid values are ``""r""`` (or ``""rt""``) and ``""rb""``.
:param encoding: Open the file with this encoding when opening in text
    mode. This is ignored when opening in binary mode.

.. versionchanged:: 3.1
    Added the ``encoding`` parameter.","    def open_resource(
        self, resource: str, mode: str = ""rb"", encoding: str | None = ""utf-8""
    ) -> t.IO[t.AnyStr]:
        """"""Open a resource file relative to :attr:`root_path` for reading. The
        blueprint-relative equivalent of the app's :meth:`~.Flask.open_resource`
        method.

        :param resource: Path to the resource relative to :attr:`root_path`.
        :param mode: Open the file in this mode. Only reading is supported,
            valid values are ``""r""`` (or ``""rt""``) and ``""rb""``.
        :param encoding: Open the file with this encoding when opening in text
            mode. This is ignored when opening in binary mode.

        .. versionchanged:: 3.1
            Added the ``encoding`` parameter.
        """"""
        if mode not in {""r"", ""rt"", ""rb""}:
            raise ValueError(""Resources can only be opened for reading."")

        path = os.path.join(self.root_path, resource)

        if mode == ""rb"":
            return open(path, mode)  # pyright: ignore

        return open(path, mode, encoding=encoding)",False
dbc3db8a8e7874c6006578626cd121d0b3603392,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,class,NoAppException,NoAppException,37,38,Raised if an application cannot be found or loaded.,"class NoAppException(click.UsageError):
    """"""Raised if an application cannot be found or loaded.""""""",False
13d6c3e85fa0d485604a106e73d0c7efe8d5b64d,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,function,find_best_app,find_best_app,41,91,"Given a module instance this tries to find the best possible
application in the module or raises an exception.","def find_best_app(module: ModuleType) -> Flask:
    """"""Given a module instance this tries to find the best possible
    application in the module or raises an exception.
    """"""
    from . import Flask

    # Search for the most common names first.
    for attr_name in (""app"", ""application""):
        app = getattr(module, attr_name, None)

        if isinstance(app, Flask):
            return app

    # Otherwise find the only object that is a Flask instance.
    matches = [v for v in module.__dict__.values() if isinstance(v, Flask)]

    if len(matches) == 1:
        return matches[0]
    elif len(matches) > 1:
        raise NoAppException(
            ""Detected multiple Flask applications in module""
            f"" '{module.__name__}'. Use '{module.__name__}:name'""
            "" to specify the correct one.""
        )

    # Search for app factory functions.
    for attr_name in (""create_app"", ""make_app""):
        app_factory = getattr(module, attr_name, None)

        if inspect.isfunction(app_factory):
            try:
                app = app_factory()

                if isinstance(app, Flask):
                    return app
            except TypeError as e:
                if not _called_with_wrong_args(app_factory):
                    raise

                raise NoAppException(
                    f""Detected factory '{attr_name}' in module '{module.__name__}',""
                    "" but could not call it without arguments. Use""
                    f"" '{module.__name__}:{attr_name}(args)'""
                    "" to specify arguments.""
                ) from e

    raise NoAppException(
        ""Failed to find Flask application or factory in module""
        f"" '{module.__name__}'. Use '{module.__name__}:name'""
        "" to specify one.""
    )",False
33b5690fdf8457ba67b0c0dfb82efe143bc66db4,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,function,_called_with_wrong_args,_called_with_wrong_args,94,117,"Check whether calling a function raised a ``TypeError`` because
the call failed or because something in the factory raised the
error.

:param f: The function that was called.
:return: ``True`` if the call failed.","def _called_with_wrong_args(f: t.Callable[..., Flask]) -> bool:
    """"""Check whether calling a function raised a ``TypeError`` because
    the call failed or because something in the factory raised the
    error.

    :param f: The function that was called.
    :return: ``True`` if the call failed.
    """"""
    tb = sys.exc_info()[2]

    try:
        while tb is not None:
            if tb.tb_frame.f_code is f.__code__:
                # In the function, it was called successfully.
                return False

            tb = tb.tb_next

        # Didn't reach the function.
        return True
    finally:
        # Delete tb to break a circular reference.
        # https://docs.python.org/2/library/sys.html#sys.exc_info
        del tb",False
b7beb794da0d24f328dee0938cad22d023d9a51b,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,function,find_app_by_string,find_app_by_string,120,197,"Check if the given string is a variable name or a function. Call
a function to get the app instance, or return the variable directly.","def find_app_by_string(module: ModuleType, app_name: str) -> Flask:
    """"""Check if the given string is a variable name or a function. Call
    a function to get the app instance, or return the variable directly.
    """"""
    from . import Flask

    # Parse app_name as a single expression to determine if it's a valid
    # attribute name or function call.
    try:
        expr = ast.parse(app_name.strip(), mode=""eval"").body
    except SyntaxError:
        raise NoAppException(
            f""Failed to parse {app_name!r} as an attribute name or function call.""
        ) from None

    if isinstance(expr, ast.Name):
        name = expr.id
        args = []
        kwargs = {}
    elif isinstance(expr, ast.Call):
        # Ensure the function name is an attribute name only.
        if not isinstance(expr.func, ast.Name):
            raise NoAppException(
                f""Function reference must be a simple name: {app_name!r}.""
            )

        name = expr.func.id

        # Parse the positional and keyword arguments as literals.
        try:
            args = [ast.literal_eval(arg) for arg in expr.args]
            kwargs = {
                kw.arg: ast.literal_eval(kw.value)
                for kw in expr.keywords
                if kw.arg is not None
            }
        except ValueError:
            # literal_eval gives cryptic error messages, show a generic
            # message with the full expression instead.
            raise NoAppException(
                f""Failed to parse arguments as literal values: {app_name!r}.""
            ) from None
    else:
        raise NoAppException(
            f""Failed to parse {app_name!r} as an attribute name or function call.""
        )

    try:
        attr = getattr(module, name)
    except AttributeError as e:
        raise NoAppException(
            f""Failed to find attribute {name!r} in {module.__name__!r}.""
        ) from e

    # If the attribute is a function, call it with any args and kwargs
    # to get the real application.
    if inspect.isfunction(attr):
        try:
            app = attr(*args, **kwargs)
        except TypeError as e:
            if not _called_with_wrong_args(attr):
                raise

            raise NoAppException(
                f""The factory {app_name!r} in module""
                f"" {module.__name__!r} could not be called with the""
                "" specified arguments.""
            ) from e
    else:
        app = attr

    if isinstance(app, Flask):
        return app

    raise NoAppException(
        ""A valid Flask application was not obtained from""
        f"" '{module.__name__}:{app_name}'.""
    )",False
92336be8eece75dc270691a6d8b0dd8e4140c5a2,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,function,prepare_import,prepare_import,200,226,"Given a filename this will try to calculate the python path, add it
to the search path and return the actual module name that is expected.","def prepare_import(path: str) -> str:
    """"""Given a filename this will try to calculate the python path, add it
    to the search path and return the actual module name that is expected.
    """"""
    path = os.path.realpath(path)

    fname, ext = os.path.splitext(path)
    if ext == "".py"":
        path = fname

    if os.path.basename(path) == ""__init__"":
        path = os.path.dirname(path)

    module_name = []

    # move up until outside package structure (no __init__.py)
    while True:
        path, name = os.path.split(path)
        module_name.append(name)

        if not os.path.exists(os.path.join(path, ""__init__.py"")):
            break

    if sys.path[0] != path:
        sys.path.insert(0, path)

    return ""."".join(module_name[::-1])",False
f34bf8fc18a157272cbd51e668ff97b8d4555958,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,function,locate_app,locate_app,230,232,,"def locate_app(
    module_name: str, app_name: str | None, raise_if_not_found: t.Literal[True] = True
) -> Flask: ...",False
8681c9b95566441ebb93816ddaa92452bcbb99fa,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,function,locate_app,locate_app,236,238,,"def locate_app(
    module_name: str, app_name: str | None, raise_if_not_found: t.Literal[False] = ...
) -> Flask | None: ...",False
8c4189f9bfae0a6d8b5eb9eb9c1fb1005743727f,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,function,locate_app,locate_app,241,264,,"def locate_app(
    module_name: str, app_name: str | None, raise_if_not_found: bool = True
) -> Flask | None:
    try:
        __import__(module_name)
    except ImportError:
        # Reraise the ImportError if it occurred within the imported module.
        # Determine this by checking whether the trace has a depth > 1.
        if sys.exc_info()[2].tb_next:  # type: ignore[union-attr]
            raise NoAppException(
                f""While importing {module_name!r}, an ImportError was""
                f"" raised:\n\n{traceback.format_exc()}""
            ) from None
        elif raise_if_not_found:
            raise NoAppException(f""Could not import {module_name!r}."") from None
        else:
            return None

    module = sys.modules[module_name]

    if app_name is None:
        return find_best_app(module)
    else:
        return find_app_by_string(module, app_name)",False
f50cd701612495d569c579c17a2b8eb9aabe6857,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,function,get_version,get_version,267,280,,"def get_version(ctx: click.Context, param: click.Parameter, value: t.Any) -> None:
    if not value or ctx.resilient_parsing:
        return

    flask_version = importlib.metadata.version(""flask"")
    werkzeug_version = importlib.metadata.version(""werkzeug"")

    click.echo(
        f""Python {platform.python_version()}\n""
        f""Flask {flask_version}\n""
        f""Werkzeug {werkzeug_version}"",
        color=ctx.color,
    )
    ctx.exit()",False
d0aec7e062085aa4ae78c875a0c83e45738b1581,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,class,ScriptInfo,ScriptInfo,293,372,"Helper object to deal with Flask applications.  This is usually not
necessary to interface with as it's used internally in the dispatching
to click.  In future versions of Flask this object will most likely play
a bigger role.  Typically it's created automatically by the
:class:`FlaskGroup` but you can also manually create it and pass it
onwards as click object.

.. versionchanged:: 3.1
    Added the ``load_dotenv_defaults`` parameter and attribute.","class ScriptInfo:
    """"""Helper object to deal with Flask applications.  This is usually not
    necessary to interface with as it's used internally in the dispatching
    to click.  In future versions of Flask this object will most likely play
    a bigger role.  Typically it's created automatically by the
    :class:`FlaskGroup` but you can also manually create it and pass it
    onwards as click object.

    .. versionchanged:: 3.1
        Added the ``load_dotenv_defaults`` parameter and attribute.
    """"""

    def __init__(
        self,
        app_import_path: str | None = None,
        create_app: t.Callable[..., Flask] | None = None,
        set_debug_flag: bool = True,
        load_dotenv_defaults: bool = True,
    ) -> None:
        #: Optionally the import path for the Flask application.
        self.app_import_path = app_import_path
        #: Optionally a function that is passed the script info to create
        #: the instance of the application.
        self.create_app = create_app
        #: A dictionary with arbitrary data that can be associated with
        #: this script info.
        self.data: dict[t.Any, t.Any] = {}
        self.set_debug_flag = set_debug_flag

        self.load_dotenv_defaults = get_load_dotenv(load_dotenv_defaults)
        """"""Whether default ``.flaskenv`` and ``.env`` files should be loaded.

        ``ScriptInfo`` doesn't load anything, this is for reference when doing
        the load elsewhere during processing.

        .. versionadded:: 3.1
        """"""

        self._loaded_app: Flask | None = None

    def load_app(self) -> Flask:
        """"""Loads the Flask app (if not yet loaded) and returns it.  Calling
        this multiple times will just result in the already loaded app to
        be returned.
        """"""
        if self._loaded_app is not None:
            return self._loaded_app
        app: Flask | None = None
        if self.create_app is not None:
            app = self.create_app()
        else:
            if self.app_import_path:
                path, name = (
                    re.split(r"":(?![\\/])"", self.app_import_path, maxsplit=1) + [None]
                )[:2]
                import_name = prepare_import(path)
                app = locate_app(import_name, name)
            else:
                for path in (""wsgi.py"", ""app.py""):
                    import_name = prepare_import(path)
                    app = locate_app(import_name, None, raise_if_not_found=False)

                    if app is not None:
                        break

        if app is None:
            raise NoAppException(
                ""Could not locate a Flask application. Use the""
                "" 'flask --app' option, 'FLASK_APP' environment""
                "" variable, or a 'wsgi.py' or 'app.py' file in the""
                "" current directory.""
            )

        if self.set_debug_flag:
            # Update the app's debug flag through the descriptor so that
            # other values repopulate as well.
            app.debug = get_debug_flag()

        self._loaded_app = app
        return app",False
bb8b373c6e3748c380c1afe8fda418f0c16084d3,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,method,__init__,ScriptInfo.__init__,305,331,,"    def __init__(
        self,
        app_import_path: str | None = None,
        create_app: t.Callable[..., Flask] | None = None,
        set_debug_flag: bool = True,
        load_dotenv_defaults: bool = True,
    ) -> None:
        #: Optionally the import path for the Flask application.
        self.app_import_path = app_import_path
        #: Optionally a function that is passed the script info to create
        #: the instance of the application.
        self.create_app = create_app
        #: A dictionary with arbitrary data that can be associated with
        #: this script info.
        self.data: dict[t.Any, t.Any] = {}
        self.set_debug_flag = set_debug_flag

        self.load_dotenv_defaults = get_load_dotenv(load_dotenv_defaults)
        """"""Whether default ``.flaskenv`` and ``.env`` files should be loaded.

        ``ScriptInfo`` doesn't load anything, this is for reference when doing
        the load elsewhere during processing.

        .. versionadded:: 3.1
        """"""

        self._loaded_app: Flask | None = None",False
188aa932dc26b3fa3413072cd11031f8665c3389,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,method,load_app,ScriptInfo.load_app,333,372,"Loads the Flask app (if not yet loaded) and returns it.  Calling
this multiple times will just result in the already loaded app to
be returned.","    def load_app(self) -> Flask:
        """"""Loads the Flask app (if not yet loaded) and returns it.  Calling
        this multiple times will just result in the already loaded app to
        be returned.
        """"""
        if self._loaded_app is not None:
            return self._loaded_app
        app: Flask | None = None
        if self.create_app is not None:
            app = self.create_app()
        else:
            if self.app_import_path:
                path, name = (
                    re.split(r"":(?![\\/])"", self.app_import_path, maxsplit=1) + [None]
                )[:2]
                import_name = prepare_import(path)
                app = locate_app(import_name, name)
            else:
                for path in (""wsgi.py"", ""app.py""):
                    import_name = prepare_import(path)
                    app = locate_app(import_name, None, raise_if_not_found=False)

                    if app is not None:
                        break

        if app is None:
            raise NoAppException(
                ""Could not locate a Flask application. Use the""
                "" 'flask --app' option, 'FLASK_APP' environment""
                "" variable, or a 'wsgi.py' or 'app.py' file in the""
                "" current directory.""
            )

        if self.set_debug_flag:
            # Update the app's debug flag through the descriptor so that
            # other values repopulate as well.
            app.debug = get_debug_flag()

        self._loaded_app = app
        return app",False
714cf9709a38f4c40ff9a995621e9db6e619ed75,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,function,with_appcontext,with_appcontext,380,402,"Wraps a callback so that it's guaranteed to be executed with the
script's application context.

Custom commands (and their options) registered under ``app.cli`` or
``blueprint.cli`` will always have an app context available, this
decorator is not required in that case.

.. versionchanged:: 2.2
    The app context is active for subcommands as well as the
    decorated callback. The app context is always available to
    ``app.cli`` command and parameter callbacks.","def with_appcontext(f: F) -> F:
    """"""Wraps a callback so that it's guaranteed to be executed with the
    script's application context.

    Custom commands (and their options) registered under ``app.cli`` or
    ``blueprint.cli`` will always have an app context available, this
    decorator is not required in that case.

    .. versionchanged:: 2.2
        The app context is active for subcommands as well as the
        decorated callback. The app context is always available to
        ``app.cli`` command and parameter callbacks.
    """"""

    @click.pass_context
    def decorator(ctx: click.Context, /, *args: t.Any, **kwargs: t.Any) -> t.Any:
        if not current_app:
            app = ctx.ensure_object(ScriptInfo).load_app()
            ctx.with_resource(app.app_context())

        return ctx.invoke(f, *args, **kwargs)

    return update_wrapper(decorator, f)  # type: ignore[return-value]",False
8ef2912dc73d129bc531743ed5da7939831d6ee5,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,class,AppGroup,AppGroup,405,437,"This works similar to a regular click :class:`~click.Group` but it
changes the behavior of the :meth:`command` decorator so that it
automatically wraps the functions in :func:`with_appcontext`.

Not to be confused with :class:`FlaskGroup`.","class AppGroup(click.Group):
    """"""This works similar to a regular click :class:`~click.Group` but it
    changes the behavior of the :meth:`command` decorator so that it
    automatically wraps the functions in :func:`with_appcontext`.

    Not to be confused with :class:`FlaskGroup`.
    """"""

    def command(  # type: ignore[override]
        self, *args: t.Any, **kwargs: t.Any
    ) -> t.Callable[[t.Callable[..., t.Any]], click.Command]:
        """"""This works exactly like the method of the same name on a regular
        :class:`click.Group` but it wraps callbacks in :func:`with_appcontext`
        unless it's disabled by passing ``with_appcontext=False``.
        """"""
        wrap_for_ctx = kwargs.pop(""with_appcontext"", True)

        def decorator(f: t.Callable[..., t.Any]) -> click.Command:
            if wrap_for_ctx:
                f = with_appcontext(f)
            return super(AppGroup, self).command(*args, **kwargs)(f)  # type: ignore[no-any-return]

        return decorator

    def group(  # type: ignore[override]
        self, *args: t.Any, **kwargs: t.Any
    ) -> t.Callable[[t.Callable[..., t.Any]], click.Group]:
        """"""This works exactly like the method of the same name on a regular
        :class:`click.Group` but it defaults the group class to
        :class:`AppGroup`.
        """"""
        kwargs.setdefault(""cls"", AppGroup)
        return super().group(*args, **kwargs)  # type: ignore[no-any-return]",False
4394744b568f748edce0064aa87559216aca5f42,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,method,command,AppGroup.command,413,427,"This works exactly like the method of the same name on a regular
:class:`click.Group` but it wraps callbacks in :func:`with_appcontext`
unless it's disabled by passing ``with_appcontext=False``.","    def command(  # type: ignore[override]
        self, *args: t.Any, **kwargs: t.Any
    ) -> t.Callable[[t.Callable[..., t.Any]], click.Command]:
        """"""This works exactly like the method of the same name on a regular
        :class:`click.Group` but it wraps callbacks in :func:`with_appcontext`
        unless it's disabled by passing ``with_appcontext=False``.
        """"""
        wrap_for_ctx = kwargs.pop(""with_appcontext"", True)

        def decorator(f: t.Callable[..., t.Any]) -> click.Command:
            if wrap_for_ctx:
                f = with_appcontext(f)
            return super(AppGroup, self).command(*args, **kwargs)(f)  # type: ignore[no-any-return]

        return decorator",False
6ff63ce14bd4967d2a61e78d7b2114210163c260,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,method,group,AppGroup.group,429,437,"This works exactly like the method of the same name on a regular
:class:`click.Group` but it defaults the group class to
:class:`AppGroup`.","    def group(  # type: ignore[override]
        self, *args: t.Any, **kwargs: t.Any
    ) -> t.Callable[[t.Callable[..., t.Any]], click.Group]:
        """"""This works exactly like the method of the same name on a regular
        :class:`click.Group` but it defaults the group class to
        :class:`AppGroup`.
        """"""
        kwargs.setdefault(""cls"", AppGroup)
        return super().group(*args, **kwargs)  # type: ignore[no-any-return]",False
6a1079c268422ee8aa6b87b2cbdd1947c417335e,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,function,_set_app,_set_app,440,446,,"def _set_app(ctx: click.Context, param: click.Option, value: str | None) -> str | None:
    if value is None:
        return None

    info = ctx.ensure_object(ScriptInfo)
    info.app_import_path = value
    return value",False
10e5a5b4986f10bc2bc83a6d260300734ac918d5,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,function,_set_debug,_set_debug,468,482,,"def _set_debug(ctx: click.Context, param: click.Option, value: bool) -> bool | None:
    # If the flag isn't provided, it will default to False. Don't use
    # that, let debug be set by env in that case.
    source = ctx.get_parameter_source(param.name)  # type: ignore[arg-type]

    if source is not None and source in (
        ParameterSource.DEFAULT,
        ParameterSource.DEFAULT_MAP,
    ):
        return None

    # Set with env var instead of ScriptInfo.load so that it can be
    # accessed early during a factory function.
    os.environ[""FLASK_DEBUG""] = ""1"" if value else ""0""
    return value",False
1c8f3f248c99330e2ef9e3077fd60ffe7060559a,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,function,_env_file_callback,_env_file_callback,493,512,,"def _env_file_callback(
    ctx: click.Context, param: click.Option, value: str | None
) -> str | None:
    try:
        import dotenv  # noqa: F401
    except ImportError:
        # Only show an error if a value was passed, otherwise we still want to
        # call load_dotenv and show a message without exiting.
        if value is not None:
            raise click.BadParameter(
                ""python-dotenv must be installed to load an env file."",
                ctx=ctx,
                param=param,
            ) from None

    # Load if a value was passed, or we want to load default files, or both.
    if value is not None or ctx.obj.load_dotenv_defaults:
        load_dotenv(value, load_defaults=ctx.obj.load_dotenv_defaults)

    return value",False
44475fae39f2c155f96c193b31bd7f9dbd0df3a3,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,class,FlaskGroup,FlaskGroup,531,696,"Special subclass of the :class:`AppGroup` group that supports
loading more commands from the configured Flask app.  Normally a
developer does not have to interface with this class but there are
some very advanced use cases for which it makes sense to create an
instance of this. see :ref:`custom-scripts`.

:param add_default_commands: if this is True then the default run and
    shell commands will be added.
:param add_version_option: adds the ``--version`` option.
:param create_app: an optional callback that is passed the script info and
    returns the loaded app.
:param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`
    files to set environment variables. Will also change the working
    directory to the directory containing the first file found.
:param set_debug_flag: Set the app's debug flag.

.. versionchanged:: 3.1
    ``-e path`` takes precedence over default ``.env`` and ``.flaskenv`` files.

.. versionchanged:: 2.2
    Added the ``-A/--app``, ``--debug/--no-debug``, ``-e/--env-file`` options.

.. versionchanged:: 2.2
    An app context is pushed when running ``app.cli`` commands, so
    ``@with_appcontext`` is no longer required for those commands.

.. versionchanged:: 1.0
    If installed, python-dotenv will be used to load environment variables
    from :file:`.env` and :file:`.flaskenv` files.","class FlaskGroup(AppGroup):
    """"""Special subclass of the :class:`AppGroup` group that supports
    loading more commands from the configured Flask app.  Normally a
    developer does not have to interface with this class but there are
    some very advanced use cases for which it makes sense to create an
    instance of this. see :ref:`custom-scripts`.

    :param add_default_commands: if this is True then the default run and
        shell commands will be added.
    :param add_version_option: adds the ``--version`` option.
    :param create_app: an optional callback that is passed the script info and
        returns the loaded app.
    :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`
        files to set environment variables. Will also change the working
        directory to the directory containing the first file found.
    :param set_debug_flag: Set the app's debug flag.

    .. versionchanged:: 3.1
        ``-e path`` takes precedence over default ``.env`` and ``.flaskenv`` files.

    .. versionchanged:: 2.2
        Added the ``-A/--app``, ``--debug/--no-debug``, ``-e/--env-file`` options.

    .. versionchanged:: 2.2
        An app context is pushed when running ``app.cli`` commands, so
        ``@with_appcontext`` is no longer required for those commands.

    .. versionchanged:: 1.0
        If installed, python-dotenv will be used to load environment variables
        from :file:`.env` and :file:`.flaskenv` files.
    """"""

    def __init__(
        self,
        add_default_commands: bool = True,
        create_app: t.Callable[..., Flask] | None = None,
        add_version_option: bool = True,
        load_dotenv: bool = True,
        set_debug_flag: bool = True,
        **extra: t.Any,
    ) -> None:
        params: list[click.Parameter] = list(extra.pop(""params"", None) or ())
        # Processing is done with option callbacks instead of a group
        # callback. This allows users to make a custom group callback
        # without losing the behavior. --env-file must come first so
        # that it is eagerly evaluated before --app.
        params.extend((_env_file_option, _app_option, _debug_option))

        if add_version_option:
            params.append(version_option)

        if ""context_settings"" not in extra:
            extra[""context_settings""] = {}

        extra[""context_settings""].setdefault(""auto_envvar_prefix"", ""FLASK"")

        super().__init__(params=params, **extra)

        self.create_app = create_app
        self.load_dotenv = load_dotenv
        self.set_debug_flag = set_debug_flag

        if add_default_commands:
            self.add_command(run_command)
            self.add_command(shell_command)
            self.add_command(routes_command)

        self._loaded_plugin_commands = False

    def _load_plugin_commands(self) -> None:
        if self._loaded_plugin_commands:
            return

        if sys.version_info >= (3, 10):
            from importlib import metadata
        else:
            # Use a backport on Python < 3.10. We technically have
            # importlib.metadata on 3.8+, but the API changed in 3.10,
            # so use the backport for consistency.
            import importlib_metadata as metadata  # pyright: ignore

        for ep in metadata.entry_points(group=""flask.commands""):
            self.add_command(ep.load(), ep.name)

        self._loaded_plugin_commands = True

    def get_command(self, ctx: click.Context, name: str) -> click.Command | None:
        self._load_plugin_commands()
        # Look up built-in and plugin commands, which should be
        # available even if the app fails to load.
        rv = super().get_command(ctx, name)

        if rv is not None:
            return rv

        info = ctx.ensure_object(ScriptInfo)

        # Look up commands provided by the app, showing an error and
        # continuing if the app couldn't be loaded.
        try:
            app = info.load_app()
        except NoAppException as e:
            click.secho(f""Error: {e.format_message()}\n"", err=True, fg=""red"")
            return None

        # Push an app context for the loaded app unless it is already
        # active somehow. This makes the context available to parameter
        # and command callbacks without needing @with_appcontext.
        if not current_app or current_app._get_current_object() is not app:  # type: ignore[attr-defined]
            ctx.with_resource(app.app_context())

        return app.cli.get_command(ctx, name)

    def list_commands(self, ctx: click.Context) -> list[str]:
        self._load_plugin_commands()
        # Start with the built-in and plugin commands.
        rv = set(super().list_commands(ctx))
        info = ctx.ensure_object(ScriptInfo)

        # Add commands provided by the app, showing an error and
        # continuing if the app couldn't be loaded.
        try:
            rv.update(info.load_app().cli.list_commands(ctx))
        except NoAppException as e:
            # When an app couldn't be loaded, show the error message
            # without the traceback.
            click.secho(f""Error: {e.format_message()}\n"", err=True, fg=""red"")
        except Exception:
            # When any other errors occurred during loading, show the
            # full traceback.
            click.secho(f""{traceback.format_exc()}\n"", err=True, fg=""red"")

        return sorted(rv)

    def make_context(
        self,
        info_name: str | None,
        args: list[str],
        parent: click.Context | None = None,
        **extra: t.Any,
    ) -> click.Context:
        # Set a flag to tell app.run to become a no-op. If app.run was
        # not in a __name__ == __main__ guard, it would start the server
        # when importing, blocking whatever command is being called.
        os.environ[""FLASK_RUN_FROM_CLI""] = ""true""

        if ""obj"" not in extra and ""obj"" not in self.context_settings:
            extra[""obj""] = ScriptInfo(
                create_app=self.create_app,
                set_debug_flag=self.set_debug_flag,
                load_dotenv_defaults=self.load_dotenv,
            )

        return super().make_context(info_name, args, parent=parent, **extra)

    def parse_args(self, ctx: click.Context, args: list[str]) -> list[str]:
        if (not args and self.no_args_is_help) or (
            len(args) == 1 and args[0] in self.get_help_option_names(ctx)
        ):
            # Attempt to load --env-file and --app early in case they
            # were given as env vars. Otherwise no_args_is_help will not
            # see commands from app.cli.
            _env_file_option.handle_parse_result(ctx, {}, [])
            _app_option.handle_parse_result(ctx, {}, [])

        return super().parse_args(ctx, args)",False
f40c9cc5dee89ab28ce3395baad7640e7d9cfe4b,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,method,__init__,FlaskGroup.__init__,563,598,,"    def __init__(
        self,
        add_default_commands: bool = True,
        create_app: t.Callable[..., Flask] | None = None,
        add_version_option: bool = True,
        load_dotenv: bool = True,
        set_debug_flag: bool = True,
        **extra: t.Any,
    ) -> None:
        params: list[click.Parameter] = list(extra.pop(""params"", None) or ())
        # Processing is done with option callbacks instead of a group
        # callback. This allows users to make a custom group callback
        # without losing the behavior. --env-file must come first so
        # that it is eagerly evaluated before --app.
        params.extend((_env_file_option, _app_option, _debug_option))

        if add_version_option:
            params.append(version_option)

        if ""context_settings"" not in extra:
            extra[""context_settings""] = {}

        extra[""context_settings""].setdefault(""auto_envvar_prefix"", ""FLASK"")

        super().__init__(params=params, **extra)

        self.create_app = create_app
        self.load_dotenv = load_dotenv
        self.set_debug_flag = set_debug_flag

        if add_default_commands:
            self.add_command(run_command)
            self.add_command(shell_command)
            self.add_command(routes_command)

        self._loaded_plugin_commands = False",False
a73988ed626172b3de845c440c16f38334d8d609,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,method,_load_plugin_commands,FlaskGroup._load_plugin_commands,600,615,,"    def _load_plugin_commands(self) -> None:
        if self._loaded_plugin_commands:
            return

        if sys.version_info >= (3, 10):
            from importlib import metadata
        else:
            # Use a backport on Python < 3.10. We technically have
            # importlib.metadata on 3.8+, but the API changed in 3.10,
            # so use the backport for consistency.
            import importlib_metadata as metadata  # pyright: ignore

        for ep in metadata.entry_points(group=""flask.commands""):
            self.add_command(ep.load(), ep.name)

        self._loaded_plugin_commands = True",False
e204da37ebd24267a28ec1af53838c5f545bde0e,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,method,get_command,FlaskGroup.get_command,617,642,,"    def get_command(self, ctx: click.Context, name: str) -> click.Command | None:
        self._load_plugin_commands()
        # Look up built-in and plugin commands, which should be
        # available even if the app fails to load.
        rv = super().get_command(ctx, name)

        if rv is not None:
            return rv

        info = ctx.ensure_object(ScriptInfo)

        # Look up commands provided by the app, showing an error and
        # continuing if the app couldn't be loaded.
        try:
            app = info.load_app()
        except NoAppException as e:
            click.secho(f""Error: {e.format_message()}\n"", err=True, fg=""red"")
            return None

        # Push an app context for the loaded app unless it is already
        # active somehow. This makes the context available to parameter
        # and command callbacks without needing @with_appcontext.
        if not current_app or current_app._get_current_object() is not app:  # type: ignore[attr-defined]
            ctx.with_resource(app.app_context())

        return app.cli.get_command(ctx, name)",False
beaf12d6c6010cbd32ad7ac509246967ffc020de,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,method,list_commands,FlaskGroup.list_commands,644,663,,"    def list_commands(self, ctx: click.Context) -> list[str]:
        self._load_plugin_commands()
        # Start with the built-in and plugin commands.
        rv = set(super().list_commands(ctx))
        info = ctx.ensure_object(ScriptInfo)

        # Add commands provided by the app, showing an error and
        # continuing if the app couldn't be loaded.
        try:
            rv.update(info.load_app().cli.list_commands(ctx))
        except NoAppException as e:
            # When an app couldn't be loaded, show the error message
            # without the traceback.
            click.secho(f""Error: {e.format_message()}\n"", err=True, fg=""red"")
        except Exception:
            # When any other errors occurred during loading, show the
            # full traceback.
            click.secho(f""{traceback.format_exc()}\n"", err=True, fg=""red"")

        return sorted(rv)",False
f2086f01c303d1474f7c26c4de4301b78ef2e06b,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,method,make_context,FlaskGroup.make_context,665,684,,"    def make_context(
        self,
        info_name: str | None,
        args: list[str],
        parent: click.Context | None = None,
        **extra: t.Any,
    ) -> click.Context:
        # Set a flag to tell app.run to become a no-op. If app.run was
        # not in a __name__ == __main__ guard, it would start the server
        # when importing, blocking whatever command is being called.
        os.environ[""FLASK_RUN_FROM_CLI""] = ""true""

        if ""obj"" not in extra and ""obj"" not in self.context_settings:
            extra[""obj""] = ScriptInfo(
                create_app=self.create_app,
                set_debug_flag=self.set_debug_flag,
                load_dotenv_defaults=self.load_dotenv,
            )

        return super().make_context(info_name, args, parent=parent, **extra)",False
b842b9e350abe509c7d880311bbe188bb61f5320,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,method,parse_args,FlaskGroup.parse_args,686,696,,"    def parse_args(self, ctx: click.Context, args: list[str]) -> list[str]:
        if (not args and self.no_args_is_help) or (
            len(args) == 1 and args[0] in self.get_help_option_names(ctx)
        ):
            # Attempt to load --env-file and --app early in case they
            # were given as env vars. Otherwise no_args_is_help will not
            # see commands from app.cli.
            _env_file_option.handle_parse_result(ctx, {}, [])
            _app_option.handle_parse_result(ctx, {}, [])

        return super().parse_args(ctx, args)",False
567661ea5cf5c0c7ec4f99a5f2a25cce8ad279ec,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,function,_path_is_ancestor,_path_is_ancestor,699,703,"Take ``other`` and remove the length of ``path`` from it. Then join it
to ``path``. If it is the original value, ``path`` is an ancestor of
``other``.","def _path_is_ancestor(path: str, other: str) -> bool:
    """"""Take ``other`` and remove the length of ``path`` from it. Then join it
    to ``path``. If it is the original value, ``path`` is an ancestor of
    ``other``.""""""
    return os.path.join(path, other[len(path) :].lstrip(os.sep)) == other",False
71461cbccdeae579d7a6497ce7b7bd8481819f73,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,function,load_dotenv,load_dotenv,706,771,"Load ""dotenv"" files to set environment variables. A given path takes
precedence over ``.env``, which takes precedence over ``.flaskenv``. After
loading and combining these files, values are only set if the key is not
already set in ``os.environ``.

This is a no-op if `python-dotenv`_ is not installed.

.. _python-dotenv: https://github.com/theskumar/python-dotenv#readme

:param path: Load the file at this location.
:param load_defaults: Search for and load the default ``.flaskenv`` and
    ``.env`` files.
:return: ``True`` if at least one env var was loaded.

.. versionchanged:: 3.1
    Added the ``load_defaults`` parameter. A given path takes precedence
    over default files.

.. versionchanged:: 2.0
    The current directory is not changed to the location of the
    loaded file.

.. versionchanged:: 2.0
    When loading the env files, set the default encoding to UTF-8.

.. versionchanged:: 1.1.0
    Returns ``False`` when python-dotenv is not installed, or when
    the given path isn't a file.

.. versionadded:: 1.0","def load_dotenv(
    path: str | os.PathLike[str] | None = None, load_defaults: bool = True
) -> bool:
    """"""Load ""dotenv"" files to set environment variables. A given path takes
    precedence over ``.env``, which takes precedence over ``.flaskenv``. After
    loading and combining these files, values are only set if the key is not
    already set in ``os.environ``.

    This is a no-op if `python-dotenv`_ is not installed.

    .. _python-dotenv: https://github.com/theskumar/python-dotenv#readme

    :param path: Load the file at this location.
    :param load_defaults: Search for and load the default ``.flaskenv`` and
        ``.env`` files.
    :return: ``True`` if at least one env var was loaded.

    .. versionchanged:: 3.1
        Added the ``load_defaults`` parameter. A given path takes precedence
        over default files.

    .. versionchanged:: 2.0
        The current directory is not changed to the location of the
        loaded file.

    .. versionchanged:: 2.0
        When loading the env files, set the default encoding to UTF-8.

    .. versionchanged:: 1.1.0
        Returns ``False`` when python-dotenv is not installed, or when
        the given path isn't a file.

    .. versionadded:: 1.0
    """"""
    try:
        import dotenv
    except ImportError:
        if path or os.path.isfile("".env"") or os.path.isfile("".flaskenv""):
            click.secho(
                "" * Tip: There are .env files present. Install python-dotenv""
                "" to use them."",
                fg=""yellow"",
                err=True,
            )

        return False

    data: dict[str, str | None] = {}

    if load_defaults:
        for default_name in ("".flaskenv"", "".env""):
            if not (default_path := dotenv.find_dotenv(default_name, usecwd=True)):
                continue

            data |= dotenv.dotenv_values(default_path, encoding=""utf-8"")

    if path is not None and os.path.isfile(path):
        data |= dotenv.dotenv_values(path, encoding=""utf-8"")

    for key, value in data.items():
        if key in os.environ or value is None:
            continue

        os.environ[key] = value

    return bool(data)  # True if at least one env var was loaded.",False
3ab8b20264e0770e4174bef46bd5c41a7679a93c,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,function,show_server_banner,show_server_banner,774,785,"Show extra startup messages the first time the server is run,
ignoring the reloader.","def show_server_banner(debug: bool, app_import_path: str | None) -> None:
    """"""Show extra startup messages the first time the server is run,
    ignoring the reloader.
    """"""
    if is_running_from_reloader():
        return

    if app_import_path is not None:
        click.echo(f"" * Serving Flask app '{app_import_path}'"")

    if debug is not None:
        click.echo(f"" * Debug mode: {'on' if debug else 'off'}"")",False
3d35f3c0494465e0c739aa2f6180b72aeb75f409,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,class,CertParamType,CertParamType,788,833,"Click option type for the ``--cert`` option. Allows either an
existing file, the string ``'adhoc'``, or an import for a
:class:`~ssl.SSLContext` object.","class CertParamType(click.ParamType):
    """"""Click option type for the ``--cert`` option. Allows either an
    existing file, the string ``'adhoc'``, or an import for a
    :class:`~ssl.SSLContext` object.
    """"""

    name = ""path""

    def __init__(self) -> None:
        self.path_type = click.Path(exists=True, dir_okay=False, resolve_path=True)

    def convert(
        self, value: t.Any, param: click.Parameter | None, ctx: click.Context | None
    ) -> t.Any:
        try:
            import ssl
        except ImportError:
            raise click.BadParameter(
                'Using ""--cert"" requires Python to be compiled with SSL support.',
                ctx,
                param,
            ) from None

        try:
            return self.path_type(value, param, ctx)
        except click.BadParameter:
            value = click.STRING(value, param, ctx).lower()

            if value == ""adhoc"":
                try:
                    import cryptography  # noqa: F401
                except ImportError:
                    raise click.BadParameter(
                        ""Using ad-hoc certificates requires the cryptography library."",
                        ctx,
                        param,
                    ) from None

                return value

            obj = import_string(value, silent=True)

            if isinstance(obj, ssl.SSLContext):
                return obj

            raise",False
c0438b3bfd75258bf73be27bffbf3cb8548e5fbe,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,method,__init__,CertParamType.__init__,796,797,,"    def __init__(self) -> None:
        self.path_type = click.Path(exists=True, dir_okay=False, resolve_path=True)",False
827093065d9141bf6edde768b2c7accecce81e00,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,method,convert,CertParamType.convert,799,833,,"    def convert(
        self, value: t.Any, param: click.Parameter | None, ctx: click.Context | None
    ) -> t.Any:
        try:
            import ssl
        except ImportError:
            raise click.BadParameter(
                'Using ""--cert"" requires Python to be compiled with SSL support.',
                ctx,
                param,
            ) from None

        try:
            return self.path_type(value, param, ctx)
        except click.BadParameter:
            value = click.STRING(value, param, ctx).lower()

            if value == ""adhoc"":
                try:
                    import cryptography  # noqa: F401
                except ImportError:
                    raise click.BadParameter(
                        ""Using ad-hoc certificates requires the cryptography library."",
                        ctx,
                        param,
                    ) from None

                return value

            obj = import_string(value, silent=True)

            if isinstance(obj, ssl.SSLContext):
                return obj

            raise",False
7e4055ec4f2fd371ac2c74b8f8c6b91e35a9dcf4,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,function,_validate_key,_validate_key,836,872,"The ``--key`` option must be specified when ``--cert`` is a file.
Modifies the ``cert`` param to be a ``(cert, key)`` pair if needed.","def _validate_key(ctx: click.Context, param: click.Parameter, value: t.Any) -> t.Any:
    """"""The ``--key`` option must be specified when ``--cert`` is a file.
    Modifies the ``cert`` param to be a ``(cert, key)`` pair if needed.
    """"""
    cert = ctx.params.get(""cert"")
    is_adhoc = cert == ""adhoc""

    try:
        import ssl
    except ImportError:
        is_context = False
    else:
        is_context = isinstance(cert, ssl.SSLContext)

    if value is not None:
        if is_adhoc:
            raise click.BadParameter(
                'When ""--cert"" is ""adhoc"", ""--key"" is not used.', ctx, param
            )

        if is_context:
            raise click.BadParameter(
                'When ""--cert"" is an SSLContext object, ""--key"" is not used.',
                ctx,
                param,
            )

        if not cert:
            raise click.BadParameter('""--cert"" must also be specified.', ctx, param)

        ctx.params[""cert""] = cert, value

    else:
        if cert and not (is_adhoc or is_context):
            raise click.BadParameter('Required when using ""--cert"".', ctx, param)

    return value",False
b85e1e055e7e56bb94040b4fe0bbb452c9e0cc9c,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,class,SeparatedPathType,SeparatedPathType,875,887,"Click option type that accepts a list of values separated by the
OS's path separator (``:``, ``;`` on Windows). Each value is
validated as a :class:`click.Path` type.","class SeparatedPathType(click.Path):
    """"""Click option type that accepts a list of values separated by the
    OS's path separator (``:``, ``;`` on Windows). Each value is
    validated as a :class:`click.Path` type.
    """"""

    def convert(
        self, value: t.Any, param: click.Parameter | None, ctx: click.Context | None
    ) -> t.Any:
        items = self.split_envvar_value(value)
        # can't call no-arg super() inside list comprehension until Python 3.12
        super_convert = super().convert
        return [super_convert(item, param, ctx) for item in items]",False
4c4ce32ef7a9304cfba2b5bfde0f7b6caf47d583,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,method,convert,SeparatedPathType.convert,881,887,,"    def convert(
        self, value: t.Any, param: click.Parameter | None, ctx: click.Context | None
    ) -> t.Any:
        items = self.split_envvar_value(value)
        # can't call no-arg super() inside list comprehension until Python 3.12
        super_convert = super().convert
        return [super_convert(item, param, ctx) for item in items]",False
e5ca9c2e5cbd145f37297dbf40b852f8ba3448ca,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,function,run_command,run_command,943,1001,"Run a local development server.

This server is for development purposes only. It does not provide
the stability, security, or performance of production WSGI servers.

The reloader and debugger are enabled by default with the '--debug'
option.","def run_command(
    info: ScriptInfo,
    host: str,
    port: int,
    reload: bool,
    debugger: bool,
    with_threads: bool,
    cert: ssl.SSLContext | tuple[str, str | None] | t.Literal[""adhoc""] | None,
    extra_files: list[str] | None,
    exclude_patterns: list[str] | None,
) -> None:
    """"""Run a local development server.

    This server is for development purposes only. It does not provide
    the stability, security, or performance of production WSGI servers.

    The reloader and debugger are enabled by default with the '--debug'
    option.
    """"""
    try:
        app: WSGIApplication = info.load_app()  # pyright: ignore
    except Exception as e:
        if is_running_from_reloader():
            # When reloading, print out the error immediately, but raise
            # it later so the debugger or server can handle it.
            traceback.print_exc()
            err = e

            def app(
                environ: WSGIEnvironment, start_response: StartResponse
            ) -> cabc.Iterable[bytes]:
                raise err from None

        else:
            # When not reloading, raise the error immediately so the
            # command fails.
            raise e from None

    debug = get_debug_flag()

    if reload is None:
        reload = debug

    if debugger is None:
        debugger = debug

    show_server_banner(debug, info.app_import_path)

    run_simple(
        host,
        port,
        app,
        use_reloader=reload,
        use_debugger=debugger,
        threaded=with_threads,
        ssl_context=cert,
        extra_files=extra_files,
        exclude_patterns=exclude_patterns,
    )",False
f0dde381d95fcbecd4ead09fb2ca6d8b93472b9c,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,function,shell_command,shell_command,1009,1053,"Run an interactive Python shell in the context of a given
Flask application.  The application will populate the default
namespace of this shell according to its configuration.

This is useful for executing small snippets of management code
without having to manually configure the application.","def shell_command() -> None:
    """"""Run an interactive Python shell in the context of a given
    Flask application.  The application will populate the default
    namespace of this shell according to its configuration.

    This is useful for executing small snippets of management code
    without having to manually configure the application.
    """"""
    import code

    banner = (
        f""Python {sys.version} on {sys.platform}\n""
        f""App: {current_app.import_name}\n""
        f""Instance: {current_app.instance_path}""
    )
    ctx: dict[str, t.Any] = {}

    # Support the regular Python interpreter startup script if someone
    # is using it.
    startup = os.environ.get(""PYTHONSTARTUP"")
    if startup and os.path.isfile(startup):
        with open(startup) as f:
            eval(compile(f.read(), startup, ""exec""), ctx)

    ctx.update(current_app.make_shell_context())

    # Site, customize, or startup script can set a hook to call when
    # entering interactive mode. The default one sets up readline with
    # tab and history completion.
    interactive_hook = getattr(sys, ""__interactivehook__"", None)

    if interactive_hook is not None:
        try:
            import readline
            from rlcompleter import Completer
        except ImportError:
            pass
        else:
            # rlcompleter uses __main__.__dict__ by default, which is
            # flask.__main__. Use the shell context instead.
            readline.set_completer(Completer(ctx).complete)

        interactive_hook()

    code.interact(banner=banner, local=ctx)",False
754ff3332da81430efdda732e3bff0b845a02e98,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,function,routes_command,routes_command,1069,1115,Show all registered routes with endpoints and methods.,"def routes_command(sort: str, all_methods: bool) -> None:
    """"""Show all registered routes with endpoints and methods.""""""
    rules = list(current_app.url_map.iter_rules())

    if not rules:
        click.echo(""No routes were registered."")
        return

    ignored_methods = set() if all_methods else {""HEAD"", ""OPTIONS""}
    host_matching = current_app.url_map.host_matching
    has_domain = any(rule.host if host_matching else rule.subdomain for rule in rules)
    rows = []

    for rule in rules:
        row = [
            rule.endpoint,
            "", "".join(sorted((rule.methods or set()) - ignored_methods)),
        ]

        if has_domain:
            row.append((rule.host if host_matching else rule.subdomain) or """")

        row.append(rule.rule)
        rows.append(row)

    headers = [""Endpoint"", ""Methods""]
    sorts = [""endpoint"", ""methods""]

    if has_domain:
        headers.append(""Host"" if host_matching else ""Subdomain"")
        sorts.append(""domain"")

    headers.append(""Rule"")
    sorts.append(""rule"")

    try:
        rows.sort(key=itemgetter(sorts.index(sort)))
    except ValueError:
        pass

    rows.insert(0, headers)
    widths = [max(len(row[i]) for row in rows) for i in range(len(headers))]
    rows.insert(1, [""-"" * w for w in widths])
    template = ""  "".join(f""{{{i}:<{w}}}"" for i, w in enumerate(widths))

    for row in rows:
        click.echo(template.format(*row))",False
b46506d52037c646a520e1f5645981e49c88cb2b,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\cli.py,function,main,main,1130,1131,,"def main() -> None:
    cli.main()",False
8d0b0fe6fe90d0b883ad190344b298392f47377e,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\config.py,class,ConfigAttribute,ConfigAttribute,20,47,Makes an attribute forward to the config,"class ConfigAttribute(t.Generic[T]):
    """"""Makes an attribute forward to the config""""""

    def __init__(
        self, name: str, get_converter: t.Callable[[t.Any], T] | None = None
    ) -> None:
        self.__name__ = name
        self.get_converter = get_converter

    @t.overload
    def __get__(self, obj: None, owner: None) -> te.Self: ...

    @t.overload
    def __get__(self, obj: App, owner: type[App]) -> T: ...

    def __get__(self, obj: App | None, owner: type[App] | None = None) -> T | te.Self:
        if obj is None:
            return self

        rv = obj.config[self.__name__]

        if self.get_converter is not None:
            rv = self.get_converter(rv)

        return rv  # type: ignore[no-any-return]

    def __set__(self, obj: App, value: t.Any) -> None:
        obj.config[self.__name__] = value",False
92ab8e85cf48f69e69243a6ad73cafba584f7a80,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\config.py,method,__init__,ConfigAttribute.__init__,23,27,,"    def __init__(
        self, name: str, get_converter: t.Callable[[t.Any], T] | None = None
    ) -> None:
        self.__name__ = name
        self.get_converter = get_converter",False
dbce0c3c0dae7b39c46292c9a80219b9cf36520a,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\config.py,method,__get__,ConfigAttribute.__get__,30,30,,"    def __get__(self, obj: None, owner: None) -> te.Self: ...",False
1331235084911db93475fb2237035462639e387d,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\config.py,method,__get__,ConfigAttribute.__get__,33,33,,"    def __get__(self, obj: App, owner: type[App]) -> T: ...",False
8c7b24ce5614caaab10298192a074c9d28b8fed6,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\config.py,method,__get__,ConfigAttribute.__get__,35,44,,"    def __get__(self, obj: App | None, owner: type[App] | None = None) -> T | te.Self:
        if obj is None:
            return self

        rv = obj.config[self.__name__]

        if self.get_converter is not None:
            rv = self.get_converter(rv)

        return rv  # type: ignore[no-any-return]",False
e6e7fb1d7000fb589e85c58bdc360687aca180be,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\config.py,method,__set__,ConfigAttribute.__set__,46,47,,"    def __set__(self, obj: App, value: t.Any) -> None:
        obj.config[self.__name__] = value",False
37b55288fe5510252fd9cee31f9c14974201a9d1,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\config.py,class,Config,Config,50,367,"Works exactly like a dict but provides ways to fill it from files
or special dictionaries.  There are two common patterns to populate the
config.

Either you can fill the config from a config file::

    app.config.from_pyfile('yourconfig.cfg')

Or alternatively you can define the configuration options in the
module that calls :meth:`from_object` or provide an import path to
a module that should be loaded.  It is also possible to tell it to
use the same module and with that provide the configuration values
just before the call::

    DEBUG = True
    SECRET_KEY = 'development key'
    app.config.from_object(__name__)

In both cases (loading from any Python file or loading from modules),
only uppercase keys are added to the config.  This makes it possible to use
lowercase values in the config file for temporary values that are not added
to the config or to define the config keys in the same file that implements
the application.

Probably the most interesting way to load configurations is from an
environment variable pointing to a file::

    app.config.from_envvar('YOURAPPLICATION_SETTINGS')

In this case before launching the application you have to set this
environment variable to the file you want to use.  On Linux and OS X
use the export statement::

    export YOURAPPLICATION_SETTINGS='/path/to/config/file'

On windows use `set` instead.

:param root_path: path to which files are read relative from.  When the
                  config object is created by the application, this is
                  the application's :attr:`~flask.Flask.root_path`.
:param defaults: an optional dictionary of default values","class Config(dict):  # type: ignore[type-arg]
    """"""Works exactly like a dict but provides ways to fill it from files
    or special dictionaries.  There are two common patterns to populate the
    config.

    Either you can fill the config from a config file::

        app.config.from_pyfile('yourconfig.cfg')

    Or alternatively you can define the configuration options in the
    module that calls :meth:`from_object` or provide an import path to
    a module that should be loaded.  It is also possible to tell it to
    use the same module and with that provide the configuration values
    just before the call::

        DEBUG = True
        SECRET_KEY = 'development key'
        app.config.from_object(__name__)

    In both cases (loading from any Python file or loading from modules),
    only uppercase keys are added to the config.  This makes it possible to use
    lowercase values in the config file for temporary values that are not added
    to the config or to define the config keys in the same file that implements
    the application.

    Probably the most interesting way to load configurations is from an
    environment variable pointing to a file::

        app.config.from_envvar('YOURAPPLICATION_SETTINGS')

    In this case before launching the application you have to set this
    environment variable to the file you want to use.  On Linux and OS X
    use the export statement::

        export YOURAPPLICATION_SETTINGS='/path/to/config/file'

    On windows use `set` instead.

    :param root_path: path to which files are read relative from.  When the
                      config object is created by the application, this is
                      the application's :attr:`~flask.Flask.root_path`.
    :param defaults: an optional dictionary of default values
    """"""

    def __init__(
        self,
        root_path: str | os.PathLike[str],
        defaults: dict[str, t.Any] | None = None,
    ) -> None:
        super().__init__(defaults or {})
        self.root_path = root_path

    def from_envvar(self, variable_name: str, silent: bool = False) -> bool:
        """"""Loads a configuration from an environment variable pointing to
        a configuration file.  This is basically just a shortcut with nicer
        error messages for this line of code::

            app.config.from_pyfile(os.environ['YOURAPPLICATION_SETTINGS'])

        :param variable_name: name of the environment variable
        :param silent: set to ``True`` if you want silent failure for missing
                       files.
        :return: ``True`` if the file was loaded successfully.
        """"""
        rv = os.environ.get(variable_name)
        if not rv:
            if silent:
                return False
            raise RuntimeError(
                f""The environment variable {variable_name!r} is not set""
                "" and as such configuration could not be loaded. Set""
                "" this variable and make it point to a configuration""
                "" file""
            )
        return self.from_pyfile(rv, silent=silent)

    def from_prefixed_env(
        self, prefix: str = ""FLASK"", *, loads: t.Callable[[str], t.Any] = json.loads
    ) -> bool:
        """"""Load any environment variables that start with ``FLASK_``,
        dropping the prefix from the env key for the config key. Values
        are passed through a loading function to attempt to convert them
        to more specific types than strings.

        Keys are loaded in :func:`sorted` order.

        The default loading function attempts to parse values as any
        valid JSON type, including dicts and lists.

        Specific items in nested dicts can be set by separating the
        keys with double underscores (``__``). If an intermediate key
        doesn't exist, it will be initialized to an empty dict.

        :param prefix: Load env vars that start with this prefix,
            separated with an underscore (``_``).
        :param loads: Pass each string value to this function and use
            the returned value as the config value. If any error is
            raised it is ignored and the value remains a string. The
            default is :func:`json.loads`.

        .. versionadded:: 2.1
        """"""
        prefix = f""{prefix}_""

        for key in sorted(os.environ):
            if not key.startswith(prefix):
                continue

            value = os.environ[key]
            key = key.removeprefix(prefix)

            try:
                value = loads(value)
            except Exception:
                # Keep the value as a string if loading failed.
                pass

            if ""__"" not in key:
                # A non-nested key, set directly.
                self[key] = value
                continue

            # Traverse nested dictionaries with keys separated by ""__"".
            current = self
            *parts, tail = key.split(""__"")

            for part in parts:
                # If an intermediate dict does not exist, create it.
                if part not in current:
                    current[part] = {}

                current = current[part]

            current[tail] = value

        return True

    def from_pyfile(
        self, filename: str | os.PathLike[str], silent: bool = False
    ) -> bool:
        """"""Updates the values in the config from a Python file.  This function
        behaves as if the file was imported as module with the
        :meth:`from_object` function.

        :param filename: the filename of the config.  This can either be an
                         absolute filename or a filename relative to the
                         root path.
        :param silent: set to ``True`` if you want silent failure for missing
                       files.
        :return: ``True`` if the file was loaded successfully.

        .. versionadded:: 0.7
           `silent` parameter.
        """"""
        filename = os.path.join(self.root_path, filename)
        d = types.ModuleType(""config"")
        d.__file__ = filename
        try:
            with open(filename, mode=""rb"") as config_file:
                exec(compile(config_file.read(), filename, ""exec""), d.__dict__)
        except OSError as e:
            if silent and e.errno in (errno.ENOENT, errno.EISDIR, errno.ENOTDIR):
                return False
            e.strerror = f""Unable to load configuration file ({e.strerror})""
            raise
        self.from_object(d)
        return True

    def from_object(self, obj: object | str) -> None:
        """"""Updates the values from the given object.  An object can be of one
        of the following two types:

        -   a string: in this case the object with that name will be imported
        -   an actual object reference: that object is used directly

        Objects are usually either modules or classes. :meth:`from_object`
        loads only the uppercase attributes of the module/class. A ``dict``
        object will not work with :meth:`from_object` because the keys of a
        ``dict`` are not attributes of the ``dict`` class.

        Example of module-based configuration::

            app.config.from_object('yourapplication.default_config')
            from yourapplication import default_config
            app.config.from_object(default_config)

        Nothing is done to the object before loading. If the object is a
        class and has ``@property`` attributes, it needs to be
        instantiated before being passed to this method.

        You should not use this function to load the actual configuration but
        rather configuration defaults.  The actual config should be loaded
        with :meth:`from_pyfile` and ideally from a location not within the
        package because the package might be installed system wide.

        See :ref:`config-dev-prod` for an example of class-based configuration
        using :meth:`from_object`.

        :param obj: an import name or object
        """"""
        if 
...<truncated>...
",True
45c58e32dad56b9a3c8456916f5814a7cbd8c330,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\config.py,method,__init__,Config.__init__,94,100,,"    def __init__(
        self,
        root_path: str | os.PathLike[str],
        defaults: dict[str, t.Any] | None = None,
    ) -> None:
        super().__init__(defaults or {})
        self.root_path = root_path",False
728cefbe93f0b095dd4f1098e89ce35d1aba3c0c,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\config.py,method,from_envvar,Config.from_envvar,102,124,"Loads a configuration from an environment variable pointing to
a configuration file.  This is basically just a shortcut with nicer
error messages for this line of code::

    app.config.from_pyfile(os.environ['YOURAPPLICATION_SETTINGS'])

:param variable_name: name of the environment variable
:param silent: set to ``True`` if you want silent failure for missing
               files.
:return: ``True`` if the file was loaded successfully.","    def from_envvar(self, variable_name: str, silent: bool = False) -> bool:
        """"""Loads a configuration from an environment variable pointing to
        a configuration file.  This is basically just a shortcut with nicer
        error messages for this line of code::

            app.config.from_pyfile(os.environ['YOURAPPLICATION_SETTINGS'])

        :param variable_name: name of the environment variable
        :param silent: set to ``True`` if you want silent failure for missing
                       files.
        :return: ``True`` if the file was loaded successfully.
        """"""
        rv = os.environ.get(variable_name)
        if not rv:
            if silent:
                return False
            raise RuntimeError(
                f""The environment variable {variable_name!r} is not set""
                "" and as such configuration could not be loaded. Set""
                "" this variable and make it point to a configuration""
                "" file""
            )
        return self.from_pyfile(rv, silent=silent)",False
91022ebefe60b6afa8dc03e5646809a06b431cec,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\config.py,method,from_prefixed_env,Config.from_prefixed_env,126,185,"Load any environment variables that start with ``FLASK_``,
dropping the prefix from the env key for the config key. Values
are passed through a loading function to attempt to convert them
to more specific types than strings.

Keys are loaded in :func:`sorted` order.

The default loading function attempts to parse values as any
valid JSON type, including dicts and lists.

Specific items in nested dicts can be set by separating the
keys with double underscores (``__``). If an intermediate key
doesn't exist, it will be initialized to an empty dict.

:param prefix: Load env vars that start with this prefix,
    separated with an underscore (``_``).
:param loads: Pass each string value to this function and use
    the returned value as the config value. If any error is
    raised it is ignored and the value remains a string. The
    default is :func:`json.loads`.

.. versionadded:: 2.1","    def from_prefixed_env(
        self, prefix: str = ""FLASK"", *, loads: t.Callable[[str], t.Any] = json.loads
    ) -> bool:
        """"""Load any environment variables that start with ``FLASK_``,
        dropping the prefix from the env key for the config key. Values
        are passed through a loading function to attempt to convert them
        to more specific types than strings.

        Keys are loaded in :func:`sorted` order.

        The default loading function attempts to parse values as any
        valid JSON type, including dicts and lists.

        Specific items in nested dicts can be set by separating the
        keys with double underscores (``__``). If an intermediate key
        doesn't exist, it will be initialized to an empty dict.

        :param prefix: Load env vars that start with this prefix,
            separated with an underscore (``_``).
        :param loads: Pass each string value to this function and use
            the returned value as the config value. If any error is
            raised it is ignored and the value remains a string. The
            default is :func:`json.loads`.

        .. versionadded:: 2.1
        """"""
        prefix = f""{prefix}_""

        for key in sorted(os.environ):
            if not key.startswith(prefix):
                continue

            value = os.environ[key]
            key = key.removeprefix(prefix)

            try:
                value = loads(value)
            except Exception:
                # Keep the value as a string if loading failed.
                pass

            if ""__"" not in key:
                # A non-nested key, set directly.
                self[key] = value
                continue

            # Traverse nested dictionaries with keys separated by ""__"".
            current = self
            *parts, tail = key.split(""__"")

            for part in parts:
                # If an intermediate dict does not exist, create it.
                if part not in current:
                    current[part] = {}

                current = current[part]

            current[tail] = value

        return True",False
2d273ca6bad663263b3e5f3d045ea9b8ffd69c8b,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\config.py,method,from_pyfile,Config.from_pyfile,187,216,"Updates the values in the config from a Python file.  This function
behaves as if the file was imported as module with the
:meth:`from_object` function.

:param filename: the filename of the config.  This can either be an
                 absolute filename or a filename relative to the
                 root path.
:param silent: set to ``True`` if you want silent failure for missing
               files.
:return: ``True`` if the file was loaded successfully.

.. versionadded:: 0.7
   `silent` parameter.","    def from_pyfile(
        self, filename: str | os.PathLike[str], silent: bool = False
    ) -> bool:
        """"""Updates the values in the config from a Python file.  This function
        behaves as if the file was imported as module with the
        :meth:`from_object` function.

        :param filename: the filename of the config.  This can either be an
                         absolute filename or a filename relative to the
                         root path.
        :param silent: set to ``True`` if you want silent failure for missing
                       files.
        :return: ``True`` if the file was loaded successfully.

        .. versionadded:: 0.7
           `silent` parameter.
        """"""
        filename = os.path.join(self.root_path, filename)
        d = types.ModuleType(""config"")
        d.__file__ = filename
        try:
            with open(filename, mode=""rb"") as config_file:
                exec(compile(config_file.read(), filename, ""exec""), d.__dict__)
        except OSError as e:
            if silent and e.errno in (errno.ENOENT, errno.EISDIR, errno.ENOTDIR):
                return False
            e.strerror = f""Unable to load configuration file ({e.strerror})""
            raise
        self.from_object(d)
        return True",False
d13d7fc67628964b5cafc5fb6cac00e1d4cfd23e,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\config.py,method,from_object,Config.from_object,218,254,"Updates the values from the given object.  An object can be of one
of the following two types:

-   a string: in this case the object with that name will be imported
-   an actual object reference: that object is used directly

Objects are usually either modules or classes. :meth:`from_object`
loads only the uppercase attributes of the module/class. A ``dict``
object will not work with :meth:`from_object` because the keys of a
``dict`` are not attributes of the ``dict`` class.

Example of module-based configuration::

    app.config.from_object('yourapplication.default_config')
    from yourapplication import default_config
    app.config.from_object(default_config)

Nothing is done to the object before loading. If the object is a
class and has ``@property`` attributes, it needs to be
instantiated before being passed to this method.

You should not use this function to load the actual configuration but
rather configuration defaults.  The actual config should be loaded
with :meth:`from_pyfile` and ideally from a location not within the
package because the package might be installed system wide.

See :ref:`config-dev-prod` for an example of class-based configuration
using :meth:`from_object`.

:param obj: an import name or object","    def from_object(self, obj: object | str) -> None:
        """"""Updates the values from the given object.  An object can be of one
        of the following two types:

        -   a string: in this case the object with that name will be imported
        -   an actual object reference: that object is used directly

        Objects are usually either modules or classes. :meth:`from_object`
        loads only the uppercase attributes of the module/class. A ``dict``
        object will not work with :meth:`from_object` because the keys of a
        ``dict`` are not attributes of the ``dict`` class.

        Example of module-based configuration::

            app.config.from_object('yourapplication.default_config')
            from yourapplication import default_config
            app.config.from_object(default_config)

        Nothing is done to the object before loading. If the object is a
        class and has ``@property`` attributes, it needs to be
        instantiated before being passed to this method.

        You should not use this function to load the actual configuration but
        rather configuration defaults.  The actual config should be loaded
        with :meth:`from_pyfile` and ideally from a location not within the
        package because the package might be installed system wide.

        See :ref:`config-dev-prod` for an example of class-based configuration
        using :meth:`from_object`.

        :param obj: an import name or object
        """"""
        if isinstance(obj, str):
            obj = import_string(obj)
        for key in dir(obj):
            if key.isupper():
                self[key] = getattr(obj, key)",False
fe6692cbdeb28aeb5a8310c0120defd68e00212f,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\config.py,method,from_file,Config.from_file,256,302,"Update the values in the config from a file that is loaded
using the ``load`` parameter. The loaded data is passed to the
:meth:`from_mapping` method.

.. code-block:: python

    import json
    app.config.from_file(""config.json"", load=json.load)

    import tomllib
    app.config.from_file(""config.toml"", load=tomllib.load, text=False)

:param filename: The path to the data file. This can be an
    absolute path or relative to the config root path.
:param load: A callable that takes a file handle and returns a
    mapping of loaded data from the file.
:type load: ``Callable[[Reader], Mapping]`` where ``Reader``
    implements a ``read`` method.
:param silent: Ignore the file if it doesn't exist.
:param text: Open the file in text or binary mode.
:return: ``True`` if the file was loaded successfully.

.. versionchanged:: 2.3
    The ``text`` parameter was added.

.. versionadded:: 2.0","    def from_file(
        self,
        filename: str | os.PathLike[str],
        load: t.Callable[[t.IO[t.Any]], t.Mapping[str, t.Any]],
        silent: bool = False,
        text: bool = True,
    ) -> bool:
        """"""Update the values in the config from a file that is loaded
        using the ``load`` parameter. The loaded data is passed to the
        :meth:`from_mapping` method.

        .. code-block:: python

            import json
            app.config.from_file(""config.json"", load=json.load)

            import tomllib
            app.config.from_file(""config.toml"", load=tomllib.load, text=False)

        :param filename: The path to the data file. This can be an
            absolute path or relative to the config root path.
        :param load: A callable that takes a file handle and returns a
            mapping of loaded data from the file.
        :type load: ``Callable[[Reader], Mapping]`` where ``Reader``
            implements a ``read`` method.
        :param silent: Ignore the file if it doesn't exist.
        :param text: Open the file in text or binary mode.
        :return: ``True`` if the file was loaded successfully.

        .. versionchanged:: 2.3
            The ``text`` parameter was added.

        .. versionadded:: 2.0
        """"""
        filename = os.path.join(self.root_path, filename)

        try:
            with open(filename, ""r"" if text else ""rb"") as f:
                obj = load(f)
        except OSError as e:
            if silent and e.errno in (errno.ENOENT, errno.EISDIR):
                return False

            e.strerror = f""Unable to load configuration file ({e.strerror})""
            raise

        return self.from_mapping(obj)",False
59231706887068e0ff2c625781e6a1a04f67a765,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\config.py,method,from_mapping,Config.from_mapping,304,321,"Updates the config like :meth:`update` ignoring items with
non-upper keys.

:return: Always returns ``True``.

.. versionadded:: 0.11","    def from_mapping(
        self, mapping: t.Mapping[str, t.Any] | None = None, **kwargs: t.Any
    ) -> bool:
        """"""Updates the config like :meth:`update` ignoring items with
        non-upper keys.

        :return: Always returns ``True``.

        .. versionadded:: 0.11
        """"""
        mappings: dict[str, t.Any] = {}
        if mapping is not None:
            mappings.update(mapping)
        mappings.update(kwargs)
        for key, value in mappings.items():
            if key.isupper():
                self[key] = value
        return True",False
6845a86aed842c7f0f81eecdc9e734e714434544,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\config.py,method,get_namespace,Config.get_namespace,323,364,"Returns a dictionary containing a subset of configuration options
that match the specified namespace/prefix. Example usage::

    app.config['IMAGE_STORE_TYPE'] = 'fs'
    app.config['IMAGE_STORE_PATH'] = '/var/app/images'
    app.config['IMAGE_STORE_BASE_URL'] = 'http://img.website.com'
    image_store_config = app.config.get_namespace('IMAGE_STORE_')

The resulting dictionary `image_store_config` would look like::

    {
        'type': 'fs',
        'path': '/var/app/images',
        'base_url': 'http://img.website.com'
    }

This is often useful when configuration options map directly to
keyword arguments in functions or class constructors.

:param namespace: a configuration namespace
:param lowercase: a flag indicating if the keys of the resulting
                  dictionary should be lowercase
:param trim_namespace: a flag indicating if the keys of the resulting
                  dictionary should not include the namespace

.. versionadded:: 0.11","    def get_namespace(
        self, namespace: str, lowercase: bool = True, trim_namespace: bool = True
    ) -> dict[str, t.Any]:
        """"""Returns a dictionary containing a subset of configuration options
        that match the specified namespace/prefix. Example usage::

            app.config['IMAGE_STORE_TYPE'] = 'fs'
            app.config['IMAGE_STORE_PATH'] = '/var/app/images'
            app.config['IMAGE_STORE_BASE_URL'] = 'http://img.website.com'
            image_store_config = app.config.get_namespace('IMAGE_STORE_')

        The resulting dictionary `image_store_config` would look like::

            {
                'type': 'fs',
                'path': '/var/app/images',
                'base_url': 'http://img.website.com'
            }

        This is often useful when configuration options map directly to
        keyword arguments in functions or class constructors.

        :param namespace: a configuration namespace
        :param lowercase: a flag indicating if the keys of the resulting
                          dictionary should be lowercase
        :param trim_namespace: a flag indicating if the keys of the resulting
                          dictionary should not include the namespace

        .. versionadded:: 0.11
        """"""
        rv = {}
        for k, v in self.items():
            if not k.startswith(namespace):
                continue
            if trim_namespace:
                key = k[len(namespace) :]
            else:
                key = k
            if lowercase:
                key = key.lower()
            rv[key] = v
        return rv",False
962d835cf642ef367619c5fc18da454c118ee5b9,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\config.py,method,__repr__,Config.__repr__,366,367,,"    def __repr__(self) -> str:
        return f""<{type(self).__name__} {dict.__repr__(self)}>""",False
44c77d92fa17759d1979c5a05aba9800c06f8274,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,class,_AppCtxGlobals,_AppCtxGlobals,29,114,"A plain object. Used as a namespace for storing data during an
application context.

Creating an app context automatically creates this object, which is
made available as the :data:`g` proxy.

.. describe:: 'key' in g

    Check whether an attribute is present.

    .. versionadded:: 0.10

.. describe:: iter(g)

    Return an iterator over the attribute names.

    .. versionadded:: 0.10","class _AppCtxGlobals:
    """"""A plain object. Used as a namespace for storing data during an
    application context.

    Creating an app context automatically creates this object, which is
    made available as the :data:`g` proxy.

    .. describe:: 'key' in g

        Check whether an attribute is present.

        .. versionadded:: 0.10

    .. describe:: iter(g)

        Return an iterator over the attribute names.

        .. versionadded:: 0.10
    """"""

    # Define attr methods to let mypy know this is a namespace object
    # that has arbitrary attributes.

    def __getattr__(self, name: str) -> t.Any:
        try:
            return self.__dict__[name]
        except KeyError:
            raise AttributeError(name) from None

    def __setattr__(self, name: str, value: t.Any) -> None:
        self.__dict__[name] = value

    def __delattr__(self, name: str) -> None:
        try:
            del self.__dict__[name]
        except KeyError:
            raise AttributeError(name) from None

    def get(self, name: str, default: t.Any | None = None) -> t.Any:
        """"""Get an attribute by name, or a default value. Like
        :meth:`dict.get`.

        :param name: Name of attribute to get.
        :param default: Value to return if the attribute is not present.

        .. versionadded:: 0.10
        """"""
        return self.__dict__.get(name, default)

    def pop(self, name: str, default: t.Any = _sentinel) -> t.Any:
        """"""Get and remove an attribute by name. Like :meth:`dict.pop`.

        :param name: Name of attribute to pop.
        :param default: Value to return if the attribute is not present,
            instead of raising a ``KeyError``.

        .. versionadded:: 0.11
        """"""
        if default is _sentinel:
            return self.__dict__.pop(name)
        else:
            return self.__dict__.pop(name, default)

    def setdefault(self, name: str, default: t.Any = None) -> t.Any:
        """"""Get the value of an attribute if it is present, otherwise
        set and return a default value. Like :meth:`dict.setdefault`.

        :param name: Name of attribute to get.
        :param default: Value to set and return if the attribute is not
            present.

        .. versionadded:: 0.11
        """"""
        return self.__dict__.setdefault(name, default)

    def __contains__(self, item: str) -> bool:
        return item in self.__dict__

    def __iter__(self) -> t.Iterator[str]:
        return iter(self.__dict__)

    def __repr__(self) -> str:
        ctx = _cv_app.get(None)
        if ctx is not None:
            return f""<flask.g of '{ctx.app.name}'>""
        return object.__repr__(self)",False
055f8de21224313ab50d228bdb221b0a0473e0f6,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,method,__getattr__,_AppCtxGlobals.__getattr__,52,56,,"    def __getattr__(self, name: str) -> t.Any:
        try:
            return self.__dict__[name]
        except KeyError:
            raise AttributeError(name) from None",False
b9e3f9bf51cd7f30a9f34d918abfdef96eefed3d,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,method,__setattr__,_AppCtxGlobals.__setattr__,58,59,,"    def __setattr__(self, name: str, value: t.Any) -> None:
        self.__dict__[name] = value",False
b96ab3112b5996ef77fb8fa76854c4881a207a48,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,method,__delattr__,_AppCtxGlobals.__delattr__,61,65,,"    def __delattr__(self, name: str) -> None:
        try:
            del self.__dict__[name]
        except KeyError:
            raise AttributeError(name) from None",False
d0502bdf80471a824148bbb955322ee2f436254a,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,method,get,_AppCtxGlobals.get,67,76,"Get an attribute by name, or a default value. Like
:meth:`dict.get`.

:param name: Name of attribute to get.
:param default: Value to return if the attribute is not present.

.. versionadded:: 0.10","    def get(self, name: str, default: t.Any | None = None) -> t.Any:
        """"""Get an attribute by name, or a default value. Like
        :meth:`dict.get`.

        :param name: Name of attribute to get.
        :param default: Value to return if the attribute is not present.

        .. versionadded:: 0.10
        """"""
        return self.__dict__.get(name, default)",False
bc865d38274c910169a9a0889701fa36ecec009f,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,method,pop,_AppCtxGlobals.pop,78,90,"Get and remove an attribute by name. Like :meth:`dict.pop`.

:param name: Name of attribute to pop.
:param default: Value to return if the attribute is not present,
    instead of raising a ``KeyError``.

.. versionadded:: 0.11","    def pop(self, name: str, default: t.Any = _sentinel) -> t.Any:
        """"""Get and remove an attribute by name. Like :meth:`dict.pop`.

        :param name: Name of attribute to pop.
        :param default: Value to return if the attribute is not present,
            instead of raising a ``KeyError``.

        .. versionadded:: 0.11
        """"""
        if default is _sentinel:
            return self.__dict__.pop(name)
        else:
            return self.__dict__.pop(name, default)",False
753489aed7046f61c4069ac2cb143394df98a93f,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,method,setdefault,_AppCtxGlobals.setdefault,92,102,"Get the value of an attribute if it is present, otherwise
set and return a default value. Like :meth:`dict.setdefault`.

:param name: Name of attribute to get.
:param default: Value to set and return if the attribute is not
    present.

.. versionadded:: 0.11","    def setdefault(self, name: str, default: t.Any = None) -> t.Any:
        """"""Get the value of an attribute if it is present, otherwise
        set and return a default value. Like :meth:`dict.setdefault`.

        :param name: Name of attribute to get.
        :param default: Value to set and return if the attribute is not
            present.

        .. versionadded:: 0.11
        """"""
        return self.__dict__.setdefault(name, default)",False
800768b8e4e8935555af15f68de67c59054b0a5b,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,method,__contains__,_AppCtxGlobals.__contains__,104,105,,"    def __contains__(self, item: str) -> bool:
        return item in self.__dict__",False
3a9d7c7527f08c0bc83aa80432fb9d27a4bef7e5,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,method,__iter__,_AppCtxGlobals.__iter__,107,108,,"    def __iter__(self) -> t.Iterator[str]:
        return iter(self.__dict__)",False
91396da431c8966f2e39972632e8345aaa57cff9,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,method,__repr__,_AppCtxGlobals.__repr__,110,114,,"    def __repr__(self) -> str:
        ctx = _cv_app.get(None)
        if ctx is not None:
            return f""<flask.g of '{ctx.app.name}'>""
        return object.__repr__(self)",False
28eba1999f536b17761eeebf8dc2a18d2152c477,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,function,after_this_request,after_this_request,117,149,"Executes a function after this request.  This is useful to modify
response objects.  The function is passed the response object and has
to return the same or a new one.

Example::

    @app.route('/')
    def index():
        @after_this_request
        def add_header(response):
            response.headers['X-Foo'] = 'Parachute'
            return response
        return 'Hello World!'

This is more useful if a function other than the view function wants to
modify a response.  For instance think of a decorator that wants to add
some headers without converting the return value into a response object.

.. versionadded:: 0.9","def after_this_request(
    f: ft.AfterRequestCallable[t.Any],
) -> ft.AfterRequestCallable[t.Any]:
    """"""Executes a function after this request.  This is useful to modify
    response objects.  The function is passed the response object and has
    to return the same or a new one.

    Example::

        @app.route('/')
        def index():
            @after_this_request
            def add_header(response):
                response.headers['X-Foo'] = 'Parachute'
                return response
            return 'Hello World!'

    This is more useful if a function other than the view function wants to
    modify a response.  For instance think of a decorator that wants to add
    some headers without converting the return value into a response object.

    .. versionadded:: 0.9
    """"""
    ctx = _cv_request.get(None)

    if ctx is None:
        raise RuntimeError(
            ""'after_this_request' can only be used when a request""
            "" context is active, such as in a view function.""
        )

    ctx._after_request_functions.append(f)
    return f",False
32c789be2111e119757d9e206232be026a0831ee,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,function,copy_current_request_context,copy_current_request_context,155,193,"A helper function that decorates a function to retain the current
request context.  This is useful when working with greenlets.  The moment
the function is decorated a copy of the request context is created and
then pushed when the function is called.  The current session is also
included in the copied request context.

Example::

    import gevent
    from flask import copy_current_request_context

    @app.route('/')
    def index():
        @copy_current_request_context
        def do_some_work():
            # do some work here, it can access flask.request or
            # flask.session like you would otherwise in the view function.
            ...
        gevent.spawn(do_some_work)
        return 'Regular response'

.. versionadded:: 0.10","def copy_current_request_context(f: F) -> F:
    """"""A helper function that decorates a function to retain the current
    request context.  This is useful when working with greenlets.  The moment
    the function is decorated a copy of the request context is created and
    then pushed when the function is called.  The current session is also
    included in the copied request context.

    Example::

        import gevent
        from flask import copy_current_request_context

        @app.route('/')
        def index():
            @copy_current_request_context
            def do_some_work():
                # do some work here, it can access flask.request or
                # flask.session like you would otherwise in the view function.
                ...
            gevent.spawn(do_some_work)
            return 'Regular response'

    .. versionadded:: 0.10
    """"""
    ctx = _cv_request.get(None)

    if ctx is None:
        raise RuntimeError(
            ""'copy_current_request_context' can only be used when a""
            "" request context is active, such as in a view function.""
        )

    ctx = ctx.copy()

    def wrapper(*args: t.Any, **kwargs: t.Any) -> t.Any:
        with ctx:
            return ctx.app.ensure_sync(f)(*args, **kwargs)

    return update_wrapper(wrapper, f)  # type: ignore[return-value]",False
461d3d8dc61e031b0a99f06005ee29af04d5deb2,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,function,has_request_context,has_request_context,196,225,"If you have code that wants to test if a request context is there or
not this function can be used.  For instance, you may want to take advantage
of request information if the request object is available, but fail
silently if it is unavailable.

::

    class User(db.Model):

        def __init__(self, username, remote_addr=None):
            self.username = username
            if remote_addr is None and has_request_context():
                remote_addr = request.remote_addr
            self.remote_addr = remote_addr

Alternatively you can also just test any of the context bound objects
(such as :class:`request` or :class:`g`) for truthness::

    class User(db.Model):

        def __init__(self, username, remote_addr=None):
            self.username = username
            if remote_addr is None and request:
                remote_addr = request.remote_addr
            self.remote_addr = remote_addr

.. versionadded:: 0.7","def has_request_context() -> bool:
    """"""If you have code that wants to test if a request context is there or
    not this function can be used.  For instance, you may want to take advantage
    of request information if the request object is available, but fail
    silently if it is unavailable.

    ::

        class User(db.Model):

            def __init__(self, username, remote_addr=None):
                self.username = username
                if remote_addr is None and has_request_context():
                    remote_addr = request.remote_addr
                self.remote_addr = remote_addr

    Alternatively you can also just test any of the context bound objects
    (such as :class:`request` or :class:`g`) for truthness::

        class User(db.Model):

            def __init__(self, username, remote_addr=None):
                self.username = username
                if remote_addr is None and request:
                    remote_addr = request.remote_addr
                self.remote_addr = remote_addr

    .. versionadded:: 0.7
    """"""
    return _cv_request.get(None) is not None",False
e411e8a99249549914e2f9e3762c21432260bc9e,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,function,has_app_context,has_app_context,228,235,"Works like :func:`has_request_context` but for the application
context.  You can also just do a boolean check on the
:data:`current_app` object instead.

.. versionadded:: 0.9","def has_app_context() -> bool:
    """"""Works like :func:`has_request_context` but for the application
    context.  You can also just do a boolean check on the
    :data:`current_app` object instead.

    .. versionadded:: 0.9
    """"""
    return _cv_app.get(None) is not None",False
c6bd06a4228ee1a36ea4cf812254f29cd756fc90,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,class,AppContext,AppContext,238,284,"The app context contains application-specific information. An app
context is created and pushed at the beginning of each request if
one is not already active. An app context is also pushed when
running CLI commands.","class AppContext:
    """"""The app context contains application-specific information. An app
    context is created and pushed at the beginning of each request if
    one is not already active. An app context is also pushed when
    running CLI commands.
    """"""

    def __init__(self, app: Flask) -> None:
        self.app = app
        self.url_adapter = app.create_url_adapter(None)
        self.g: _AppCtxGlobals = app.app_ctx_globals_class()
        self._cv_tokens: list[contextvars.Token[AppContext]] = []

    def push(self) -> None:
        """"""Binds the app context to the current context.""""""
        self._cv_tokens.append(_cv_app.set(self))
        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """"""Pops the app context.""""""
        try:
            if len(self._cv_tokens) == 1:
                if exc is _sentinel:
                    exc = sys.exc_info()[1]
                self.app.do_teardown_appcontext(exc)
        finally:
            ctx = _cv_app.get()
            _cv_app.reset(self._cv_tokens.pop())

        if ctx is not self:
            raise AssertionError(
                f""Popped wrong app context. ({ctx!r} instead of {self!r})""
            )

        appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)

    def __enter__(self) -> AppContext:
        self.push()
        return self

    def __exit__(
        self,
        exc_type: type | None,
        exc_value: BaseException | None,
        tb: TracebackType | None,
    ) -> None:
        self.pop(exc_value)",False
a0a4a1160148982b2fd60152bde487441c02cf46,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,method,__init__,AppContext.__init__,245,249,,"    def __init__(self, app: Flask) -> None:
        self.app = app
        self.url_adapter = app.create_url_adapter(None)
        self.g: _AppCtxGlobals = app.app_ctx_globals_class()
        self._cv_tokens: list[contextvars.Token[AppContext]] = []",False
70e6e642b3c3b648282ffdf3066e1970e8755776,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,method,push,AppContext.push,251,254,Binds the app context to the current context.,"    def push(self) -> None:
        """"""Binds the app context to the current context.""""""
        self._cv_tokens.append(_cv_app.set(self))
        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)",False
2be9b318f26c1859ce76b1946fdf4ee8c1480c92,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,method,pop,AppContext.pop,256,272,Pops the app context.,"    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """"""Pops the app context.""""""
        try:
            if len(self._cv_tokens) == 1:
                if exc is _sentinel:
                    exc = sys.exc_info()[1]
                self.app.do_teardown_appcontext(exc)
        finally:
            ctx = _cv_app.get()
            _cv_app.reset(self._cv_tokens.pop())

        if ctx is not self:
            raise AssertionError(
                f""Popped wrong app context. ({ctx!r} instead of {self!r})""
            )

        appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)",False
255ba506d2f22251e05953bb11d31c6b020d7078,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,method,__enter__,AppContext.__enter__,274,276,,"    def __enter__(self) -> AppContext:
        self.push()
        return self",False
fc68e63101cef0690112c0b5b229b1b41703b66d,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,method,__exit__,AppContext.__exit__,278,284,,"    def __exit__(
        self,
        exc_type: type | None,
        exc_value: BaseException | None,
        tb: TracebackType | None,
    ) -> None:
        self.pop(exc_value)",False
715a991d5fe825b518d951270a4d8c14473662b2,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,class,RequestContext,RequestContext,287,449,"The request context contains per-request information. The Flask
app creates and pushes it at the beginning of the request, then pops
it at the end of the request. It will create the URL adapter and
request object for the WSGI environment provided.

Do not attempt to use this class directly, instead use
:meth:`~flask.Flask.test_request_context` and
:meth:`~flask.Flask.request_context` to create this object.

When the request context is popped, it will evaluate all the
functions registered on the application for teardown execution
(:meth:`~flask.Flask.teardown_request`).

The request context is automatically popped at the end of the
request. When using the interactive debugger, the context will be
restored so ``request`` is still accessible. Similarly, the test
client can preserve the context after the request ends. However,
teardown functions may already have closed some resources such as
database connections.","class RequestContext:
    """"""The request context contains per-request information. The Flask
    app creates and pushes it at the beginning of the request, then pops
    it at the end of the request. It will create the URL adapter and
    request object for the WSGI environment provided.

    Do not attempt to use this class directly, instead use
    :meth:`~flask.Flask.test_request_context` and
    :meth:`~flask.Flask.request_context` to create this object.

    When the request context is popped, it will evaluate all the
    functions registered on the application for teardown execution
    (:meth:`~flask.Flask.teardown_request`).

    The request context is automatically popped at the end of the
    request. When using the interactive debugger, the context will be
    restored so ``request`` is still accessible. Similarly, the test
    client can preserve the context after the request ends. However,
    teardown functions may already have closed some resources such as
    database connections.
    """"""

    def __init__(
        self,
        app: Flask,
        environ: WSGIEnvironment,
        request: Request | None = None,
        session: SessionMixin | None = None,
    ) -> None:
        self.app = app
        if request is None:
            request = app.request_class(environ)
            request.json_module = app.json
        self.request: Request = request
        self.url_adapter = None
        try:
            self.url_adapter = app.create_url_adapter(self.request)
        except HTTPException as e:
            self.request.routing_exception = e
        self.flashes: list[tuple[str, str]] | None = None
        self.session: SessionMixin | None = session
        # Functions that should be executed after the request on the response
        # object.  These will be called before the regular ""after_request""
        # functions.
        self._after_request_functions: list[ft.AfterRequestCallable[t.Any]] = []

        self._cv_tokens: list[
            tuple[contextvars.Token[RequestContext], AppContext | None]
        ] = []

    def copy(self) -> RequestContext:
        """"""Creates a copy of this request context with the same request object.
        This can be used to move a request context to a different greenlet.
        Because the actual request object is the same this cannot be used to
        move a request context to a different thread unless access to the
        request object is locked.

        .. versionadded:: 0.10

        .. versionchanged:: 1.1
           The current session object is used instead of reloading the original
           data. This prevents `flask.session` pointing to an out-of-date object.
        """"""
        return self.__class__(
            self.app,
            environ=self.request.environ,
            request=self.request,
            session=self.session,
        )

    def match_request(self) -> None:
        """"""Can be overridden by a subclass to hook into the matching
        of the request.
        """"""
        try:
            result = self.url_adapter.match(return_rule=True)  # type: ignore
            self.request.url_rule, self.request.view_args = result  # type: ignore
        except HTTPException as e:
            self.request.routing_exception = e

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)

        if app_ctx is None or app_ctx.app is not self.app:
            app_ctx = self.app.app_context()
            app_ctx.push()
        else:
            app_ctx = None

        self._cv_tokens.append((_cv_request.set(self), app_ctx))

        # Open the session at the moment that the request context is available.
        # This allows a custom open_session method to use the request context.
        # Only open a new session if this is the first time the request was
        # pushed, otherwise stream_with_context loses the session.
        if self.session is None:
            session_interface = self.app.session_interface
            self.session = session_interface.open_session(self.app, self.request)

            if self.session is None:
                self.session = session_interface.make_null_session(self.app)

        # Match the request URL after loading the session, so that the
        # session is available in custom URL converters.
        if self.url_adapter is not None:
            self.match_request()

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """"""Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.

        .. versionchanged:: 0.9
           Added the `exc` argument.
        """"""
        clear_request = len(self._cv_tokens) == 1

        try:
            if clear_request:
                if exc is _sentinel:
                    exc = sys.exc_info()[1]
                self.app.do_teardown_request(exc)

                request_close = getattr(self.request, ""close"", None)
                if request_close is not None:
                    request_close()
        finally:
            ctx = _cv_request.get()
            token, app_ctx = self._cv_tokens.pop()
            _cv_request.reset(token)

            # get rid of circular dependencies at the end of the request
            # so that we don't require the GC to be active.
            if clear_request:
                ctx.request.environ[""werkzeug.request""] = None

            if app_ctx is not None:
                app_ctx.pop(exc)

            if ctx is not self:
                raise AssertionError(
                    f""Popped wrong request context. ({ctx!r} instead of {self!r})""
                )

    def __enter__(self) -> RequestContext:
        self.push()
        return self

    def __exit__(
        self,
        exc_type: type | None,
        exc_value: BaseException | None,
        tb: TracebackType | None,
    ) -> None:
        self.pop(exc_value)

    def __repr__(self) -> str:
        return (
            f""<{type(self).__name__} {self.request.url!r}""
            f"" [{self.request.method}] of {self.app.name}>""
        )",False
45e39c75627746e8d351af755ae300aeba86c26a,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,method,__init__,RequestContext.__init__,309,335,,"    def __init__(
        self,
        app: Flask,
        environ: WSGIEnvironment,
        request: Request | None = None,
        session: SessionMixin | None = None,
    ) -> None:
        self.app = app
        if request is None:
            request = app.request_class(environ)
            request.json_module = app.json
        self.request: Request = request
        self.url_adapter = None
        try:
            self.url_adapter = app.create_url_adapter(self.request)
        except HTTPException as e:
            self.request.routing_exception = e
        self.flashes: list[tuple[str, str]] | None = None
        self.session: SessionMixin | None = session
        # Functions that should be executed after the request on the response
        # object.  These will be called before the regular ""after_request""
        # functions.
        self._after_request_functions: list[ft.AfterRequestCallable[t.Any]] = []

        self._cv_tokens: list[
            tuple[contextvars.Token[RequestContext], AppContext | None]
        ] = []",False
6c7ab9154194a68a478567858b23dab80de72354,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,method,copy,RequestContext.copy,337,355,"Creates a copy of this request context with the same request object.
This can be used to move a request context to a different greenlet.
Because the actual request object is the same this cannot be used to
move a request context to a different thread unless access to the
request object is locked.

.. versionadded:: 0.10

.. versionchanged:: 1.1
   The current session object is used instead of reloading the original
   data. This prevents `flask.session` pointing to an out-of-date object.","    def copy(self) -> RequestContext:
        """"""Creates a copy of this request context with the same request object.
        This can be used to move a request context to a different greenlet.
        Because the actual request object is the same this cannot be used to
        move a request context to a different thread unless access to the
        request object is locked.

        .. versionadded:: 0.10

        .. versionchanged:: 1.1
           The current session object is used instead of reloading the original
           data. This prevents `flask.session` pointing to an out-of-date object.
        """"""
        return self.__class__(
            self.app,
            environ=self.request.environ,
            request=self.request,
            session=self.session,
        )",False
ee08c03c24ec165d4d4f1db2819aa8a5b5e5ff65,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,method,match_request,RequestContext.match_request,357,365,"Can be overridden by a subclass to hook into the matching
of the request.","    def match_request(self) -> None:
        """"""Can be overridden by a subclass to hook into the matching
        of the request.
        """"""
        try:
            result = self.url_adapter.match(return_rule=True)  # type: ignore
            self.request.url_rule, self.request.view_args = result  # type: ignore
        except HTTPException as e:
            self.request.routing_exception = e",False
3dc5c5c37eb60548324f81f0dead8f138c850967,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,method,push,RequestContext.push,367,394,,"    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)

        if app_ctx is None or app_ctx.app is not self.app:
            app_ctx = self.app.app_context()
            app_ctx.push()
        else:
            app_ctx = None

        self._cv_tokens.append((_cv_request.set(self), app_ctx))

        # Open the session at the moment that the request context is available.
        # This allows a custom open_session method to use the request context.
        # Only open a new session if this is the first time the request was
        # pushed, otherwise stream_with_context loses the session.
        if self.session is None:
            session_interface = self.app.session_interface
            self.session = session_interface.open_session(self.app, self.request)

            if self.session is None:
                self.session = session_interface.make_null_session(self.app)

        # Match the request URL after loading the session, so that the
        # session is available in custom URL converters.
        if self.url_adapter is not None:
            self.match_request()",False
2a0f759a81a0bbfc63c29af13c854fdf7fadefb0,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,method,pop,RequestContext.pop,396,431,"Pops the request context and unbinds it by doing that.  This will
also trigger the execution of functions registered by the
:meth:`~flask.Flask.teardown_request` decorator.

.. versionchanged:: 0.9
   Added the `exc` argument.","    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """"""Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.

        .. versionchanged:: 0.9
           Added the `exc` argument.
        """"""
        clear_request = len(self._cv_tokens) == 1

        try:
            if clear_request:
                if exc is _sentinel:
                    exc = sys.exc_info()[1]
                self.app.do_teardown_request(exc)

                request_close = getattr(self.request, ""close"", None)
                if request_close is not None:
                    request_close()
        finally:
            ctx = _cv_request.get()
            token, app_ctx = self._cv_tokens.pop()
            _cv_request.reset(token)

            # get rid of circular dependencies at the end of the request
            # so that we don't require the GC to be active.
            if clear_request:
                ctx.request.environ[""werkzeug.request""] = None

            if app_ctx is not None:
                app_ctx.pop(exc)

            if ctx is not self:
                raise AssertionError(
                    f""Popped wrong request context. ({ctx!r} instead of {self!r})""
                )",False
4c36e67476f5471e3f6ce7f3d7785ad3bbb9a5a5,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,method,__enter__,RequestContext.__enter__,433,435,,"    def __enter__(self) -> RequestContext:
        self.push()
        return self",False
bb216e34a9b3fd806db760d1ad54c9a4680c84ad,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,method,__exit__,RequestContext.__exit__,437,443,,"    def __exit__(
        self,
        exc_type: type | None,
        exc_value: BaseException | None,
        tb: TracebackType | None,
    ) -> None:
        self.pop(exc_value)",False
db094e0b9eca5a80f0e76be1578b2eaea04c2e4f,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\ctx.py,method,__repr__,RequestContext.__repr__,445,449,,"    def __repr__(self) -> str:
        return (
            f""<{type(self).__name__} {self.request.url!r}""
            f"" [{self.request.method}] of {self.app.name}>""
        )",False
f2f4d0920b3dd2dad0ac44096cb9e07b63e2a057,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\debughelpers.py,class,UnexpectedUnicodeError,UnexpectedUnicodeError,17,20,"Raised in places where we want some better error reporting for
unexpected unicode or binary data.","class UnexpectedUnicodeError(AssertionError, UnicodeError):
    """"""Raised in places where we want some better error reporting for
    unexpected unicode or binary data.
    """"""",False
d1833c5ea2be7f4633451596716a736526ca5420,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\debughelpers.py,class,DebugFilesKeyError,DebugFilesKeyError,23,47,"Raised from request.files during debugging.  The idea is that it can
provide a better error message than just a generic KeyError/BadRequest.","class DebugFilesKeyError(KeyError, AssertionError):
    """"""Raised from request.files during debugging.  The idea is that it can
    provide a better error message than just a generic KeyError/BadRequest.
    """"""

    def __init__(self, request: Request, key: str) -> None:
        form_matches = request.form.getlist(key)
        buf = [
            f""You tried to access the file {key!r} in the request.files""
            "" dictionary but it does not exist. The mimetype for the""
            f"" request is {request.mimetype!r} instead of""
            "" 'multipart/form-data' which means that no file contents""
            "" were transmitted. To fix this error you should provide""
            ' enctype=""multipart/form-data"" in your form.'
        ]
        if form_matches:
            names = "", "".join(repr(x) for x in form_matches)
            buf.append(
                ""\n\nThe browser instead transmitted some file names. ""
                f""This was submitted: {names}""
            )
        self.msg = """".join(buf)

    def __str__(self) -> str:
        return self.msg",False
a470337596d3f8e19b100505f0e2070ed3535213,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\debughelpers.py,method,__init__,DebugFilesKeyError.__init__,28,44,,"    def __init__(self, request: Request, key: str) -> None:
        form_matches = request.form.getlist(key)
        buf = [
            f""You tried to access the file {key!r} in the request.files""
            "" dictionary but it does not exist. The mimetype for the""
            f"" request is {request.mimetype!r} instead of""
            "" 'multipart/form-data' which means that no file contents""
            "" were transmitted. To fix this error you should provide""
            ' enctype=""multipart/form-data"" in your form.'
        ]
        if form_matches:
            names = "", "".join(repr(x) for x in form_matches)
            buf.append(
                ""\n\nThe browser instead transmitted some file names. ""
                f""This was submitted: {names}""
            )
        self.msg = """".join(buf)",False
631fae917e761fc8cb642b2fbc66d5d382f8fd76,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\debughelpers.py,method,__str__,DebugFilesKeyError.__str__,46,47,,"    def __str__(self) -> str:
        return self.msg",False
2af3e32a02df90f67ae11525899e121f3d63ab5e,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\debughelpers.py,class,FormDataRoutingRedirect,FormDataRoutingRedirect,50,78,"This exception is raised in debug mode if a routing redirect
would cause the browser to drop the method or body. This happens
when method is not GET, HEAD or OPTIONS and the status code is not
307 or 308.","class FormDataRoutingRedirect(AssertionError):
    """"""This exception is raised in debug mode if a routing redirect
    would cause the browser to drop the method or body. This happens
    when method is not GET, HEAD or OPTIONS and the status code is not
    307 or 308.
    """"""

    def __init__(self, request: Request) -> None:
        exc = request.routing_exception
        assert isinstance(exc, RequestRedirect)
        buf = [
            f""A request was sent to '{request.url}', but routing issued""
            f"" a redirect to the canonical URL '{exc.new_url}'.""
        ]

        if f""{request.base_url}/"" == exc.new_url.partition(""?"")[0]:
            buf.append(
                "" The URL was defined with a trailing slash. Flask""
                "" will redirect to the URL with a trailing slash if it""
                "" was accessed without one.""
            )

        buf.append(
            "" Send requests to the canonical URL, or use 307 or 308 for""
            "" routing redirects. Otherwise, browsers will drop form""
            "" data.\n\n""
            ""This exception is only raised in debug mode.""
        )
        super().__init__("""".join(buf))",False
897ecb46f1df42a07069a2002d9f4d5a22987f95,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\debughelpers.py,method,__init__,FormDataRoutingRedirect.__init__,57,78,,"    def __init__(self, request: Request) -> None:
        exc = request.routing_exception
        assert isinstance(exc, RequestRedirect)
        buf = [
            f""A request was sent to '{request.url}', but routing issued""
            f"" a redirect to the canonical URL '{exc.new_url}'.""
        ]

        if f""{request.base_url}/"" == exc.new_url.partition(""?"")[0]:
            buf.append(
                "" The URL was defined with a trailing slash. Flask""
                "" will redirect to the URL with a trailing slash if it""
                "" was accessed without one.""
            )

        buf.append(
            "" Send requests to the canonical URL, or use 307 or 308 for""
            "" routing redirects. Otherwise, browsers will drop form""
            "" data.\n\n""
            ""This exception is only raised in debug mode.""
        )
        super().__init__("""".join(buf))",False
b99c84f71ce1274bbbf188c4f83ec653099c2d37,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\debughelpers.py,function,attach_enctype_error_multidict,attach_enctype_error_multidict,81,104,"Patch ``request.files.__getitem__`` to raise a descriptive error
about ``enctype=multipart/form-data``.

:param request: The request to patch.
:meta private:","def attach_enctype_error_multidict(request: Request) -> None:
    """"""Patch ``request.files.__getitem__`` to raise a descriptive error
    about ``enctype=multipart/form-data``.

    :param request: The request to patch.
    :meta private:
    """"""
    oldcls = request.files.__class__

    class newcls(oldcls):  # type: ignore[valid-type, misc]
        def __getitem__(self, key: str) -> t.Any:
            try:
                return super().__getitem__(key)
            except KeyError as e:
                if key not in request.form:
                    raise

                raise DebugFilesKeyError(request, key).with_traceback(
                    e.__traceback__
                ) from None

    newcls.__name__ = oldcls.__name__
    newcls.__module__ = oldcls.__module__
    request.files.__class__ = newcls",False
bf2d73a81bb186e3f7e6def0b59f70f7817462ab,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\debughelpers.py,function,_dump_loader_info,_dump_loader_info,107,121,,"def _dump_loader_info(loader: BaseLoader) -> t.Iterator[str]:
    yield f""class: {type(loader).__module__}.{type(loader).__name__}""
    for key, value in sorted(loader.__dict__.items()):
        if key.startswith(""_""):
            continue
        if isinstance(value, (tuple, list)):
            if not all(isinstance(x, str) for x in value):
                continue
            yield f""{key}:""
            for item in value:
                yield f""  - {item}""
            continue
        elif not isinstance(value, (str, int, float, bool)):
            continue
        yield f""{key}: {value!r}""",False
0ab8b2f5d7fc957fde17dcca77aa8ed74c2ad2e8,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\debughelpers.py,function,explain_template_loading_attempts,explain_template_loading_attempts,124,178,This should help developers understand what failed,"def explain_template_loading_attempts(
    app: App,
    template: str,
    attempts: list[
        tuple[
            BaseLoader,
            Scaffold,
            tuple[str, str | None, t.Callable[[], bool] | None] | None,
        ]
    ],
) -> None:
    """"""This should help developers understand what failed""""""
    info = [f""Locating template {template!r}:""]
    total_found = 0
    blueprint = None
    if request_ctx and request_ctx.request.blueprint is not None:
        blueprint = request_ctx.request.blueprint

    for idx, (loader, srcobj, triple) in enumerate(attempts):
        if isinstance(srcobj, App):
            src_info = f""application {srcobj.import_name!r}""
        elif isinstance(srcobj, Blueprint):
            src_info = f""blueprint {srcobj.name!r} ({srcobj.import_name})""
        else:
            src_info = repr(srcobj)

        info.append(f""{idx + 1:5}: trying loader of {src_info}"")

        for line in _dump_loader_info(loader):
            info.append(f""       {line}"")

        if triple is None:
            detail = ""no match""
        else:
            detail = f""found ({triple[1] or '<string>'!r})""
            total_found += 1
        info.append(f""       -> {detail}"")

    seems_fishy = False
    if total_found == 0:
        info.append(""Error: the template could not be found."")
        seems_fishy = True
    elif total_found > 1:
        info.append(""Warning: multiple loaders returned a match for the template."")
        seems_fishy = True

    if blueprint is not None and seems_fishy:
        info.append(
            ""  The template was looked up from an endpoint that belongs""
            f"" to the blueprint {blueprint!r}.""
        )
        info.append(""  Maybe you did not place a template in the right folder?"")
        info.append(""  See https://flask.palletsprojects.com/blueprints/#templates"")

    app.logger.info(""\n"".join(info))",False
63db3c63eb844efcaf3eae34b35ecc7b558cf471,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\helpers.py,function,get_debug_flag,get_debug_flag,28,33,"Get whether debug mode should be enabled for the app, indicated by the
:envvar:`FLASK_DEBUG` environment variable. The default is ``False``.","def get_debug_flag() -> bool:
    """"""Get whether debug mode should be enabled for the app, indicated by the
    :envvar:`FLASK_DEBUG` environment variable. The default is ``False``.
    """"""
    val = os.environ.get(""FLASK_DEBUG"")
    return bool(val and val.lower() not in {""0"", ""false"", ""no""})",False
bc58cf55f5ee9a3cb859b29dadd2b34d6afb3201,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\helpers.py,function,get_load_dotenv,get_load_dotenv,36,48,"Get whether the user has disabled loading default dotenv files by
setting :envvar:`FLASK_SKIP_DOTENV`. The default is ``True``, load
the files.

:param default: What to return if the env var isn't set.","def get_load_dotenv(default: bool = True) -> bool:
    """"""Get whether the user has disabled loading default dotenv files by
    setting :envvar:`FLASK_SKIP_DOTENV`. The default is ``True``, load
    the files.

    :param default: What to return if the env var isn't set.
    """"""
    val = os.environ.get(""FLASK_SKIP_DOTENV"")

    if not val:
        return default

    return val.lower() in (""0"", ""false"", ""no"")",False
ab3362ef784a2103493ebc982480d5943ff59021,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\helpers.py,function,stream_with_context,stream_with_context,52,54,,"def stream_with_context(
    generator_or_function: t.Iterator[t.AnyStr],
) -> t.Iterator[t.AnyStr]: ...",False
b899b395a8f94217728fb14982a9303d65afd033,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\helpers.py,function,stream_with_context,stream_with_context,58,60,,"def stream_with_context(
    generator_or_function: t.Callable[..., t.Iterator[t.AnyStr]],
) -> t.Callable[[t.Iterator[t.AnyStr]], t.Iterator[t.AnyStr]]: ...",False
98cf1787ccc0088c9211d12092cafa8790ca73d9,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\helpers.py,function,stream_with_context,stream_with_context,63,143,"Wrap a response generator function so that it runs inside the current
request context. This keeps :data:`request`, :data:`session`, and :data:`g`
available, even though at the point the generator runs the request context
will typically have ended.

Use it as a decorator on a generator function:

.. code-block:: python

    from flask import stream_with_context, request, Response

    @app.get(""/stream"")
    def streamed_response():
        @stream_with_context
        def generate():
            yield ""Hello ""
            yield request.args[""name""]
            yield ""!""

        return Response(generate())

Or use it as a wrapper around a created generator:

.. code-block:: python

    from flask import stream_with_context, request, Response

    @app.get(""/stream"")
    def streamed_response():
        def generate():
            yield ""Hello ""
            yield request.args[""name""]
            yield ""!""

        return Response(stream_with_context(generate()))

.. versionadded:: 0.9","def stream_with_context(
    generator_or_function: t.Iterator[t.AnyStr] | t.Callable[..., t.Iterator[t.AnyStr]],
) -> t.Iterator[t.AnyStr] | t.Callable[[t.Iterator[t.AnyStr]], t.Iterator[t.AnyStr]]:
    """"""Wrap a response generator function so that it runs inside the current
    request context. This keeps :data:`request`, :data:`session`, and :data:`g`
    available, even though at the point the generator runs the request context
    will typically have ended.

    Use it as a decorator on a generator function:

    .. code-block:: python

        from flask import stream_with_context, request, Response

        @app.get(""/stream"")
        def streamed_response():
            @stream_with_context
            def generate():
                yield ""Hello ""
                yield request.args[""name""]
                yield ""!""

            return Response(generate())

    Or use it as a wrapper around a created generator:

    .. code-block:: python

        from flask import stream_with_context, request, Response

        @app.get(""/stream"")
        def streamed_response():
            def generate():
                yield ""Hello ""
                yield request.args[""name""]
                yield ""!""

            return Response(stream_with_context(generate()))

    .. versionadded:: 0.9
    """"""
    try:
        gen = iter(generator_or_function)  # type: ignore[arg-type]
    except TypeError:

        def decorator(*args: t.Any, **kwargs: t.Any) -> t.Any:
            gen = generator_or_function(*args, **kwargs)  # type: ignore[operator]
            return stream_with_context(gen)

        return update_wrapper(decorator, generator_or_function)  # type: ignore[arg-type]

    def generator() -> t.Iterator[t.AnyStr]:
        if (req_ctx := _cv_request.get(None)) is None:
            raise RuntimeError(
                ""'stream_with_context' can only be used when a request""
                "" context is active, such as in a view function.""
            )

        app_ctx = _cv_app.get()
        # Setup code below will run the generator to this point, so that the
        # current contexts are recorded. The contexts must be pushed after,
        # otherwise their ContextVar will record the wrong event loop during
        # async view functions.
        yield None  # type: ignore[misc]

        # Push the app context first, so that the request context does not
        # automatically create and push a different app context.
        with app_ctx, req_ctx:
            try:
                yield from gen
            finally:
                # Clean up in case the user wrapped a WSGI iterator.
                if hasattr(gen, ""close""):
                    gen.close()

    # Execute the generator to the sentinel value. This ensures the context is
    # preserved in the generator's state. Further iteration will push the
    # context and yield from the original iterator.
    wrapped_g = generator()
    next(wrapped_g)
    return wrapped_g",False
2dfc5506835c0e29fedb2d69a219ff0373f24665,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\helpers.py,function,make_response,make_response,146,192,"Sometimes it is necessary to set additional headers in a view.  Because
views do not have to return response objects but can return a value that
is converted into a response object by Flask itself, it becomes tricky to
add headers to it.  This function can be called instead of using a return
and you will get a response object which you can use to attach headers.

If view looked like this and you want to add a new header::

    def index():
        return render_template('index.html', foo=42)

You can now do something like this::

    def index():
        response = make_response(render_template('index.html', foo=42))
        response.headers['X-Parachutes'] = 'parachutes are cool'
        return response

This function accepts the very same arguments you can return from a
view function.  This for example creates a response with a 404 error
code::

    response = make_response(render_template('not_found.html'), 404)

The other use case of this function is to force the return value of a
view function into a response which is helpful with view
decorators::

    response = make_response(view_function())
    response.headers['X-Parachutes'] = 'parachutes are cool'

Internally this function does the following things:

-   if no arguments are passed, it creates a new response argument
-   if one argument is passed, :meth:`flask.Flask.make_response`
    is invoked with it.
-   if more than one argument is passed, the arguments are passed
    to the :meth:`flask.Flask.make_response` function as tuple.

.. versionadded:: 0.6","def make_response(*args: t.Any) -> Response:
    """"""Sometimes it is necessary to set additional headers in a view.  Because
    views do not have to return response objects but can return a value that
    is converted into a response object by Flask itself, it becomes tricky to
    add headers to it.  This function can be called instead of using a return
    and you will get a response object which you can use to attach headers.

    If view looked like this and you want to add a new header::

        def index():
            return render_template('index.html', foo=42)

    You can now do something like this::

        def index():
            response = make_response(render_template('index.html', foo=42))
            response.headers['X-Parachutes'] = 'parachutes are cool'
            return response

    This function accepts the very same arguments you can return from a
    view function.  This for example creates a response with a 404 error
    code::

        response = make_response(render_template('not_found.html'), 404)

    The other use case of this function is to force the return value of a
    view function into a response which is helpful with view
    decorators::

        response = make_response(view_function())
        response.headers['X-Parachutes'] = 'parachutes are cool'

    Internally this function does the following things:

    -   if no arguments are passed, it creates a new response argument
    -   if one argument is passed, :meth:`flask.Flask.make_response`
        is invoked with it.
    -   if more than one argument is passed, the arguments are passed
        to the :meth:`flask.Flask.make_response` function as tuple.

    .. versionadded:: 0.6
    """"""
    if not args:
        return current_app.response_class()
    if len(args) == 1:
        args = args[0]
    return current_app.make_response(args)",False
2c28428d21c93787734ea32bd8841a8913bbac5b,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\helpers.py,function,url_for,url_for,195,246,"Generate a URL to the given endpoint with the given values.

This requires an active request or application context, and calls
:meth:`current_app.url_for() <flask.Flask.url_for>`. See that method
for full documentation.

:param endpoint: The endpoint name associated with the URL to
    generate. If this starts with a ``.``, the current blueprint
    name (if any) will be used.
:param _anchor: If given, append this as ``#anchor`` to the URL.
:param _method: If given, generate the URL associated with this
    method for the endpoint.
:param _scheme: If given, the URL will have this scheme if it is
    external.
:param _external: If given, prefer the URL to be internal (False) or
    require it to be external (True). External URLs include the
    scheme and domain. When not in an active request, URLs are
    external by default.
:param values: Values to use for the variable parts of the URL rule.
    Unknown keys are appended as query string arguments, like
    ``?a=b&c=d``.

.. versionchanged:: 2.2
    Calls ``current_app.url_for``, allowing an app to override the
    behavior.

.. versionchanged:: 0.10
   The ``_scheme`` parameter was added.

.. versionchanged:: 0.9
   The ``_anchor`` and ``_method`` parameters were added.

.. versionchanged:: 0.9
   Calls ``app.handle_url_build_error`` on build errors.","def url_for(
    endpoint: str,
    *,
    _anchor: str | None = None,
    _method: str | None = None,
    _scheme: str | None = None,
    _external: bool | None = None,
    **values: t.Any,
) -> str:
    """"""Generate a URL to the given endpoint with the given values.

    This requires an active request or application context, and calls
    :meth:`current_app.url_for() <flask.Flask.url_for>`. See that method
    for full documentation.

    :param endpoint: The endpoint name associated with the URL to
        generate. If this starts with a ``.``, the current blueprint
        name (if any) will be used.
    :param _anchor: If given, append this as ``#anchor`` to the URL.
    :param _method: If given, generate the URL associated with this
        method for the endpoint.
    :param _scheme: If given, the URL will have this scheme if it is
        external.
    :param _external: If given, prefer the URL to be internal (False) or
        require it to be external (True). External URLs include the
        scheme and domain. When not in an active request, URLs are
        external by default.
    :param values: Values to use for the variable parts of the URL rule.
        Unknown keys are appended as query string arguments, like
        ``?a=b&c=d``.

    .. versionchanged:: 2.2
        Calls ``current_app.url_for``, allowing an app to override the
        behavior.

    .. versionchanged:: 0.10
       The ``_scheme`` parameter was added.

    .. versionchanged:: 0.9
       The ``_anchor`` and ``_method`` parameters were added.

    .. versionchanged:: 0.9
       Calls ``app.handle_url_build_error`` on build errors.
    """"""
    return current_app.url_for(
        endpoint,
        _anchor=_anchor,
        _method=_method,
        _scheme=_scheme,
        _external=_external,
        **values,
    )",False
ee2bd40dbbb98ee733b8b3dbd78ae41f67566828,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\helpers.py,function,redirect,redirect,249,270,"Create a redirect response object.

If :data:`~flask.current_app` is available, it will use its
:meth:`~flask.Flask.redirect` method, otherwise it will use
:func:`werkzeug.utils.redirect`.

:param location: The URL to redirect to.
:param code: The status code for the redirect.
:param Response: The response class to use. Not used when
    ``current_app`` is active, which uses ``app.response_class``.

.. versionadded:: 2.2
    Calls ``current_app.redirect`` if available instead of always
    using Werkzeug's default ``redirect``.","def redirect(
    location: str, code: int = 302, Response: type[BaseResponse] | None = None
) -> BaseResponse:
    """"""Create a redirect response object.

    If :data:`~flask.current_app` is available, it will use its
    :meth:`~flask.Flask.redirect` method, otherwise it will use
    :func:`werkzeug.utils.redirect`.

    :param location: The URL to redirect to.
    :param code: The status code for the redirect.
    :param Response: The response class to use. Not used when
        ``current_app`` is active, which uses ``app.response_class``.

    .. versionadded:: 2.2
        Calls ``current_app.redirect`` if available instead of always
        using Werkzeug's default ``redirect``.
    """"""
    if current_app:
        return current_app.redirect(location, code=code)

    return _wz_redirect(location, code=code, Response=Response)",False
d2958f0ec1affc8291ca77843bc6023f2553841c,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\helpers.py,function,abort,abort,273,293,"Raise an :exc:`~werkzeug.exceptions.HTTPException` for the given
status code.

If :data:`~flask.current_app` is available, it will call its
:attr:`~flask.Flask.aborter` object, otherwise it will use
:func:`werkzeug.exceptions.abort`.

:param code: The status code for the exception, which must be
    registered in ``app.aborter``.
:param args: Passed to the exception.
:param kwargs: Passed to the exception.

.. versionadded:: 2.2
    Calls ``current_app.aborter`` if available instead of always
    using Werkzeug's default ``abort``.","def abort(code: int | BaseResponse, *args: t.Any, **kwargs: t.Any) -> t.NoReturn:
    """"""Raise an :exc:`~werkzeug.exceptions.HTTPException` for the given
    status code.

    If :data:`~flask.current_app` is available, it will call its
    :attr:`~flask.Flask.aborter` object, otherwise it will use
    :func:`werkzeug.exceptions.abort`.

    :param code: The status code for the exception, which must be
        registered in ``app.aborter``.
    :param args: Passed to the exception.
    :param kwargs: Passed to the exception.

    .. versionadded:: 2.2
        Calls ``current_app.aborter`` if available instead of always
        using Werkzeug's default ``abort``.
    """"""
    if current_app:
        current_app.aborter(code, *args, **kwargs)

    _wz_abort(code, *args, **kwargs)",False
6ae458164b7fb362955ce9212cd526db327c23a4,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\helpers.py,function,get_template_attribute,get_template_attribute,296,315,"Loads a macro (or variable) a template exports.  This can be used to
invoke a macro from within Python code.  If you for example have a
template named :file:`_cider.html` with the following contents:

.. sourcecode:: html+jinja

   {% macro hello(name) %}Hello {{ name }}!{% endmacro %}

You can access this from Python code like this::

    hello = get_template_attribute('_cider.html', 'hello')
    return hello('World')

.. versionadded:: 0.2

:param template_name: the name of the template
:param attribute: the name of the variable of macro to access","def get_template_attribute(template_name: str, attribute: str) -> t.Any:
    """"""Loads a macro (or variable) a template exports.  This can be used to
    invoke a macro from within Python code.  If you for example have a
    template named :file:`_cider.html` with the following contents:

    .. sourcecode:: html+jinja

       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}

    You can access this from Python code like this::

        hello = get_template_attribute('_cider.html', 'hello')
        return hello('World')

    .. versionadded:: 0.2

    :param template_name: the name of the template
    :param attribute: the name of the variable of macro to access
    """"""
    return getattr(current_app.jinja_env.get_template(template_name).module, attribute)",False
51a4404ca5f792b054cd5564fe5fc5dae14aad34,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\helpers.py,function,flash,flash,318,349,"Flashes a message to the next request.  In order to remove the
flashed message from the session and to display it to the user,
the template has to call :func:`get_flashed_messages`.

.. versionchanged:: 0.3
   `category` parameter added.

:param message: the message to be flashed.
:param category: the category for the message.  The following values
                 are recommended: ``'message'`` for any kind of message,
                 ``'error'`` for errors, ``'info'`` for information
                 messages and ``'warning'`` for warnings.  However any
                 kind of string can be used as category.","def flash(message: str, category: str = ""message"") -> None:
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    .. versionchanged:: 0.3
       `category` parameter added.

    :param message: the message to be flashed.
    :param category: the category for the message.  The following values
                     are recommended: ``'message'`` for any kind of message,
                     ``'error'`` for errors, ``'info'`` for information
                     messages and ``'warning'`` for warnings.  However any
                     kind of string can be used as category.
    """"""
    # Original implementation:
    #
    #     session.setdefault('_flashes', []).append((category, message))
    #
    # This assumed that changes made to mutable structures in the session are
    # always in sync with the session object, which is not true for session
    # implementations that use external storage for keeping their keys/values.
    flashes = session.get(""_flashes"", [])
    flashes.append((category, message))
    session[""_flashes""] = flashes
    app = current_app._get_current_object()  # type: ignore
    message_flashed.send(
        app,
        _async_wrapper=app.ensure_sync,
        message=message,
        category=category,
    )",False
1eef1c41721e6f0f016c962ab10008b6b1362921,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\helpers.py,function,get_flashed_messages,get_flashed_messages,352,391,"Pulls all flashed messages from the session and returns them.
Further calls in the same request to the function will return
the same messages.  By default just the messages are returned,
but when `with_categories` is set to ``True``, the return value will
be a list of tuples in the form ``(category, message)`` instead.

Filter the flashed messages to one or more categories by providing those
categories in `category_filter`.  This allows rendering categories in
separate html blocks.  The `with_categories` and `category_filter`
arguments are distinct:

* `with_categories` controls whether categories are returned with message
  text (``True`` gives a tuple, where ``False`` gives just the message text).
* `category_filter` filters the messages down to only those matching the
  provided categories.

See :doc:`/patterns/flashing` for examples.

.. versionchanged:: 0.3
   `with_categories` parameter added.

.. versionchanged:: 0.9
    `category_filter` parameter added.

:param with_categories: set to ``True`` to also receive categories.
:param category_filter: filter of categories to limit return values.  Only
                        categories in the list will be returned.","def get_flashed_messages(
    with_categories: bool = False, category_filter: t.Iterable[str] = ()
) -> list[str] | list[tuple[str, str]]:
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.  By default just the messages are returned,
    but when `with_categories` is set to ``True``, the return value will
    be a list of tuples in the form ``(category, message)`` instead.

    Filter the flashed messages to one or more categories by providing those
    categories in `category_filter`.  This allows rendering categories in
    separate html blocks.  The `with_categories` and `category_filter`
    arguments are distinct:

    * `with_categories` controls whether categories are returned with message
      text (``True`` gives a tuple, where ``False`` gives just the message text).
    * `category_filter` filters the messages down to only those matching the
      provided categories.

    See :doc:`/patterns/flashing` for examples.

    .. versionchanged:: 0.3
       `with_categories` parameter added.

    .. versionchanged:: 0.9
        `category_filter` parameter added.

    :param with_categories: set to ``True`` to also receive categories.
    :param category_filter: filter of categories to limit return values.  Only
                            categories in the list will be returned.
    """"""
    flashes = request_ctx.flashes
    if flashes is None:
        flashes = session.pop(""_flashes"") if ""_flashes"" in session else []
        request_ctx.flashes = flashes
    if category_filter:
        flashes = list(filter(lambda f: f[0] in category_filter, flashes))
    if not with_categories:
        return [x[1] for x in flashes]
    return flashes",False
391db30f43f1ce28de9b593975c77b09532155f3,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\helpers.py,function,_prepare_send_file_kwargs,_prepare_send_file_kwargs,394,404,,"def _prepare_send_file_kwargs(**kwargs: t.Any) -> dict[str, t.Any]:
    if kwargs.get(""max_age"") is None:
        kwargs[""max_age""] = current_app.get_send_file_max_age

    kwargs.update(
        environ=request.environ,
        use_x_sendfile=current_app.config[""USE_X_SENDFILE""],
        response_class=current_app.response_class,
        _root_path=current_app.root_path,
    )
    return kwargs",False
e4349f8c793a98e1c2a8133fd2dd5d00ea3edd7c,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\helpers.py,function,send_file,send_file,407,530,"Send the contents of a file to the client.

The first argument can be a file path or a file-like object. Paths
are preferred in most cases because Werkzeug can manage the file and
get extra information from the path. Passing a file-like object
requires that the file is opened in binary mode, and is mostly
useful when building a file in memory with :class:`io.BytesIO`.

Never pass file paths provided by a user. The path is assumed to be
trusted, so a user could craft a path to access a file you didn't
intend. Use :func:`send_from_directory` to safely serve
user-requested paths from within a directory.

If the WSGI server sets a ``file_wrapper`` in ``environ``, it is
used, otherwise Werkzeug's built-in wrapper is used. Alternatively,
if the HTTP server supports ``X-Sendfile``, configuring Flask with
``USE_X_SENDFILE = True`` will tell the server to send the given
path, which is much more efficient than reading it in Python.

:param path_or_file: The path to the file to send, relative to the
    current working directory if a relative path is given.
    Alternatively, a file-like object opened in binary mode. Make
    sure the file pointer is seeked to the start of the data.
:param mimetype: The MIME type to send for the file. If not
    provided, it will try to detect it from the file name.
:param as_attachment: Indicate to a browser that it should offer to
    save the file instead of displaying it.
:param download_name: The default name browsers will use when saving
    the file. Defaults to the passed file name.
:param conditional: Enable conditional and range responses based on
    request headers. Requires passing a file path and ``environ``.
:param etag: Calculate an ETag for the file, which requires passing
    a file path. Can also be a string to use instead.
:param last_modified: The last modified time to send for the file,
    in seconds. If not provided, it will try to detect it from the
    file path.
:param max_age: How long the client should cache the file, in
    seconds. If set, ``Cache-Control`` will be ``public``, otherwise
    it will be ``no-cache`` to prefer conditional caching.

.. versionchanged:: 2.0
    ``download_name`` replaces the ``attachment_filename``
    parameter. If ``as_attachment=False``, it is passed with
    ``Content-Disposition: inline`` instead.

.. versionchanged:: 2.0
    ``max_age`` replaces the ``cache_timeout`` parameter.
    ``conditional`` is enabled and ``max_age`` is not set by
    default.

.. versionchanged:: 2.0
    ``etag`` replaces the ``add_etags`` parameter. It can be a
    string to use instead of generating one.

.. versionchanged:: 2.0
    Passing a file-like object that inherits from
    :class:`~io.TextIOBase` will raise a :exc:`ValueError` rather
    than sending an empty file.

.. versionadded:: 2.0
    Moved the implementation to Werkzeug. This is now a wrapper to
    pass some Flask-specific arguments.

.. versionchanged:: 1.1
    ``filename`` may be a :class:`~os.PathLike` object.

.. versionchanged:: 1.1
    Passing a :class:`~io.BytesIO` object supports range requests.

.. versionchanged:: 1.0.3
    Filenames are encoded with ASCII instead of Latin-1 for broader
    compatibility with WSGI servers.

.. versionchanged:: 1.0
    UTF-8 filenames as specified in :rfc:`2231` are supported.

.. versionchanged:: 0.12
    The filename is no longer automatically inferred from file
    objects. If you want to use automatic MIME and etag support,
    pass a filename via ``filename_or_fp`` or
    ``attachment_filename``.

.. versionchanged:: 0.12
    ``attachment_filename`` is preferred over ``filename`` for MIME
    detection.

.. versionchanged:: 0.9
    ``cache_timeout`` defaults to
    :meth:`Flask.get_send_file_max_age`.

.. versionchanged:: 0.7
    MIME guessing and etag support for file-like objects was
    removed because it was unreliable. Pass a filename if you are
    able to, otherwise attach an etag yourself.

.. versionchanged:: 0.5
    The ``add_etags``, ``cache_timeout`` and ``conditional``
    parameters were added. The default behavior is to add etags.

.. versionadded:: 0.2","def send_file(
    path_or_file: os.PathLike[t.AnyStr] | str | t.IO[bytes],
    mimetype: str | None = None,
    as_attachment: bool = False,
    download_name: str | None = None,
    conditional: bool = True,
    etag: bool | str = True,
    last_modified: datetime | int | float | None = None,
    max_age: None | (int | t.Callable[[str | None], int | None]) = None,
) -> Response:
    """"""Send the contents of a file to the client.

    The first argument can be a file path or a file-like object. Paths
    are preferred in most cases because Werkzeug can manage the file and
    get extra information from the path. Passing a file-like object
    requires that the file is opened in binary mode, and is mostly
    useful when building a file in memory with :class:`io.BytesIO`.

    Never pass file paths provided by a user. The path is assumed to be
    trusted, so a user could craft a path to access a file you didn't
    intend. Use :func:`send_from_directory` to safely serve
    user-requested paths from within a directory.

    If the WSGI server sets a ``file_wrapper`` in ``environ``, it is
    used, otherwise Werkzeug's built-in wrapper is used. Alternatively,
    if the HTTP server supports ``X-Sendfile``, configuring Flask with
    ``USE_X_SENDFILE = True`` will tell the server to send the given
    path, which is much more efficient than reading it in Python.

    :param path_or_file: The path to the file to send, relative to the
        current working directory if a relative path is given.
        Alternatively, a file-like object opened in binary mode. Make
        sure the file pointer is seeked to the start of the data.
    :param mimetype: The MIME type to send for the file. If not
        provided, it will try to detect it from the file name.
    :param as_attachment: Indicate to a browser that it should offer to
        save the file instead of displaying it.
    :param download_name: The default name browsers will use when saving
        the file. Defaults to the passed file name.
    :param conditional: Enable conditional and range responses based on
        request headers. Requires passing a file path and ``environ``.
    :param etag: Calculate an ETag for the file, which requires passing
        a file path. Can also be a string to use instead.
    :param last_modified: The last modified time to send for the file,
        in seconds. If not provided, it will try to detect it from the
        file path.
    :param max_age: How long the client should cache the file, in
        seconds. If set, ``Cache-Control`` will be ``public``, otherwise
        it will be ``no-cache`` to prefer conditional caching.

    .. versionchanged:: 2.0
        ``download_name`` replaces the ``attachment_filename``
        parameter. If ``as_attachment=False``, it is passed with
        ``Content-Disposition: inline`` instead.

    .. versionchanged:: 2.0
        ``max_age`` replaces the ``cache_timeout`` parameter.
        ``conditional`` is enabled and ``max_age`` is not set by
        default.

    .. versionchanged:: 2.0
        ``etag`` replaces the ``add_etags`` parameter. It can be a
        string to use instead of generating one.

    .. versionchanged:: 2.0
        Passing a file-like object that inherits from
        :class:`~io.TextIOBase` will raise a :exc:`ValueError` rather
        than sending an empty file.

    .. versionadded:: 2.0
        Moved the implementation to Werkzeug. This is now a wrapper to
        pass some Flask-specific arguments.

    .. versionchanged:: 1.1
        ``filename`` may be a :class:`~os.PathLike` object.

    .. versionchanged:: 1.1
        Passing a :class:`~io.BytesIO` object supports range requests.

    .. versionchanged:: 1.0.3
        Filenames are encoded with ASCII instead of Latin-1 for broader
        compatibility with WSGI servers.

    .. versionchanged:: 1.0
        UTF-8 filenames as specified in :rfc:`2231` are supported.

    .. versionchanged:: 0.12
        The filename is no longer automatically inferred from file
        objects. If you want to use automatic MIME and etag support,
        pass a filename via ``filename_or_fp`` or
        ``attachment_filename``.

    .. versionchanged:: 0.12
        ``attachment_filename`` is preferred over ``filename`` for MIME
        detection.

    .. versionchanged:: 0.9
        ``cache_timeout`` defaults to
        :meth:`Flask.get_send_file_max_age`.

    .. versionchanged:: 0.7
        MIME guessing and etag support for file-like objects was
        removed because it was unreliable. Pass a filename if you are
        able to, otherwise attach an etag yourself.

    .. versionchanged:: 0.5
        The ``add_etags``, ``cache_timeout`` and ``conditional``
        parameters were added. The default behavior is to add etags.

    .. versionadded:: 0.2
    """"""
    return werkzeug.utils.send_file(  # type: ignore[return-value]
        **_prepare_send_file_kwargs(
            path_or_file=path_or_file,
            environ=request.environ,
            mimetype=mimetype,
            as_attachment=as_attachment,
            download_name=download_name,
            conditional=conditional,
            etag=etag,
            last_modified=last_modified,
            max_age=max_age,
        )
    )",False
44808507d2f2fda08e93a65dc9dd11b509ae4e6c,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\helpers.py,function,send_from_directory,send_from_directory,533,574,"Send a file from within a directory using :func:`send_file`.

.. code-block:: python

    @app.route(""/uploads/<path:name>"")
    def download_file(name):
        return send_from_directory(
            app.config['UPLOAD_FOLDER'], name, as_attachment=True
        )

This is a secure way to serve files from a folder, such as static
files or uploads. Uses :func:`~werkzeug.security.safe_join` to
ensure the path coming from the client is not maliciously crafted to
point outside the specified directory.

If the final path does not point to an existing regular file,
raises a 404 :exc:`~werkzeug.exceptions.NotFound` error.

:param directory: The directory that ``path`` must be located under,
    relative to the current application's root path. This *must not*
    be a value provided by the client, otherwise it becomes insecure.
:param path: The path to the file to send, relative to
    ``directory``.
:param kwargs: Arguments to pass to :func:`send_file`.

.. versionchanged:: 2.0
    ``path`` replaces the ``filename`` parameter.

.. versionadded:: 2.0
    Moved the implementation to Werkzeug. This is now a wrapper to
    pass some Flask-specific arguments.

.. versionadded:: 0.5","def send_from_directory(
    directory: os.PathLike[str] | str,
    path: os.PathLike[str] | str,
    **kwargs: t.Any,
) -> Response:
    """"""Send a file from within a directory using :func:`send_file`.

    .. code-block:: python

        @app.route(""/uploads/<path:name>"")
        def download_file(name):
            return send_from_directory(
                app.config['UPLOAD_FOLDER'], name, as_attachment=True
            )

    This is a secure way to serve files from a folder, such as static
    files or uploads. Uses :func:`~werkzeug.security.safe_join` to
    ensure the path coming from the client is not maliciously crafted to
    point outside the specified directory.

    If the final path does not point to an existing regular file,
    raises a 404 :exc:`~werkzeug.exceptions.NotFound` error.

    :param directory: The directory that ``path`` must be located under,
        relative to the current application's root path. This *must not*
        be a value provided by the client, otherwise it becomes insecure.
    :param path: The path to the file to send, relative to
        ``directory``.
    :param kwargs: Arguments to pass to :func:`send_file`.

    .. versionchanged:: 2.0
        ``path`` replaces the ``filename`` parameter.

    .. versionadded:: 2.0
        Moved the implementation to Werkzeug. This is now a wrapper to
        pass some Flask-specific arguments.

    .. versionadded:: 0.5
    """"""
    return werkzeug.utils.send_from_directory(  # type: ignore[return-value]
        directory, path, **_prepare_send_file_kwargs(**kwargs)
    )",False
bfb1396ef17c45b0b2ab1a1fddf79eac32e6855f,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\helpers.py,function,get_root_path,get_root_path,577,631,"Find the root path of a package, or the path that contains a
module. If it cannot be found, returns the current working
directory.

Not to be confused with the value returned by :func:`find_package`.

:meta private:","def get_root_path(import_name: str) -> str:
    """"""Find the root path of a package, or the path that contains a
    module. If it cannot be found, returns the current working
    directory.

    Not to be confused with the value returned by :func:`find_package`.

    :meta private:
    """"""
    # Module already imported and has a file attribute. Use that first.
    mod = sys.modules.get(import_name)

    if mod is not None and hasattr(mod, ""__file__"") and mod.__file__ is not None:
        return os.path.dirname(os.path.abspath(mod.__file__))

    # Next attempt: check the loader.
    try:
        spec = importlib.util.find_spec(import_name)

        if spec is None:
            raise ValueError
    except (ImportError, ValueError):
        loader = None
    else:
        loader = spec.loader

    # Loader does not exist or we're referring to an unloaded main
    # module or a main module without path (interactive sessions), go
    # with the current working directory.
    if loader is None:
        return os.getcwd()

    if hasattr(loader, ""get_filename""):
        filepath = loader.get_filename(import_name)  # pyright: ignore
    else:
        # Fall back to imports.
        __import__(import_name)
        mod = sys.modules[import_name]
        filepath = getattr(mod, ""__file__"", None)

        # If we don't have a file path it might be because it is a
        # namespace package. In this case pick the root path from the
        # first module that is contained in the package.
        if filepath is None:
            raise RuntimeError(
                ""No root path can be found for the provided module""
                f"" {import_name!r}. This can happen because the module""
                "" came from an import hook that does not provide file""
                "" name information or because it's a namespace package.""
                "" In this case the root path needs to be explicitly""
                "" provided.""
            )

    # filepath is import_name.py for a module, or __init__.py for a package.
    return os.path.dirname(os.path.abspath(filepath))  # type: ignore[no-any-return]",False
46dabc8438a65dd053f8b76a67eca426d716fc12,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\helpers.py,function,_split_blueprint_path,_split_blueprint_path,635,641,,"def _split_blueprint_path(name: str) -> list[str]:
    out: list[str] = [name]

    if ""."" in name:
        out.extend(_split_blueprint_path(name.rpartition(""."")[0]))

    return out",False
0600b3e965906602129528674a9a09175ca2b891,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\__init__.py,function,dumps,dumps,13,44,"Serialize data as JSON.

If :data:`~flask.current_app` is available, it will use its
:meth:`app.json.dumps() <flask.json.provider.JSONProvider.dumps>`
method, otherwise it will use :func:`json.dumps`.

:param obj: The data to serialize.
:param kwargs: Arguments passed to the ``dumps`` implementation.

.. versionchanged:: 2.3
    The ``app`` parameter was removed.

.. versionchanged:: 2.2
    Calls ``current_app.json.dumps``, allowing an app to override
    the behavior.

.. versionchanged:: 2.0.2
    :class:`decimal.Decimal` is supported by converting to a string.

.. versionchanged:: 2.0
    ``encoding`` will be removed in Flask 2.1.

.. versionchanged:: 1.0.3
    ``app`` can be passed directly, rather than requiring an app
    context for configuration.","def dumps(obj: t.Any, **kwargs: t.Any) -> str:
    """"""Serialize data as JSON.

    If :data:`~flask.current_app` is available, it will use its
    :meth:`app.json.dumps() <flask.json.provider.JSONProvider.dumps>`
    method, otherwise it will use :func:`json.dumps`.

    :param obj: The data to serialize.
    :param kwargs: Arguments passed to the ``dumps`` implementation.

    .. versionchanged:: 2.3
        The ``app`` parameter was removed.

    .. versionchanged:: 2.2
        Calls ``current_app.json.dumps``, allowing an app to override
        the behavior.

    .. versionchanged:: 2.0.2
        :class:`decimal.Decimal` is supported by converting to a string.

    .. versionchanged:: 2.0
        ``encoding`` will be removed in Flask 2.1.

    .. versionchanged:: 1.0.3
        ``app`` can be passed directly, rather than requiring an app
        context for configuration.
    """"""
    if current_app:
        return current_app.json.dumps(obj, **kwargs)

    kwargs.setdefault(""default"", _default)
    return _json.dumps(obj, **kwargs)",False
66c59e597bab748beac3b4958cd735edc4990b05,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\__init__.py,function,dump,dump,47,74,"Serialize data as JSON and write to a file.

If :data:`~flask.current_app` is available, it will use its
:meth:`app.json.dump() <flask.json.provider.JSONProvider.dump>`
method, otherwise it will use :func:`json.dump`.

:param obj: The data to serialize.
:param fp: A file opened for writing text. Should use the UTF-8
    encoding to be valid JSON.
:param kwargs: Arguments passed to the ``dump`` implementation.

.. versionchanged:: 2.3
    The ``app`` parameter was removed.

.. versionchanged:: 2.2
    Calls ``current_app.json.dump``, allowing an app to override
    the behavior.

.. versionchanged:: 2.0
    Writing to a binary file, and the ``encoding`` argument, will be
    removed in Flask 2.1.","def dump(obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -> None:
    """"""Serialize data as JSON and write to a file.

    If :data:`~flask.current_app` is available, it will use its
    :meth:`app.json.dump() <flask.json.provider.JSONProvider.dump>`
    method, otherwise it will use :func:`json.dump`.

    :param obj: The data to serialize.
    :param fp: A file opened for writing text. Should use the UTF-8
        encoding to be valid JSON.
    :param kwargs: Arguments passed to the ``dump`` implementation.

    .. versionchanged:: 2.3
        The ``app`` parameter was removed.

    .. versionchanged:: 2.2
        Calls ``current_app.json.dump``, allowing an app to override
        the behavior.

    .. versionchanged:: 2.0
        Writing to a binary file, and the ``encoding`` argument, will be
        removed in Flask 2.1.
    """"""
    if current_app:
        current_app.json.dump(obj, fp, **kwargs)
    else:
        kwargs.setdefault(""default"", _default)
        _json.dump(obj, fp, **kwargs)",False
f7bd374a6e54fe45ae7fbe2d58286c5cf5237148,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\__init__.py,function,loads,loads,77,105,"Deserialize data as JSON.

If :data:`~flask.current_app` is available, it will use its
:meth:`app.json.loads() <flask.json.provider.JSONProvider.loads>`
method, otherwise it will use :func:`json.loads`.

:param s: Text or UTF-8 bytes.
:param kwargs: Arguments passed to the ``loads`` implementation.

.. versionchanged:: 2.3
    The ``app`` parameter was removed.

.. versionchanged:: 2.2
    Calls ``current_app.json.loads``, allowing an app to override
    the behavior.

.. versionchanged:: 2.0
    ``encoding`` will be removed in Flask 2.1. The data must be a
    string or UTF-8 bytes.

.. versionchanged:: 1.0.3
    ``app`` can be passed directly, rather than requiring an app
    context for configuration.","def loads(s: str | bytes, **kwargs: t.Any) -> t.Any:
    """"""Deserialize data as JSON.

    If :data:`~flask.current_app` is available, it will use its
    :meth:`app.json.loads() <flask.json.provider.JSONProvider.loads>`
    method, otherwise it will use :func:`json.loads`.

    :param s: Text or UTF-8 bytes.
    :param kwargs: Arguments passed to the ``loads`` implementation.

    .. versionchanged:: 2.3
        The ``app`` parameter was removed.

    .. versionchanged:: 2.2
        Calls ``current_app.json.loads``, allowing an app to override
        the behavior.

    .. versionchanged:: 2.0
        ``encoding`` will be removed in Flask 2.1. The data must be a
        string or UTF-8 bytes.

    .. versionchanged:: 1.0.3
        ``app`` can be passed directly, rather than requiring an app
        context for configuration.
    """"""
    if current_app:
        return current_app.json.loads(s, **kwargs)

    return _json.loads(s, **kwargs)",False
0d2ebe8ad134e755aaafbd0067a2d0aa215b6ed3,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\__init__.py,function,load,load,108,135,"Deserialize data as JSON read from a file.

If :data:`~flask.current_app` is available, it will use its
:meth:`app.json.load() <flask.json.provider.JSONProvider.load>`
method, otherwise it will use :func:`json.load`.

:param fp: A file opened for reading text or UTF-8 bytes.
:param kwargs: Arguments passed to the ``load`` implementation.

.. versionchanged:: 2.3
    The ``app`` parameter was removed.

.. versionchanged:: 2.2
    Calls ``current_app.json.load``, allowing an app to override
    the behavior.

.. versionchanged:: 2.2
    The ``app`` parameter will be removed in Flask 2.3.

.. versionchanged:: 2.0
    ``encoding`` will be removed in Flask 2.1. The file must be text
    mode, or binary mode with UTF-8 bytes.","def load(fp: t.IO[t.AnyStr], **kwargs: t.Any) -> t.Any:
    """"""Deserialize data as JSON read from a file.

    If :data:`~flask.current_app` is available, it will use its
    :meth:`app.json.load() <flask.json.provider.JSONProvider.load>`
    method, otherwise it will use :func:`json.load`.

    :param fp: A file opened for reading text or UTF-8 bytes.
    :param kwargs: Arguments passed to the ``load`` implementation.

    .. versionchanged:: 2.3
        The ``app`` parameter was removed.

    .. versionchanged:: 2.2
        Calls ``current_app.json.load``, allowing an app to override
        the behavior.

    .. versionchanged:: 2.2
        The ``app`` parameter will be removed in Flask 2.3.

    .. versionchanged:: 2.0
        ``encoding`` will be removed in Flask 2.1. The file must be text
        mode, or binary mode with UTF-8 bytes.
    """"""
    if current_app:
        return current_app.json.load(fp, **kwargs)

    return _json.load(fp, **kwargs)",False
8b5c4c39a5e4b9968f072bf3cf1d2c8ec53d38cb,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\__init__.py,function,jsonify,jsonify,138,170,"Serialize the given arguments as JSON, and return a
:class:`~flask.Response` object with the ``application/json``
mimetype. A dict or list returned from a view will be converted to a
JSON response automatically without needing to call this.

This requires an active request or application context, and calls
:meth:`app.json.response() <flask.json.provider.JSONProvider.response>`.

In debug mode, the output is formatted with indentation to make it
easier to read. This may also be controlled by the provider.

Either positional or keyword arguments can be given, not both.
If no arguments are given, ``None`` is serialized.

:param args: A single value to serialize, or multiple values to
    treat as a list to serialize.
:param kwargs: Treat as a dict to serialize.

.. versionchanged:: 2.2
    Calls ``current_app.json.response``, allowing an app to override
    the behavior.

.. versionchanged:: 2.0.2
    :class:`decimal.Decimal` is supported by converting to a string.

.. versionchanged:: 0.11
    Added support for serializing top-level arrays. This was a
    security risk in ancient browsers. See :ref:`security-json`.

.. versionadded:: 0.2","def jsonify(*args: t.Any, **kwargs: t.Any) -> Response:
    """"""Serialize the given arguments as JSON, and return a
    :class:`~flask.Response` object with the ``application/json``
    mimetype. A dict or list returned from a view will be converted to a
    JSON response automatically without needing to call this.

    This requires an active request or application context, and calls
    :meth:`app.json.response() <flask.json.provider.JSONProvider.response>`.

    In debug mode, the output is formatted with indentation to make it
    easier to read. This may also be controlled by the provider.

    Either positional or keyword arguments can be given, not both.
    If no arguments are given, ``None`` is serialized.

    :param args: A single value to serialize, or multiple values to
        treat as a list to serialize.
    :param kwargs: Treat as a dict to serialize.

    .. versionchanged:: 2.2
        Calls ``current_app.json.response``, allowing an app to override
        the behavior.

    .. versionchanged:: 2.0.2
        :class:`decimal.Decimal` is supported by converting to a string.

    .. versionchanged:: 0.11
        Added support for serializing top-level arrays. This was a
        security risk in ancient browsers. See :ref:`security-json`.

    .. versionadded:: 0.2
    """"""
    return current_app.json.response(*args, **kwargs)  # type: ignore[return-value]",False
4e3038bdfbdf80915de18032addbe3441e6e5486,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\provider.py,class,JSONProvider,JSONProvider,19,105,"A standard set of JSON operations for an application. Subclasses
of this can be used to customize JSON behavior or use different
JSON libraries.

To implement a provider for a specific library, subclass this base
class and implement at least :meth:`dumps` and :meth:`loads`. All
other methods have default implementations.

To use a different provider, either subclass ``Flask`` and set
:attr:`~flask.Flask.json_provider_class` to a provider class, or set
:attr:`app.json <flask.Flask.json>` to an instance of the class.

:param app: An application instance. This will be stored as a
    :class:`weakref.proxy` on the :attr:`_app` attribute.

.. versionadded:: 2.2","class JSONProvider:
    """"""A standard set of JSON operations for an application. Subclasses
    of this can be used to customize JSON behavior or use different
    JSON libraries.

    To implement a provider for a specific library, subclass this base
    class and implement at least :meth:`dumps` and :meth:`loads`. All
    other methods have default implementations.

    To use a different provider, either subclass ``Flask`` and set
    :attr:`~flask.Flask.json_provider_class` to a provider class, or set
    :attr:`app.json <flask.Flask.json>` to an instance of the class.

    :param app: An application instance. This will be stored as a
        :class:`weakref.proxy` on the :attr:`_app` attribute.

    .. versionadded:: 2.2
    """"""

    def __init__(self, app: App) -> None:
        self._app: App = weakref.proxy(app)

    def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:
        """"""Serialize data as JSON.

        :param obj: The data to serialize.
        :param kwargs: May be passed to the underlying JSON library.
        """"""
        raise NotImplementedError

    def dump(self, obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -> None:
        """"""Serialize data as JSON and write to a file.

        :param obj: The data to serialize.
        :param fp: A file opened for writing text. Should use the UTF-8
            encoding to be valid JSON.
        :param kwargs: May be passed to the underlying JSON library.
        """"""
        fp.write(self.dumps(obj, **kwargs))

    def loads(self, s: str | bytes, **kwargs: t.Any) -> t.Any:
        """"""Deserialize data as JSON.

        :param s: Text or UTF-8 bytes.
        :param kwargs: May be passed to the underlying JSON library.
        """"""
        raise NotImplementedError

    def load(self, fp: t.IO[t.AnyStr], **kwargs: t.Any) -> t.Any:
        """"""Deserialize data as JSON read from a file.

        :param fp: A file opened for reading text or UTF-8 bytes.
        :param kwargs: May be passed to the underlying JSON library.
        """"""
        return self.loads(fp.read(), **kwargs)

    def _prepare_response_obj(
        self, args: tuple[t.Any, ...], kwargs: dict[str, t.Any]
    ) -> t.Any:
        if args and kwargs:
            raise TypeError(""app.json.response() takes either args or kwargs, not both"")

        if not args and not kwargs:
            return None

        if len(args) == 1:
            return args[0]

        return args or kwargs

    def response(self, *args: t.Any, **kwargs: t.Any) -> Response:
        """"""Serialize the given arguments as JSON, and return a
        :class:`~flask.Response` object with the ``application/json``
        mimetype.

        The :func:`~flask.json.jsonify` function calls this method for
        the current application.

        Either positional or keyword arguments can be given, not both.
        If no arguments are given, ``None`` is serialized.

        :param args: A single value to serialize, or multiple values to
            treat as a list to serialize.
        :param kwargs: Treat as a dict to serialize.
        """"""
        obj = self._prepare_response_obj(args, kwargs)
        return self._app.response_class(self.dumps(obj), mimetype=""application/json"")",False
020beee511e4b6018af29ad2980fbe8a67ee88d0,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\provider.py,method,__init__,JSONProvider.__init__,38,39,,"    def __init__(self, app: App) -> None:
        self._app: App = weakref.proxy(app)",False
0c3c47e3fe299bc59c57e943252db42ae32de81b,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\provider.py,method,dumps,JSONProvider.dumps,41,47,"Serialize data as JSON.

:param obj: The data to serialize.
:param kwargs: May be passed to the underlying JSON library.","    def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:
        """"""Serialize data as JSON.

        :param obj: The data to serialize.
        :param kwargs: May be passed to the underlying JSON library.
        """"""
        raise NotImplementedError",False
b3487f1cdd754ea4e5516e62d78eda5c4adc4cab,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\provider.py,method,dump,JSONProvider.dump,49,57,"Serialize data as JSON and write to a file.

:param obj: The data to serialize.
:param fp: A file opened for writing text. Should use the UTF-8
    encoding to be valid JSON.
:param kwargs: May be passed to the underlying JSON library.","    def dump(self, obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -> None:
        """"""Serialize data as JSON and write to a file.

        :param obj: The data to serialize.
        :param fp: A file opened for writing text. Should use the UTF-8
            encoding to be valid JSON.
        :param kwargs: May be passed to the underlying JSON library.
        """"""
        fp.write(self.dumps(obj, **kwargs))",False
4260b90255a8335971ebfc29f451620bcf665cee,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\provider.py,method,loads,JSONProvider.loads,59,65,"Deserialize data as JSON.

:param s: Text or UTF-8 bytes.
:param kwargs: May be passed to the underlying JSON library.","    def loads(self, s: str | bytes, **kwargs: t.Any) -> t.Any:
        """"""Deserialize data as JSON.

        :param s: Text or UTF-8 bytes.
        :param kwargs: May be passed to the underlying JSON library.
        """"""
        raise NotImplementedError",False
7716069a862e0112d3f885292364cc307e21c4cf,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\provider.py,method,load,JSONProvider.load,67,73,"Deserialize data as JSON read from a file.

:param fp: A file opened for reading text or UTF-8 bytes.
:param kwargs: May be passed to the underlying JSON library.","    def load(self, fp: t.IO[t.AnyStr], **kwargs: t.Any) -> t.Any:
        """"""Deserialize data as JSON read from a file.

        :param fp: A file opened for reading text or UTF-8 bytes.
        :param kwargs: May be passed to the underlying JSON library.
        """"""
        return self.loads(fp.read(), **kwargs)",False
28c74e5b50568d743fe626ba0e392063a45ba092,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\provider.py,method,_prepare_response_obj,JSONProvider._prepare_response_obj,75,87,,"    def _prepare_response_obj(
        self, args: tuple[t.Any, ...], kwargs: dict[str, t.Any]
    ) -> t.Any:
        if args and kwargs:
            raise TypeError(""app.json.response() takes either args or kwargs, not both"")

        if not args and not kwargs:
            return None

        if len(args) == 1:
            return args[0]

        return args or kwargs",False
c8ee5c7a4583259500fa04a9eac423649080e2f6,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\provider.py,method,response,JSONProvider.response,89,105,"Serialize the given arguments as JSON, and return a
:class:`~flask.Response` object with the ``application/json``
mimetype.

The :func:`~flask.json.jsonify` function calls this method for
the current application.

Either positional or keyword arguments can be given, not both.
If no arguments are given, ``None`` is serialized.

:param args: A single value to serialize, or multiple values to
    treat as a list to serialize.
:param kwargs: Treat as a dict to serialize.","    def response(self, *args: t.Any, **kwargs: t.Any) -> Response:
        """"""Serialize the given arguments as JSON, and return a
        :class:`~flask.Response` object with the ``application/json``
        mimetype.

        The :func:`~flask.json.jsonify` function calls this method for
        the current application.

        Either positional or keyword arguments can be given, not both.
        If no arguments are given, ``None`` is serialized.

        :param args: A single value to serialize, or multiple values to
            treat as a list to serialize.
        :param kwargs: Treat as a dict to serialize.
        """"""
        obj = self._prepare_response_obj(args, kwargs)
        return self._app.response_class(self.dumps(obj), mimetype=""application/json"")",False
7f81047358be109b8346293c8f48834199a90fd9,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\provider.py,function,_default,_default,108,121,,"def _default(o: t.Any) -> t.Any:
    if isinstance(o, date):
        return http_date(o)

    if isinstance(o, (decimal.Decimal, uuid.UUID)):
        return str(o)

    if dataclasses and dataclasses.is_dataclass(o):
        return dataclasses.asdict(o)  # type: ignore[arg-type]

    if hasattr(o, ""__html__""):
        return str(o.__html__())

    raise TypeError(f""Object of type {type(o).__name__} is not JSON serializable"")",False
adedca9b751b850a7c7b77bcc41f7128a774492d,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\provider.py,class,DefaultJSONProvider,DefaultJSONProvider,124,215,"Provide JSON operations using Python's built-in :mod:`json`
library. Serializes the following additional data types:

-   :class:`datetime.datetime` and :class:`datetime.date` are
    serialized to :rfc:`822` strings. This is the same as the HTTP
    date format.
-   :class:`uuid.UUID` is serialized to a string.
-   :class:`dataclasses.dataclass` is passed to
    :func:`dataclasses.asdict`.
-   :class:`~markupsafe.Markup` (or any object with a ``__html__``
    method) will call the ``__html__`` method to get a string.","class DefaultJSONProvider(JSONProvider):
    """"""Provide JSON operations using Python's built-in :mod:`json`
    library. Serializes the following additional data types:

    -   :class:`datetime.datetime` and :class:`datetime.date` are
        serialized to :rfc:`822` strings. This is the same as the HTTP
        date format.
    -   :class:`uuid.UUID` is serialized to a string.
    -   :class:`dataclasses.dataclass` is passed to
        :func:`dataclasses.asdict`.
    -   :class:`~markupsafe.Markup` (or any object with a ``__html__``
        method) will call the ``__html__`` method to get a string.
    """"""

    default: t.Callable[[t.Any], t.Any] = staticmethod(_default)  # type: ignore[assignment]
    """"""Apply this function to any object that :meth:`json.dumps` does
    not know how to serialize. It should return a valid JSON type or
    raise a ``TypeError``.
    """"""

    ensure_ascii = True
    """"""Replace non-ASCII characters with escape sequences. This may be
    more compatible with some clients, but can be disabled for better
    performance and size.
    """"""

    sort_keys = True
    """"""Sort the keys in any serialized dicts. This may be useful for
    some caching situations, but can be disabled for better performance.
    When enabled, keys must all be strings, they are not converted
    before sorting.
    """"""

    compact: bool | None = None
    """"""If ``True``, or ``None`` out of debug mode, the :meth:`response`
    output will not add indentation, newlines, or spaces. If ``False``,
    or ``None`` in debug mode, it will use a non-compact representation.
    """"""

    mimetype = ""application/json""
    """"""The mimetype set in :meth:`response`.""""""

    def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:
        """"""Serialize data as JSON to a string.

        Keyword arguments are passed to :func:`json.dumps`. Sets some
        parameter defaults from the :attr:`default`,
        :attr:`ensure_ascii`, and :attr:`sort_keys` attributes.

        :param obj: The data to serialize.
        :param kwargs: Passed to :func:`json.dumps`.
        """"""
        kwargs.setdefault(""default"", self.default)
        kwargs.setdefault(""ensure_ascii"", self.ensure_ascii)
        kwargs.setdefault(""sort_keys"", self.sort_keys)
        return json.dumps(obj, **kwargs)

    def loads(self, s: str | bytes, **kwargs: t.Any) -> t.Any:
        """"""Deserialize data as JSON from a string or bytes.

        :param s: Text or UTF-8 bytes.
        :param kwargs: Passed to :func:`json.loads`.
        """"""
        return json.loads(s, **kwargs)

    def response(self, *args: t.Any, **kwargs: t.Any) -> Response:
        """"""Serialize the given arguments as JSON, and return a
        :class:`~flask.Response` object with it. The response mimetype
        will be ""application/json"" and can be changed with
        :attr:`mimetype`.

        If :attr:`compact` is ``False`` or debug mode is enabled, the
        output will be formatted to be easier to read.

        Either positional or keyword arguments can be given, not both.
        If no arguments are given, ``None`` is serialized.

        :param args: A single value to serialize, or multiple values to
            treat as a list to serialize.
        :param kwargs: Treat as a dict to serialize.
        """"""
        obj = self._prepare_response_obj(args, kwargs)
        dump_args: dict[str, t.Any] = {}

        if (self.compact is None and self._app.debug) or self.compact is False:
            dump_args.setdefault(""indent"", 2)
        else:
            dump_args.setdefault(""separators"", ("","", "":""))

        return self._app.response_class(
            f""{self.dumps(obj, **dump_args)}\n"", mimetype=self.mimetype
        )",False
5276326adc981a01a45e693186b404f95b6db6ca,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\provider.py,method,dumps,DefaultJSONProvider.dumps,166,179,"Serialize data as JSON to a string.

Keyword arguments are passed to :func:`json.dumps`. Sets some
parameter defaults from the :attr:`default`,
:attr:`ensure_ascii`, and :attr:`sort_keys` attributes.

:param obj: The data to serialize.
:param kwargs: Passed to :func:`json.dumps`.","    def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:
        """"""Serialize data as JSON to a string.

        Keyword arguments are passed to :func:`json.dumps`. Sets some
        parameter defaults from the :attr:`default`,
        :attr:`ensure_ascii`, and :attr:`sort_keys` attributes.

        :param obj: The data to serialize.
        :param kwargs: Passed to :func:`json.dumps`.
        """"""
        kwargs.setdefault(""default"", self.default)
        kwargs.setdefault(""ensure_ascii"", self.ensure_ascii)
        kwargs.setdefault(""sort_keys"", self.sort_keys)
        return json.dumps(obj, **kwargs)",False
47dcb6a2ae9746786c023a3c07eb0203d6a39e82,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\provider.py,method,loads,DefaultJSONProvider.loads,181,187,"Deserialize data as JSON from a string or bytes.

:param s: Text or UTF-8 bytes.
:param kwargs: Passed to :func:`json.loads`.","    def loads(self, s: str | bytes, **kwargs: t.Any) -> t.Any:
        """"""Deserialize data as JSON from a string or bytes.

        :param s: Text or UTF-8 bytes.
        :param kwargs: Passed to :func:`json.loads`.
        """"""
        return json.loads(s, **kwargs)",False
33d30b56cf8b44ee87e090a41e7e85600b622a4f,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\provider.py,method,response,DefaultJSONProvider.response,189,215,"Serialize the given arguments as JSON, and return a
:class:`~flask.Response` object with it. The response mimetype
will be ""application/json"" and can be changed with
:attr:`mimetype`.

If :attr:`compact` is ``False`` or debug mode is enabled, the
output will be formatted to be easier to read.

Either positional or keyword arguments can be given, not both.
If no arguments are given, ``None`` is serialized.

:param args: A single value to serialize, or multiple values to
    treat as a list to serialize.
:param kwargs: Treat as a dict to serialize.","    def response(self, *args: t.Any, **kwargs: t.Any) -> Response:
        """"""Serialize the given arguments as JSON, and return a
        :class:`~flask.Response` object with it. The response mimetype
        will be ""application/json"" and can be changed with
        :attr:`mimetype`.

        If :attr:`compact` is ``False`` or debug mode is enabled, the
        output will be formatted to be easier to read.

        Either positional or keyword arguments can be given, not both.
        If no arguments are given, ``None`` is serialized.

        :param args: A single value to serialize, or multiple values to
            treat as a list to serialize.
        :param kwargs: Treat as a dict to serialize.
        """"""
        obj = self._prepare_response_obj(args, kwargs)
        dump_args: dict[str, t.Any] = {}

        if (self.compact is None and self._app.debug) or self.compact is False:
            dump_args.setdefault(""indent"", 2)
        else:
            dump_args.setdefault(""separators"", ("","", "":""))

        return self._app.response_class(
            f""{self.dumps(obj, **dump_args)}\n"", mimetype=self.mimetype
        )",False
39aa78514b7bb97c6196ccaa0659bc14a2d8ec80,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,class,JSONTag,JSONTag,60,90,Base class for defining type tags for :class:`TaggedJSONSerializer`.,"class JSONTag:
    """"""Base class for defining type tags for :class:`TaggedJSONSerializer`.""""""

    __slots__ = (""serializer"",)

    #: The tag to mark the serialized object with. If empty, this tag is
    #: only used as an intermediate step during tagging.
    key: str = """"

    def __init__(self, serializer: TaggedJSONSerializer) -> None:
        """"""Create a tagger for the given serializer.""""""
        self.serializer = serializer

    def check(self, value: t.Any) -> bool:
        """"""Check if the given value should be tagged by this tag.""""""
        raise NotImplementedError

    def to_json(self, value: t.Any) -> t.Any:
        """"""Convert the Python object to an object that is a valid JSON type.
        The tag will be added later.""""""
        raise NotImplementedError

    def to_python(self, value: t.Any) -> t.Any:
        """"""Convert the JSON representation back to the correct type. The tag
        will already be removed.""""""
        raise NotImplementedError

    def tag(self, value: t.Any) -> dict[str, t.Any]:
        """"""Convert the value to a valid JSON type and add the tag structure
        around it.""""""
        return {self.key: self.to_json(value)}",False
e3bdeabff11ac8e715a7ba34f00584d18b7958fb,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,__init__,JSONTag.__init__,69,71,Create a tagger for the given serializer.,"    def __init__(self, serializer: TaggedJSONSerializer) -> None:
        """"""Create a tagger for the given serializer.""""""
        self.serializer = serializer",False
aa7656a021fd333f98f1b0b49931b40768ca5da7,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,check,JSONTag.check,73,75,Check if the given value should be tagged by this tag.,"    def check(self, value: t.Any) -> bool:
        """"""Check if the given value should be tagged by this tag.""""""
        raise NotImplementedError",False
27e2c485fc7897725031b7e0debd35fb3d228f18,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,to_json,JSONTag.to_json,77,80,"Convert the Python object to an object that is a valid JSON type.
The tag will be added later.","    def to_json(self, value: t.Any) -> t.Any:
        """"""Convert the Python object to an object that is a valid JSON type.
        The tag will be added later.""""""
        raise NotImplementedError",False
26b282749bb2c8ca6a95d4b0b7de3f2224c8d3c5,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,to_python,JSONTag.to_python,82,85,"Convert the JSON representation back to the correct type. The tag
will already be removed.","    def to_python(self, value: t.Any) -> t.Any:
        """"""Convert the JSON representation back to the correct type. The tag
        will already be removed.""""""
        raise NotImplementedError",False
c38131b85f87bcb13c0749f10448a176f01df8e8,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,tag,JSONTag.tag,87,90,"Convert the value to a valid JSON type and add the tag structure
around it.","    def tag(self, value: t.Any) -> dict[str, t.Any]:
        """"""Convert the value to a valid JSON type and add the tag structure
        around it.""""""
        return {self.key: self.to_json(value)}",False
651c00cc51942a2f8d39173809041c01d0c937fa,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,class,TagDict,TagDict,93,116,"Tag for 1-item dicts whose only key matches a registered tag.

Internally, the dict key is suffixed with `__`, and the suffix is removed
when deserializing.","class TagDict(JSONTag):
    """"""Tag for 1-item dicts whose only key matches a registered tag.

    Internally, the dict key is suffixed with `__`, and the suffix is removed
    when deserializing.
    """"""

    __slots__ = ()
    key = "" di""

    def check(self, value: t.Any) -> bool:
        return (
            isinstance(value, dict)
            and len(value) == 1
            and next(iter(value)) in self.serializer.tags
        )

    def to_json(self, value: t.Any) -> t.Any:
        key = next(iter(value))
        return {f""{key}__"": self.serializer.tag(value[key])}

    def to_python(self, value: t.Any) -> t.Any:
        key = next(iter(value))
        return {key[:-2]: value[key]}",False
42cdc01e83946e81176319ec8a1fc91f58c73a76,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,check,TagDict.check,103,108,,"    def check(self, value: t.Any) -> bool:
        return (
            isinstance(value, dict)
            and len(value) == 1
            and next(iter(value)) in self.serializer.tags
        )",False
a1510b3fedd3ab5dcc8795e3c025e551d7f4faf8,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,to_json,TagDict.to_json,110,112,,"    def to_json(self, value: t.Any) -> t.Any:
        key = next(iter(value))
        return {f""{key}__"": self.serializer.tag(value[key])}",False
f52738e13ff783ba1ba5241647db8ac8c54fde41,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,to_python,TagDict.to_python,114,116,,"    def to_python(self, value: t.Any) -> t.Any:
        key = next(iter(value))
        return {key[:-2]: value[key]}",False
2858c9c6982f57ac9b6fa5231fc5d1c3b0d6ba3b,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,class,PassDict,PassDict,119,130,,"class PassDict(JSONTag):
    __slots__ = ()

    def check(self, value: t.Any) -> bool:
        return isinstance(value, dict)

    def to_json(self, value: t.Any) -> t.Any:
        # JSON objects may only have string keys, so don't bother tagging the
        # key here.
        return {k: self.serializer.tag(v) for k, v in value.items()}

    tag = to_json",False
69d0c7aa9919a5bb019bb47dfae3c52e02e449cd,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,check,PassDict.check,122,123,,"    def check(self, value: t.Any) -> bool:
        return isinstance(value, dict)",False
f804fe109d4f54991d04f252dc382664e088015a,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,to_json,PassDict.to_json,125,128,,"    def to_json(self, value: t.Any) -> t.Any:
        # JSON objects may only have string keys, so don't bother tagging the
        # key here.
        return {k: self.serializer.tag(v) for k, v in value.items()}",False
9b9156ce911a7d3b967e7c5247b234b8f4027e55,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,class,TagTuple,TagTuple,133,144,,"class TagTuple(JSONTag):
    __slots__ = ()
    key = "" t""

    def check(self, value: t.Any) -> bool:
        return isinstance(value, tuple)

    def to_json(self, value: t.Any) -> t.Any:
        return [self.serializer.tag(item) for item in value]

    def to_python(self, value: t.Any) -> t.Any:
        return tuple(value)",False
24e76ae9f2dfe9947525d8f3e33c5c1aa0e90459,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,check,TagTuple.check,137,138,,"    def check(self, value: t.Any) -> bool:
        return isinstance(value, tuple)",False
17bf47c20f455599d56558bd0fa04da7a3e6bead,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,to_json,TagTuple.to_json,140,141,,"    def to_json(self, value: t.Any) -> t.Any:
        return [self.serializer.tag(item) for item in value]",False
7bdb7990ea229b092ff8343422100580d74f98fd,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,to_python,TagTuple.to_python,143,144,,"    def to_python(self, value: t.Any) -> t.Any:
        return tuple(value)",False
4765646236a81b97bd41a6ab01e8b7c98d64e8fe,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,class,PassList,PassList,147,156,,"class PassList(JSONTag):
    __slots__ = ()

    def check(self, value: t.Any) -> bool:
        return isinstance(value, list)

    def to_json(self, value: t.Any) -> t.Any:
        return [self.serializer.tag(item) for item in value]

    tag = to_json",False
97f3150f1e2bf10e1e457b964abc05ed28c240e5,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,check,PassList.check,150,151,,"    def check(self, value: t.Any) -> bool:
        return isinstance(value, list)",False
d32f924d72f502a2816296bcc105c20f0d2fca72,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,to_json,PassList.to_json,153,154,,"    def to_json(self, value: t.Any) -> t.Any:
        return [self.serializer.tag(item) for item in value]",False
9a59f24fe6c45255e3ffa5338dbb89d3421a2706,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,class,TagBytes,TagBytes,159,170,,"class TagBytes(JSONTag):
    __slots__ = ()
    key = "" b""

    def check(self, value: t.Any) -> bool:
        return isinstance(value, bytes)

    def to_json(self, value: t.Any) -> t.Any:
        return b64encode(value).decode(""ascii"")

    def to_python(self, value: t.Any) -> t.Any:
        return b64decode(value)",False
b5bd54c304bcef935c4674f9fc8125df9564e44d,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,check,TagBytes.check,163,164,,"    def check(self, value: t.Any) -> bool:
        return isinstance(value, bytes)",False
3db3140ae49fdbf35792b23174bc3b38c1765962,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,to_json,TagBytes.to_json,166,167,,"    def to_json(self, value: t.Any) -> t.Any:
        return b64encode(value).decode(""ascii"")",False
f966e772f1c1063d0369758e65bf41d938a3a21a,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,to_python,TagBytes.to_python,169,170,,"    def to_python(self, value: t.Any) -> t.Any:
        return b64decode(value)",False
dc5ed681238ff870a9d8057d2ea5883ec720f486,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,class,TagMarkup,TagMarkup,173,188,"Serialize anything matching the :class:`~markupsafe.Markup` API by
having a ``__html__`` method to the result of that method. Always
deserializes to an instance of :class:`~markupsafe.Markup`.","class TagMarkup(JSONTag):
    """"""Serialize anything matching the :class:`~markupsafe.Markup` API by
    having a ``__html__`` method to the result of that method. Always
    deserializes to an instance of :class:`~markupsafe.Markup`.""""""

    __slots__ = ()
    key = "" m""

    def check(self, value: t.Any) -> bool:
        return callable(getattr(value, ""__html__"", None))

    def to_json(self, value: t.Any) -> t.Any:
        return str(value.__html__())

    def to_python(self, value: t.Any) -> t.Any:
        return Markup(value)",False
604165d6810387b76931c269780c2a4d1c54b00c,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,check,TagMarkup.check,181,182,,"    def check(self, value: t.Any) -> bool:
        return callable(getattr(value, ""__html__"", None))",False
650ef6b558e13943f2ac910994f5d2e40d487c1e,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,to_json,TagMarkup.to_json,184,185,,"    def to_json(self, value: t.Any) -> t.Any:
        return str(value.__html__())",False
6c50c7d69dad20d6f8686746178a8cbea2ec8131,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,to_python,TagMarkup.to_python,187,188,,"    def to_python(self, value: t.Any) -> t.Any:
        return Markup(value)",False
a9870459b8d740cca3e5d34ea6e39fc771fa7b70,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,class,TagUUID,TagUUID,191,202,,"class TagUUID(JSONTag):
    __slots__ = ()
    key = "" u""

    def check(self, value: t.Any) -> bool:
        return isinstance(value, UUID)

    def to_json(self, value: t.Any) -> t.Any:
        return value.hex

    def to_python(self, value: t.Any) -> t.Any:
        return UUID(value)",False
c703e6ee18211830180b82dd16d7a47cf6364fc6,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,check,TagUUID.check,195,196,,"    def check(self, value: t.Any) -> bool:
        return isinstance(value, UUID)",False
7020241fd04ebc79052a10583727ee191056cca4,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,to_json,TagUUID.to_json,198,199,,"    def to_json(self, value: t.Any) -> t.Any:
        return value.hex",False
962c19aec34ea71beefbd977ac1471bbfe7fbb92,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,to_python,TagUUID.to_python,201,202,,"    def to_python(self, value: t.Any) -> t.Any:
        return UUID(value)",False
a1abd2fa96f9393524ddb82962681baf6e64dbd7,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,class,TagDateTime,TagDateTime,205,216,,"class TagDateTime(JSONTag):
    __slots__ = ()
    key = "" d""

    def check(self, value: t.Any) -> bool:
        return isinstance(value, datetime)

    def to_json(self, value: t.Any) -> t.Any:
        return http_date(value)

    def to_python(self, value: t.Any) -> t.Any:
        return parse_date(value)",False
ba0c5cd18e7dfa8f3ed312e0e7642aed458358c4,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,check,TagDateTime.check,209,210,,"    def check(self, value: t.Any) -> bool:
        return isinstance(value, datetime)",False
c01ce58a6d690e4a112311c499fa316d6b51d82c,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,to_json,TagDateTime.to_json,212,213,,"    def to_json(self, value: t.Any) -> t.Any:
        return http_date(value)",False
7c2fc990c8e6114bc76ffcc4e3a1cf324037b2ac,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,to_python,TagDateTime.to_python,215,216,,"    def to_python(self, value: t.Any) -> t.Any:
        return parse_date(value)",False
e6a6996e1d7194df02736cc44964c35e8186cb50,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,class,TaggedJSONSerializer,TaggedJSONSerializer,219,327,"Serializer that uses a tag system to compactly represent objects that
are not JSON types. Passed as the intermediate serializer to
:class:`itsdangerous.Serializer`.

The following extra types are supported:

* :class:`dict`
* :class:`tuple`
* :class:`bytes`
* :class:`~markupsafe.Markup`
* :class:`~uuid.UUID`
* :class:`~datetime.datetime`","class TaggedJSONSerializer:
    """"""Serializer that uses a tag system to compactly represent objects that
    are not JSON types. Passed as the intermediate serializer to
    :class:`itsdangerous.Serializer`.

    The following extra types are supported:

    * :class:`dict`
    * :class:`tuple`
    * :class:`bytes`
    * :class:`~markupsafe.Markup`
    * :class:`~uuid.UUID`
    * :class:`~datetime.datetime`
    """"""

    __slots__ = (""tags"", ""order"")

    #: Tag classes to bind when creating the serializer. Other tags can be
    #: added later using :meth:`~register`.
    default_tags = [
        TagDict,
        PassDict,
        TagTuple,
        PassList,
        TagBytes,
        TagMarkup,
        TagUUID,
        TagDateTime,
    ]

    def __init__(self) -> None:
        self.tags: dict[str, JSONTag] = {}
        self.order: list[JSONTag] = []

        for cls in self.default_tags:
            self.register(cls)

    def register(
        self,
        tag_class: type[JSONTag],
        force: bool = False,
        index: int | None = None,
    ) -> None:
        """"""Register a new tag with this serializer.

        :param tag_class: tag class to register. Will be instantiated with this
            serializer instance.
        :param force: overwrite an existing tag. If false (default), a
            :exc:`KeyError` is raised.
        :param index: index to insert the new tag in the tag order. Useful when
            the new tag is a special case of an existing tag. If ``None``
            (default), the tag is appended to the end of the order.

        :raise KeyError: if the tag key is already registered and ``force`` is
            not true.
        """"""
        tag = tag_class(self)
        key = tag.key

        if key:
            if not force and key in self.tags:
                raise KeyError(f""Tag '{key}' is already registered."")

            self.tags[key] = tag

        if index is None:
            self.order.append(tag)
        else:
            self.order.insert(index, tag)

    def tag(self, value: t.Any) -> t.Any:
        """"""Convert a value to a tagged representation if necessary.""""""
        for tag in self.order:
            if tag.check(value):
                return tag.tag(value)

        return value

    def untag(self, value: dict[str, t.Any]) -> t.Any:
        """"""Convert a tagged representation back to the original type.""""""
        if len(value) != 1:
            return value

        key = next(iter(value))

        if key not in self.tags:
            return value

        return self.tags[key].to_python(value[key])

    def _untag_scan(self, value: t.Any) -> t.Any:
        if isinstance(value, dict):
            # untag each item recursively
            value = {k: self._untag_scan(v) for k, v in value.items()}
            # untag the dict itself
            value = self.untag(value)
        elif isinstance(value, list):
            # untag each item recursively
            value = [self._untag_scan(item) for item in value]

        return value

    def dumps(self, value: t.Any) -> str:
        """"""Tag the value and dump it to a compact JSON string.""""""
        return dumps(self.tag(value), separators=("","", "":""))

    def loads(self, value: str) -> t.Any:
        """"""Load data from a JSON string and deserialized any tagged objects.""""""
        return self._untag_scan(loads(value))",False
7cf3819997f611c2463a993a5dcd0329559d745b,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,__init__,TaggedJSONSerializer.__init__,249,254,,"    def __init__(self) -> None:
        self.tags: dict[str, JSONTag] = {}
        self.order: list[JSONTag] = []

        for cls in self.default_tags:
            self.register(cls)",False
238fbf16bcf481cb3e1137b0f215f7c16b2aaca7,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,register,TaggedJSONSerializer.register,256,287,"Register a new tag with this serializer.

:param tag_class: tag class to register. Will be instantiated with this
    serializer instance.
:param force: overwrite an existing tag. If false (default), a
    :exc:`KeyError` is raised.
:param index: index to insert the new tag in the tag order. Useful when
    the new tag is a special case of an existing tag. If ``None``
    (default), the tag is appended to the end of the order.

:raise KeyError: if the tag key is already registered and ``force`` is
    not true.","    def register(
        self,
        tag_class: type[JSONTag],
        force: bool = False,
        index: int | None = None,
    ) -> None:
        """"""Register a new tag with this serializer.

        :param tag_class: tag class to register. Will be instantiated with this
            serializer instance.
        :param force: overwrite an existing tag. If false (default), a
            :exc:`KeyError` is raised.
        :param index: index to insert the new tag in the tag order. Useful when
            the new tag is a special case of an existing tag. If ``None``
            (default), the tag is appended to the end of the order.

        :raise KeyError: if the tag key is already registered and ``force`` is
            not true.
        """"""
        tag = tag_class(self)
        key = tag.key

        if key:
            if not force and key in self.tags:
                raise KeyError(f""Tag '{key}' is already registered."")

            self.tags[key] = tag

        if index is None:
            self.order.append(tag)
        else:
            self.order.insert(index, tag)",False
05bded5a01091ed588cecbb5b0fa42c6ffd4ddc3,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,tag,TaggedJSONSerializer.tag,289,295,Convert a value to a tagged representation if necessary.,"    def tag(self, value: t.Any) -> t.Any:
        """"""Convert a value to a tagged representation if necessary.""""""
        for tag in self.order:
            if tag.check(value):
                return tag.tag(value)

        return value",False
c18f03066812fc49f6d08a75dbf782594079d838,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,untag,TaggedJSONSerializer.untag,297,307,Convert a tagged representation back to the original type.,"    def untag(self, value: dict[str, t.Any]) -> t.Any:
        """"""Convert a tagged representation back to the original type.""""""
        if len(value) != 1:
            return value

        key = next(iter(value))

        if key not in self.tags:
            return value

        return self.tags[key].to_python(value[key])",False
22a56a347b328ef1ac040ed0bcfaf299dd2904a6,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,_untag_scan,TaggedJSONSerializer._untag_scan,309,319,,"    def _untag_scan(self, value: t.Any) -> t.Any:
        if isinstance(value, dict):
            # untag each item recursively
            value = {k: self._untag_scan(v) for k, v in value.items()}
            # untag the dict itself
            value = self.untag(value)
        elif isinstance(value, list):
            # untag each item recursively
            value = [self._untag_scan(item) for item in value]

        return value",False
0ba2eba887c6dc8461e6e61f26cfd9daffec65e0,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,dumps,TaggedJSONSerializer.dumps,321,323,Tag the value and dump it to a compact JSON string.,"    def dumps(self, value: t.Any) -> str:
        """"""Tag the value and dump it to a compact JSON string.""""""
        return dumps(self.tag(value), separators=("","", "":""))",False
fd61640340d5ca8e0f39df2f4563ca9208f3a4b1,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\json\tag.py,method,loads,TaggedJSONSerializer.loads,325,327,Load data from a JSON string and deserialized any tagged objects.,"    def loads(self, value: str) -> t.Any:
        """"""Load data from a JSON string and deserialized any tagged objects.""""""
        return self._untag_scan(loads(value))",False
9717f361919c4a1fb5541813ab9a2d68630bb15e,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\logging.py,function,wsgi_errors_stream,wsgi_errors_stream,16,28,"Find the most appropriate error stream for the application. If a request
is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.

If you configure your own :class:`logging.StreamHandler`, you may want to
use this for the stream. If you are using file or dict configuration and
can't import this directly, you can refer to it as
``ext://flask.logging.wsgi_errors_stream``.","def wsgi_errors_stream() -> t.TextIO:
    """"""Find the most appropriate error stream for the application. If a request
    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.

    If you configure your own :class:`logging.StreamHandler`, you may want to
    use this for the stream. If you are using file or dict configuration and
    can't import this directly, you can refer to it as
    ``ext://flask.logging.wsgi_errors_stream``.
    """"""
    if request:
        return request.environ[""wsgi.errors""]  # type: ignore[no-any-return]

    return sys.stderr",False
58ae1fdcdb7e63ceec0c2528190432d1a7816009,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\logging.py,function,has_level_handler,has_level_handler,31,47,"Check if there is a handler in the logging chain that will handle the
given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.","def has_level_handler(logger: logging.Logger) -> bool:
    """"""Check if there is a handler in the logging chain that will handle the
    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.
    """"""
    level = logger.getEffectiveLevel()
    current = logger

    while current:
        if any(handler.level <= level for handler in current.handlers):
            return True

        if not current.propagate:
            break

        current = current.parent  # type: ignore

    return False",False
6e023e4429a8ec6db84f2c69d5775ec9364a3423,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\logging.py,function,create_logger,create_logger,58,79,"Get the Flask app's logger and configure it if needed.

The logger name will be the same as
:attr:`app.import_name <flask.Flask.name>`.

When :attr:`~flask.Flask.debug` is enabled, set the logger level to
:data:`logging.DEBUG` if it is not set.

If there is no handler for the logger's effective level, add a
:class:`~logging.StreamHandler` for
:func:`~flask.logging.wsgi_errors_stream` with a basic format.","def create_logger(app: App) -> logging.Logger:
    """"""Get the Flask app's logger and configure it if needed.

    The logger name will be the same as
    :attr:`app.import_name <flask.Flask.name>`.

    When :attr:`~flask.Flask.debug` is enabled, set the logger level to
    :data:`logging.DEBUG` if it is not set.

    If there is no handler for the logger's effective level, add a
    :class:`~logging.StreamHandler` for
    :func:`~flask.logging.wsgi_errors_stream` with a basic format.
    """"""
    logger = logging.getLogger(app.name)

    if app.debug and not logger.level:
        logger.setLevel(logging.DEBUG)

    if not has_level_handler(logger):
        logger.addHandler(default_handler)

    return logger",False
c5b32106abedce51d9142451a22a87b3c6fdee2d,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,function,_make_timedelta,_make_timedelta,52,56,,"def _make_timedelta(value: timedelta | int | None) -> timedelta | None:
    if value is None or isinstance(value, timedelta):
        return value

    return timedelta(seconds=value)",False
d8e1e548b0d74489e38636dd026adf46eb04032a,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,class,App,App,59,964,"The flask object implements a WSGI application and acts as the central
object.  It is passed the name of the module or package of the
application.  Once it is created it will act as a central registry for
the view functions, the URL rules, template configuration and much more.

The name of the package is used to resolve resources from inside the
package or the folder the module is contained in depending on if the
package parameter resolves to an actual python package (a folder with
an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).

For more information about resource loading, see :func:`open_resource`.

Usually you create a :class:`Flask` instance in your main module or
in the :file:`__init__.py` file of your package like this::

    from flask import Flask
    app = Flask(__name__)

.. admonition:: About the First Parameter

    The idea of the first parameter is to give Flask an idea of what
    belongs to your application.  This name is used to find resources
    on the filesystem, can be used by extensions to improve debugging
    information and a lot more.

    So it's important what you provide there.  If you are using a single
    module, `__name__` is always the correct value.  If you however are
    using a package, it's usually recommended to hardcode the name of
    your package there.

    For example if your application is defined in :file:`yourapplication/app.py`
    you should create it with one of the two versions below::

        app = Flask('yourapplication')
        app = Flask(__name__.split('.')[0])

    Why is that?  The application will work even with `__name__`, thanks
    to how resources are looked up.  However it will make debugging more
    painful.  Certain extensions can make assumptions based on the
    import name of your application.  For example the Flask-SQLAlchemy
    extension will look for the code in your application that triggered
    an SQL query in debug mode.  If the import name is not properly set
    up, that debugging information is lost.  (For example it would only
    pick up SQL queries in `yourapplication.app` and not
    `yourapplication.views.frontend`)

.. versionadded:: 0.7
   The `static_url_path`, `static_folder`, and `template_folder`
   parameters were added.

.. versionadded:: 0.8
   The `instance_path` and `instance_relative_config` parameters were
   added.

.. versionadded:: 0.11
   The `root_path` parameter was added.

.. versionadded:: 1.0
   The ``host_matching`` and ``static_host`` parameters were added.

.. versionadded:: 1.0
   The ``subdomain_matching`` parameter was added. Subdomain
   matching needs to be enabled manually now. Setting
   :data:`SERVER_NAME` does not implicitly enable it.

:param import_name: the name of the application package
:param static_url_path: can be used to specify a different path for the
                        static files on the web.  Defaults to the name
                        of the `static_folder` folder.
:param static_folder: The folder with static files that is served at
    ``static_url_path``. Relative to the application ``root_path``
    or an absolute path. Defaults to ``'static'``.
:param static_host: the host to use when adding the static route.
    Defaults to None. Required when using ``host_matching=True``
    with a ``static_folder`` configured.
:param host_matching: set ``url_map.host_matching`` attribute.
    Defaults to False.
:param subdomain_matching: consider the subdomain relative to
    :data:`SERVER_NAME` when matching routes. Defaults to False.
:param template_folder: the folder that contains the templates that should
                        be used by the application.  Defaults to
                        ``'templates'`` folder in the root path of the
                        application.
:param instance_path: An alternative instance path for the application.
                      By default the folder ``'instance'`` next to the
                      package or module is assumed to be the instance
                      path.
:param instance_relative_config: if set to ``True`` relative filenames
                                 for loading the config are assumed to
                                 be relative to the instance path instead
                                 of the application root.
:param root_path: The path to the root of the application files.
    This should only be set manually when it can't be detected
    automatically, such as for namespace packages.","class App(Scaffold):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the :file:`__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)

    .. admonition:: About the First Parameter

        The idea of the first parameter is to give Flask an idea of what
        belongs to your application.  This name is used to find resources
        on the filesystem, can be used by extensions to improve debugging
        information and a lot more.

        So it's important what you provide there.  If you are using a single
        module, `__name__` is always the correct value.  If you however are
        using a package, it's usually recommended to hardcode the name of
        your package there.

        For example if your application is defined in :file:`yourapplication/app.py`
        you should create it with one of the two versions below::

            app = Flask('yourapplication')
            app = Flask(__name__.split('.')[0])

        Why is that?  The application will work even with `__name__`, thanks
        to how resources are looked up.  However it will make debugging more
        painful.  Certain extensions can make assumptions based on the
        import name of your application.  For example the Flask-SQLAlchemy
        extension will look for the code in your application that triggered
        an SQL query in debug mode.  If the import name is not properly set
        up, that debugging information is lost.  (For example it would only
        pick up SQL queries in `yourapplication.app` and not
        `yourapplication.views.frontend`)

    .. versionadded:: 0.7
       The `static_url_path`, `static_folder`, and `template_folder`
       parameters were added.

    .. versionadded:: 0.8
       The `instance_path` and `instance_relative_config` parameters were
       added.

    .. versionadded:: 0.11
       The `root_path` parameter was added.

    .. versionadded:: 1.0
       The ``host_matching`` and ``static_host`` parameters were added.

    .. versionadded:: 1.0
       The ``subdomain_matching`` parameter was added. Subdomain
       matching needs to be enabled manually now. Setting
       :data:`SERVER_NAME` does not implicitly enable it.

    :param import_name: the name of the application package
    :param static_url_path: can be used to specify a different path for the
                            static files on the web.  Defaults to the name
                            of the `static_folder` folder.
    :param static_folder: The folder with static files that is served at
        ``static_url_path``. Relative to the application ``root_path``
        or an absolute path. Defaults to ``'static'``.
    :param static_host: the host to use when adding the static route.
        Defaults to None. Required when using ``host_matching=True``
        with a ``static_folder`` configured.
    :param host_matching: set ``url_map.host_matching`` attribute.
        Defaults to False.
    :param subdomain_matching: consider the subdomain relative to
        :data:`SERVER_NAME` when matching routes. Defaults to False.
    :param template_folder: the folder that contains the templates that should
                            be used by the application.  Defaults to
                            ``'templates'`` folder in the root path of the
                            application.
    :param instance_path: An alternative instance path for the application.
                          By default the folder ``'instance'`` next to the
                          package or module is assumed to be the instance
                          path.
    :param instance_relative_config: if set to ``True`` relative filenames
                                     for loading the config are assumed to
                                     be relative to the instance path instead
                                     of the application root.
    :param root_path: The path to the root of the application files.
        This should only be set manually when it can't be detected
        automatically, such as for namespace packages.
    """"""

    #: The class of the object assigned to :attr:`aborter`, created by
    #: :meth:`create_aborter`. That object is called by
    #: :func:`flask.abort` to raise HTTP errors, and can be
    #: called directly as well.
    #:
    #: Defaults to :class:`werkzeug.exceptions.Aborter`.
    #:
    #: .. versionadded:: 2.2
    aborter_class = Aborter

    #: The class that is used for the Jinja environment.
    #:
    #: .. versionadded:: 0.11
    jinja_environment = Environment

    #: The class that is used for the :data:`~flask.g` instance.
    #:
    #: Example use cases for a custom class:
    #:
    #: 1. Store arbitrary attributes on flask.g.
    #: 2. Add a property for lazy per-request database connectors.
    #: 3. Return None instead of AttributeError on unexpected attributes.
    #: 4. Raise exception if an unexpected attr is set, a ""controlled"" flask.g.
    #:
    #: In Flask 0.9 this property was called `request_globals_class` but it
    #: was changed in 0.10 to :attr:`app_ctx_globals_class` because the
    #: flask.g object is now application context scoped.
    #:
    #: .. versionadded:: 0.10
    app_ctx_globals_class = _AppCtxGlobals

    #: The class that is used for the ``config`` attribute of this app.
    #: Defaults to :class:`~flask.Config`.
    #:
    #: Example use cases for a custom class:
    #:
    #: 1. Default values for certain config options.
    #: 2. Access to config values through attributes in addition to keys.
    #:
    #: .. versionadded:: 0.11
    config_class = Config

    #: The testing flag.  Set this to ``True`` to enable the test mode of
    #: Flask extensions (and in the future probably also Flask itself).
    #: For example this might activate test helpers that have an
    #: additional runtime cost which should not be enabled by default.
    #:
    #: If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the
    #: default it's implicitly enabled.
    #:
    #: This attribute can also be configured from the config with the
    #: ``TESTING`` configuration key.  Defaults to ``False``.
    testing = ConfigAttribute[bool](""TESTING"")

    #: If a secret key is set, cryptographic components can use this to
    #: sign cookies and other things. Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    #:
    #: This attribute can also be configured from the config with the
    #: :data:`SECRET_KEY` configuration key. Defaults to ``None``.
    secret_key = ConfigAttribute[t.Union[str, bytes, None]](""SECRET_KEY"")

    #: A :class:`~datetime.timedelta` which is used to set the expiration
    #: date of a permanent session.  The default is 31 days which makes a
    #: permanent session survive for roughly one month.
    #:
    #: This attribute can also be configured from the config with the
    #: ``PERMANENT_SESSION_LIFETIME`` configuration key.  Defaults to
    #: ``timedelta(days=31)``
    permanent_session_lifetime = ConfigAttribute[timedelta](
        ""PERMANENT_SESSION_LIFETIME"",
        get_converter=_make_timedelta,  # type: ignore[arg-type]
    )

    json_provider_class: type[J
...<truncated>...
",True
b195d9c5c5f20c0df7fba6d87bf0c6746428cdec,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,__init__,App.__init__,282,411,,"    def __init__(
        self,
        import_name: str,
        static_url_path: str | None = None,
        static_folder: str | os.PathLike[str] | None = ""static"",
        static_host: str | None = None,
        host_matching: bool = False,
        subdomain_matching: bool = False,
        template_folder: str | os.PathLike[str] | None = ""templates"",
        instance_path: str | None = None,
        instance_relative_config: bool = False,
        root_path: str | None = None,
    ) -> None:
        super().__init__(
            import_name=import_name,
            static_folder=static_folder,
            static_url_path=static_url_path,
            template_folder=template_folder,
            root_path=root_path,
        )

        if instance_path is None:
            instance_path = self.auto_find_instance_path()
        elif not os.path.isabs(instance_path):
            raise ValueError(
                ""If an instance path is provided it must be absolute.""
                "" A relative path was given instead.""
            )

        #: Holds the path to the instance folder.
        #:
        #: .. versionadded:: 0.8
        self.instance_path = instance_path

        #: The configuration dictionary as :class:`Config`.  This behaves
        #: exactly like a regular dictionary but supports additional methods
        #: to load a config from files.
        self.config = self.make_config(instance_relative_config)

        #: An instance of :attr:`aborter_class` created by
        #: :meth:`make_aborter`. This is called by :func:`flask.abort`
        #: to raise HTTP errors, and can be called directly as well.
        #:
        #: .. versionadded:: 2.2
        #:     Moved from ``flask.abort``, which calls this object.
        self.aborter = self.make_aborter()

        self.json: JSONProvider = self.json_provider_class(self)
        """"""Provides access to JSON methods. Functions in ``flask.json``
        will call methods on this provider when the application context
        is active. Used for handling JSON requests and responses.

        An instance of :attr:`json_provider_class`. Can be customized by
        changing that attribute on a subclass, or by assigning to this
        attribute afterwards.

        The default, :class:`~flask.json.provider.DefaultJSONProvider`,
        uses Python's built-in :mod:`json` library. A different provider
        can use a different JSON library.

        .. versionadded:: 2.2
        """"""

        #: A list of functions that are called by
        #: :meth:`handle_url_build_error` when :meth:`.url_for` raises a
        #: :exc:`~werkzeug.routing.BuildError`. Each function is called
        #: with ``error``, ``endpoint`` and ``values``. If a function
        #: returns ``None`` or raises a ``BuildError``, it is skipped.
        #: Otherwise, its return value is returned by ``url_for``.
        #:
        #: .. versionadded:: 0.9
        self.url_build_error_handlers: list[
            t.Callable[[Exception, str, dict[str, t.Any]], str]
        ] = []

        #: A list of functions that are called when the application context
        #: is destroyed.  Since the application context is also torn down
        #: if the request ends this is the place to store code that disconnects
        #: from databases.
        #:
        #: .. versionadded:: 0.9
        self.teardown_appcontext_funcs: list[ft.TeardownCallable] = []

        #: A list of shell context processor functions that should be run
        #: when a shell context is created.
        #:
        #: .. versionadded:: 0.11
        self.shell_context_processors: list[ft.ShellContextProcessorCallable] = []

        #: Maps registered blueprint names to blueprint objects. The
        #: dict retains the order the blueprints were registered in.
        #: Blueprints can be registered multiple times, this dict does
        #: not track how often they were attached.
        #:
        #: .. versionadded:: 0.7
        self.blueprints: dict[str, Blueprint] = {}

        #: a place where extensions can store application specific state.  For
        #: example this is where an extension could store database engines and
        #: similar things.
        #:
        #: The key must match the name of the extension module. For example in
        #: case of a ""Flask-Foo"" extension in `flask_foo`, the key would be
        #: ``'foo'``.
        #:
        #: .. versionadded:: 0.7
        self.extensions: dict[str, t.Any] = {}

        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use
        #: this to change the routing converters after the class was created
        #: but before any routes are connected.  Example::
        #:
        #:    from werkzeug.routing import BaseConverter
        #:
        #:    class ListConverter(BaseConverter):
        #:        def to_python(self, value):
        #:            return value.split(',')
        #:        def to_url(self, values):
        #:            return ','.join(super(ListConverter, self).to_url(value)
        #:                            for value in values)
        #:
        #:    app = Flask(__name__)
        #:    app.url_map.converters['list'] = ListConverter
        self.url_map = self.url_map_class(host_matching=host_matching)

        self.subdomain_matching = subdomain_matching

        # tracks internally if the application already handled at least one
        # request.
        self._got_first_request = False",False
4796316b2dddf620935e0452c21ef9f02f8c867e,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,_check_setup_finished,App._check_setup_finished,413,423,,"    def _check_setup_finished(self, f_name: str) -> None:
        if self._got_first_request:
            raise AssertionError(
                f""The setup method '{f_name}' can no longer be called""
                "" on the application. It has already handled its first""
                "" request, any changes will not be applied""
                "" consistently.\n""
                ""Make sure all imports, decorators, functions, etc.""
                "" needed to set up the application are done before""
                "" running it.""
            )",False
db57206579fe68e5787d3dbdb2e5c5813a4f86cb,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,name,App.name,426,440,"The name of the application.  This is usually the import name
with the difference that it's guessed from the run file if the
import name is main.  This name is used as a display name when
Flask needs the name of the application.  It can be set and overridden
to change the value.

.. versionadded:: 0.8","    def name(self) -> str:
        """"""The name of the application.  This is usually the import name
        with the difference that it's guessed from the run file if the
        import name is main.  This name is used as a display name when
        Flask needs the name of the application.  It can be set and overridden
        to change the value.

        .. versionadded:: 0.8
        """"""
        if self.import_name == ""__main__"":
            fn: str | None = getattr(sys.modules[""__main__""], ""__file__"", None)
            if fn is None:
                return ""__main__""
            return os.path.splitext(os.path.basename(fn))[0]
        return self.import_name",False
5fe8320f7fc9c7430b83b0dc0cf9a69a1894f558,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,logger,App.logger,443,467,"A standard Python :class:`~logging.Logger` for the app, with
the same name as :attr:`name`.

In debug mode, the logger's :attr:`~logging.Logger.level` will
be set to :data:`~logging.DEBUG`.

If there are no handlers configured, a default handler will be
added. See :doc:`/logging` for more information.

.. versionchanged:: 1.1.0
    The logger takes the same name as :attr:`name` rather than
    hard-coding ``""flask.app""``.

.. versionchanged:: 1.0.0
    Behavior was simplified. The logger is always named
    ``""flask.app""``. The level is only set during configuration,
    it doesn't check ``app.debug`` each time. Only one format is
    used, not different ones depending on ``app.debug``. No
    handlers are removed, and a handler is only added if no
    handlers are already configured.

.. versionadded:: 0.3","    def logger(self) -> logging.Logger:
        """"""A standard Python :class:`~logging.Logger` for the app, with
        the same name as :attr:`name`.

        In debug mode, the logger's :attr:`~logging.Logger.level` will
        be set to :data:`~logging.DEBUG`.

        If there are no handlers configured, a default handler will be
        added. See :doc:`/logging` for more information.

        .. versionchanged:: 1.1.0
            The logger takes the same name as :attr:`name` rather than
            hard-coding ``""flask.app""``.

        .. versionchanged:: 1.0.0
            Behavior was simplified. The logger is always named
            ``""flask.app""``. The level is only set during configuration,
            it doesn't check ``app.debug`` each time. Only one format is
            used, not different ones depending on ``app.debug``. No
            handlers are removed, and a handler is only added if no
            handlers are already configured.

        .. versionadded:: 0.3
        """"""
        return create_logger(self)",False
dc995c73ac8ca7543a6c1befe5a96ed88d5b6a12,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,jinja_env,App.jinja_env,470,477,"The Jinja environment used to load templates.

The environment is created the first time this property is
accessed. Changing :attr:`jinja_options` after that will have no
effect.","    def jinja_env(self) -> Environment:
        """"""The Jinja environment used to load templates.

        The environment is created the first time this property is
        accessed. Changing :attr:`jinja_options` after that will have no
        effect.
        """"""
        return self.create_jinja_environment()",False
691ecd88436dd444df51ed37bddf59b3ac0488cb,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,create_jinja_environment,App.create_jinja_environment,479,480,,"    def create_jinja_environment(self) -> Environment:
        raise NotImplementedError()",False
c6513202b6b6af43787b97073bbe379b2b796aad,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,make_config,App.make_config,482,496,"Used to create the config attribute by the Flask constructor.
The `instance_relative` parameter is passed in from the constructor
of Flask (there named `instance_relative_config`) and indicates if
the config should be relative to the instance path or the root path
of the application.

.. versionadded:: 0.8","    def make_config(self, instance_relative: bool = False) -> Config:
        """"""Used to create the config attribute by the Flask constructor.
        The `instance_relative` parameter is passed in from the constructor
        of Flask (there named `instance_relative_config`) and indicates if
        the config should be relative to the instance path or the root path
        of the application.

        .. versionadded:: 0.8
        """"""
        root_path = self.root_path
        if instance_relative:
            root_path = self.instance_path
        defaults = dict(self.default_config)
        defaults[""DEBUG""] = get_debug_flag()
        return self.config_class(root_path, defaults)",False
17f2c955735ab2c55d10fbe472a45a4ca9a9765c,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,make_aborter,App.make_aborter,498,508,"Create the object to assign to :attr:`aborter`. That object
is called by :func:`flask.abort` to raise HTTP errors, and can
be called directly as well.

By default, this creates an instance of :attr:`aborter_class`,
which defaults to :class:`werkzeug.exceptions.Aborter`.

.. versionadded:: 2.2","    def make_aborter(self) -> Aborter:
        """"""Create the object to assign to :attr:`aborter`. That object
        is called by :func:`flask.abort` to raise HTTP errors, and can
        be called directly as well.

        By default, this creates an instance of :attr:`aborter_class`,
        which defaults to :class:`werkzeug.exceptions.Aborter`.

        .. versionadded:: 2.2
        """"""
        return self.aborter_class()",False
97e191056ca6486f73df02ed734814bf6b6a7985,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,auto_find_instance_path,App.auto_find_instance_path,510,521,"Tries to locate the instance path if it was not provided to the
constructor of the application class.  It will basically calculate
the path to a folder named ``instance`` next to your main file or
the package.

.. versionadded:: 0.8","    def auto_find_instance_path(self) -> str:
        """"""Tries to locate the instance path if it was not provided to the
        constructor of the application class.  It will basically calculate
        the path to a folder named ``instance`` next to your main file or
        the package.

        .. versionadded:: 0.8
        """"""
        prefix, package_path = find_package(self.import_name)
        if prefix is None:
            return os.path.join(package_path, ""instance"")
        return os.path.join(prefix, ""var"", f""{self.name}-instance"")",False
f3e16f446c9c5cd0fcd6be473c17ee7f2ccad9bf,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,create_global_jinja_loader,App.create_global_jinja_loader,523,534,"Creates the loader for the Jinja environment.  Can be used to
override just the loader and keeping the rest unchanged.  It's
discouraged to override this function.  Instead one should override
the :meth:`jinja_loader` function instead.

The global loader dispatches between the loaders of the application
and the individual blueprints.

.. versionadded:: 0.7","    def create_global_jinja_loader(self) -> DispatchingJinjaLoader:
        """"""Creates the loader for the Jinja environment.  Can be used to
        override just the loader and keeping the rest unchanged.  It's
        discouraged to override this function.  Instead one should override
        the :meth:`jinja_loader` function instead.

        The global loader dispatches between the loaders of the application
        and the individual blueprints.

        .. versionadded:: 0.7
        """"""
        return DispatchingJinjaLoader(self)",False
ef0566ce1e79198d30189e4cf73bb11ef0997c61,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,select_jinja_autoescape,App.select_jinja_autoescape,536,547,"Returns ``True`` if autoescaping should be active for the given
template name. If no template name is given, returns `True`.

.. versionchanged:: 2.2
    Autoescaping is now enabled by default for ``.svg`` files.

.. versionadded:: 0.5","    def select_jinja_autoescape(self, filename: str) -> bool:
        """"""Returns ``True`` if autoescaping should be active for the given
        template name. If no template name is given, returns `True`.

        .. versionchanged:: 2.2
            Autoescaping is now enabled by default for ``.svg`` files.

        .. versionadded:: 0.5
        """"""
        if filename is None:
            return True
        return filename.endswith(("".html"", "".htm"", "".xml"", "".xhtml"", "".svg""))",False
7cd63dd765a74952bf58b4eaef1cd789fb817105,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,debug,App.debug,550,560,"Whether debug mode is enabled. When using ``flask run`` to start the
development server, an interactive debugger will be shown for unhandled
exceptions, and the server will be reloaded when code changes. This maps to the
:data:`DEBUG` config key. It may not behave as expected if set late.

**Do not enable debug mode when deploying in production.**

Default: ``False``","    def debug(self) -> bool:
        """"""Whether debug mode is enabled. When using ``flask run`` to start the
        development server, an interactive debugger will be shown for unhandled
        exceptions, and the server will be reloaded when code changes. This maps to the
        :data:`DEBUG` config key. It may not behave as expected if set late.

        **Do not enable debug mode when deploying in production.**

        Default: ``False``
        """"""
        return self.config[""DEBUG""]  # type: ignore[no-any-return]",False
469171d62a549ccf4840a8e90f16bef9326e4e9c,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,debug,App.debug,563,567,,"    def debug(self, value: bool) -> None:
        self.config[""DEBUG""] = value

        if self.config[""TEMPLATES_AUTO_RELOAD""] is None:
            self.jinja_env.auto_reload = value",False
080ae014166e64107367e8e32590248c62dcc701,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,register_blueprint,App.register_blueprint,570,595,"Register a :class:`~flask.Blueprint` on the application. Keyword
arguments passed to this method will override the defaults set on the
blueprint.

Calls the blueprint's :meth:`~flask.Blueprint.register` method after
recording the blueprint in the application's :attr:`blueprints`.

:param blueprint: The blueprint to register.
:param url_prefix: Blueprint routes will be prefixed with this.
:param subdomain: Blueprint routes will match on this subdomain.
:param url_defaults: Blueprint routes will use these default values for
    view arguments.
:param options: Additional keyword arguments are passed to
    :class:`~flask.blueprints.BlueprintSetupState`. They can be
    accessed in :meth:`~flask.Blueprint.record` callbacks.

.. versionchanged:: 2.0.1
    The ``name`` option can be used to change the (pre-dotted)
    name the blueprint is registered with. This allows the same
    blueprint to be registered multiple times with unique names
    for ``url_for``.

.. versionadded:: 0.7","    def register_blueprint(self, blueprint: Blueprint, **options: t.Any) -> None:
        """"""Register a :class:`~flask.Blueprint` on the application. Keyword
        arguments passed to this method will override the defaults set on the
        blueprint.

        Calls the blueprint's :meth:`~flask.Blueprint.register` method after
        recording the blueprint in the application's :attr:`blueprints`.

        :param blueprint: The blueprint to register.
        :param url_prefix: Blueprint routes will be prefixed with this.
        :param subdomain: Blueprint routes will match on this subdomain.
        :param url_defaults: Blueprint routes will use these default values for
            view arguments.
        :param options: Additional keyword arguments are passed to
            :class:`~flask.blueprints.BlueprintSetupState`. They can be
            accessed in :meth:`~flask.Blueprint.record` callbacks.

        .. versionchanged:: 2.0.1
            The ``name`` option can be used to change the (pre-dotted)
            name the blueprint is registered with. This allows the same
            blueprint to be registered multiple times with unique names
            for ``url_for``.

        .. versionadded:: 0.7
        """"""
        blueprint.register(self, options)",False
21c8952678dfdb08a0f5235d87bb9fcd7b9319b7,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,iter_blueprints,App.iter_blueprints,597,602,"Iterates over all blueprints by the order they were registered.

.. versionadded:: 0.11","    def iter_blueprints(self) -> t.ValuesView[Blueprint]:
        """"""Iterates over all blueprints by the order they were registered.

        .. versionadded:: 0.11
        """"""
        return self.blueprints.values()",False
aa6e127f5bc80dd25610dae68a6cf424845b75e2,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,add_url_rule,App.add_url_rule,605,661,,"    def add_url_rule(
        self,
        rule: str,
        endpoint: str | None = None,
        view_func: ft.RouteCallable | None = None,
        provide_automatic_options: bool | None = None,
        **options: t.Any,
    ) -> None:
        if endpoint is None:
            endpoint = _endpoint_from_view_func(view_func)  # type: ignore
        options[""endpoint""] = endpoint
        methods = options.pop(""methods"", None)

        # if the methods are not given and the view_func object knows its
        # methods we can use that instead.  If neither exists, we go with
        # a tuple of only ``GET`` as default.
        if methods is None:
            methods = getattr(view_func, ""methods"", None) or (""GET"",)
        if isinstance(methods, str):
            raise TypeError(
                ""Allowed methods must be a list of strings, for""
                ' example: @app.route(..., methods=[""POST""])'
            )
        methods = {item.upper() for item in methods}

        # Methods that should always be added
        required_methods: set[str] = set(getattr(view_func, ""required_methods"", ()))

        # starting with Flask 0.8 the view_func object can disable and
        # force-enable the automatic options handling.
        if provide_automatic_options is None:
            provide_automatic_options = getattr(
                view_func, ""provide_automatic_options"", None
            )

        if provide_automatic_options is None:
            if ""OPTIONS"" not in methods and self.config[""PROVIDE_AUTOMATIC_OPTIONS""]:
                provide_automatic_options = True
                required_methods.add(""OPTIONS"")
            else:
                provide_automatic_options = False

        # Add the required methods now.
        methods |= required_methods

        rule_obj = self.url_rule_class(rule, methods=methods, **options)
        rule_obj.provide_automatic_options = provide_automatic_options  # type: ignore[attr-defined]

        self.url_map.add(rule_obj)
        if view_func is not None:
            old_func = self.view_functions.get(endpoint)
            if old_func is not None and old_func != view_func:
                raise AssertionError(
                    ""View function mapping is overwriting an existing""
                    f"" endpoint function: {endpoint}""
                )
            self.view_functions[endpoint] = view_func",False
ca0040d23a50f7215406da6da3fcf0807e51deaf,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,template_filter,App.template_filter,664,683,"A decorator that is used to register custom template filter.
You can specify a name for the filter, otherwise the function
name will be used. Example::

  @app.template_filter()
  def reverse(s):
      return s[::-1]

:param name: the optional name of the filter, otherwise the
             function name will be used.","    def template_filter(
        self, name: str | None = None
    ) -> t.Callable[[T_template_filter], T_template_filter]:
        """"""A decorator that is used to register custom template filter.
        You can specify a name for the filter, otherwise the function
        name will be used. Example::

          @app.template_filter()
          def reverse(s):
              return s[::-1]

        :param name: the optional name of the filter, otherwise the
                     function name will be used.
        """"""

        def decorator(f: T_template_filter) -> T_template_filter:
            self.add_template_filter(f, name=name)
            return f

        return decorator",False
813594455d9d505a0bc594068f4b6cd4174ad491,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,add_template_filter,App.add_template_filter,686,695,"Register a custom template filter.  Works exactly like the
:meth:`template_filter` decorator.

:param name: the optional name of the filter, otherwise the
             function name will be used.","    def add_template_filter(
        self, f: ft.TemplateFilterCallable, name: str | None = None
    ) -> None:
        """"""Register a custom template filter.  Works exactly like the
        :meth:`template_filter` decorator.

        :param name: the optional name of the filter, otherwise the
                     function name will be used.
        """"""
        self.jinja_env.filters[name or f.__name__] = f",False
2569198fe96bebb5852974b9a4a6bfd8d473f232,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,template_test,App.template_test,698,724,"A decorator that is used to register custom template test.
You can specify a name for the test, otherwise the function
name will be used. Example::

  @app.template_test()
  def is_prime(n):
      if n == 2:
          return True
      for i in range(2, int(math.ceil(math.sqrt(n))) + 1):
          if n % i == 0:
              return False
      return True

.. versionadded:: 0.10

:param name: the optional name of the test, otherwise the
             function name will be used.","    def template_test(
        self, name: str | None = None
    ) -> t.Callable[[T_template_test], T_template_test]:
        """"""A decorator that is used to register custom template test.
        You can specify a name for the test, otherwise the function
        name will be used. Example::

          @app.template_test()
          def is_prime(n):
              if n == 2:
                  return True
              for i in range(2, int(math.ceil(math.sqrt(n))) + 1):
                  if n % i == 0:
                      return False
              return True

        .. versionadded:: 0.10

        :param name: the optional name of the test, otherwise the
                     function name will be used.
        """"""

        def decorator(f: T_template_test) -> T_template_test:
            self.add_template_test(f, name=name)
            return f

        return decorator",False
d35b1879a9c3177ae6ee76e2e19f560f2f7957ab,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,add_template_test,App.add_template_test,727,738,"Register a custom template test.  Works exactly like the
:meth:`template_test` decorator.

.. versionadded:: 0.10

:param name: the optional name of the test, otherwise the
             function name will be used.","    def add_template_test(
        self, f: ft.TemplateTestCallable, name: str | None = None
    ) -> None:
        """"""Register a custom template test.  Works exactly like the
        :meth:`template_test` decorator.

        .. versionadded:: 0.10

        :param name: the optional name of the test, otherwise the
                     function name will be used.
        """"""
        self.jinja_env.tests[name or f.__name__] = f",False
e71cad5967d9d02731655d2349fcf367443e18d1,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,template_global,App.template_global,741,762,"A decorator that is used to register a custom template global function.
You can specify a name for the global function, otherwise the function
name will be used. Example::

    @app.template_global()
    def double(n):
        return 2 * n

.. versionadded:: 0.10

:param name: the optional name of the global function, otherwise the
             function name will be used.","    def template_global(
        self, name: str | None = None
    ) -> t.Callable[[T_template_global], T_template_global]:
        """"""A decorator that is used to register a custom template global function.
        You can specify a name for the global function, otherwise the function
        name will be used. Example::

            @app.template_global()
            def double(n):
                return 2 * n

        .. versionadded:: 0.10

        :param name: the optional name of the global function, otherwise the
                     function name will be used.
        """"""

        def decorator(f: T_template_global) -> T_template_global:
            self.add_template_global(f, name=name)
            return f

        return decorator",False
8fd9b4abe5836dde6767d78840182a143277301a,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,add_template_global,App.add_template_global,765,776,"Register a custom template global function. Works exactly like the
:meth:`template_global` decorator.

.. versionadded:: 0.10

:param name: the optional name of the global function, otherwise the
             function name will be used.","    def add_template_global(
        self, f: ft.TemplateGlobalCallable, name: str | None = None
    ) -> None:
        """"""Register a custom template global function. Works exactly like the
        :meth:`template_global` decorator.

        .. versionadded:: 0.10

        :param name: the optional name of the global function, otherwise the
                     function name will be used.
        """"""
        self.jinja_env.globals[name or f.__name__] = f",False
6059b8cff063ad2af1c963477b73418d17680c1f,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,teardown_appcontext,App.teardown_appcontext,779,810,"Registers a function to be called when the application
context is popped. The application context is typically popped
after the request context for each request, at the end of CLI
commands, or after a manually pushed context ends.

.. code-block:: python

    with app.app_context():
        ...

When the ``with`` block exits (or ``ctx.pop()`` is called), the
teardown functions are called just before the app context is
made inactive. Since a request context typically also manages an
application context it would also be called when you pop a
request context.

When a teardown function was called because of an unhandled
exception it will be passed an error object. If an
:meth:`errorhandler` is registered, it will handle the exception
and the teardown will not receive it.

Teardown functions must avoid raising exceptions. If they
execute code that might fail they must surround that code with a
``try``/``except`` block and log any errors.

The return values of teardown functions are ignored.

.. versionadded:: 0.9","    def teardown_appcontext(self, f: T_teardown) -> T_teardown:
        """"""Registers a function to be called when the application
        context is popped. The application context is typically popped
        after the request context for each request, at the end of CLI
        commands, or after a manually pushed context ends.

        .. code-block:: python

            with app.app_context():
                ...

        When the ``with`` block exits (or ``ctx.pop()`` is called), the
        teardown functions are called just before the app context is
        made inactive. Since a request context typically also manages an
        application context it would also be called when you pop a
        request context.

        When a teardown function was called because of an unhandled
        exception it will be passed an error object. If an
        :meth:`errorhandler` is registered, it will handle the exception
        and the teardown will not receive it.

        Teardown functions must avoid raising exceptions. If they
        execute code that might fail they must surround that code with a
        ``try``/``except`` block and log any errors.

        The return values of teardown functions are ignored.

        .. versionadded:: 0.9
        """"""
        self.teardown_appcontext_funcs.append(f)
        return f",False
acb72a9eddf4034d2c3c9a4428458dc0eb313585,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,shell_context_processor,App.shell_context_processor,813,821,"Registers a shell context processor function.

.. versionadded:: 0.11","    def shell_context_processor(
        self, f: T_shell_context_processor
    ) -> T_shell_context_processor:
        """"""Registers a shell context processor function.

        .. versionadded:: 0.11
        """"""
        self.shell_context_processors.append(f)
        return f",False
bd8aa579677d2103529098bf0dde5363bf27801b,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,_find_error_handler,App._find_error_handler,823,846,"Return a registered error handler for an exception in this order:
blueprint handler for a specific code, app handler for a specific code,
blueprint handler for an exception class, app handler for an exception
class, or ``None`` if a suitable handler is not found.","    def _find_error_handler(
        self, e: Exception, blueprints: list[str]
    ) -> ft.ErrorHandlerCallable | None:
        """"""Return a registered error handler for an exception in this order:
        blueprint handler for a specific code, app handler for a specific code,
        blueprint handler for an exception class, app handler for an exception
        class, or ``None`` if a suitable handler is not found.
        """"""
        exc_class, code = self._get_exc_class_and_code(type(e))
        names = (*blueprints, None)

        for c in (code, None) if code is not None else (None,):
            for name in names:
                handler_map = self.error_handler_spec[name][c]

                if not handler_map:
                    continue

                for cls in exc_class.__mro__:
                    handler = handler_map.get(cls)

                    if handler is not None:
                        return handler
        return None",False
72546f3f59b50590d57414770de886085622f2f1,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,trap_http_exception,App.trap_http_exception,848,881,"Checks if an HTTP exception should be trapped or not.  By default
this will return ``False`` for all exceptions except for a bad request
key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to ``True``.  It
also returns ``True`` if ``TRAP_HTTP_EXCEPTIONS`` is set to ``True``.

This is called for all HTTP exceptions raised by a view function.
If it returns ``True`` for any exception the error handler for this
exception is not called and it shows up as regular exception in the
traceback.  This is helpful for debugging implicitly raised HTTP
exceptions.

.. versionchanged:: 1.0
    Bad request errors are not trapped by default in debug mode.

.. versionadded:: 0.8","    def trap_http_exception(self, e: Exception) -> bool:
        """"""Checks if an HTTP exception should be trapped or not.  By default
        this will return ``False`` for all exceptions except for a bad request
        key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to ``True``.  It
        also returns ``True`` if ``TRAP_HTTP_EXCEPTIONS`` is set to ``True``.

        This is called for all HTTP exceptions raised by a view function.
        If it returns ``True`` for any exception the error handler for this
        exception is not called and it shows up as regular exception in the
        traceback.  This is helpful for debugging implicitly raised HTTP
        exceptions.

        .. versionchanged:: 1.0
            Bad request errors are not trapped by default in debug mode.

        .. versionadded:: 0.8
        """"""
        if self.config[""TRAP_HTTP_EXCEPTIONS""]:
            return True

        trap_bad_request = self.config[""TRAP_BAD_REQUEST_ERRORS""]

        # if unset, trap key errors in debug mode
        if (
            trap_bad_request is None
            and self.debug
            and isinstance(e, BadRequestKeyError)
        ):
            return True

        if trap_bad_request:
            return isinstance(e, BadRequest)

        return False",False
4fd106d0acc60784e359a803c65f9744a62087b2,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,should_ignore_error,App.should_ignore_error,883,891,"This is called to figure out if an error should be ignored
or not as far as the teardown system is concerned.  If this
function returns ``True`` then the teardown handlers will not be
passed the error.

.. versionadded:: 0.10","    def should_ignore_error(self, error: BaseException | None) -> bool:
        """"""This is called to figure out if an error should be ignored
        or not as far as the teardown system is concerned.  If this
        function returns ``True`` then the teardown handlers will not be
        passed the error.

        .. versionadded:: 0.10
        """"""
        return False",False
0fe87bd449f395823c39ea148f7c889540f4c12f,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,redirect,App.redirect,893,909,"Create a redirect response object.

This is called by :func:`flask.redirect`, and can be called
directly as well.

:param location: The URL to redirect to.
:param code: The status code for the redirect.

.. versionadded:: 2.2
    Moved from ``flask.redirect``, which calls this method.","    def redirect(self, location: str, code: int = 302) -> BaseResponse:
        """"""Create a redirect response object.

        This is called by :func:`flask.redirect`, and can be called
        directly as well.

        :param location: The URL to redirect to.
        :param code: The status code for the redirect.

        .. versionadded:: 2.2
            Moved from ``flask.redirect``, which calls this method.
        """"""
        return _wz_redirect(
            location,
            code=code,
            Response=self.response_class,  # type: ignore[arg-type]
        )",False
1c6a2d953793959fcb82bc2bdb28a28346b5ccbd,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,inject_url_defaults,App.inject_url_defaults,911,930,"Injects the URL defaults for the given endpoint directly into
the values dictionary passed.  This is used internally and
automatically called on URL building.

.. versionadded:: 0.7","    def inject_url_defaults(self, endpoint: str, values: dict[str, t.Any]) -> None:
        """"""Injects the URL defaults for the given endpoint directly into
        the values dictionary passed.  This is used internally and
        automatically called on URL building.

        .. versionadded:: 0.7
        """"""
        names: t.Iterable[str | None] = (None,)

        # url_for may be called outside a request context, parse the
        # passed endpoint instead of using request.blueprints.
        if ""."" in endpoint:
            names = chain(
                names, reversed(_split_blueprint_path(endpoint.rpartition(""."")[0]))
            )

        for name in names:
            if name in self.url_default_functions:
                for func in self.url_default_functions[name]:
                    func(endpoint, values)",False
07ba41ceb2d3059832f5847a2c36e09fe36ad136,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\app.py,method,handle_url_build_error,App.handle_url_build_error,932,964,"Called by :meth:`.url_for` if a
:exc:`~werkzeug.routing.BuildError` was raised. If this returns
a value, it will be returned by ``url_for``, otherwise the error
will be re-raised.

Each function in :attr:`url_build_error_handlers` is called with
``error``, ``endpoint`` and ``values``. If a function returns
``None`` or raises a ``BuildError``, it is skipped. Otherwise,
its return value is returned by ``url_for``.

:param error: The active ``BuildError`` being handled.
:param endpoint: The endpoint being built.
:param values: The keyword arguments passed to ``url_for``.","    def handle_url_build_error(
        self, error: BuildError, endpoint: str, values: dict[str, t.Any]
    ) -> str:
        """"""Called by :meth:`.url_for` if a
        :exc:`~werkzeug.routing.BuildError` was raised. If this returns
        a value, it will be returned by ``url_for``, otherwise the error
        will be re-raised.

        Each function in :attr:`url_build_error_handlers` is called with
        ``error``, ``endpoint`` and ``values``. If a function returns
        ``None`` or raises a ``BuildError``, it is skipped. Otherwise,
        its return value is returned by ``url_for``.

        :param error: The active ``BuildError`` being handled.
        :param endpoint: The endpoint being built.
        :param values: The keyword arguments passed to ``url_for``.
        """"""
        for handler in self.url_build_error_handlers:
            try:
                rv = handler(error, endpoint, values)
            except BuildError as e:
                # make error available outside except block
                error = e
            else:
                if rv is not None:
                    return rv

        # Re-raise if called with an active exception, otherwise raise
        # the passed in exception.
        if error is sys.exc_info()[1]:
            raise

        raise error",False
7f0c359aad4268bf236509bc1333835e34a3124c,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\blueprints.py,class,BlueprintSetupState,BlueprintSetupState,34,116,"Temporary holder object for registering a blueprint with the
application.  An instance of this class is created by the
:meth:`~flask.Blueprint.make_setup_state` method and later passed
to all register callback functions.","class BlueprintSetupState:
    """"""Temporary holder object for registering a blueprint with the
    application.  An instance of this class is created by the
    :meth:`~flask.Blueprint.make_setup_state` method and later passed
    to all register callback functions.
    """"""

    def __init__(
        self,
        blueprint: Blueprint,
        app: App,
        options: t.Any,
        first_registration: bool,
    ) -> None:
        #: a reference to the current application
        self.app = app

        #: a reference to the blueprint that created this setup state.
        self.blueprint = blueprint

        #: a dictionary with all options that were passed to the
        #: :meth:`~flask.Flask.register_blueprint` method.
        self.options = options

        #: as blueprints can be registered multiple times with the
        #: application and not everything wants to be registered
        #: multiple times on it, this attribute can be used to figure
        #: out if the blueprint was registered in the past already.
        self.first_registration = first_registration

        subdomain = self.options.get(""subdomain"")
        if subdomain is None:
            subdomain = self.blueprint.subdomain

        #: The subdomain that the blueprint should be active for, ``None``
        #: otherwise.
        self.subdomain = subdomain

        url_prefix = self.options.get(""url_prefix"")
        if url_prefix is None:
            url_prefix = self.blueprint.url_prefix
        #: The prefix that should be used for all URLs defined on the
        #: blueprint.
        self.url_prefix = url_prefix

        self.name = self.options.get(""name"", blueprint.name)
        self.name_prefix = self.options.get(""name_prefix"", """")

        #: A dictionary with URL defaults that is added to each and every
        #: URL that was defined with the blueprint.
        self.url_defaults = dict(self.blueprint.url_values_defaults)
        self.url_defaults.update(self.options.get(""url_defaults"", ()))

    def add_url_rule(
        self,
        rule: str,
        endpoint: str | None = None,
        view_func: ft.RouteCallable | None = None,
        **options: t.Any,
    ) -> None:
        """"""A helper method to register a rule (and optionally a view function)
        to the application.  The endpoint is automatically prefixed with the
        blueprint's name.
        """"""
        if self.url_prefix is not None:
            if rule:
                rule = ""/"".join((self.url_prefix.rstrip(""/""), rule.lstrip(""/"")))
            else:
                rule = self.url_prefix
        options.setdefault(""subdomain"", self.subdomain)
        if endpoint is None:
            endpoint = _endpoint_from_view_func(view_func)  # type: ignore
        defaults = self.url_defaults
        if ""defaults"" in options:
            defaults = dict(defaults, **options.pop(""defaults""))

        self.app.add_url_rule(
            rule,
            f""{self.name_prefix}.{self.name}.{endpoint}"".lstrip("".""),
            view_func,
            defaults=defaults,
            **options,
        )",False
9e23e53f49d961e84b6ea3826e6fc27d069e339d,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\blueprints.py,method,__init__,BlueprintSetupState.__init__,41,85,,"    def __init__(
        self,
        blueprint: Blueprint,
        app: App,
        options: t.Any,
        first_registration: bool,
    ) -> None:
        #: a reference to the current application
        self.app = app

        #: a reference to the blueprint that created this setup state.
        self.blueprint = blueprint

        #: a dictionary with all options that were passed to the
        #: :meth:`~flask.Flask.register_blueprint` method.
        self.options = options

        #: as blueprints can be registered multiple times with the
        #: application and not everything wants to be registered
        #: multiple times on it, this attribute can be used to figure
        #: out if the blueprint was registered in the past already.
        self.first_registration = first_registration

        subdomain = self.options.get(""subdomain"")
        if subdomain is None:
            subdomain = self.blueprint.subdomain

        #: The subdomain that the blueprint should be active for, ``None``
        #: otherwise.
        self.subdomain = subdomain

        url_prefix = self.options.get(""url_prefix"")
        if url_prefix is None:
            url_prefix = self.blueprint.url_prefix
        #: The prefix that should be used for all URLs defined on the
        #: blueprint.
        self.url_prefix = url_prefix

        self.name = self.options.get(""name"", blueprint.name)
        self.name_prefix = self.options.get(""name_prefix"", """")

        #: A dictionary with URL defaults that is added to each and every
        #: URL that was defined with the blueprint.
        self.url_defaults = dict(self.blueprint.url_values_defaults)
        self.url_defaults.update(self.options.get(""url_defaults"", ()))",False
5da66ec3713bd62dcf402fd5a782459a0146cc90,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\blueprints.py,method,add_url_rule,BlueprintSetupState.add_url_rule,87,116,"A helper method to register a rule (and optionally a view function)
to the application.  The endpoint is automatically prefixed with the
blueprint's name.","    def add_url_rule(
        self,
        rule: str,
        endpoint: str | None = None,
        view_func: ft.RouteCallable | None = None,
        **options: t.Any,
    ) -> None:
        """"""A helper method to register a rule (and optionally a view function)
        to the application.  The endpoint is automatically prefixed with the
        blueprint's name.
        """"""
        if self.url_prefix is not None:
            if rule:
                rule = ""/"".join((self.url_prefix.rstrip(""/""), rule.lstrip(""/"")))
            else:
                rule = self.url_prefix
        options.setdefault(""subdomain"", self.subdomain)
        if endpoint is None:
            endpoint = _endpoint_from_view_func(view_func)  # type: ignore
        defaults = self.url_defaults
        if ""defaults"" in options:
            defaults = dict(defaults, **options.pop(""defaults""))

        self.app.add_url_rule(
            rule,
            f""{self.name_prefix}.{self.name}.{endpoint}"".lstrip("".""),
            view_func,
            defaults=defaults,
            **options,
        )",False
050eb8c31229f16efc649b2a5db466224acdf8df,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\blueprints.py,class,Blueprint,Blueprint,119,632,"Represents a blueprint, a collection of routes and other
app-related functions that can be registered on a real application
later.

A blueprint is an object that allows defining application functions
without requiring an application object ahead of time. It uses the
same decorators as :class:`~flask.Flask`, but defers the need for an
application by recording them for later registration.

Decorating a function with a blueprint creates a deferred function
that is called with :class:`~flask.blueprints.BlueprintSetupState`
when the blueprint is registered on an application.

See :doc:`/blueprints` for more information.

:param name: The name of the blueprint. Will be prepended to each
    endpoint name.
:param import_name: The name of the blueprint package, usually
    ``__name__``. This helps locate the ``root_path`` for the
    blueprint.
:param static_folder: A folder with static files that should be
    served by the blueprint's static route. The path is relative to
    the blueprint's root path. Blueprint static files are disabled
    by default.
:param static_url_path: The url to serve static files from.
    Defaults to ``static_folder``. If the blueprint does not have
    a ``url_prefix``, the app's static route will take precedence,
    and the blueprint's static files won't be accessible.
:param template_folder: A folder with templates that should be added
    to the app's template search path. The path is relative to the
    blueprint's root path. Blueprint templates are disabled by
    default. Blueprint templates have a lower precedence than those
    in the app's templates folder.
:param url_prefix: A path to prepend to all of the blueprint's URLs,
    to make them distinct from the rest of the app's routes.
:param subdomain: A subdomain that blueprint routes will match on by
    default.
:param url_defaults: A dict of default values that blueprint routes
    will receive by default.
:param root_path: By default, the blueprint will automatically set
    this based on ``import_name``. In certain situations this
    automatic detection can fail, so the path can be specified
    manually instead.

.. versionchanged:: 1.1.0
    Blueprints have a ``cli`` group to register nested CLI commands.
    The ``cli_group`` parameter controls the name of the group under
    the ``flask`` command.

.. versionadded:: 0.7","class Blueprint(Scaffold):
    """"""Represents a blueprint, a collection of routes and other
    app-related functions that can be registered on a real application
    later.

    A blueprint is an object that allows defining application functions
    without requiring an application object ahead of time. It uses the
    same decorators as :class:`~flask.Flask`, but defers the need for an
    application by recording them for later registration.

    Decorating a function with a blueprint creates a deferred function
    that is called with :class:`~flask.blueprints.BlueprintSetupState`
    when the blueprint is registered on an application.

    See :doc:`/blueprints` for more information.

    :param name: The name of the blueprint. Will be prepended to each
        endpoint name.
    :param import_name: The name of the blueprint package, usually
        ``__name__``. This helps locate the ``root_path`` for the
        blueprint.
    :param static_folder: A folder with static files that should be
        served by the blueprint's static route. The path is relative to
        the blueprint's root path. Blueprint static files are disabled
        by default.
    :param static_url_path: The url to serve static files from.
        Defaults to ``static_folder``. If the blueprint does not have
        a ``url_prefix``, the app's static route will take precedence,
        and the blueprint's static files won't be accessible.
    :param template_folder: A folder with templates that should be added
        to the app's template search path. The path is relative to the
        blueprint's root path. Blueprint templates are disabled by
        default. Blueprint templates have a lower precedence than those
        in the app's templates folder.
    :param url_prefix: A path to prepend to all of the blueprint's URLs,
        to make them distinct from the rest of the app's routes.
    :param subdomain: A subdomain that blueprint routes will match on by
        default.
    :param url_defaults: A dict of default values that blueprint routes
        will receive by default.
    :param root_path: By default, the blueprint will automatically set
        this based on ``import_name``. In certain situations this
        automatic detection can fail, so the path can be specified
        manually instead.

    .. versionchanged:: 1.1.0
        Blueprints have a ``cli`` group to register nested CLI commands.
        The ``cli_group`` parameter controls the name of the group under
        the ``flask`` command.

    .. versionadded:: 0.7
    """"""

    _got_registered_once = False

    def __init__(
        self,
        name: str,
        import_name: str,
        static_folder: str | os.PathLike[str] | None = None,
        static_url_path: str | None = None,
        template_folder: str | os.PathLike[str] | None = None,
        url_prefix: str | None = None,
        subdomain: str | None = None,
        url_defaults: dict[str, t.Any] | None = None,
        root_path: str | None = None,
        cli_group: str | None = _sentinel,  # type: ignore[assignment]
    ):
        super().__init__(
            import_name=import_name,
            static_folder=static_folder,
            static_url_path=static_url_path,
            template_folder=template_folder,
            root_path=root_path,
        )

        if not name:
            raise ValueError(""'name' may not be empty."")

        if ""."" in name:
            raise ValueError(""'name' may not contain a dot '.' character."")

        self.name = name
        self.url_prefix = url_prefix
        self.subdomain = subdomain
        self.deferred_functions: list[DeferredSetupFunction] = []

        if url_defaults is None:
            url_defaults = {}

        self.url_values_defaults = url_defaults
        self.cli_group = cli_group
        self._blueprints: list[tuple[Blueprint, dict[str, t.Any]]] = []

    def _check_setup_finished(self, f_name: str) -> None:
        if self._got_registered_once:
            raise AssertionError(
                f""The setup method '{f_name}' can no longer be called on the blueprint""
                f"" '{self.name}'. It has already been registered at least once, any""
                "" changes will not be applied consistently.\n""
                ""Make sure all imports, decorators, functions, etc. needed to set up""
                "" the blueprint are done before registering it.""
            )

    @setupmethod
    def record(self, func: DeferredSetupFunction) -> None:
        """"""Registers a function that is called when the blueprint is
        registered on the application.  This function is called with the
        state as argument as returned by the :meth:`make_setup_state`
        method.
        """"""
        self.deferred_functions.append(func)

    @setupmethod
    def record_once(self, func: DeferredSetupFunction) -> None:
        """"""Works like :meth:`record` but wraps the function in another
        function that will ensure the function is only called once.  If the
        blueprint is registered a second time on the application, the
        function passed is not called.
        """"""

        def wrapper(state: BlueprintSetupState) -> None:
            if state.first_registration:
                func(state)

        self.record(update_wrapper(wrapper, func))

    def make_setup_state(
        self, app: App, options: dict[str, t.Any], first_registration: bool = False
    ) -> BlueprintSetupState:
        """"""Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState`
        object that is later passed to the register callback functions.
        Subclasses can override this to return a subclass of the setup state.
        """"""
        return BlueprintSetupState(self, app, options, first_registration)

    @setupmethod
    def register_blueprint(self, blueprint: Blueprint, **options: t.Any) -> None:
        """"""Register a :class:`~flask.Blueprint` on this blueprint. Keyword
        arguments passed to this method will override the defaults set
        on the blueprint.

        .. versionchanged:: 2.0.1
            The ``name`` option can be used to change the (pre-dotted)
            name the blueprint is registered with. This allows the same
            blueprint to be registered multiple times with unique names
            for ``url_for``.

        .. versionadded:: 2.0
        """"""
        if blueprint is self:
            raise ValueError(""Cannot register a blueprint on itself"")
        self._blueprints.append((blueprint, options))

    def register(self, app: App, options: dict[str, t.Any]) -> None:
        """"""Called by :meth:`Flask.register_blueprint` to register all
        views and callbacks registered on the blueprint with the
        application. Creates a :class:`.BlueprintSetupState` and calls
        each :meth:`record` callback with it.

        :param app: The application this blueprint is being registered
            with.
        :param options: Keyword arguments forwarded from
            :meth:`~Flask.register_blueprint`.

        .. versionchanged:: 2.3
            Nested blueprints now correctly apply subdomains.

        .. versionchanged:: 2.1
            Registering the same blueprint with the same name multiple
            times is an error.

        .. versionchanged:: 2.0.1
            Nested blueprints are registered with their dotted name.
            This allows different blueprints with the same name to be
            nested at different locations.

        .. versionchanged:: 2.0.1
            The ``name`` option can be used to change the (pre-dotted)
            name the blueprint is registered with. This allows the same
            blueprint to be registered multiple times with unique names
            for ``url_for``.
        """"""
        name_prefix = options.get(""name_prefix"", """")
        self_name = options.get(""name"", self.name)
        name = f""{name_prefix}.{self_name}"".lstrip(""."")

        if name in app.blueprints:
    
...<truncated>...
",True
4a15cd3b26430caeb872f19ee57b7d0deb3c943b,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\blueprints.py,method,__init__,Blueprint.__init__,174,211,,"    def __init__(
        self,
        name: str,
        import_name: str,
        static_folder: str | os.PathLike[str] | None = None,
        static_url_path: str | None = None,
        template_folder: str | os.PathLike[str] | None = None,
        url_prefix: str | None = None,
        subdomain: str | None = None,
        url_defaults: dict[str, t.Any] | None = None,
        root_path: str | None = None,
        cli_group: str | None = _sentinel,  # type: ignore[assignment]
    ):
        super().__init__(
            import_name=import_name,
            static_folder=static_folder,
            static_url_path=static_url_path,
            template_folder=template_folder,
            root_path=root_path,
        )

        if not name:
            raise ValueError(""'name' may not be empty."")

        if ""."" in name:
            raise ValueError(""'name' may not contain a dot '.' character."")

        self.name = name
        self.url_prefix = url_prefix
        self.subdomain = subdomain
        self.deferred_functions: list[DeferredSetupFunction] = []

        if url_defaults is None:
            url_defaults = {}

        self.url_values_defaults = url_defaults
        self.cli_group = cli_group
        self._blueprints: list[tuple[Blueprint, dict[str, t.Any]]] = []",False
263b75b731c031841002d59bc4d02b1888e999ec,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\blueprints.py,method,_check_setup_finished,Blueprint._check_setup_finished,213,221,,"    def _check_setup_finished(self, f_name: str) -> None:
        if self._got_registered_once:
            raise AssertionError(
                f""The setup method '{f_name}' can no longer be called on the blueprint""
                f"" '{self.name}'. It has already been registered at least once, any""
                "" changes will not be applied consistently.\n""
                ""Make sure all imports, decorators, functions, etc. needed to set up""
                "" the blueprint are done before registering it.""
            )",False
19c64700651ca0aac083d837afb21a2455d48c2a,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\blueprints.py,method,record,Blueprint.record,224,230,"Registers a function that is called when the blueprint is
registered on the application.  This function is called with the
state as argument as returned by the :meth:`make_setup_state`
method.","    def record(self, func: DeferredSetupFunction) -> None:
        """"""Registers a function that is called when the blueprint is
        registered on the application.  This function is called with the
        state as argument as returned by the :meth:`make_setup_state`
        method.
        """"""
        self.deferred_functions.append(func)",False
83e3801266e6e403bbb1c599b2f2a3bc155e67ee,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\blueprints.py,method,record_once,Blueprint.record_once,233,244,"Works like :meth:`record` but wraps the function in another
function that will ensure the function is only called once.  If the
blueprint is registered a second time on the application, the
function passed is not called.","    def record_once(self, func: DeferredSetupFunction) -> None:
        """"""Works like :meth:`record` but wraps the function in another
        function that will ensure the function is only called once.  If the
        blueprint is registered a second time on the application, the
        function passed is not called.
        """"""

        def wrapper(state: BlueprintSetupState) -> None:
            if state.first_registration:
                func(state)

        self.record(update_wrapper(wrapper, func))",False
29304152079461a508cf1dfac77165ca2f133ac1,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\blueprints.py,method,make_setup_state,Blueprint.make_setup_state,246,253,"Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState`
object that is later passed to the register callback functions.
Subclasses can override this to return a subclass of the setup state.","    def make_setup_state(
        self, app: App, options: dict[str, t.Any], first_registration: bool = False
    ) -> BlueprintSetupState:
        """"""Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState`
        object that is later passed to the register callback functions.
        Subclasses can override this to return a subclass of the setup state.
        """"""
        return BlueprintSetupState(self, app, options, first_registration)",False
24470ee7108c483a9ebebccc2d621e4f43beba97,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\blueprints.py,method,register_blueprint,Blueprint.register_blueprint,256,271,"Register a :class:`~flask.Blueprint` on this blueprint. Keyword
arguments passed to this method will override the defaults set
on the blueprint.

.. versionchanged:: 2.0.1
    The ``name`` option can be used to change the (pre-dotted)
    name the blueprint is registered with. This allows the same
    blueprint to be registered multiple times with unique names
    for ``url_for``.

.. versionadded:: 2.0","    def register_blueprint(self, blueprint: Blueprint, **options: t.Any) -> None:
        """"""Register a :class:`~flask.Blueprint` on this blueprint. Keyword
        arguments passed to this method will override the defaults set
        on the blueprint.

        .. versionchanged:: 2.0.1
            The ``name`` option can be used to change the (pre-dotted)
            name the blueprint is registered with. This allows the same
            blueprint to be registered multiple times with unique names
            for ``url_for``.

        .. versionadded:: 2.0
        """"""
        if blueprint is self:
            raise ValueError(""Cannot register a blueprint on itself"")
        self._blueprints.append((blueprint, options))",False
0ccb67a8a1fa0e6433839b0105192d8c71accff4,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\blueprints.py,method,register,Blueprint.register,273,377,"Called by :meth:`Flask.register_blueprint` to register all
views and callbacks registered on the blueprint with the
application. Creates a :class:`.BlueprintSetupState` and calls
each :meth:`record` callback with it.

:param app: The application this blueprint is being registered
    with.
:param options: Keyword arguments forwarded from
    :meth:`~Flask.register_blueprint`.

.. versionchanged:: 2.3
    Nested blueprints now correctly apply subdomains.

.. versionchanged:: 2.1
    Registering the same blueprint with the same name multiple
    times is an error.

.. versionchanged:: 2.0.1
    Nested blueprints are registered with their dotted name.
    This allows different blueprints with the same name to be
    nested at different locations.

.. versionchanged:: 2.0.1
    The ``name`` option can be used to change the (pre-dotted)
    name the blueprint is registered with. This allows the same
    blueprint to be registered multiple times with unique names
    for ``url_for``.","    def register(self, app: App, options: dict[str, t.Any]) -> None:
        """"""Called by :meth:`Flask.register_blueprint` to register all
        views and callbacks registered on the blueprint with the
        application. Creates a :class:`.BlueprintSetupState` and calls
        each :meth:`record` callback with it.

        :param app: The application this blueprint is being registered
            with.
        :param options: Keyword arguments forwarded from
            :meth:`~Flask.register_blueprint`.

        .. versionchanged:: 2.3
            Nested blueprints now correctly apply subdomains.

        .. versionchanged:: 2.1
            Registering the same blueprint with the same name multiple
            times is an error.

        .. versionchanged:: 2.0.1
            Nested blueprints are registered with their dotted name.
            This allows different blueprints with the same name to be
            nested at different locations.

        .. versionchanged:: 2.0.1
            The ``name`` option can be used to change the (pre-dotted)
            name the blueprint is registered with. This allows the same
            blueprint to be registered multiple times with unique names
            for ``url_for``.
        """"""
        name_prefix = options.get(""name_prefix"", """")
        self_name = options.get(""name"", self.name)
        name = f""{name_prefix}.{self_name}"".lstrip(""."")

        if name in app.blueprints:
            bp_desc = ""this"" if app.blueprints[name] is self else ""a different""
            existing_at = f"" '{name}'"" if self_name != name else """"

            raise ValueError(
                f""The name '{self_name}' is already registered for""
                f"" {bp_desc} blueprint{existing_at}. Use 'name=' to""
                f"" provide a unique name.""
            )

        first_bp_registration = not any(bp is self for bp in app.blueprints.values())
        first_name_registration = name not in app.blueprints

        app.blueprints[name] = self
        self._got_registered_once = True
        state = self.make_setup_state(app, options, first_bp_registration)

        if self.has_static_folder:
            state.add_url_rule(
                f""{self.static_url_path}/<path:filename>"",
                view_func=self.send_static_file,  # type: ignore[attr-defined]
                endpoint=""static"",
            )

        # Merge blueprint data into parent.
        if first_bp_registration or first_name_registration:
            self._merge_blueprint_funcs(app, name)

        for deferred in self.deferred_functions:
            deferred(state)

        cli_resolved_group = options.get(""cli_group"", self.cli_group)

        if self.cli.commands:
            if cli_resolved_group is None:
                app.cli.commands.update(self.cli.commands)
            elif cli_resolved_group is _sentinel:
                self.cli.name = name
                app.cli.add_command(self.cli)
            else:
                self.cli.name = cli_resolved_group
                app.cli.add_command(self.cli)

        for blueprint, bp_options in self._blueprints:
            bp_options = bp_options.copy()
            bp_url_prefix = bp_options.get(""url_prefix"")
            bp_subdomain = bp_options.get(""subdomain"")

            if bp_subdomain is None:
                bp_subdomain = blueprint.subdomain

            if state.subdomain is not None and bp_subdomain is not None:
                bp_options[""subdomain""] = bp_subdomain + ""."" + state.subdomain
            elif bp_subdomain is not None:
                bp_options[""subdomain""] = bp_subdomain
            elif state.subdomain is not None:
                bp_options[""subdomain""] = state.subdomain

            if bp_url_prefix is None:
                bp_url_prefix = blueprint.url_prefix

            if state.url_prefix is not None and bp_url_prefix is not None:
                bp_options[""url_prefix""] = (
                    state.url_prefix.rstrip(""/"") + ""/"" + bp_url_prefix.lstrip(""/"")
                )
            elif bp_url_prefix is not None:
                bp_options[""url_prefix""] = bp_url_prefix
            elif state.url_prefix is not None:
                bp_options[""url_prefix""] = state.url_prefix

            bp_options[""name_prefix""] = name
            blueprint.register(app, bp_options)",False
8a3d7b954cac8c75d598ee17583b3a8497ce7af8,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\blueprints.py,method,_merge_blueprint_funcs,Blueprint._merge_blueprint_funcs,379,410,,"    def _merge_blueprint_funcs(self, app: App, name: str) -> None:
        def extend(
            bp_dict: dict[ft.AppOrBlueprintKey, list[t.Any]],
            parent_dict: dict[ft.AppOrBlueprintKey, list[t.Any]],
        ) -> None:
            for key, values in bp_dict.items():
                key = name if key is None else f""{name}.{key}""
                parent_dict[key].extend(values)

        for key, value in self.error_handler_spec.items():
            key = name if key is None else f""{name}.{key}""
            value = defaultdict(
                dict,
                {
                    code: {exc_class: func for exc_class, func in code_values.items()}
                    for code, code_values in value.items()
                },
            )
            app.error_handler_spec[key] = value

        for endpoint, func in self.view_functions.items():
            app.view_functions[endpoint] = func

        extend(self.before_request_funcs, app.before_request_funcs)
        extend(self.after_request_funcs, app.after_request_funcs)
        extend(
            self.teardown_request_funcs,
            app.teardown_request_funcs,
        )
        extend(self.url_default_functions, app.url_default_functions)
        extend(self.url_value_preprocessors, app.url_value_preprocessors)
        extend(self.template_context_processors, app.template_context_processors)",False
f41009b67a3927ef7a561c0a130593aba5a4399d,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\blueprints.py,method,add_url_rule,Blueprint.add_url_rule,413,441,"Register a URL rule with the blueprint. See :meth:`.Flask.add_url_rule` for
full documentation.

The URL rule is prefixed with the blueprint's URL prefix. The endpoint name,
used with :func:`url_for`, is prefixed with the blueprint's name.","    def add_url_rule(
        self,
        rule: str,
        endpoint: str | None = None,
        view_func: ft.RouteCallable | None = None,
        provide_automatic_options: bool | None = None,
        **options: t.Any,
    ) -> None:
        """"""Register a URL rule with the blueprint. See :meth:`.Flask.add_url_rule` for
        full documentation.

        The URL rule is prefixed with the blueprint's URL prefix. The endpoint name,
        used with :func:`url_for`, is prefixed with the blueprint's name.
        """"""
        if endpoint and ""."" in endpoint:
            raise ValueError(""'endpoint' may not contain a dot '.' character."")

        if view_func and hasattr(view_func, ""__name__"") and ""."" in view_func.__name__:
            raise ValueError(""'view_func' name may not contain a dot '.' character."")

        self.record(
            lambda s: s.add_url_rule(
                rule,
                endpoint,
                view_func,
                provide_automatic_options=provide_automatic_options,
                **options,
            )
        )",False
ca9069882255da60cc0d50ae24217ebd2b62d28d,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\blueprints.py,method,app_template_filter,Blueprint.app_template_filter,444,458,"Register a template filter, available in any template rendered by the
application. Equivalent to :meth:`.Flask.template_filter`.

:param name: the optional name of the filter, otherwise the
             function name will be used.","    def app_template_filter(
        self, name: str | None = None
    ) -> t.Callable[[T_template_filter], T_template_filter]:
        """"""Register a template filter, available in any template rendered by the
        application. Equivalent to :meth:`.Flask.template_filter`.

        :param name: the optional name of the filter, otherwise the
                     function name will be used.
        """"""

        def decorator(f: T_template_filter) -> T_template_filter:
            self.add_app_template_filter(f, name=name)
            return f

        return decorator",False
378b4375ddd68319c2ca0ee7832f05511a9e32e3,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\blueprints.py,method,add_app_template_filter,Blueprint.add_app_template_filter,461,475,"Register a template filter, available in any template rendered by the
application. Works like the :meth:`app_template_filter` decorator. Equivalent to
:meth:`.Flask.add_template_filter`.

:param name: the optional name of the filter, otherwise the
             function name will be used.","    def add_app_template_filter(
        self, f: ft.TemplateFilterCallable, name: str | None = None
    ) -> None:
        """"""Register a template filter, available in any template rendered by the
        application. Works like the :meth:`app_template_filter` decorator. Equivalent to
        :meth:`.Flask.add_template_filter`.

        :param name: the optional name of the filter, otherwise the
                     function name will be used.
        """"""

        def register_template(state: BlueprintSetupState) -> None:
            state.app.jinja_env.filters[name or f.__name__] = f

        self.record_once(register_template)",False
5326a1725a58e81c9da2975225e954c86e169c95,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\blueprints.py,method,app_template_test,Blueprint.app_template_test,478,494,"Register a template test, available in any template rendered by the
application. Equivalent to :meth:`.Flask.template_test`.

.. versionadded:: 0.10

:param name: the optional name of the test, otherwise the
             function name will be used.","    def app_template_test(
        self, name: str | None = None
    ) -> t.Callable[[T_template_test], T_template_test]:
        """"""Register a template test, available in any template rendered by the
        application. Equivalent to :meth:`.Flask.template_test`.

        .. versionadded:: 0.10

        :param name: the optional name of the test, otherwise the
                     function name will be used.
        """"""

        def decorator(f: T_template_test) -> T_template_test:
            self.add_app_template_test(f, name=name)
            return f

        return decorator",False
e8c4994bbbf204f08e9eb25b0e4101a0d5882f61,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\blueprints.py,method,add_app_template_test,Blueprint.add_app_template_test,497,513,"Register a template test, available in any template rendered by the
application. Works like the :meth:`app_template_test` decorator. Equivalent to
:meth:`.Flask.add_template_test`.

.. versionadded:: 0.10

:param name: the optional name of the test, otherwise the
             function name will be used.","    def add_app_template_test(
        self, f: ft.TemplateTestCallable, name: str | None = None
    ) -> None:
        """"""Register a template test, available in any template rendered by the
        application. Works like the :meth:`app_template_test` decorator. Equivalent to
        :meth:`.Flask.add_template_test`.

        .. versionadded:: 0.10

        :param name: the optional name of the test, otherwise the
                     function name will be used.
        """"""

        def register_template(state: BlueprintSetupState) -> None:
            state.app.jinja_env.tests[name or f.__name__] = f

        self.record_once(register_template)",False
89f6b178a99873ebce20ae994752030d18b35cad,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\blueprints.py,method,app_template_global,Blueprint.app_template_global,516,532,"Register a template global, available in any template rendered by the
application. Equivalent to :meth:`.Flask.template_global`.

.. versionadded:: 0.10

:param name: the optional name of the global, otherwise the
             function name will be used.","    def app_template_global(
        self, name: str | None = None
    ) -> t.Callable[[T_template_global], T_template_global]:
        """"""Register a template global, available in any template rendered by the
        application. Equivalent to :meth:`.Flask.template_global`.

        .. versionadded:: 0.10

        :param name: the optional name of the global, otherwise the
                     function name will be used.
        """"""

        def decorator(f: T_template_global) -> T_template_global:
            self.add_app_template_global(f, name=name)
            return f

        return decorator",False
9ddb74d21f370f8250ffd43dcdf5321d8210e7da,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\blueprints.py,method,add_app_template_global,Blueprint.add_app_template_global,535,551,"Register a template global, available in any template rendered by the
application. Works like the :meth:`app_template_global` decorator. Equivalent to
:meth:`.Flask.add_template_global`.

.. versionadded:: 0.10

:param name: the optional name of the global, otherwise the
             function name will be used.","    def add_app_template_global(
        self, f: ft.TemplateGlobalCallable, name: str | None = None
    ) -> None:
        """"""Register a template global, available in any template rendered by the
        application. Works like the :meth:`app_template_global` decorator. Equivalent to
        :meth:`.Flask.add_template_global`.

        .. versionadded:: 0.10

        :param name: the optional name of the global, otherwise the
                     function name will be used.
        """"""

        def register_template(state: BlueprintSetupState) -> None:
            state.app.jinja_env.globals[name or f.__name__] = f

        self.record_once(register_template)",False
d0e25a3bd2b4e073ff754483036396a315715c1b,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\blueprints.py,method,before_app_request,Blueprint.before_app_request,554,561,"Like :meth:`before_request`, but before every request, not only those handled
by the blueprint. Equivalent to :meth:`.Flask.before_request`.","    def before_app_request(self, f: T_before_request) -> T_before_request:
        """"""Like :meth:`before_request`, but before every request, not only those handled
        by the blueprint. Equivalent to :meth:`.Flask.before_request`.
        """"""
        self.record_once(
            lambda s: s.app.before_request_funcs.setdefault(None, []).append(f)
        )
        return f",False
c19a26db512d86a71223c4bcd2f571bed8fc3277,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\blueprints.py,method,after_app_request,Blueprint.after_app_request,564,571,"Like :meth:`after_request`, but after every request, not only those handled
by the blueprint. Equivalent to :meth:`.Flask.after_request`.","    def after_app_request(self, f: T_after_request) -> T_after_request:
        """"""Like :meth:`after_request`, but after every request, not only those handled
        by the blueprint. Equivalent to :meth:`.Flask.after_request`.
        """"""
        self.record_once(
            lambda s: s.app.after_request_funcs.setdefault(None, []).append(f)
        )
        return f",False
e2ddd853876ade931d7ed5d4e852a9dd33cc1194,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\blueprints.py,method,teardown_app_request,Blueprint.teardown_app_request,574,581,"Like :meth:`teardown_request`, but after every request, not only those
handled by the blueprint. Equivalent to :meth:`.Flask.teardown_request`.","    def teardown_app_request(self, f: T_teardown) -> T_teardown:
        """"""Like :meth:`teardown_request`, but after every request, not only those
        handled by the blueprint. Equivalent to :meth:`.Flask.teardown_request`.
        """"""
        self.record_once(
            lambda s: s.app.teardown_request_funcs.setdefault(None, []).append(f)
        )
        return f",False
4c51b8a8ab88e2317e44c3d5de87e4700d6ec3f4,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\blueprints.py,method,app_context_processor,Blueprint.app_context_processor,584,593,"Like :meth:`context_processor`, but for templates rendered by every view, not
only by the blueprint. Equivalent to :meth:`.Flask.context_processor`.","    def app_context_processor(
        self, f: T_template_context_processor
    ) -> T_template_context_processor:
        """"""Like :meth:`context_processor`, but for templates rendered by every view, not
        only by the blueprint. Equivalent to :meth:`.Flask.context_processor`.
        """"""
        self.record_once(
            lambda s: s.app.template_context_processors.setdefault(None, []).append(f)
        )
        return f",False
cda2b45a8dcaf8db39532ef6eee41af4035234a0,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\blueprints.py,method,app_errorhandler,Blueprint.app_errorhandler,596,610,"Like :meth:`errorhandler`, but for every request, not only those handled by
the blueprint. Equivalent to :meth:`.Flask.errorhandler`.","    def app_errorhandler(
        self, code: type[Exception] | int
    ) -> t.Callable[[T_error_handler], T_error_handler]:
        """"""Like :meth:`errorhandler`, but for every request, not only those handled by
        the blueprint. Equivalent to :meth:`.Flask.errorhandler`.
        """"""

        def decorator(f: T_error_handler) -> T_error_handler:
            def from_blueprint(state: BlueprintSetupState) -> None:
                state.app.errorhandler(code)(f)

            self.record_once(from_blueprint)
            return f

        return decorator",False
6191cddbe7cb97660d4272b5315e9df7db50b0ec,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\blueprints.py,method,app_url_value_preprocessor,Blueprint.app_url_value_preprocessor,613,622,"Like :meth:`url_value_preprocessor`, but for every request, not only those
handled by the blueprint. Equivalent to :meth:`.Flask.url_value_preprocessor`.","    def app_url_value_preprocessor(
        self, f: T_url_value_preprocessor
    ) -> T_url_value_preprocessor:
        """"""Like :meth:`url_value_preprocessor`, but for every request, not only those
        handled by the blueprint. Equivalent to :meth:`.Flask.url_value_preprocessor`.
        """"""
        self.record_once(
            lambda s: s.app.url_value_preprocessors.setdefault(None, []).append(f)
        )
        return f",False
8c67db6e91094948956abd7c6e573ef75dc8be66,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\blueprints.py,method,app_url_defaults,Blueprint.app_url_defaults,625,632,"Like :meth:`url_defaults`, but for every request, not only those handled by
the blueprint. Equivalent to :meth:`.Flask.url_defaults`.","    def app_url_defaults(self, f: T_url_defaults) -> T_url_defaults:
        """"""Like :meth:`url_defaults`, but for every request, not only those handled by
        the blueprint. Equivalent to :meth:`.Flask.url_defaults`.
        """"""
        self.record_once(
            lambda s: s.app.url_default_functions.setdefault(None, []).append(f)
        )
        return f",False
05e91afd01dc698b08ad76bf0adb047235c40edc,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,function,setupmethod,setupmethod,42,49,,"def setupmethod(f: F) -> F:
    f_name = f.__name__

    def wrapper_func(self: Scaffold, *args: t.Any, **kwargs: t.Any) -> t.Any:
        self._check_setup_finished(f_name)
        return f(self, *args, **kwargs)

    return t.cast(F, update_wrapper(wrapper_func, f))",False
8e0ec1897600e6fbc6e4ac95b19400cb38009677,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,class,Scaffold,Scaffold,52,698,"Common behavior shared between :class:`~flask.Flask` and
:class:`~flask.blueprints.Blueprint`.

:param import_name: The import name of the module where this object
    is defined. Usually :attr:`__name__` should be used.
:param static_folder: Path to a folder of static files to serve.
    If this is set, a static route will be added.
:param static_url_path: URL prefix for the static route.
:param template_folder: Path to a folder containing template files.
    for rendering. If this is set, a Jinja loader will be added.
:param root_path: The path that static, template, and resource files
    are relative to. Typically not set, it is discovered based on
    the ``import_name``.

.. versionadded:: 2.0","class Scaffold:
    """"""Common behavior shared between :class:`~flask.Flask` and
    :class:`~flask.blueprints.Blueprint`.

    :param import_name: The import name of the module where this object
        is defined. Usually :attr:`__name__` should be used.
    :param static_folder: Path to a folder of static files to serve.
        If this is set, a static route will be added.
    :param static_url_path: URL prefix for the static route.
    :param template_folder: Path to a folder containing template files.
        for rendering. If this is set, a Jinja loader will be added.
    :param root_path: The path that static, template, and resource files
        are relative to. Typically not set, it is discovered based on
        the ``import_name``.

    .. versionadded:: 2.0
    """"""

    cli: Group
    name: str
    _static_folder: str | None = None
    _static_url_path: str | None = None

    def __init__(
        self,
        import_name: str,
        static_folder: str | os.PathLike[str] | None = None,
        static_url_path: str | None = None,
        template_folder: str | os.PathLike[str] | None = None,
        root_path: str | None = None,
    ):
        #: The name of the package or module that this object belongs
        #: to. Do not change this once it is set by the constructor.
        self.import_name = import_name

        self.static_folder = static_folder
        self.static_url_path = static_url_path

        #: The path to the templates folder, relative to
        #: :attr:`root_path`, to add to the template loader. ``None`` if
        #: templates should not be added.
        self.template_folder = template_folder

        if root_path is None:
            root_path = get_root_path(self.import_name)

        #: Absolute path to the package on the filesystem. Used to look
        #: up resources contained in the package.
        self.root_path = root_path

        #: A dictionary mapping endpoint names to view functions.
        #:
        #: To register a view function, use the :meth:`route` decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
        self.view_functions: dict[str, ft.RouteCallable] = {}

        #: A data structure of registered error handlers, in the format
        #: ``{scope: {code: {class: handler}}}``. The ``scope`` key is
        #: the name of a blueprint the handlers are active for, or
        #: ``None`` for all requests. The ``code`` key is the HTTP
        #: status code for ``HTTPException``, or ``None`` for
        #: other exceptions. The innermost dictionary maps exception
        #: classes to handler functions.
        #:
        #: To register an error handler, use the :meth:`errorhandler`
        #: decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
        self.error_handler_spec: dict[
            ft.AppOrBlueprintKey,
            dict[int | None, dict[type[Exception], ft.ErrorHandlerCallable]],
        ] = defaultdict(lambda: defaultdict(dict))

        #: A data structure of functions to call at the beginning of
        #: each request, in the format ``{scope: [functions]}``. The
        #: ``scope`` key is the name of a blueprint the functions are
        #: active for, or ``None`` for all requests.
        #:
        #: To register a function, use the :meth:`before_request`
        #: decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
        self.before_request_funcs: dict[
            ft.AppOrBlueprintKey, list[ft.BeforeRequestCallable]
        ] = defaultdict(list)

        #: A data structure of functions to call at the end of each
        #: request, in the format ``{scope: [functions]}``. The
        #: ``scope`` key is the name of a blueprint the functions are
        #: active for, or ``None`` for all requests.
        #:
        #: To register a function, use the :meth:`after_request`
        #: decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
        self.after_request_funcs: dict[
            ft.AppOrBlueprintKey, list[ft.AfterRequestCallable[t.Any]]
        ] = defaultdict(list)

        #: A data structure of functions to call at the end of each
        #: request even if an exception is raised, in the format
        #: ``{scope: [functions]}``. The ``scope`` key is the name of a
        #: blueprint the functions are active for, or ``None`` for all
        #: requests.
        #:
        #: To register a function, use the :meth:`teardown_request`
        #: decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
        self.teardown_request_funcs: dict[
            ft.AppOrBlueprintKey, list[ft.TeardownCallable]
        ] = defaultdict(list)

        #: A data structure of functions to call to pass extra context
        #: values when rendering templates, in the format
        #: ``{scope: [functions]}``. The ``scope`` key is the name of a
        #: blueprint the functions are active for, or ``None`` for all
        #: requests.
        #:
        #: To register a function, use the :meth:`context_processor`
        #: decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
        self.template_context_processors: dict[
            ft.AppOrBlueprintKey, list[ft.TemplateContextProcessorCallable]
        ] = defaultdict(list, {None: [_default_template_ctx_processor]})

        #: A data structure of functions to call to modify the keyword
        #: arguments passed to the view function, in the format
        #: ``{scope: [functions]}``. The ``scope`` key is the name of a
        #: blueprint the functions are active for, or ``None`` for all
        #: requests.
        #:
        #: To register a function, use the
        #: :meth:`url_value_preprocessor` decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
        self.url_value_preprocessors: dict[
            ft.AppOrBlueprintKey,
            list[ft.URLValuePreprocessorCallable],
        ] = defaultdict(list)

        #: A data structure of functions to call to modify the keyword
        #: arguments when generating URLs, in the format
        #: ``{scope: [functions]}``. The ``scope`` key is the name of a
        #: blueprint the functions are active for, or ``None`` for all
        #: requests.
        #:
        #: To register a function, use the :meth:`url_defaults`
        #: decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
        self.url_default_functions: dict[
            ft.AppOrBlueprintKey, list[ft.URLDefaultCallable]
        ] = defaultdict(list)

    def __repr__(self) -> str:
        return f""<{type(self).__name__} {self.name!r}>""

    def _check_setup_finished(self, f_name: str) -> None:
        raise NotImplementedError

    @property
    def static_folder(self) -> str | None:
        """"""The absolute path to the configured static folder. ``None``
        if no static folder is set.
        """"""
        if self._static_folder is not None:
            return os.path.join(self.root_path, self._static_folder)
        else:
            return None

    @static_folder.setter
    def static_folder(self, value: str | os.PathLike[str] | None) -> None:
        if value is not None:
            value = os.fspath(value).rstrip(r""\/"")

        self._static_folder = value

    @property
    def has_static_folder(self) -> bool
...<truncated>...
",True
249b7c49c275bc4a8326279c76c88b136abf4c1b,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,method,__init__,Scaffold.__init__,75,215,,"    def __init__(
        self,
        import_name: str,
        static_folder: str | os.PathLike[str] | None = None,
        static_url_path: str | None = None,
        template_folder: str | os.PathLike[str] | None = None,
        root_path: str | None = None,
    ):
        #: The name of the package or module that this object belongs
        #: to. Do not change this once it is set by the constructor.
        self.import_name = import_name

        self.static_folder = static_folder
        self.static_url_path = static_url_path

        #: The path to the templates folder, relative to
        #: :attr:`root_path`, to add to the template loader. ``None`` if
        #: templates should not be added.
        self.template_folder = template_folder

        if root_path is None:
            root_path = get_root_path(self.import_name)

        #: Absolute path to the package on the filesystem. Used to look
        #: up resources contained in the package.
        self.root_path = root_path

        #: A dictionary mapping endpoint names to view functions.
        #:
        #: To register a view function, use the :meth:`route` decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
        self.view_functions: dict[str, ft.RouteCallable] = {}

        #: A data structure of registered error handlers, in the format
        #: ``{scope: {code: {class: handler}}}``. The ``scope`` key is
        #: the name of a blueprint the handlers are active for, or
        #: ``None`` for all requests. The ``code`` key is the HTTP
        #: status code for ``HTTPException``, or ``None`` for
        #: other exceptions. The innermost dictionary maps exception
        #: classes to handler functions.
        #:
        #: To register an error handler, use the :meth:`errorhandler`
        #: decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
        self.error_handler_spec: dict[
            ft.AppOrBlueprintKey,
            dict[int | None, dict[type[Exception], ft.ErrorHandlerCallable]],
        ] = defaultdict(lambda: defaultdict(dict))

        #: A data structure of functions to call at the beginning of
        #: each request, in the format ``{scope: [functions]}``. The
        #: ``scope`` key is the name of a blueprint the functions are
        #: active for, or ``None`` for all requests.
        #:
        #: To register a function, use the :meth:`before_request`
        #: decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
        self.before_request_funcs: dict[
            ft.AppOrBlueprintKey, list[ft.BeforeRequestCallable]
        ] = defaultdict(list)

        #: A data structure of functions to call at the end of each
        #: request, in the format ``{scope: [functions]}``. The
        #: ``scope`` key is the name of a blueprint the functions are
        #: active for, or ``None`` for all requests.
        #:
        #: To register a function, use the :meth:`after_request`
        #: decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
        self.after_request_funcs: dict[
            ft.AppOrBlueprintKey, list[ft.AfterRequestCallable[t.Any]]
        ] = defaultdict(list)

        #: A data structure of functions to call at the end of each
        #: request even if an exception is raised, in the format
        #: ``{scope: [functions]}``. The ``scope`` key is the name of a
        #: blueprint the functions are active for, or ``None`` for all
        #: requests.
        #:
        #: To register a function, use the :meth:`teardown_request`
        #: decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
        self.teardown_request_funcs: dict[
            ft.AppOrBlueprintKey, list[ft.TeardownCallable]
        ] = defaultdict(list)

        #: A data structure of functions to call to pass extra context
        #: values when rendering templates, in the format
        #: ``{scope: [functions]}``. The ``scope`` key is the name of a
        #: blueprint the functions are active for, or ``None`` for all
        #: requests.
        #:
        #: To register a function, use the :meth:`context_processor`
        #: decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
        self.template_context_processors: dict[
            ft.AppOrBlueprintKey, list[ft.TemplateContextProcessorCallable]
        ] = defaultdict(list, {None: [_default_template_ctx_processor]})

        #: A data structure of functions to call to modify the keyword
        #: arguments passed to the view function, in the format
        #: ``{scope: [functions]}``. The ``scope`` key is the name of a
        #: blueprint the functions are active for, or ``None`` for all
        #: requests.
        #:
        #: To register a function, use the
        #: :meth:`url_value_preprocessor` decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
        self.url_value_preprocessors: dict[
            ft.AppOrBlueprintKey,
            list[ft.URLValuePreprocessorCallable],
        ] = defaultdict(list)

        #: A data structure of functions to call to modify the keyword
        #: arguments when generating URLs, in the format
        #: ``{scope: [functions]}``. The ``scope`` key is the name of a
        #: blueprint the functions are active for, or ``None`` for all
        #: requests.
        #:
        #: To register a function, use the :meth:`url_defaults`
        #: decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
        self.url_default_functions: dict[
            ft.AppOrBlueprintKey, list[ft.URLDefaultCallable]
        ] = defaultdict(list)",False
611beb9a02b1d71cd2cead88a75f3abc9b658053,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,method,__repr__,Scaffold.__repr__,217,218,,"    def __repr__(self) -> str:
        return f""<{type(self).__name__} {self.name!r}>""",False
03d086c77c070722ef1941cff00694f8754498de,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,method,_check_setup_finished,Scaffold._check_setup_finished,220,221,,"    def _check_setup_finished(self, f_name: str) -> None:
        raise NotImplementedError",False
9247c94e92f20fdc343e7ab179357f8ac934eadb,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,method,static_folder,Scaffold.static_folder,224,231,"The absolute path to the configured static folder. ``None``
if no static folder is set.","    def static_folder(self) -> str | None:
        """"""The absolute path to the configured static folder. ``None``
        if no static folder is set.
        """"""
        if self._static_folder is not None:
            return os.path.join(self.root_path, self._static_folder)
        else:
            return None",False
69be2bba82b3b6ca75ac3001ae180933808a41a9,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,method,static_folder,Scaffold.static_folder,234,238,,"    def static_folder(self, value: str | os.PathLike[str] | None) -> None:
        if value is not None:
            value = os.fspath(value).rstrip(r""\/"")

        self._static_folder = value",False
d9156a1a6be2d48c54e7ad4e85e58a0c8f619c85,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,method,has_static_folder,Scaffold.has_static_folder,241,246,"``True`` if :attr:`static_folder` is set.

.. versionadded:: 0.5","    def has_static_folder(self) -> bool:
        """"""``True`` if :attr:`static_folder` is set.

        .. versionadded:: 0.5
        """"""
        return self.static_folder is not None",False
98d2b9e24c28a5eab62c9c8ef2656e02120fccb9,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,method,static_url_path,Scaffold.static_url_path,249,262,"The URL prefix that the static route will be accessible from.

If it was not configured during init, it is derived from
:attr:`static_folder`.","    def static_url_path(self) -> str | None:
        """"""The URL prefix that the static route will be accessible from.

        If it was not configured during init, it is derived from
        :attr:`static_folder`.
        """"""
        if self._static_url_path is not None:
            return self._static_url_path

        if self.static_folder is not None:
            basename = os.path.basename(self.static_folder)
            return f""/{basename}"".rstrip(""/"")

        return None",False
55a983241687196d6d93fc5dc2c071361c24b2f9,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,method,static_url_path,Scaffold.static_url_path,265,269,,"    def static_url_path(self, value: str | None) -> None:
        if value is not None:
            value = value.rstrip(""/"")

        self._static_url_path = value",False
4f5cc157cb71fb544b624cb9305b25f857925881,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,method,jinja_loader,Scaffold.jinja_loader,272,282,"The Jinja loader for this object's templates. By default this
is a class :class:`jinja2.loaders.FileSystemLoader` to
:attr:`template_folder` if it is set.

.. versionadded:: 0.5","    def jinja_loader(self) -> BaseLoader | None:
        """"""The Jinja loader for this object's templates. By default this
        is a class :class:`jinja2.loaders.FileSystemLoader` to
        :attr:`template_folder` if it is set.

        .. versionadded:: 0.5
        """"""
        if self.template_folder is not None:
            return FileSystemLoader(os.path.join(self.root_path, self.template_folder))
        else:
            return None",False
4af640e7e06d11cdf8ea784937fe3d22f46c5e4d,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,method,_method_route,Scaffold._method_route,284,293,,"    def _method_route(
        self,
        method: str,
        rule: str,
        options: dict[str, t.Any],
    ) -> t.Callable[[T_route], T_route]:
        if ""methods"" in options:
            raise TypeError(""Use the 'route' decorator to use the 'methods' argument."")

        return self.route(rule, methods=[method], **options)",False
0747d75901073e225a4c23c21f6cf4f83cafadda,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,method,get,Scaffold.get,296,301,"Shortcut for :meth:`route` with ``methods=[""GET""]``.

.. versionadded:: 2.0","    def get(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:
        """"""Shortcut for :meth:`route` with ``methods=[""GET""]``.

        .. versionadded:: 2.0
        """"""
        return self._method_route(""GET"", rule, options)",False
1119173357bbfc9df42dd4d116a7159bc7f00d8b,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,method,post,Scaffold.post,304,309,"Shortcut for :meth:`route` with ``methods=[""POST""]``.

.. versionadded:: 2.0","    def post(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:
        """"""Shortcut for :meth:`route` with ``methods=[""POST""]``.

        .. versionadded:: 2.0
        """"""
        return self._method_route(""POST"", rule, options)",False
af1b9bc776d2e8aaf509de16ff78884cc4b66673,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,method,put,Scaffold.put,312,317,"Shortcut for :meth:`route` with ``methods=[""PUT""]``.

.. versionadded:: 2.0","    def put(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:
        """"""Shortcut for :meth:`route` with ``methods=[""PUT""]``.

        .. versionadded:: 2.0
        """"""
        return self._method_route(""PUT"", rule, options)",False
0e53684e4adc2cf5290f6a4274bd7f8f7e73adf0,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,method,delete,Scaffold.delete,320,325,"Shortcut for :meth:`route` with ``methods=[""DELETE""]``.

.. versionadded:: 2.0","    def delete(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:
        """"""Shortcut for :meth:`route` with ``methods=[""DELETE""]``.

        .. versionadded:: 2.0
        """"""
        return self._method_route(""DELETE"", rule, options)",False
314078b6d2ad097294306e03a03fa1b2e1b9a6b2,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,method,patch,Scaffold.patch,328,333,"Shortcut for :meth:`route` with ``methods=[""PATCH""]``.

.. versionadded:: 2.0","    def patch(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:
        """"""Shortcut for :meth:`route` with ``methods=[""PATCH""]``.

        .. versionadded:: 2.0
        """"""
        return self._method_route(""PATCH"", rule, options)",False
5459d1828a8ff0c86a4589cf51f5570b17081caa,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,method,route,Scaffold.route,336,365,"Decorate a view function to register it with the given URL
rule and options. Calls :meth:`add_url_rule`, which has more
details about the implementation.

.. code-block:: python

    @app.route(""/"")
    def index():
        return ""Hello, World!""

See :ref:`url-route-registrations`.

The endpoint name for the route defaults to the name of the view
function if the ``endpoint`` parameter isn't passed.

The ``methods`` parameter defaults to ``[""GET""]``. ``HEAD`` and
``OPTIONS`` are added automatically.

:param rule: The URL rule string.
:param options: Extra options passed to the
    :class:`~werkzeug.routing.Rule` object.","    def route(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:
        """"""Decorate a view function to register it with the given URL
        rule and options. Calls :meth:`add_url_rule`, which has more
        details about the implementation.

        .. code-block:: python

            @app.route(""/"")
            def index():
                return ""Hello, World!""

        See :ref:`url-route-registrations`.

        The endpoint name for the route defaults to the name of the view
        function if the ``endpoint`` parameter isn't passed.

        The ``methods`` parameter defaults to ``[""GET""]``. ``HEAD`` and
        ``OPTIONS`` are added automatically.

        :param rule: The URL rule string.
        :param options: Extra options passed to the
            :class:`~werkzeug.routing.Rule` object.
        """"""

        def decorator(f: T_route) -> T_route:
            endpoint = options.pop(""endpoint"", None)
            self.add_url_rule(rule, endpoint, f, **options)
            return f

        return decorator",False
7babe777293f2a8cca496c96ddc8706eede1c771,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,method,add_url_rule,Scaffold.add_url_rule,368,433,"Register a rule for routing incoming requests and building
URLs. The :meth:`route` decorator is a shortcut to call this
with the ``view_func`` argument. These are equivalent:

.. code-block:: python

    @app.route(""/"")
    def index():
        ...

.. code-block:: python

    def index():
        ...

    app.add_url_rule(""/"", view_func=index)

See :ref:`url-route-registrations`.

The endpoint name for the route defaults to the name of the view
function if the ``endpoint`` parameter isn't passed. An error
will be raised if a function has already been registered for the
endpoint.

The ``methods`` parameter defaults to ``[""GET""]``. ``HEAD`` is
always added automatically, and ``OPTIONS`` is added
automatically by default.

``view_func`` does not necessarily need to be passed, but if the
rule should participate in routing an endpoint name must be
associated with a view function at some point with the
:meth:`endpoint` decorator.

.. code-block:: python

    app.add_url_rule(""/"", endpoint=""index"")

    @app.endpoint(""index"")
    def index():
        ...

If ``view_func`` has a ``required_methods`` attribute, those
methods are added to the passed and automatic methods. If it
has a ``provide_automatic_methods`` attribute, it is used as the
default if the parameter is not passed.

:param rule: The URL rule string.
:param endpoint: The endpoint name to associate with the rule
    and view function. Used when routing and building URLs.
    Defaults to ``view_func.__name__``.
:param view_func: The view function to associate with the
    endpoint name.
:param provide_automatic_options: Add the ``OPTIONS`` method and
    respond to ``OPTIONS`` requests automatically.
:param options: Extra options passed to the
    :class:`~werkzeug.routing.Rule` object.","    def add_url_rule(
        self,
        rule: str,
        endpoint: str | None = None,
        view_func: ft.RouteCallable | None = None,
        provide_automatic_options: bool | None = None,
        **options: t.Any,
    ) -> None:
        """"""Register a rule for routing incoming requests and building
        URLs. The :meth:`route` decorator is a shortcut to call this
        with the ``view_func`` argument. These are equivalent:

        .. code-block:: python

            @app.route(""/"")
            def index():
                ...

        .. code-block:: python

            def index():
                ...

            app.add_url_rule(""/"", view_func=index)

        See :ref:`url-route-registrations`.

        The endpoint name for the route defaults to the name of the view
        function if the ``endpoint`` parameter isn't passed. An error
        will be raised if a function has already been registered for the
        endpoint.

        The ``methods`` parameter defaults to ``[""GET""]``. ``HEAD`` is
        always added automatically, and ``OPTIONS`` is added
        automatically by default.

        ``view_func`` does not necessarily need to be passed, but if the
        rule should participate in routing an endpoint name must be
        associated with a view function at some point with the
        :meth:`endpoint` decorator.

        .. code-block:: python

            app.add_url_rule(""/"", endpoint=""index"")

            @app.endpoint(""index"")
            def index():
                ...

        If ``view_func`` has a ``required_methods`` attribute, those
        methods are added to the passed and automatic methods. If it
        has a ``provide_automatic_methods`` attribute, it is used as the
        default if the parameter is not passed.

        :param rule: The URL rule string.
        :param endpoint: The endpoint name to associate with the rule
            and view function. Used when routing and building URLs.
            Defaults to ``view_func.__name__``.
        :param view_func: The view function to associate with the
            endpoint name.
        :param provide_automatic_options: Add the ``OPTIONS`` method and
            respond to ``OPTIONS`` requests automatically.
        :param options: Extra options passed to the
            :class:`~werkzeug.routing.Rule` object.
        """"""
        raise NotImplementedError",False
4f21ccb0551be74d522c0fbca88828609f6503fb,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,method,endpoint,Scaffold.endpoint,436,457,"Decorate a view function to register it for the given
endpoint. Used if a rule is added without a ``view_func`` with
:meth:`add_url_rule`.

.. code-block:: python

    app.add_url_rule(""/ex"", endpoint=""example"")

    @app.endpoint(""example"")
    def example():
        ...

:param endpoint: The endpoint name to associate with the view
    function.","    def endpoint(self, endpoint: str) -> t.Callable[[F], F]:
        """"""Decorate a view function to register it for the given
        endpoint. Used if a rule is added without a ``view_func`` with
        :meth:`add_url_rule`.

        .. code-block:: python

            app.add_url_rule(""/ex"", endpoint=""example"")

            @app.endpoint(""example"")
            def example():
                ...

        :param endpoint: The endpoint name to associate with the view
            function.
        """"""

        def decorator(f: F) -> F:
            self.view_functions[endpoint] = f
            return f

        return decorator",False
4c2970425ab41d4079ee04af35417a1ed242cf16,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,method,before_request,Scaffold.before_request,460,484,"Register a function to run before each request.

For example, this can be used to open a database connection, or
to load the logged in user from the session.

.. code-block:: python

    @app.before_request
    def load_user():
        if ""user_id"" in session:
            g.user = db.session.get(session[""user_id""])

The function will be called without any arguments. If it returns
a non-``None`` value, the value is handled as if it was the
return value from the view, and further request handling is
stopped.

This is available on both app and blueprint objects. When used on an app, this
executes before every request. When used on a blueprint, this executes before
every request that the blueprint handles. To register with a blueprint and
execute before every request, use :meth:`.Blueprint.before_app_request`.","    def before_request(self, f: T_before_request) -> T_before_request:
        """"""Register a function to run before each request.

        For example, this can be used to open a database connection, or
        to load the logged in user from the session.

        .. code-block:: python

            @app.before_request
            def load_user():
                if ""user_id"" in session:
                    g.user = db.session.get(session[""user_id""])

        The function will be called without any arguments. If it returns
        a non-``None`` value, the value is handled as if it was the
        return value from the view, and further request handling is
        stopped.

        This is available on both app and blueprint objects. When used on an app, this
        executes before every request. When used on a blueprint, this executes before
        every request that the blueprint handles. To register with a blueprint and
        execute before every request, use :meth:`.Blueprint.before_app_request`.
        """"""
        self.before_request_funcs.setdefault(None, []).append(f)
        return f",False
d87ae98730a1c6ae7bb9935dedf725e0096089fe,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,method,after_request,Scaffold.after_request,487,505,"Register a function to run after each request to this object.

The function is called with the response object, and must return
a response object. This allows the functions to modify or
replace the response before it is sent.

If a function raises an exception, any remaining
``after_request`` functions will not be called. Therefore, this
should not be used for actions that must execute, such as to
close resources. Use :meth:`teardown_request` for that.

This is available on both app and blueprint objects. When used on an app, this
executes after every request. When used on a blueprint, this executes after
every request that the blueprint handles. To register with a blueprint and
execute after every request, use :meth:`.Blueprint.after_app_request`.","    def after_request(self, f: T_after_request) -> T_after_request:
        """"""Register a function to run after each request to this object.

        The function is called with the response object, and must return
        a response object. This allows the functions to modify or
        replace the response before it is sent.

        If a function raises an exception, any remaining
        ``after_request`` functions will not be called. Therefore, this
        should not be used for actions that must execute, such as to
        close resources. Use :meth:`teardown_request` for that.

        This is available on both app and blueprint objects. When used on an app, this
        executes after every request. When used on a blueprint, this executes after
        every request that the blueprint handles. To register with a blueprint and
        execute after every request, use :meth:`.Blueprint.after_app_request`.
        """"""
        self.after_request_funcs.setdefault(None, []).append(f)
        return f",False
4a74154eeeef49e5968ba1beb8e36cd6bf8d29de,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,method,teardown_request,Scaffold.teardown_request,508,539,"Register a function to be called when the request context is
popped. Typically this happens at the end of each request, but
contexts may be pushed manually as well during testing.

.. code-block:: python

    with app.test_request_context():
        ...

When the ``with`` block exits (or ``ctx.pop()`` is called), the
teardown functions are called just before the request context is
made inactive.

When a teardown function was called because of an unhandled
exception it will be passed an error object. If an
:meth:`errorhandler` is registered, it will handle the exception
and the teardown will not receive it.

Teardown functions must avoid raising exceptions. If they
execute code that might fail they must surround that code with a
``try``/``except`` block and log any errors.

The return values of teardown functions are ignored.

This is available on both app and blueprint objects. When used on an app, this
executes after every request. When used on a blueprint, this executes after
every request that the blueprint handles. To register with a blueprint and
execute after every request, use :meth:`.Blueprint.teardown_app_request`.","    def teardown_request(self, f: T_teardown) -> T_teardown:
        """"""Register a function to be called when the request context is
        popped. Typically this happens at the end of each request, but
        contexts may be pushed manually as well during testing.

        .. code-block:: python

            with app.test_request_context():
                ...

        When the ``with`` block exits (or ``ctx.pop()`` is called), the
        teardown functions are called just before the request context is
        made inactive.

        When a teardown function was called because of an unhandled
        exception it will be passed an error object. If an
        :meth:`errorhandler` is registered, it will handle the exception
        and the teardown will not receive it.

        Teardown functions must avoid raising exceptions. If they
        execute code that might fail they must surround that code with a
        ``try``/``except`` block and log any errors.

        The return values of teardown functions are ignored.

        This is available on both app and blueprint objects. When used on an app, this
        executes after every request. When used on a blueprint, this executes after
        every request that the blueprint handles. To register with a blueprint and
        execute after every request, use :meth:`.Blueprint.teardown_app_request`.
        """"""
        self.teardown_request_funcs.setdefault(None, []).append(f)
        return f",False
497a3c90d82eeb8caa272503f2864e4ae4c8a96b,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,method,context_processor,Scaffold.context_processor,542,556,"Registers a template context processor function. These functions run before
rendering a template. The keys of the returned dict are added as variables
available in the template.

This is available on both app and blueprint objects. When used on an app, this
is called for every rendered template. When used on a blueprint, this is called
for templates rendered from the blueprint's views. To register with a blueprint
and affect every template, use :meth:`.Blueprint.app_context_processor`.","    def context_processor(
        self,
        f: T_template_context_processor,
    ) -> T_template_context_processor:
        """"""Registers a template context processor function. These functions run before
        rendering a template. The keys of the returned dict are added as variables
        available in the template.

        This is available on both app and blueprint objects. When used on an app, this
        is called for every rendered template. When used on a blueprint, this is called
        for templates rendered from the blueprint's views. To register with a blueprint
        and affect every template, use :meth:`.Blueprint.app_context_processor`.
        """"""
        self.template_context_processors[None].append(f)
        return f",False
8f4d6c85195c17a8b0a97f7f7320bf216bd6e334,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,method,url_value_preprocessor,Scaffold.url_value_preprocessor,559,581,"Register a URL value preprocessor function for all view
functions in the application. These functions will be called before the
:meth:`before_request` functions.

The function can modify the values captured from the matched url before
they are passed to the view. For example, this can be used to pop a
common language code value and place it in ``g`` rather than pass it to
every view.

The function is passed the endpoint name and values dict. The return
value is ignored.

This is available on both app and blueprint objects. When used on an app, this
is called for every request. When used on a blueprint, this is called for
requests that the blueprint handles. To register with a blueprint and affect
every request, use :meth:`.Blueprint.app_url_value_preprocessor`.","    def url_value_preprocessor(
        self,
        f: T_url_value_preprocessor,
    ) -> T_url_value_preprocessor:
        """"""Register a URL value preprocessor function for all view
        functions in the application. These functions will be called before the
        :meth:`before_request` functions.

        The function can modify the values captured from the matched url before
        they are passed to the view. For example, this can be used to pop a
        common language code value and place it in ``g`` rather than pass it to
        every view.

        The function is passed the endpoint name and values dict. The return
        value is ignored.

        This is available on both app and blueprint objects. When used on an app, this
        is called for every request. When used on a blueprint, this is called for
        requests that the blueprint handles. To register with a blueprint and affect
        every request, use :meth:`.Blueprint.app_url_value_preprocessor`.
        """"""
        self.url_value_preprocessors[None].append(f)
        return f",False
a3398dc9a21c2376643493b9811f41a09d376a69,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,method,url_defaults,Scaffold.url_defaults,584,595,"Callback function for URL defaults for all view functions of the
application.  It's called with the endpoint and values and should
update the values passed in place.

This is available on both app and blueprint objects. When used on an app, this
is called for every request. When used on a blueprint, this is called for
requests that the blueprint handles. To register with a blueprint and affect
every request, use :meth:`.Blueprint.app_url_defaults`.","    def url_defaults(self, f: T_url_defaults) -> T_url_defaults:
        """"""Callback function for URL defaults for all view functions of the
        application.  It's called with the endpoint and values and should
        update the values passed in place.

        This is available on both app and blueprint objects. When used on an app, this
        is called for every request. When used on a blueprint, this is called for
        requests that the blueprint handles. To register with a blueprint and affect
        every request, use :meth:`.Blueprint.app_url_defaults`.
        """"""
        self.url_default_functions[None].append(f)
        return f",False
2557f46e899624d3ea41ba8aadb8b5fb7fc38070,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,method,errorhandler,Scaffold.errorhandler,598,639,"Register a function to handle errors by code or exception class.

A decorator that is used to register a function given an
error code.  Example::

    @app.errorhandler(404)
    def page_not_found(error):
        return 'This page does not exist', 404

You can also register handlers for arbitrary exceptions::

    @app.errorhandler(DatabaseError)
    def special_exception_handler(error):
        return 'Database connection failed', 500

This is available on both app and blueprint objects. When used on an app, this
can handle errors from every request. When used on a blueprint, this can handle
errors from requests that the blueprint handles. To register with a blueprint
and affect every request, use :meth:`.Blueprint.app_errorhandler`.

.. versionadded:: 0.7
    Use :meth:`register_error_handler` instead of modifying
    :attr:`error_handler_spec` directly, for application wide error
    handlers.

.. versionadded:: 0.7
   One can now additionally also register custom exception types
   that do not necessarily have to be a subclass of the
   :class:`~werkzeug.exceptions.HTTPException` class.

:param code_or_exception: the code as integer for the handler, or
                          an arbitrary exception","    def errorhandler(
        self, code_or_exception: type[Exception] | int
    ) -> t.Callable[[T_error_handler], T_error_handler]:
        """"""Register a function to handle errors by code or exception class.

        A decorator that is used to register a function given an
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found(error):
                return 'This page does not exist', 404

        You can also register handlers for arbitrary exceptions::

            @app.errorhandler(DatabaseError)
            def special_exception_handler(error):
                return 'Database connection failed', 500

        This is available on both app and blueprint objects. When used on an app, this
        can handle errors from every request. When used on a blueprint, this can handle
        errors from requests that the blueprint handles. To register with a blueprint
        and affect every request, use :meth:`.Blueprint.app_errorhandler`.

        .. versionadded:: 0.7
            Use :meth:`register_error_handler` instead of modifying
            :attr:`error_handler_spec` directly, for application wide error
            handlers.

        .. versionadded:: 0.7
           One can now additionally also register custom exception types
           that do not necessarily have to be a subclass of the
           :class:`~werkzeug.exceptions.HTTPException` class.

        :param code_or_exception: the code as integer for the handler, or
                                  an arbitrary exception
        """"""

        def decorator(f: T_error_handler) -> T_error_handler:
            self.register_error_handler(code_or_exception, f)
            return f

        return decorator",False
879153e0105bce6d32f8da3c2fafde3bbacbea79,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,method,register_error_handler,Scaffold.register_error_handler,642,654,"Alternative error attach function to the :meth:`errorhandler`
decorator that is more straightforward to use for non decorator
usage.

.. versionadded:: 0.7","    def register_error_handler(
        self,
        code_or_exception: type[Exception] | int,
        f: ft.ErrorHandlerCallable,
    ) -> None:
        """"""Alternative error attach function to the :meth:`errorhandler`
        decorator that is more straightforward to use for non decorator
        usage.

        .. versionadded:: 0.7
        """"""
        exc_class, code = self._get_exc_class_and_code(code_or_exception)
        self.error_handler_spec[None][code][exc_class] = f",False
b333352e4473a01a1869157e8a110c69169c963e,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,method,_get_exc_class_and_code,Scaffold._get_exc_class_and_code,657,698,"Get the exception class being handled. For HTTP status codes
or ``HTTPException`` subclasses, return both the exception and
status code.

:param exc_class_or_code: Any exception class, or an HTTP status
    code as an integer.","    def _get_exc_class_and_code(
        exc_class_or_code: type[Exception] | int,
    ) -> tuple[type[Exception], int | None]:
        """"""Get the exception class being handled. For HTTP status codes
        or ``HTTPException`` subclasses, return both the exception and
        status code.

        :param exc_class_or_code: Any exception class, or an HTTP status
            code as an integer.
        """"""
        exc_class: type[Exception]

        if isinstance(exc_class_or_code, int):
            try:
                exc_class = default_exceptions[exc_class_or_code]
            except KeyError:
                raise ValueError(
                    f""'{exc_class_or_code}' is not a recognized HTTP""
                    "" error code. Use a subclass of HTTPException with""
                    "" that code instead.""
                ) from None
        else:
            exc_class = exc_class_or_code

        if isinstance(exc_class, Exception):
            raise TypeError(
                f""{exc_class!r} is an instance, not a class. Handlers""
                "" can only be registered for Exception classes or HTTP""
                "" error codes.""
            )

        if not issubclass(exc_class, Exception):
            raise ValueError(
                f""'{exc_class.__name__}' is not a subclass of Exception.""
                "" Handlers can only be registered for Exception classes""
                "" or HTTP error codes.""
            )

        if issubclass(exc_class, HTTPException):
            return exc_class, exc_class.code
        else:
            return exc_class, None",False
e07696ed4ecf664b480e879d17bfc71d432de4b0,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,function,_endpoint_from_view_func,_endpoint_from_view_func,701,706,"Internal helper that returns the default endpoint for a given
function.  This always is the function name.","def _endpoint_from_view_func(view_func: ft.RouteCallable) -> str:
    """"""Internal helper that returns the default endpoint for a given
    function.  This always is the function name.
    """"""
    assert view_func is not None, ""expected view func if endpoint is not provided.""
    return view_func.__name__",False
7dd242583cf743e623679c1927f3f5481feff401,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,function,_find_package_path,_find_package_path,709,751,Find the path that contains the package or module.,"def _find_package_path(import_name: str) -> str:
    """"""Find the path that contains the package or module.""""""
    root_mod_name, _, _ = import_name.partition(""."")

    try:
        root_spec = importlib.util.find_spec(root_mod_name)

        if root_spec is None:
            raise ValueError(""not found"")
    except (ImportError, ValueError):
        # ImportError: the machinery told us it does not exist
        # ValueError:
        #    - the module name was invalid
        #    - the module name is __main__
        #    - we raised `ValueError` due to `root_spec` being `None`
        return os.getcwd()

    if root_spec.submodule_search_locations:
        if root_spec.origin is None or root_spec.origin == ""namespace"":
            # namespace package
            package_spec = importlib.util.find_spec(import_name)

            if package_spec is not None and package_spec.submodule_search_locations:
                # Pick the path in the namespace that contains the submodule.
                package_path = pathlib.Path(
                    os.path.commonpath(package_spec.submodule_search_locations)
                )
                search_location = next(
                    location
                    for location in root_spec.submodule_search_locations
                    if package_path.is_relative_to(location)
                )
            else:
                # Pick the first path.
                search_location = root_spec.submodule_search_locations[0]

            return os.path.dirname(search_location)
        else:
            # package with __init__.py
            return os.path.dirname(os.path.dirname(root_spec.origin))
    else:
        # module
        return os.path.dirname(root_spec.origin)  # type: ignore[type-var, return-value]",False
7ff8c2c3890e727a62e6b02d9ef00d0a01a1f4d2,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sansio\scaffold.py,function,find_package,find_package,754,792,"Find the prefix that a package is installed under, and the path
that it would be imported from.

The prefix is the directory containing the standard directory
hierarchy (lib, bin, etc.). If the package is not installed to the
system (:attr:`sys.prefix`) or a virtualenv (``site-packages``),
``None`` is returned.

The path is the entry in :attr:`sys.path` that contains the package
for import. If the package is not installed, it's assumed that the
package was imported from the current working directory.","def find_package(import_name: str) -> tuple[str | None, str]:
    """"""Find the prefix that a package is installed under, and the path
    that it would be imported from.

    The prefix is the directory containing the standard directory
    hierarchy (lib, bin, etc.). If the package is not installed to the
    system (:attr:`sys.prefix`) or a virtualenv (``site-packages``),
    ``None`` is returned.

    The path is the entry in :attr:`sys.path` that contains the package
    for import. If the package is not installed, it's assumed that the
    package was imported from the current working directory.
    """"""
    package_path = _find_package_path(import_name)
    py_prefix = os.path.abspath(sys.prefix)

    # installed to the system
    if pathlib.PurePath(package_path).is_relative_to(py_prefix):
        return py_prefix, package_path

    site_parent, site_folder = os.path.split(package_path)

    # installed to a virtualenv
    if site_folder.lower() == ""site-packages"":
        parent, folder = os.path.split(site_parent)

        # Windows (prefix/lib/site-packages)
        if folder.lower() == ""lib"":
            return parent, package_path

        # Unix (prefix/lib/pythonX.Y/site-packages)
        if os.path.basename(parent).lower() == ""lib"":
            return os.path.dirname(parent), package_path

        # something else (prefix/site-packages)
        return site_parent, package_path

    # not installed
    return None, package_path",False
bf2f10b36bef8319eed6d913a26f8d33bede7711,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,class,SessionMixin,SessionMixin,24,49,Expands a basic dictionary with session attributes.,"class SessionMixin(MutableMapping[str, t.Any]):
    """"""Expands a basic dictionary with session attributes.""""""

    @property
    def permanent(self) -> bool:
        """"""This reflects the ``'_permanent'`` key in the dict.""""""
        return self.get(""_permanent"", False)

    @permanent.setter
    def permanent(self, value: bool) -> None:
        self[""_permanent""] = bool(value)

    #: Some implementations can detect whether a session is newly
    #: created, but that is not guaranteed. Use with caution. The mixin
    # default is hard-coded ``False``.
    new = False

    #: Some implementations can detect changes to the session and set
    #: this when that happens. The mixin default is hard coded to
    #: ``True``.
    modified = True

    #: Some implementations can detect when session data is read or
    #: written and set this when that happens. The mixin default is hard
    #: coded to ``True``.
    accessed = True",False
1a144d2330298a9e599b0f87381e388e84ec3b0f,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,method,permanent,SessionMixin.permanent,28,30,This reflects the ``'_permanent'`` key in the dict.,"    def permanent(self) -> bool:
        """"""This reflects the ``'_permanent'`` key in the dict.""""""
        return self.get(""_permanent"", False)",False
fdff8645247d153e869cd606c93ce5431b7c3186,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,method,permanent,SessionMixin.permanent,33,34,,"    def permanent(self, value: bool) -> None:
        self[""_permanent""] = bool(value)",False
374d8984d30bc846b16a090bed2d9f9c8dd55d8c,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,class,SecureCookieSession,SecureCookieSession,52,94,"Base class for sessions based on signed cookies.

This session backend will set the :attr:`modified` and
:attr:`accessed` attributes. It cannot reliably track whether a
session is new (vs. empty), so :attr:`new` remains hard coded to
``False``.","class SecureCookieSession(CallbackDict[str, t.Any], SessionMixin):
    """"""Base class for sessions based on signed cookies.

    This session backend will set the :attr:`modified` and
    :attr:`accessed` attributes. It cannot reliably track whether a
    session is new (vs. empty), so :attr:`new` remains hard coded to
    ``False``.
    """"""

    #: When data is changed, this is set to ``True``. Only the session
    #: dictionary itself is tracked; if the session contains mutable
    #: data (for example a nested dict) then this must be set to
    #: ``True`` manually when modifying that data. The session cookie
    #: will only be written to the response if this is ``True``.
    modified = False

    #: When data is read or written, this is set to ``True``. Used by
    # :class:`.SecureCookieSessionInterface` to add a ``Vary: Cookie``
    #: header, which allows caching proxies to cache different pages for
    #: different users.
    accessed = False

    def __init__(
        self,
        initial: c.Mapping[str, t.Any] | c.Iterable[tuple[str, t.Any]] | None = None,
    ) -> None:
        def on_update(self: te.Self) -> None:
            self.modified = True
            self.accessed = True

        super().__init__(initial, on_update)

    def __getitem__(self, key: str) -> t.Any:
        self.accessed = True
        return super().__getitem__(key)

    def get(self, key: str, default: t.Any = None) -> t.Any:
        self.accessed = True
        return super().get(key, default)

    def setdefault(self, key: str, default: t.Any = None) -> t.Any:
        self.accessed = True
        return super().setdefault(key, default)",False
50813ef32f6e00dd22167a32db604481db4b98a4,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,method,__init__,SecureCookieSession.__init__,74,82,,"    def __init__(
        self,
        initial: c.Mapping[str, t.Any] | c.Iterable[tuple[str, t.Any]] | None = None,
    ) -> None:
        def on_update(self: te.Self) -> None:
            self.modified = True
            self.accessed = True

        super().__init__(initial, on_update)",False
d503d3a9d5a64804736f81bcc1b2e89de1cea672,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,method,__getitem__,SecureCookieSession.__getitem__,84,86,,"    def __getitem__(self, key: str) -> t.Any:
        self.accessed = True
        return super().__getitem__(key)",False
5b5c0f391ac560b365738851b50850dbe0983f6b,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,method,get,SecureCookieSession.get,88,90,,"    def get(self, key: str, default: t.Any = None) -> t.Any:
        self.accessed = True
        return super().get(key, default)",False
1c94b9e60abe2ce1a9707e62cbdcbf1d229d0265,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,method,setdefault,SecureCookieSession.setdefault,92,94,,"    def setdefault(self, key: str, default: t.Any = None) -> t.Any:
        self.accessed = True
        return super().setdefault(key, default)",False
380a9dd34a2a34e3f834bd1035f331a684fe381c,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,class,NullSession,NullSession,97,111,"Class used to generate nicer error messages if sessions are not
available.  Will still allow read-only access to the empty session
but fail on setting.","class NullSession(SecureCookieSession):
    """"""Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """"""

    def _fail(self, *args: t.Any, **kwargs: t.Any) -> t.NoReturn:
        raise RuntimeError(
            ""The session is unavailable because no secret ""
            ""key was set.  Set the secret_key on the ""
            ""application to something unique and secret.""
        )

    __setitem__ = __delitem__ = clear = pop = popitem = update = setdefault = _fail  # noqa: B950
    del _fail",False
5c6a25d6b0fbcd8ebb9c95d18e831ff9a149b0ff,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,method,_fail,NullSession._fail,103,108,,"    def _fail(self, *args: t.Any, **kwargs: t.Any) -> t.NoReturn:
        raise RuntimeError(
            ""The session is unavailable because no secret ""
            ""key was set.  Set the secret_key on the ""
            ""application to something unique and secret.""
        )",False
b57df4a39960c9ab68703424b773d6cee46d7920,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,class,SessionInterface,SessionInterface,114,284,"The basic interface you have to implement in order to replace the
default session interface which uses werkzeug's securecookie
implementation.  The only methods you have to implement are
:meth:`open_session` and :meth:`save_session`, the others have
useful defaults which you don't need to change.

The session object returned by the :meth:`open_session` method has to
provide a dictionary like interface plus the properties and methods
from the :class:`SessionMixin`.  We recommend just subclassing a dict
and adding that mixin::

    class Session(dict, SessionMixin):
        pass

If :meth:`open_session` returns ``None`` Flask will call into
:meth:`make_null_session` to create a session that acts as replacement
if the session support cannot work because some requirement is not
fulfilled.  The default :class:`NullSession` class that is created
will complain that the secret key was not set.

To replace the session interface on an application all you have to do
is to assign :attr:`flask.Flask.session_interface`::

    app = Flask(__name__)
    app.session_interface = MySessionInterface()

Multiple requests with the same session may be sent and handled
concurrently. When implementing a new session interface, consider
whether reads or writes to the backing store must be synchronized.
There is no guarantee on the order in which the session for each
request is opened or saved, it will occur in the order that requests
begin and end processing.

.. versionadded:: 0.8","class SessionInterface:
    """"""The basic interface you have to implement in order to replace the
    default session interface which uses werkzeug's securecookie
    implementation.  The only methods you have to implement are
    :meth:`open_session` and :meth:`save_session`, the others have
    useful defaults which you don't need to change.

    The session object returned by the :meth:`open_session` method has to
    provide a dictionary like interface plus the properties and methods
    from the :class:`SessionMixin`.  We recommend just subclassing a dict
    and adding that mixin::

        class Session(dict, SessionMixin):
            pass

    If :meth:`open_session` returns ``None`` Flask will call into
    :meth:`make_null_session` to create a session that acts as replacement
    if the session support cannot work because some requirement is not
    fulfilled.  The default :class:`NullSession` class that is created
    will complain that the secret key was not set.

    To replace the session interface on an application all you have to do
    is to assign :attr:`flask.Flask.session_interface`::

        app = Flask(__name__)
        app.session_interface = MySessionInterface()

    Multiple requests with the same session may be sent and handled
    concurrently. When implementing a new session interface, consider
    whether reads or writes to the backing store must be synchronized.
    There is no guarantee on the order in which the session for each
    request is opened or saved, it will occur in the order that requests
    begin and end processing.

    .. versionadded:: 0.8
    """"""

    #: :meth:`make_null_session` will look here for the class that should
    #: be created when a null session is requested.  Likewise the
    #: :meth:`is_null_session` method will perform a typecheck against
    #: this type.
    null_session_class = NullSession

    #: A flag that indicates if the session interface is pickle based.
    #: This can be used by Flask extensions to make a decision in regards
    #: to how to deal with the session object.
    #:
    #: .. versionadded:: 0.10
    pickle_based = False

    def make_null_session(self, app: Flask) -> NullSession:
        """"""Creates a null session which acts as a replacement object if the
        real session support could not be loaded due to a configuration
        error.  This mainly aids the user experience because the job of the
        null session is to still support lookup without complaining but
        modifications are answered with a helpful error message of what
        failed.

        This creates an instance of :attr:`null_session_class` by default.
        """"""
        return self.null_session_class()

    def is_null_session(self, obj: object) -> bool:
        """"""Checks if a given object is a null session.  Null sessions are
        not asked to be saved.

        This checks if the object is an instance of :attr:`null_session_class`
        by default.
        """"""
        return isinstance(obj, self.null_session_class)

    def get_cookie_name(self, app: Flask) -> str:
        """"""The name of the session cookie. Uses``app.config[""SESSION_COOKIE_NAME""]``.""""""
        return app.config[""SESSION_COOKIE_NAME""]  # type: ignore[no-any-return]

    def get_cookie_domain(self, app: Flask) -> str | None:
        """"""The value of the ``Domain`` parameter on the session cookie. If not set,
        browsers will only send the cookie to the exact domain it was set from.
        Otherwise, they will send it to any subdomain of the given value as well.

        Uses the :data:`SESSION_COOKIE_DOMAIN` config.

        .. versionchanged:: 2.3
            Not set by default, does not fall back to ``SERVER_NAME``.
        """"""
        return app.config[""SESSION_COOKIE_DOMAIN""]  # type: ignore[no-any-return]

    def get_cookie_path(self, app: Flask) -> str:
        """"""Returns the path for which the cookie should be valid.  The
        default implementation uses the value from the ``SESSION_COOKIE_PATH``
        config var if it's set, and falls back to ``APPLICATION_ROOT`` or
        uses ``/`` if it's ``None``.
        """"""
        return app.config[""SESSION_COOKIE_PATH""] or app.config[""APPLICATION_ROOT""]  # type: ignore[no-any-return]

    def get_cookie_httponly(self, app: Flask) -> bool:
        """"""Returns True if the session cookie should be httponly.  This
        currently just returns the value of the ``SESSION_COOKIE_HTTPONLY``
        config var.
        """"""
        return app.config[""SESSION_COOKIE_HTTPONLY""]  # type: ignore[no-any-return]

    def get_cookie_secure(self, app: Flask) -> bool:
        """"""Returns True if the cookie should be secure.  This currently
        just returns the value of the ``SESSION_COOKIE_SECURE`` setting.
        """"""
        return app.config[""SESSION_COOKIE_SECURE""]  # type: ignore[no-any-return]

    def get_cookie_samesite(self, app: Flask) -> str | None:
        """"""Return ``'Strict'`` or ``'Lax'`` if the cookie should use the
        ``SameSite`` attribute. This currently just returns the value of
        the :data:`SESSION_COOKIE_SAMESITE` setting.
        """"""
        return app.config[""SESSION_COOKIE_SAMESITE""]  # type: ignore[no-any-return]

    def get_cookie_partitioned(self, app: Flask) -> bool:
        """"""Returns True if the cookie should be partitioned. By default, uses
        the value of :data:`SESSION_COOKIE_PARTITIONED`.

        .. versionadded:: 3.1
        """"""
        return app.config[""SESSION_COOKIE_PARTITIONED""]  # type: ignore[no-any-return]

    def get_expiration_time(self, app: Flask, session: SessionMixin) -> datetime | None:
        """"""A helper method that returns an expiration date for the session
        or ``None`` if the session is linked to the browser session.  The
        default implementation returns now + the permanent session
        lifetime configured on the application.
        """"""
        if session.permanent:
            return datetime.now(timezone.utc) + app.permanent_session_lifetime
        return None

    def should_set_cookie(self, app: Flask, session: SessionMixin) -> bool:
        """"""Used by session backends to determine if a ``Set-Cookie`` header
        should be set for this session cookie for this response. If the session
        has been modified, the cookie is set. If the session is permanent and
        the ``SESSION_REFRESH_EACH_REQUEST`` config is true, the cookie is
        always set.

        This check is usually skipped if the session was deleted.

        .. versionadded:: 0.11
        """"""

        return session.modified or (
            session.permanent and app.config[""SESSION_REFRESH_EACH_REQUEST""]
        )

    def open_session(self, app: Flask, request: Request) -> SessionMixin | None:
        """"""This is called at the beginning of each request, after
        pushing the request context, before matching the URL.

        This must return an object which implements a dictionary-like
        interface as well as the :class:`SessionMixin` interface.

        This will return ``None`` to indicate that loading failed in
        some way that is not immediately an error. The request
        context will fall back to using :meth:`make_null_session`
        in this case.
        """"""
        raise NotImplementedError()

    def save_session(
        self, app: Flask, session: SessionMixin, response: Response
    ) -> None:
        """"""This is called at the end of each request, after generating
        a response, before removing the request context. It is skipped
        if :meth:`is_null_session` returns ``True``.
        """"""
        raise NotImplementedError()",False
78cd66933800e262bb2488eb0eff33601583c049,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,method,make_null_session,SessionInterface.make_null_session,164,174,"Creates a null session which acts as a replacement object if the
real session support could not be loaded due to a configuration
error.  This mainly aids the user experience because the job of the
null session is to still support lookup without complaining but
modifications are answered with a helpful error message of what
failed.

This creates an instance of :attr:`null_session_class` by default.","    def make_null_session(self, app: Flask) -> NullSession:
        """"""Creates a null session which acts as a replacement object if the
        real session support could not be loaded due to a configuration
        error.  This mainly aids the user experience because the job of the
        null session is to still support lookup without complaining but
        modifications are answered with a helpful error message of what
        failed.

        This creates an instance of :attr:`null_session_class` by default.
        """"""
        return self.null_session_class()",False
7284a8f3405ef3ab978c7340306855b2b8198ea2,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,method,is_null_session,SessionInterface.is_null_session,176,183,"Checks if a given object is a null session.  Null sessions are
not asked to be saved.

This checks if the object is an instance of :attr:`null_session_class`
by default.","    def is_null_session(self, obj: object) -> bool:
        """"""Checks if a given object is a null session.  Null sessions are
        not asked to be saved.

        This checks if the object is an instance of :attr:`null_session_class`
        by default.
        """"""
        return isinstance(obj, self.null_session_class)",False
735155810100328434582b7c9113615cd4f264b1,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,method,get_cookie_name,SessionInterface.get_cookie_name,185,187,"The name of the session cookie. Uses``app.config[""SESSION_COOKIE_NAME""]``.","    def get_cookie_name(self, app: Flask) -> str:
        """"""The name of the session cookie. Uses``app.config[""SESSION_COOKIE_NAME""]``.""""""
        return app.config[""SESSION_COOKIE_NAME""]  # type: ignore[no-any-return]",False
cb74cf5dc359b6300f54c65791ca52e1837cf54a,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,method,get_cookie_domain,SessionInterface.get_cookie_domain,189,199,"The value of the ``Domain`` parameter on the session cookie. If not set,
browsers will only send the cookie to the exact domain it was set from.
Otherwise, they will send it to any subdomain of the given value as well.

Uses the :data:`SESSION_COOKIE_DOMAIN` config.

.. versionchanged:: 2.3
    Not set by default, does not fall back to ``SERVER_NAME``.","    def get_cookie_domain(self, app: Flask) -> str | None:
        """"""The value of the ``Domain`` parameter on the session cookie. If not set,
        browsers will only send the cookie to the exact domain it was set from.
        Otherwise, they will send it to any subdomain of the given value as well.

        Uses the :data:`SESSION_COOKIE_DOMAIN` config.

        .. versionchanged:: 2.3
            Not set by default, does not fall back to ``SERVER_NAME``.
        """"""
        return app.config[""SESSION_COOKIE_DOMAIN""]  # type: ignore[no-any-return]",False
15e2fbb1efb7aa2cc8a54abd17c8e1ce4b01d330,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,method,get_cookie_path,SessionInterface.get_cookie_path,201,207,"Returns the path for which the cookie should be valid.  The
default implementation uses the value from the ``SESSION_COOKIE_PATH``
config var if it's set, and falls back to ``APPLICATION_ROOT`` or
uses ``/`` if it's ``None``.","    def get_cookie_path(self, app: Flask) -> str:
        """"""Returns the path for which the cookie should be valid.  The
        default implementation uses the value from the ``SESSION_COOKIE_PATH``
        config var if it's set, and falls back to ``APPLICATION_ROOT`` or
        uses ``/`` if it's ``None``.
        """"""
        return app.config[""SESSION_COOKIE_PATH""] or app.config[""APPLICATION_ROOT""]  # type: ignore[no-any-return]",False
2d56d20db760030b3b190abfff5d5475e8973d95,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,method,get_cookie_httponly,SessionInterface.get_cookie_httponly,209,214,"Returns True if the session cookie should be httponly.  This
currently just returns the value of the ``SESSION_COOKIE_HTTPONLY``
config var.","    def get_cookie_httponly(self, app: Flask) -> bool:
        """"""Returns True if the session cookie should be httponly.  This
        currently just returns the value of the ``SESSION_COOKIE_HTTPONLY``
        config var.
        """"""
        return app.config[""SESSION_COOKIE_HTTPONLY""]  # type: ignore[no-any-return]",False
b095683def6a0eec3502f2de2a5a603d3c842799,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,method,get_cookie_secure,SessionInterface.get_cookie_secure,216,220,"Returns True if the cookie should be secure.  This currently
just returns the value of the ``SESSION_COOKIE_SECURE`` setting.","    def get_cookie_secure(self, app: Flask) -> bool:
        """"""Returns True if the cookie should be secure.  This currently
        just returns the value of the ``SESSION_COOKIE_SECURE`` setting.
        """"""
        return app.config[""SESSION_COOKIE_SECURE""]  # type: ignore[no-any-return]",False
02fc75542aec0973fabd3b60d7d02e4568a52c5a,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,method,get_cookie_samesite,SessionInterface.get_cookie_samesite,222,227,"Return ``'Strict'`` or ``'Lax'`` if the cookie should use the
``SameSite`` attribute. This currently just returns the value of
the :data:`SESSION_COOKIE_SAMESITE` setting.","    def get_cookie_samesite(self, app: Flask) -> str | None:
        """"""Return ``'Strict'`` or ``'Lax'`` if the cookie should use the
        ``SameSite`` attribute. This currently just returns the value of
        the :data:`SESSION_COOKIE_SAMESITE` setting.
        """"""
        return app.config[""SESSION_COOKIE_SAMESITE""]  # type: ignore[no-any-return]",False
434da2d42af5c5b43350650b75a055b5f9374d6e,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,method,get_cookie_partitioned,SessionInterface.get_cookie_partitioned,229,235,"Returns True if the cookie should be partitioned. By default, uses
the value of :data:`SESSION_COOKIE_PARTITIONED`.

.. versionadded:: 3.1","    def get_cookie_partitioned(self, app: Flask) -> bool:
        """"""Returns True if the cookie should be partitioned. By default, uses
        the value of :data:`SESSION_COOKIE_PARTITIONED`.

        .. versionadded:: 3.1
        """"""
        return app.config[""SESSION_COOKIE_PARTITIONED""]  # type: ignore[no-any-return]",False
51aed5482727548b3bfa97c00bb4abbb0b35d246,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,method,get_expiration_time,SessionInterface.get_expiration_time,237,245,"A helper method that returns an expiration date for the session
or ``None`` if the session is linked to the browser session.  The
default implementation returns now + the permanent session
lifetime configured on the application.","    def get_expiration_time(self, app: Flask, session: SessionMixin) -> datetime | None:
        """"""A helper method that returns an expiration date for the session
        or ``None`` if the session is linked to the browser session.  The
        default implementation returns now + the permanent session
        lifetime configured on the application.
        """"""
        if session.permanent:
            return datetime.now(timezone.utc) + app.permanent_session_lifetime
        return None",False
ac7ed70a812ed94605cffba646ce037a3841885b,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,method,should_set_cookie,SessionInterface.should_set_cookie,247,261,"Used by session backends to determine if a ``Set-Cookie`` header
should be set for this session cookie for this response. If the session
has been modified, the cookie is set. If the session is permanent and
the ``SESSION_REFRESH_EACH_REQUEST`` config is true, the cookie is
always set.

This check is usually skipped if the session was deleted.

.. versionadded:: 0.11","    def should_set_cookie(self, app: Flask, session: SessionMixin) -> bool:
        """"""Used by session backends to determine if a ``Set-Cookie`` header
        should be set for this session cookie for this response. If the session
        has been modified, the cookie is set. If the session is permanent and
        the ``SESSION_REFRESH_EACH_REQUEST`` config is true, the cookie is
        always set.

        This check is usually skipped if the session was deleted.

        .. versionadded:: 0.11
        """"""

        return session.modified or (
            session.permanent and app.config[""SESSION_REFRESH_EACH_REQUEST""]
        )",False
a508815018458e44e12085fe0aaac664d941eb9e,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,method,open_session,SessionInterface.open_session,263,275,"This is called at the beginning of each request, after
pushing the request context, before matching the URL.

This must return an object which implements a dictionary-like
interface as well as the :class:`SessionMixin` interface.

This will return ``None`` to indicate that loading failed in
some way that is not immediately an error. The request
context will fall back to using :meth:`make_null_session`
in this case.","    def open_session(self, app: Flask, request: Request) -> SessionMixin | None:
        """"""This is called at the beginning of each request, after
        pushing the request context, before matching the URL.

        This must return an object which implements a dictionary-like
        interface as well as the :class:`SessionMixin` interface.

        This will return ``None`` to indicate that loading failed in
        some way that is not immediately an error. The request
        context will fall back to using :meth:`make_null_session`
        in this case.
        """"""
        raise NotImplementedError()",False
5ca2dc1849ae455491b38d4dbe3009f3ef03bb0a,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,method,save_session,SessionInterface.save_session,277,284,"This is called at the end of each request, after generating
a response, before removing the request context. It is skipped
if :meth:`is_null_session` returns ``True``.","    def save_session(
        self, app: Flask, session: SessionMixin, response: Response
    ) -> None:
        """"""This is called at the end of each request, after generating
        a response, before removing the request context. It is skipped
        if :meth:`is_null_session` returns ``True``.
        """"""
        raise NotImplementedError()",False
91c4883991c865fa9e486ed93b866510b0df1212,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,function,_lazy_sha1,_lazy_sha1,290,295,"Don't access ``hashlib.sha1`` until runtime. FIPS builds may not include
SHA-1, in which case the import and use as a default would fail before the
developer can configure something else.","def _lazy_sha1(string: bytes = b"""") -> t.Any:
    """"""Don't access ``hashlib.sha1`` until runtime. FIPS builds may not include
    SHA-1, in which case the import and use as a default would fail before the
    developer can configure something else.
    """"""
    return hashlib.sha1(string)",False
518bfe5b60d30c5ac4ccca9ba5e8482e02fec526,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,class,SecureCookieSessionInterface,SecureCookieSessionInterface,298,399,"The default session interface that stores sessions in signed cookies
through the :mod:`itsdangerous` module.","class SecureCookieSessionInterface(SessionInterface):
    """"""The default session interface that stores sessions in signed cookies
    through the :mod:`itsdangerous` module.
    """"""

    #: the salt that should be applied on top of the secret key for the
    #: signing of cookie based sessions.
    salt = ""cookie-session""
    #: the hash function to use for the signature.  The default is sha1
    digest_method = staticmethod(_lazy_sha1)
    #: the name of the itsdangerous supported key derivation.  The default
    #: is hmac.
    key_derivation = ""hmac""
    #: A python serializer for the payload.  The default is a compact
    #: JSON derived serializer with support for some extra Python types
    #: such as datetime objects or tuples.
    serializer = session_json_serializer
    session_class = SecureCookieSession

    def get_signing_serializer(self, app: Flask) -> URLSafeTimedSerializer | None:
        if not app.secret_key:
            return None

        keys: list[str | bytes] = []

        if fallbacks := app.config[""SECRET_KEY_FALLBACKS""]:
            keys.extend(fallbacks)

        keys.append(app.secret_key)  # itsdangerous expects current key at top
        return URLSafeTimedSerializer(
            keys,  # type: ignore[arg-type]
            salt=self.salt,
            serializer=self.serializer,
            signer_kwargs={
                ""key_derivation"": self.key_derivation,
                ""digest_method"": self.digest_method,
            },
        )

    def open_session(self, app: Flask, request: Request) -> SecureCookieSession | None:
        s = self.get_signing_serializer(app)
        if s is None:
            return None
        val = request.cookies.get(self.get_cookie_name(app))
        if not val:
            return self.session_class()
        max_age = int(app.permanent_session_lifetime.total_seconds())
        try:
            data = s.loads(val, max_age=max_age)
            return self.session_class(data)
        except BadSignature:
            return self.session_class()

    def save_session(
        self, app: Flask, session: SessionMixin, response: Response
    ) -> None:
        name = self.get_cookie_name(app)
        domain = self.get_cookie_domain(app)
        path = self.get_cookie_path(app)
        secure = self.get_cookie_secure(app)
        partitioned = self.get_cookie_partitioned(app)
        samesite = self.get_cookie_samesite(app)
        httponly = self.get_cookie_httponly(app)

        # Add a ""Vary: Cookie"" header if the session was accessed at all.
        if session.accessed:
            response.vary.add(""Cookie"")

        # If the session is modified to be empty, remove the cookie.
        # If the session is empty, return without setting the cookie.
        if not session:
            if session.modified:
                response.delete_cookie(
                    name,
                    domain=domain,
                    path=path,
                    secure=secure,
                    partitioned=partitioned,
                    samesite=samesite,
                    httponly=httponly,
                )
                response.vary.add(""Cookie"")

            return

        if not self.should_set_cookie(app, session):
            return

        expires = self.get_expiration_time(app, session)
        val = self.get_signing_serializer(app).dumps(dict(session))  # type: ignore[union-attr]
        response.set_cookie(
            name,
            val,
            expires=expires,
            httponly=httponly,
            domain=domain,
            path=path,
            secure=secure,
            partitioned=partitioned,
            samesite=samesite,
        )
        response.vary.add(""Cookie"")",False
483562af31495ad3bb3f913971f9167782c08c61,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,method,get_signing_serializer,SecureCookieSessionInterface.get_signing_serializer,317,335,,"    def get_signing_serializer(self, app: Flask) -> URLSafeTimedSerializer | None:
        if not app.secret_key:
            return None

        keys: list[str | bytes] = []

        if fallbacks := app.config[""SECRET_KEY_FALLBACKS""]:
            keys.extend(fallbacks)

        keys.append(app.secret_key)  # itsdangerous expects current key at top
        return URLSafeTimedSerializer(
            keys,  # type: ignore[arg-type]
            salt=self.salt,
            serializer=self.serializer,
            signer_kwargs={
                ""key_derivation"": self.key_derivation,
                ""digest_method"": self.digest_method,
            },
        )",False
cae28cc81c66b2f2d18aee592bf82ef4b2e0c405,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,method,open_session,SecureCookieSessionInterface.open_session,337,349,,"    def open_session(self, app: Flask, request: Request) -> SecureCookieSession | None:
        s = self.get_signing_serializer(app)
        if s is None:
            return None
        val = request.cookies.get(self.get_cookie_name(app))
        if not val:
            return self.session_class()
        max_age = int(app.permanent_session_lifetime.total_seconds())
        try:
            data = s.loads(val, max_age=max_age)
            return self.session_class(data)
        except BadSignature:
            return self.session_class()",False
05e70400f6f69e3dde05f05351cd4c654b8527e2,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\sessions.py,method,save_session,SecureCookieSessionInterface.save_session,351,399,,"    def save_session(
        self, app: Flask, session: SessionMixin, response: Response
    ) -> None:
        name = self.get_cookie_name(app)
        domain = self.get_cookie_domain(app)
        path = self.get_cookie_path(app)
        secure = self.get_cookie_secure(app)
        partitioned = self.get_cookie_partitioned(app)
        samesite = self.get_cookie_samesite(app)
        httponly = self.get_cookie_httponly(app)

        # Add a ""Vary: Cookie"" header if the session was accessed at all.
        if session.accessed:
            response.vary.add(""Cookie"")

        # If the session is modified to be empty, remove the cookie.
        # If the session is empty, return without setting the cookie.
        if not session:
            if session.modified:
                response.delete_cookie(
                    name,
                    domain=domain,
                    path=path,
                    secure=secure,
                    partitioned=partitioned,
                    samesite=samesite,
                    httponly=httponly,
                )
                response.vary.add(""Cookie"")

            return

        if not self.should_set_cookie(app, session):
            return

        expires = self.get_expiration_time(app, session)
        val = self.get_signing_serializer(app).dumps(dict(session))  # type: ignore[union-attr]
        response.set_cookie(
            name,
            val,
            expires=expires,
            httponly=httponly,
            domain=domain,
            path=path,
            secure=secure,
            partitioned=partitioned,
            samesite=samesite,
        )
        response.vary.add(""Cookie"")",False
5bc656eb5e728ac47dfcefd9d0b23ae744c1ff85,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\templating.py,function,_default_template_ctx_processor,_default_template_ctx_processor,24,36,"Default template context processor.  Injects `request`,
`session` and `g`.","def _default_template_ctx_processor() -> dict[str, t.Any]:
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    appctx = _cv_app.get(None)
    reqctx = _cv_request.get(None)
    rv: dict[str, t.Any] = {}
    if appctx is not None:
        rv[""g""] = appctx.g
    if reqctx is not None:
        rv[""request""] = reqctx.request
        rv[""session""] = reqctx.session
    return rv",False
75973e55b693cdff7758ddf11129be307970ab8f,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\templating.py,class,Environment,Environment,39,49,"Works like a regular Jinja environment but has some additional
knowledge of how Flask's blueprint works so that it can prepend the
name of the blueprint to referenced templates if necessary.","class Environment(BaseEnvironment):
    """"""Works like a regular Jinja environment but has some additional
    knowledge of how Flask's blueprint works so that it can prepend the
    name of the blueprint to referenced templates if necessary.
    """"""

    def __init__(self, app: App, **options: t.Any) -> None:
        if ""loader"" not in options:
            options[""loader""] = app.create_global_jinja_loader()
        BaseEnvironment.__init__(self, **options)
        self.app = app",False
90da0402e040b079d222f20bb9212525289cb407,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\templating.py,method,__init__,Environment.__init__,45,49,,"    def __init__(self, app: App, **options: t.Any) -> None:
        if ""loader"" not in options:
            options[""loader""] = app.create_global_jinja_loader()
        BaseEnvironment.__init__(self, **options)
        self.app = app",False
68beefb989cc4e59da2126bcd3b4868fd6b77504,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\templating.py,class,DispatchingJinjaLoader,DispatchingJinjaLoader,52,123,"A loader that looks for templates in the application and all
the blueprint folders.","class DispatchingJinjaLoader(BaseLoader):
    """"""A loader that looks for templates in the application and all
    the blueprint folders.
    """"""

    def __init__(self, app: App) -> None:
        self.app = app

    def get_source(
        self, environment: BaseEnvironment, template: str
    ) -> tuple[str, str | None, t.Callable[[], bool] | None]:
        if self.app.config[""EXPLAIN_TEMPLATE_LOADING""]:
            return self._get_source_explained(environment, template)
        return self._get_source_fast(environment, template)

    def _get_source_explained(
        self, environment: BaseEnvironment, template: str
    ) -> tuple[str, str | None, t.Callable[[], bool] | None]:
        attempts = []
        rv: tuple[str, str | None, t.Callable[[], bool] | None] | None
        trv: None | (tuple[str, str | None, t.Callable[[], bool] | None]) = None

        for srcobj, loader in self._iter_loaders(template):
            try:
                rv = loader.get_source(environment, template)
                if trv is None:
                    trv = rv
            except TemplateNotFound:
                rv = None
            attempts.append((loader, srcobj, rv))

        from .debughelpers import explain_template_loading_attempts

        explain_template_loading_attempts(self.app, template, attempts)

        if trv is not None:
            return trv
        raise TemplateNotFound(template)

    def _get_source_fast(
        self, environment: BaseEnvironment, template: str
    ) -> tuple[str, str | None, t.Callable[[], bool] | None]:
        for _srcobj, loader in self._iter_loaders(template):
            try:
                return loader.get_source(environment, template)
            except TemplateNotFound:
                continue
        raise TemplateNotFound(template)

    def _iter_loaders(self, template: str) -> t.Iterator[tuple[Scaffold, BaseLoader]]:
        loader = self.app.jinja_loader
        if loader is not None:
            yield self.app, loader

        for blueprint in self.app.iter_blueprints():
            loader = blueprint.jinja_loader
            if loader is not None:
                yield blueprint, loader

    def list_templates(self) -> list[str]:
        result = set()
        loader = self.app.jinja_loader
        if loader is not None:
            result.update(loader.list_templates())

        for blueprint in self.app.iter_blueprints():
            loader = blueprint.jinja_loader
            if loader is not None:
                for template in loader.list_templates():
                    result.add(template)

        return list(result)",False
eee3cb2137ad1724983eb2c9a11b795301c0def4,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\templating.py,method,__init__,DispatchingJinjaLoader.__init__,57,58,,"    def __init__(self, app: App) -> None:
        self.app = app",False
2c3326635a09c183e74a8c04fff1759f4fd5a585,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\templating.py,method,get_source,DispatchingJinjaLoader.get_source,60,65,,"    def get_source(
        self, environment: BaseEnvironment, template: str
    ) -> tuple[str, str | None, t.Callable[[], bool] | None]:
        if self.app.config[""EXPLAIN_TEMPLATE_LOADING""]:
            return self._get_source_explained(environment, template)
        return self._get_source_fast(environment, template)",False
00f81161bf5876f5391be153bb7ba97be793fdf9,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\templating.py,method,_get_source_explained,DispatchingJinjaLoader._get_source_explained,67,89,,"    def _get_source_explained(
        self, environment: BaseEnvironment, template: str
    ) -> tuple[str, str | None, t.Callable[[], bool] | None]:
        attempts = []
        rv: tuple[str, str | None, t.Callable[[], bool] | None] | None
        trv: None | (tuple[str, str | None, t.Callable[[], bool] | None]) = None

        for srcobj, loader in self._iter_loaders(template):
            try:
                rv = loader.get_source(environment, template)
                if trv is None:
                    trv = rv
            except TemplateNotFound:
                rv = None
            attempts.append((loader, srcobj, rv))

        from .debughelpers import explain_template_loading_attempts

        explain_template_loading_attempts(self.app, template, attempts)

        if trv is not None:
            return trv
        raise TemplateNotFound(template)",False
d6a68e883961d8df24ba3bc39e67f6ff45e26dc2,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\templating.py,method,_get_source_fast,DispatchingJinjaLoader._get_source_fast,91,99,,"    def _get_source_fast(
        self, environment: BaseEnvironment, template: str
    ) -> tuple[str, str | None, t.Callable[[], bool] | None]:
        for _srcobj, loader in self._iter_loaders(template):
            try:
                return loader.get_source(environment, template)
            except TemplateNotFound:
                continue
        raise TemplateNotFound(template)",False
f663e75d9d1c03244ccfcd8f0b6decbab98e5b73,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\templating.py,method,_iter_loaders,DispatchingJinjaLoader._iter_loaders,101,109,,"    def _iter_loaders(self, template: str) -> t.Iterator[tuple[Scaffold, BaseLoader]]:
        loader = self.app.jinja_loader
        if loader is not None:
            yield self.app, loader

        for blueprint in self.app.iter_blueprints():
            loader = blueprint.jinja_loader
            if loader is not None:
                yield blueprint, loader",False
19b106dc52d79b1ed9a77bda667d09be1b74dc87,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\templating.py,method,list_templates,DispatchingJinjaLoader.list_templates,111,123,,"    def list_templates(self) -> list[str]:
        result = set()
        loader = self.app.jinja_loader
        if loader is not None:
            result.update(loader.list_templates())

        for blueprint in self.app.iter_blueprints():
            loader = blueprint.jinja_loader
            if loader is not None:
                for template in loader.list_templates():
                    result.add(template)

        return list(result)",False
aad6265e0666a65f0ea75a4e7974d3fb1cfc4a7a,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\templating.py,function,_render,_render,126,135,,"def _render(app: Flask, template: Template, context: dict[str, t.Any]) -> str:
    app.update_template_context(context)
    before_render_template.send(
        app, _async_wrapper=app.ensure_sync, template=template, context=context
    )
    rv = template.render(context)
    template_rendered.send(
        app, _async_wrapper=app.ensure_sync, template=template, context=context
    )
    return rv",False
e351586ae65a21b1e22af5a270a3f86b39ca7f76,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\templating.py,function,render_template,render_template,138,150,"Render a template by name with the given context.

:param template_name_or_list: The name of the template to render. If
    a list is given, the first name to exist will be rendered.
:param context: The variables to make available in the template.","def render_template(
    template_name_or_list: str | Template | list[str | Template],
    **context: t.Any,
) -> str:
    """"""Render a template by name with the given context.

    :param template_name_or_list: The name of the template to render. If
        a list is given, the first name to exist will be rendered.
    :param context: The variables to make available in the template.
    """"""
    app = current_app._get_current_object()  # type: ignore[attr-defined]
    template = app.jinja_env.get_or_select_template(template_name_or_list)
    return _render(app, template, context)",False
e0abb03199cf3ed22e829042d98f4bf84f0b0c15,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\templating.py,function,render_template_string,render_template_string,153,162,"Render a template from the given source string with the given
context.

:param source: The source code of the template to render.
:param context: The variables to make available in the template.","def render_template_string(source: str, **context: t.Any) -> str:
    """"""Render a template from the given source string with the given
    context.

    :param source: The source code of the template to render.
    :param context: The variables to make available in the template.
    """"""
    app = current_app._get_current_object()  # type: ignore[attr-defined]
    template = app.jinja_env.from_string(source)
    return _render(app, template, context)",False
3defb03b0e6e84e48d3cf3c615eb1374473097e7,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\templating.py,function,_stream,_stream,165,185,,"def _stream(
    app: Flask, template: Template, context: dict[str, t.Any]
) -> t.Iterator[str]:
    app.update_template_context(context)
    before_render_template.send(
        app, _async_wrapper=app.ensure_sync, template=template, context=context
    )

    def generate() -> t.Iterator[str]:
        yield from template.generate(context)
        template_rendered.send(
            app, _async_wrapper=app.ensure_sync, template=template, context=context
        )

    rv = generate()

    # If a request context is active, keep it while generating.
    if request:
        rv = stream_with_context(rv)

    return rv",False
aa7eca1418812afd79bcfefb95b8318615445f39,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\templating.py,function,stream_template,stream_template,188,204,"Render a template by name with the given context as a stream.
This returns an iterator of strings, which can be used as a
streaming response from a view.

:param template_name_or_list: The name of the template to render. If
    a list is given, the first name to exist will be rendered.
:param context: The variables to make available in the template.

.. versionadded:: 2.2","def stream_template(
    template_name_or_list: str | Template | list[str | Template],
    **context: t.Any,
) -> t.Iterator[str]:
    """"""Render a template by name with the given context as a stream.
    This returns an iterator of strings, which can be used as a
    streaming response from a view.

    :param template_name_or_list: The name of the template to render. If
        a list is given, the first name to exist will be rendered.
    :param context: The variables to make available in the template.

    .. versionadded:: 2.2
    """"""
    app = current_app._get_current_object()  # type: ignore[attr-defined]
    template = app.jinja_env.get_or_select_template(template_name_or_list)
    return _stream(app, template, context)",False
14bbe26bff41faa5b46f4738dedfb0f1d56b2878,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\templating.py,function,stream_template_string,stream_template_string,207,219,"Render a template from the given source string with the given
context as a stream. This returns an iterator of strings, which can
be used as a streaming response from a view.

:param source: The source code of the template to render.
:param context: The variables to make available in the template.

.. versionadded:: 2.2","def stream_template_string(source: str, **context: t.Any) -> t.Iterator[str]:
    """"""Render a template from the given source string with the given
    context as a stream. This returns an iterator of strings, which can
    be used as a streaming response from a view.

    :param source: The source code of the template to render.
    :param context: The variables to make available in the template.

    .. versionadded:: 2.2
    """"""
    app = current_app._get_current_object()  # type: ignore[attr-defined]
    template = app.jinja_env.from_string(source)
    return _stream(app, template, context)",False
f52125d8f4c3a2aaaf5086815be87d491ca8d191,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\testing.py,class,EnvironBuilder,EnvironBuilder,27,94,"An :class:`~werkzeug.test.EnvironBuilder`, that takes defaults from the
application.

:param app: The Flask application to configure the environment from.
:param path: URL path being requested.
:param base_url: Base URL where the app is being served, which
    ``path`` is relative to. If not given, built from
    :data:`PREFERRED_URL_SCHEME`, ``subdomain``,
    :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.
:param subdomain: Subdomain name to append to :data:`SERVER_NAME`.
:param url_scheme: Scheme to use instead of
    :data:`PREFERRED_URL_SCHEME`.
:param json: If given, this is serialized as JSON and passed as
    ``data``. Also defaults ``content_type`` to
    ``application/json``.
:param args: other positional arguments passed to
    :class:`~werkzeug.test.EnvironBuilder`.
:param kwargs: other keyword arguments passed to
    :class:`~werkzeug.test.EnvironBuilder`.","class EnvironBuilder(werkzeug.test.EnvironBuilder):
    """"""An :class:`~werkzeug.test.EnvironBuilder`, that takes defaults from the
    application.

    :param app: The Flask application to configure the environment from.
    :param path: URL path being requested.
    :param base_url: Base URL where the app is being served, which
        ``path`` is relative to. If not given, built from
        :data:`PREFERRED_URL_SCHEME`, ``subdomain``,
        :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.
    :param subdomain: Subdomain name to append to :data:`SERVER_NAME`.
    :param url_scheme: Scheme to use instead of
        :data:`PREFERRED_URL_SCHEME`.
    :param json: If given, this is serialized as JSON and passed as
        ``data``. Also defaults ``content_type`` to
        ``application/json``.
    :param args: other positional arguments passed to
        :class:`~werkzeug.test.EnvironBuilder`.
    :param kwargs: other keyword arguments passed to
        :class:`~werkzeug.test.EnvironBuilder`.
    """"""

    def __init__(
        self,
        app: Flask,
        path: str = ""/"",
        base_url: str | None = None,
        subdomain: str | None = None,
        url_scheme: str | None = None,
        *args: t.Any,
        **kwargs: t.Any,
    ) -> None:
        assert not (base_url or subdomain or url_scheme) or (
            base_url is not None
        ) != bool(subdomain or url_scheme), (
            'Cannot pass ""subdomain"" or ""url_scheme"" with ""base_url"".'
        )

        if base_url is None:
            http_host = app.config.get(""SERVER_NAME"") or ""localhost""
            app_root = app.config[""APPLICATION_ROOT""]

            if subdomain:
                http_host = f""{subdomain}.{http_host}""

            if url_scheme is None:
                url_scheme = app.config[""PREFERRED_URL_SCHEME""]

            url = urlsplit(path)
            base_url = (
                f""{url.scheme or url_scheme}://{url.netloc or http_host}""
                f""/{app_root.lstrip('/')}""
            )
            path = url.path

            if url.query:
                path = f""{path}?{url.query}""

        self.app = app
        super().__init__(path, base_url, *args, **kwargs)

    def json_dumps(self, obj: t.Any, **kwargs: t.Any) -> str:
        """"""Serialize ``obj`` to a JSON-formatted string.

        The serialization will be configured according to the config associated
        with this EnvironBuilder's ``app``.
        """"""
        return self.app.json.dumps(obj, **kwargs)",False
a69b43a026a9bf8c67f5e2aa375769b97d276689,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\testing.py,method,__init__,EnvironBuilder.__init__,49,86,,"    def __init__(
        self,
        app: Flask,
        path: str = ""/"",
        base_url: str | None = None,
        subdomain: str | None = None,
        url_scheme: str | None = None,
        *args: t.Any,
        **kwargs: t.Any,
    ) -> None:
        assert not (base_url or subdomain or url_scheme) or (
            base_url is not None
        ) != bool(subdomain or url_scheme), (
            'Cannot pass ""subdomain"" or ""url_scheme"" with ""base_url"".'
        )

        if base_url is None:
            http_host = app.config.get(""SERVER_NAME"") or ""localhost""
            app_root = app.config[""APPLICATION_ROOT""]

            if subdomain:
                http_host = f""{subdomain}.{http_host}""

            if url_scheme is None:
                url_scheme = app.config[""PREFERRED_URL_SCHEME""]

            url = urlsplit(path)
            base_url = (
                f""{url.scheme or url_scheme}://{url.netloc or http_host}""
                f""/{app_root.lstrip('/')}""
            )
            path = url.path

            if url.query:
                path = f""{path}?{url.query}""

        self.app = app
        super().__init__(path, base_url, *args, **kwargs)",False
0b1c7d4bde80b0b920aec4c54e6e843db80e6671,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\testing.py,method,json_dumps,EnvironBuilder.json_dumps,88,94,"Serialize ``obj`` to a JSON-formatted string.

The serialization will be configured according to the config associated
with this EnvironBuilder's ``app``.","    def json_dumps(self, obj: t.Any, **kwargs: t.Any) -> str:
        """"""Serialize ``obj`` to a JSON-formatted string.

        The serialization will be configured according to the config associated
        with this EnvironBuilder's ``app``.
        """"""
        return self.app.json.dumps(obj, **kwargs)",False
7a2afda558db1f740fba12231349c4bfbd82a292,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\testing.py,function,_get_werkzeug_version,_get_werkzeug_version,100,106,,"def _get_werkzeug_version() -> str:
    global _werkzeug_version

    if not _werkzeug_version:
        _werkzeug_version = importlib.metadata.version(""werkzeug"")

    return _werkzeug_version",False
a616de8f21b35d22180a814f9c869a64d946d704,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\testing.py,class,FlaskClient,FlaskClient,109,262,"Works like a regular Werkzeug test client but has knowledge about
Flask's contexts to defer the cleanup of the request context until
the end of a ``with`` block. For general information about how to
use this class refer to :class:`werkzeug.test.Client`.

.. versionchanged:: 0.12
   `app.test_client()` includes preset default environment, which can be
   set after instantiation of the `app.test_client()` object in
   `client.environ_base`.

Basic usage is outlined in the :doc:`/testing` chapter.","class FlaskClient(Client):
    """"""Works like a regular Werkzeug test client but has knowledge about
    Flask's contexts to defer the cleanup of the request context until
    the end of a ``with`` block. For general information about how to
    use this class refer to :class:`werkzeug.test.Client`.

    .. versionchanged:: 0.12
       `app.test_client()` includes preset default environment, which can be
       set after instantiation of the `app.test_client()` object in
       `client.environ_base`.

    Basic usage is outlined in the :doc:`/testing` chapter.
    """"""

    application: Flask

    def __init__(self, *args: t.Any, **kwargs: t.Any) -> None:
        super().__init__(*args, **kwargs)
        self.preserve_context = False
        self._new_contexts: list[t.ContextManager[t.Any]] = []
        self._context_stack = ExitStack()
        self.environ_base = {
            ""REMOTE_ADDR"": ""127.0.0.1"",
            ""HTTP_USER_AGENT"": f""Werkzeug/{_get_werkzeug_version()}"",
        }

    @contextmanager
    def session_transaction(
        self, *args: t.Any, **kwargs: t.Any
    ) -> t.Iterator[SessionMixin]:
        """"""When used in combination with a ``with`` statement this opens a
        session transaction.  This can be used to modify the session that
        the test client uses.  Once the ``with`` block is left the session is
        stored back.

        ::

            with client.session_transaction() as session:
                session['value'] = 42

        Internally this is implemented by going through a temporary test
        request context and since session handling could depend on
        request variables this function accepts the same arguments as
        :meth:`~flask.Flask.test_request_context` which are directly
        passed through.
        """"""
        if self._cookies is None:
            raise TypeError(
                ""Cookies are disabled. Create a client with 'use_cookies=True'.""
            )

        app = self.application
        ctx = app.test_request_context(*args, **kwargs)
        self._add_cookies_to_wsgi(ctx.request.environ)

        with ctx:
            sess = app.session_interface.open_session(app, ctx.request)

        if sess is None:
            raise RuntimeError(""Session backend did not open a session."")

        yield sess
        resp = app.response_class()

        if app.session_interface.is_null_session(sess):
            return

        with ctx:
            app.session_interface.save_session(app, sess, resp)

        self._update_cookies_from_response(
            ctx.request.host.partition("":"")[0],
            ctx.request.path,
            resp.headers.getlist(""Set-Cookie""),
        )

    def _copy_environ(self, other: WSGIEnvironment) -> WSGIEnvironment:
        out = {**self.environ_base, **other}

        if self.preserve_context:
            out[""werkzeug.debug.preserve_context""] = self._new_contexts.append

        return out

    def _request_from_builder_args(
        self, args: tuple[t.Any, ...], kwargs: dict[str, t.Any]
    ) -> BaseRequest:
        kwargs[""environ_base""] = self._copy_environ(kwargs.get(""environ_base"", {}))
        builder = EnvironBuilder(self.application, *args, **kwargs)

        try:
            return builder.get_request()
        finally:
            builder.close()

    def open(
        self,
        *args: t.Any,
        buffered: bool = False,
        follow_redirects: bool = False,
        **kwargs: t.Any,
    ) -> TestResponse:
        if args and isinstance(
            args[0], (werkzeug.test.EnvironBuilder, dict, BaseRequest)
        ):
            if isinstance(args[0], werkzeug.test.EnvironBuilder):
                builder = copy(args[0])
                builder.environ_base = self._copy_environ(builder.environ_base or {})  # type: ignore[arg-type]
                request = builder.get_request()
            elif isinstance(args[0], dict):
                request = EnvironBuilder.from_environ(
                    args[0], app=self.application, environ_base=self._copy_environ({})
                ).get_request()
            else:
                # isinstance(args[0], BaseRequest)
                request = copy(args[0])
                request.environ = self._copy_environ(request.environ)
        else:
            # request is None
            request = self._request_from_builder_args(args, kwargs)

        # Pop any previously preserved contexts. This prevents contexts
        # from being preserved across redirects or multiple requests
        # within a single block.
        self._context_stack.close()

        response = super().open(
            request,
            buffered=buffered,
            follow_redirects=follow_redirects,
        )
        response.json_module = self.application.json  # type: ignore[assignment]

        # Re-push contexts that were preserved during the request.
        for cm in self._new_contexts:
            self._context_stack.enter_context(cm)

        self._new_contexts.clear()
        return response

    def __enter__(self) -> FlaskClient:
        if self.preserve_context:
            raise RuntimeError(""Cannot nest client invocations"")
        self.preserve_context = True
        return self

    def __exit__(
        self,
        exc_type: type | None,
        exc_value: BaseException | None,
        tb: TracebackType | None,
    ) -> None:
        self.preserve_context = False
        self._context_stack.close()",False
0f6b63ff5afbec686edf764081c663f331538646,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\testing.py,method,__init__,FlaskClient.__init__,125,133,,"    def __init__(self, *args: t.Any, **kwargs: t.Any) -> None:
        super().__init__(*args, **kwargs)
        self.preserve_context = False
        self._new_contexts: list[t.ContextManager[t.Any]] = []
        self._context_stack = ExitStack()
        self.environ_base = {
            ""REMOTE_ADDR"": ""127.0.0.1"",
            ""HTTP_USER_AGENT"": f""Werkzeug/{_get_werkzeug_version()}"",
        }",False
72a8ab3a2aad25dace4d7c71907c0d9383be07a8,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\testing.py,method,session_transaction,FlaskClient.session_transaction,136,183,"When used in combination with a ``with`` statement this opens a
session transaction.  This can be used to modify the session that
the test client uses.  Once the ``with`` block is left the session is
stored back.

::

    with client.session_transaction() as session:
        session['value'] = 42

Internally this is implemented by going through a temporary test
request context and since session handling could depend on
request variables this function accepts the same arguments as
:meth:`~flask.Flask.test_request_context` which are directly
passed through.","    def session_transaction(
        self, *args: t.Any, **kwargs: t.Any
    ) -> t.Iterator[SessionMixin]:
        """"""When used in combination with a ``with`` statement this opens a
        session transaction.  This can be used to modify the session that
        the test client uses.  Once the ``with`` block is left the session is
        stored back.

        ::

            with client.session_transaction() as session:
                session['value'] = 42

        Internally this is implemented by going through a temporary test
        request context and since session handling could depend on
        request variables this function accepts the same arguments as
        :meth:`~flask.Flask.test_request_context` which are directly
        passed through.
        """"""
        if self._cookies is None:
            raise TypeError(
                ""Cookies are disabled. Create a client with 'use_cookies=True'.""
            )

        app = self.application
        ctx = app.test_request_context(*args, **kwargs)
        self._add_cookies_to_wsgi(ctx.request.environ)

        with ctx:
            sess = app.session_interface.open_session(app, ctx.request)

        if sess is None:
            raise RuntimeError(""Session backend did not open a session."")

        yield sess
        resp = app.response_class()

        if app.session_interface.is_null_session(sess):
            return

        with ctx:
            app.session_interface.save_session(app, sess, resp)

        self._update_cookies_from_response(
            ctx.request.host.partition("":"")[0],
            ctx.request.path,
            resp.headers.getlist(""Set-Cookie""),
        )",False
bb1f9039fa1f207c5f87faddd38bc686900ce45b,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\testing.py,method,_copy_environ,FlaskClient._copy_environ,185,191,,"    def _copy_environ(self, other: WSGIEnvironment) -> WSGIEnvironment:
        out = {**self.environ_base, **other}

        if self.preserve_context:
            out[""werkzeug.debug.preserve_context""] = self._new_contexts.append

        return out",False
4ae5eff427c375c69020cab0c1cfde76473b9d4c,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\testing.py,method,_request_from_builder_args,FlaskClient._request_from_builder_args,193,202,,"    def _request_from_builder_args(
        self, args: tuple[t.Any, ...], kwargs: dict[str, t.Any]
    ) -> BaseRequest:
        kwargs[""environ_base""] = self._copy_environ(kwargs.get(""environ_base"", {}))
        builder = EnvironBuilder(self.application, *args, **kwargs)

        try:
            return builder.get_request()
        finally:
            builder.close()",False
f49b6a78bf160db5c2ffb21b5963c932655cb3e4,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\testing.py,method,open,FlaskClient.open,204,247,,"    def open(
        self,
        *args: t.Any,
        buffered: bool = False,
        follow_redirects: bool = False,
        **kwargs: t.Any,
    ) -> TestResponse:
        if args and isinstance(
            args[0], (werkzeug.test.EnvironBuilder, dict, BaseRequest)
        ):
            if isinstance(args[0], werkzeug.test.EnvironBuilder):
                builder = copy(args[0])
                builder.environ_base = self._copy_environ(builder.environ_base or {})  # type: ignore[arg-type]
                request = builder.get_request()
            elif isinstance(args[0], dict):
                request = EnvironBuilder.from_environ(
                    args[0], app=self.application, environ_base=self._copy_environ({})
                ).get_request()
            else:
                # isinstance(args[0], BaseRequest)
                request = copy(args[0])
                request.environ = self._copy_environ(request.environ)
        else:
            # request is None
            request = self._request_from_builder_args(args, kwargs)

        # Pop any previously preserved contexts. This prevents contexts
        # from being preserved across redirects or multiple requests
        # within a single block.
        self._context_stack.close()

        response = super().open(
            request,
            buffered=buffered,
            follow_redirects=follow_redirects,
        )
        response.json_module = self.application.json  # type: ignore[assignment]

        # Re-push contexts that were preserved during the request.
        for cm in self._new_contexts:
            self._context_stack.enter_context(cm)

        self._new_contexts.clear()
        return response",False
4bd022487b138746a39d12dc7ac7626f87038427,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\testing.py,method,__enter__,FlaskClient.__enter__,249,253,,"    def __enter__(self) -> FlaskClient:
        if self.preserve_context:
            raise RuntimeError(""Cannot nest client invocations"")
        self.preserve_context = True
        return self",False
010bcd312f229c6b8fe3c9db6059b84ef40ac6a6,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\testing.py,method,__exit__,FlaskClient.__exit__,255,262,,"    def __exit__(
        self,
        exc_type: type | None,
        exc_value: BaseException | None,
        tb: TracebackType | None,
    ) -> None:
        self.preserve_context = False
        self._context_stack.close()",False
d953e53c02d8d7f47535682b641a916c4f81864c,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\testing.py,class,FlaskCliRunner,FlaskCliRunner,265,298,"A :class:`~click.testing.CliRunner` for testing a Flask app's
CLI commands. Typically created using
:meth:`~flask.Flask.test_cli_runner`. See :ref:`testing-cli`.","class FlaskCliRunner(CliRunner):
    """"""A :class:`~click.testing.CliRunner` for testing a Flask app's
    CLI commands. Typically created using
    :meth:`~flask.Flask.test_cli_runner`. See :ref:`testing-cli`.
    """"""

    def __init__(self, app: Flask, **kwargs: t.Any) -> None:
        self.app = app
        super().__init__(**kwargs)

    def invoke(  # type: ignore
        self, cli: t.Any = None, args: t.Any = None, **kwargs: t.Any
    ) -> Result:
        """"""Invokes a CLI command in an isolated environment. See
        :meth:`CliRunner.invoke <click.testing.CliRunner.invoke>` for
        full method documentation. See :ref:`testing-cli` for examples.

        If the ``obj`` argument is not given, passes an instance of
        :class:`~flask.cli.ScriptInfo` that knows how to load the Flask
        app being tested.

        :param cli: Command object to invoke. Default is the app's
            :attr:`~flask.app.Flask.cli` group.
        :param args: List of strings to invoke the command with.

        :return: a :class:`~click.testing.Result` object.
        """"""
        if cli is None:
            cli = self.app.cli

        if ""obj"" not in kwargs:
            kwargs[""obj""] = ScriptInfo(create_app=lambda: self.app)

        return super().invoke(cli, args, **kwargs)",False
b83d2c9e4c0596eab5ff4660d4af20139e5a19a4,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\testing.py,method,__init__,FlaskCliRunner.__init__,271,273,,"    def __init__(self, app: Flask, **kwargs: t.Any) -> None:
        self.app = app
        super().__init__(**kwargs)",False
4179f2151f60c076b3f21b3f88d7a2eec28f036f,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\testing.py,method,invoke,FlaskCliRunner.invoke,275,298,"Invokes a CLI command in an isolated environment. See
:meth:`CliRunner.invoke <click.testing.CliRunner.invoke>` for
full method documentation. See :ref:`testing-cli` for examples.

If the ``obj`` argument is not given, passes an instance of
:class:`~flask.cli.ScriptInfo` that knows how to load the Flask
app being tested.

:param cli: Command object to invoke. Default is the app's
    :attr:`~flask.app.Flask.cli` group.
:param args: List of strings to invoke the command with.

:return: a :class:`~click.testing.Result` object.","    def invoke(  # type: ignore
        self, cli: t.Any = None, args: t.Any = None, **kwargs: t.Any
    ) -> Result:
        """"""Invokes a CLI command in an isolated environment. See
        :meth:`CliRunner.invoke <click.testing.CliRunner.invoke>` for
        full method documentation. See :ref:`testing-cli` for examples.

        If the ``obj`` argument is not given, passes an instance of
        :class:`~flask.cli.ScriptInfo` that knows how to load the Flask
        app being tested.

        :param cli: Command object to invoke. Default is the app's
            :attr:`~flask.app.Flask.cli` group.
        :param args: List of strings to invoke the command with.

        :return: a :class:`~click.testing.Result` object.
        """"""
        if cli is None:
            cli = self.app.cli

        if ""obj"" not in kwargs:
            kwargs[""obj""] = ScriptInfo(create_app=lambda: self.app)

        return super().invoke(cli, args, **kwargs)",False
3f9ce00d35ecb62912ec586af0febc509e323f0b,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\views.py,class,View,View,16,135,"Subclass this class and override :meth:`dispatch_request` to
create a generic class-based view. Call :meth:`as_view` to create a
view function that creates an instance of the class with the given
arguments and calls its ``dispatch_request`` method with any URL
variables.

See :doc:`views` for a detailed guide.

.. code-block:: python

    class Hello(View):
        init_every_request = False

        def dispatch_request(self, name):
            return f""Hello, {name}!""

    app.add_url_rule(
        ""/hello/<name>"", view_func=Hello.as_view(""hello"")
    )

Set :attr:`methods` on the class to change what methods the view
accepts.

Set :attr:`decorators` on the class to apply a list of decorators to
the generated view function. Decorators applied to the class itself
will not be applied to the generated view function!

Set :attr:`init_every_request` to ``False`` for efficiency, unless
you need to store request-global data on ``self``.","class View:
    """"""Subclass this class and override :meth:`dispatch_request` to
    create a generic class-based view. Call :meth:`as_view` to create a
    view function that creates an instance of the class with the given
    arguments and calls its ``dispatch_request`` method with any URL
    variables.

    See :doc:`views` for a detailed guide.

    .. code-block:: python

        class Hello(View):
            init_every_request = False

            def dispatch_request(self, name):
                return f""Hello, {name}!""

        app.add_url_rule(
            ""/hello/<name>"", view_func=Hello.as_view(""hello"")
        )

    Set :attr:`methods` on the class to change what methods the view
    accepts.

    Set :attr:`decorators` on the class to apply a list of decorators to
    the generated view function. Decorators applied to the class itself
    will not be applied to the generated view function!

    Set :attr:`init_every_request` to ``False`` for efficiency, unless
    you need to store request-global data on ``self``.
    """"""

    #: The methods this view is registered for. Uses the same default
    #: (``[""GET"", ""HEAD"", ""OPTIONS""]``) as ``route`` and
    #: ``add_url_rule`` by default.
    methods: t.ClassVar[t.Collection[str] | None] = None

    #: Control whether the ``OPTIONS`` method is handled automatically.
    #: Uses the same default (``True``) as ``route`` and
    #: ``add_url_rule`` by default.
    provide_automatic_options: t.ClassVar[bool | None] = None

    #: A list of decorators to apply, in order, to the generated view
    #: function. Remember that ``@decorator`` syntax is applied bottom
    #: to top, so the first decorator in the list would be the bottom
    #: decorator.
    #:
    #: .. versionadded:: 0.8
    decorators: t.ClassVar[list[t.Callable[..., t.Any]]] = []

    #: Create a new instance of this view class for every request by
    #: default. If a view subclass sets this to ``False``, the same
    #: instance is used for every request.
    #:
    #: A single instance is more efficient, especially if complex setup
    #: is done during init. However, storing data on ``self`` is no
    #: longer safe across requests, and :data:`~flask.g` should be used
    #: instead.
    #:
    #: .. versionadded:: 2.2
    init_every_request: t.ClassVar[bool] = True

    def dispatch_request(self) -> ft.ResponseReturnValue:
        """"""The actual view function behavior. Subclasses must override
        this and return a valid response. Any variables from the URL
        rule are passed as keyword arguments.
        """"""
        raise NotImplementedError()

    @classmethod
    def as_view(
        cls, name: str, *class_args: t.Any, **class_kwargs: t.Any
    ) -> ft.RouteCallable:
        """"""Convert the class into a view function that can be registered
        for a route.

        By default, the generated view will create a new instance of the
        view class for every request and call its
        :meth:`dispatch_request` method. If the view class sets
        :attr:`init_every_request` to ``False``, the same instance will
        be used for every request.

        Except for ``name``, all other arguments passed to this method
        are forwarded to the view class ``__init__`` method.

        .. versionchanged:: 2.2
            Added the ``init_every_request`` class attribute.
        """"""
        if cls.init_every_request:

            def view(**kwargs: t.Any) -> ft.ResponseReturnValue:
                self = view.view_class(  # type: ignore[attr-defined]
                    *class_args, **class_kwargs
                )
                return current_app.ensure_sync(self.dispatch_request)(**kwargs)  # type: ignore[no-any-return]

        else:
            self = cls(*class_args, **class_kwargs)  # pyright: ignore

            def view(**kwargs: t.Any) -> ft.ResponseReturnValue:
                return current_app.ensure_sync(self.dispatch_request)(**kwargs)  # type: ignore[no-any-return]

        if cls.decorators:
            view.__name__ = name
            view.__module__ = cls.__module__
            for decorator in cls.decorators:
                view = decorator(view)

        # We attach the view class to the view function for two reasons:
        # first of all it allows us to easily figure out what class-based
        # view this thing came from, secondly it's also used for instantiating
        # the view class so you can actually replace it with something else
        # for testing purposes and debugging.
        view.view_class = cls  # type: ignore
        view.__name__ = name
        view.__doc__ = cls.__doc__
        view.__module__ = cls.__module__
        view.methods = cls.methods  # type: ignore
        view.provide_automatic_options = cls.provide_automatic_options  # type: ignore
        return view",False
17608ffa5520d6454b4036b30c465b0f983505ac,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\views.py,method,dispatch_request,View.dispatch_request,78,83,"The actual view function behavior. Subclasses must override
this and return a valid response. Any variables from the URL
rule are passed as keyword arguments.","    def dispatch_request(self) -> ft.ResponseReturnValue:
        """"""The actual view function behavior. Subclasses must override
        this and return a valid response. Any variables from the URL
        rule are passed as keyword arguments.
        """"""
        raise NotImplementedError()",False
0dcb1837d7a5c26ab2fb4113b004be5a6176ff3d,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\views.py,method,as_view,View.as_view,86,135,"Convert the class into a view function that can be registered
for a route.

By default, the generated view will create a new instance of the
view class for every request and call its
:meth:`dispatch_request` method. If the view class sets
:attr:`init_every_request` to ``False``, the same instance will
be used for every request.

Except for ``name``, all other arguments passed to this method
are forwarded to the view class ``__init__`` method.

.. versionchanged:: 2.2
    Added the ``init_every_request`` class attribute.","    def as_view(
        cls, name: str, *class_args: t.Any, **class_kwargs: t.Any
    ) -> ft.RouteCallable:
        """"""Convert the class into a view function that can be registered
        for a route.

        By default, the generated view will create a new instance of the
        view class for every request and call its
        :meth:`dispatch_request` method. If the view class sets
        :attr:`init_every_request` to ``False``, the same instance will
        be used for every request.

        Except for ``name``, all other arguments passed to this method
        are forwarded to the view class ``__init__`` method.

        .. versionchanged:: 2.2
            Added the ``init_every_request`` class attribute.
        """"""
        if cls.init_every_request:

            def view(**kwargs: t.Any) -> ft.ResponseReturnValue:
                self = view.view_class(  # type: ignore[attr-defined]
                    *class_args, **class_kwargs
                )
                return current_app.ensure_sync(self.dispatch_request)(**kwargs)  # type: ignore[no-any-return]

        else:
            self = cls(*class_args, **class_kwargs)  # pyright: ignore

            def view(**kwargs: t.Any) -> ft.ResponseReturnValue:
                return current_app.ensure_sync(self.dispatch_request)(**kwargs)  # type: ignore[no-any-return]

        if cls.decorators:
            view.__name__ = name
            view.__module__ = cls.__module__
            for decorator in cls.decorators:
                view = decorator(view)

        # We attach the view class to the view function for two reasons:
        # first of all it allows us to easily figure out what class-based
        # view this thing came from, secondly it's also used for instantiating
        # the view class so you can actually replace it with something else
        # for testing purposes and debugging.
        view.view_class = cls  # type: ignore
        view.__name__ = name
        view.__doc__ = cls.__doc__
        view.__module__ = cls.__module__
        view.methods = cls.methods  # type: ignore
        view.provide_automatic_options = cls.provide_automatic_options  # type: ignore
        return view",False
8834fd1142b76cb97549c006a2d71666fe0b22ae,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\views.py,class,MethodView,MethodView,138,191,"Dispatches request methods to the corresponding instance methods.
For example, if you implement a ``get`` method, it will be used to
handle ``GET`` requests.

This can be useful for defining a REST API.

:attr:`methods` is automatically set based on the methods defined on
the class.

See :doc:`views` for a detailed guide.

.. code-block:: python

    class CounterAPI(MethodView):
        def get(self):
            return str(session.get(""counter"", 0))

        def post(self):
            session[""counter""] = session.get(""counter"", 0) + 1
            return redirect(url_for(""counter""))

    app.add_url_rule(
        ""/counter"", view_func=CounterAPI.as_view(""counter"")
    )","class MethodView(View):
    """"""Dispatches request methods to the corresponding instance methods.
    For example, if you implement a ``get`` method, it will be used to
    handle ``GET`` requests.

    This can be useful for defining a REST API.

    :attr:`methods` is automatically set based on the methods defined on
    the class.

    See :doc:`views` for a detailed guide.

    .. code-block:: python

        class CounterAPI(MethodView):
            def get(self):
                return str(session.get(""counter"", 0))

            def post(self):
                session[""counter""] = session.get(""counter"", 0) + 1
                return redirect(url_for(""counter""))

        app.add_url_rule(
            ""/counter"", view_func=CounterAPI.as_view(""counter"")
        )
    """"""

    def __init_subclass__(cls, **kwargs: t.Any) -> None:
        super().__init_subclass__(**kwargs)

        if ""methods"" not in cls.__dict__:
            methods = set()

            for base in cls.__bases__:
                if getattr(base, ""methods"", None):
                    methods.update(base.methods)  # type: ignore[attr-defined]

            for key in http_method_funcs:
                if hasattr(cls, key):
                    methods.add(key.upper())

            if methods:
                cls.methods = methods

    def dispatch_request(self, **kwargs: t.Any) -> ft.ResponseReturnValue:
        meth = getattr(self, request.method.lower(), None)

        # If the request method is HEAD and we don't have a handler for it
        # retry with GET.
        if meth is None and request.method == ""HEAD"":
            meth = getattr(self, ""get"", None)

        assert meth is not None, f""Unimplemented method {request.method!r}""
        return current_app.ensure_sync(meth)(**kwargs)  # type: ignore[no-any-return]",False
0ab54ed8fd956f4610215c3590b05e0d7c1b0d39,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\views.py,method,__init_subclass__,MethodView.__init_subclass__,165,180,,"    def __init_subclass__(cls, **kwargs: t.Any) -> None:
        super().__init_subclass__(**kwargs)

        if ""methods"" not in cls.__dict__:
            methods = set()

            for base in cls.__bases__:
                if getattr(base, ""methods"", None):
                    methods.update(base.methods)  # type: ignore[attr-defined]

            for key in http_method_funcs:
                if hasattr(cls, key):
                    methods.add(key.upper())

            if methods:
                cls.methods = methods",False
de86014793b9c98c5f2e2a31859f77b1e2c44f15,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\views.py,method,dispatch_request,MethodView.dispatch_request,182,191,,"    def dispatch_request(self, **kwargs: t.Any) -> ft.ResponseReturnValue:
        meth = getattr(self, request.method.lower(), None)

        # If the request method is HEAD and we don't have a handler for it
        # retry with GET.
        if meth is None and request.method == ""HEAD"":
            meth = getattr(self, ""get"", None)

        assert meth is not None, f""Unimplemented method {request.method!r}""
        return current_app.ensure_sync(meth)(**kwargs)  # type: ignore[no-any-return]",False
09f37e17fa8339f46a595a3965f217d0ba50f69f,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\wrappers.py,class,Request,Request,18,219,"The request object used by default in Flask.  Remembers the
matched endpoint and view arguments.

It is what ends up as :class:`~flask.request`.  If you want to replace
the request object used you can subclass this and set
:attr:`~flask.Flask.request_class` to your subclass.

The request object is a :class:`~werkzeug.wrappers.Request` subclass and
provides all of the attributes Werkzeug defines plus a few Flask
specific ones.","class Request(RequestBase):
    """"""The request object used by default in Flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.

    The request object is a :class:`~werkzeug.wrappers.Request` subclass and
    provides all of the attributes Werkzeug defines plus a few Flask
    specific ones.
    """"""

    json_module: t.Any = json

    #: The internal URL rule that matched the request.  This can be
    #: useful to inspect which methods are allowed for the URL from
    #: a before/after handler (``request.url_rule.methods``) etc.
    #: Though if the request's method was invalid for the URL rule,
    #: the valid list is available in ``routing_exception.valid_methods``
    #: instead (an attribute of the Werkzeug exception
    #: :exc:`~werkzeug.exceptions.MethodNotAllowed`)
    #: because the request was never internally bound.
    #:
    #: .. versionadded:: 0.6
    url_rule: Rule | None = None

    #: A dict of view arguments that matched the request.  If an exception
    #: happened when matching, this will be ``None``.
    view_args: dict[str, t.Any] | None = None

    #: If matching the URL failed, this is the exception that will be
    #: raised / was raised as part of the request handling.  This is
    #: usually a :exc:`~werkzeug.exceptions.NotFound` exception or
    #: something similar.
    routing_exception: HTTPException | None = None

    _max_content_length: int | None = None
    _max_form_memory_size: int | None = None
    _max_form_parts: int | None = None

    @property
    def max_content_length(self) -> int | None:
        """"""The maximum number of bytes that will be read during this request. If
        this limit is exceeded, a 413 :exc:`~werkzeug.exceptions.RequestEntityTooLarge`
        error is raised. If it is set to ``None``, no limit is enforced at the
        Flask application level. However, if it is ``None`` and the request has
        no ``Content-Length`` header and the WSGI server does not indicate that
        it terminates the stream, then no data is read to avoid an infinite
        stream.

        Each request defaults to the :data:`MAX_CONTENT_LENGTH` config, which
        defaults to ``None``. It can be set on a specific ``request`` to apply
        the limit to that specific view. This should be set appropriately based
        on an application's or view's specific needs.

        .. versionchanged:: 3.1
            This can be set per-request.

        .. versionchanged:: 0.6
            This is configurable through Flask config.
        """"""
        if self._max_content_length is not None:
            return self._max_content_length

        if not current_app:
            return super().max_content_length

        return current_app.config[""MAX_CONTENT_LENGTH""]  # type: ignore[no-any-return]

    @max_content_length.setter
    def max_content_length(self, value: int | None) -> None:
        self._max_content_length = value

    @property
    def max_form_memory_size(self) -> int | None:
        """"""The maximum size in bytes any non-file form field may be in a
        ``multipart/form-data`` body. If this limit is exceeded, a 413
        :exc:`~werkzeug.exceptions.RequestEntityTooLarge` error is raised. If it
        is set to ``None``, no limit is enforced at the Flask application level.

        Each request defaults to the :data:`MAX_FORM_MEMORY_SIZE` config, which
        defaults to ``500_000``. It can be set on a specific ``request`` to
        apply the limit to that specific view. This should be set appropriately
        based on an application's or view's specific needs.

        .. versionchanged:: 3.1
            This is configurable through Flask config.
        """"""
        if self._max_form_memory_size is not None:
            return self._max_form_memory_size

        if not current_app:
            return super().max_form_memory_size

        return current_app.config[""MAX_FORM_MEMORY_SIZE""]  # type: ignore[no-any-return]

    @max_form_memory_size.setter
    def max_form_memory_size(self, value: int | None) -> None:
        self._max_form_memory_size = value

    @property  # type: ignore[override]
    def max_form_parts(self) -> int | None:
        """"""The maximum number of fields that may be present in a
        ``multipart/form-data`` body. If this limit is exceeded, a 413
        :exc:`~werkzeug.exceptions.RequestEntityTooLarge` error is raised. If it
        is set to ``None``, no limit is enforced at the Flask application level.

        Each request defaults to the :data:`MAX_FORM_PARTS` config, which
        defaults to ``1_000``. It can be set on a specific ``request`` to apply
        the limit to that specific view. This should be set appropriately based
        on an application's or view's specific needs.

        .. versionchanged:: 3.1
            This is configurable through Flask config.
        """"""
        if self._max_form_parts is not None:
            return self._max_form_parts

        if not current_app:
            return super().max_form_parts

        return current_app.config[""MAX_FORM_PARTS""]  # type: ignore[no-any-return]

    @max_form_parts.setter
    def max_form_parts(self, value: int | None) -> None:
        self._max_form_parts = value

    @property
    def endpoint(self) -> str | None:
        """"""The endpoint that matched the request URL.

        This will be ``None`` if matching failed or has not been
        performed yet.

        This in combination with :attr:`view_args` can be used to
        reconstruct the same URL or a modified URL.
        """"""
        if self.url_rule is not None:
            return self.url_rule.endpoint  # type: ignore[no-any-return]

        return None

    @property
    def blueprint(self) -> str | None:
        """"""The registered name of the current blueprint.

        This will be ``None`` if the endpoint is not part of a
        blueprint, or if URL matching failed or has not been performed
        yet.

        This does not necessarily match the name the blueprint was
        created with. It may have been nested, or registered with a
        different name.
        """"""
        endpoint = self.endpoint

        if endpoint is not None and ""."" in endpoint:
            return endpoint.rpartition(""."")[0]

        return None

    @property
    def blueprints(self) -> list[str]:
        """"""The registered names of the current blueprint upwards through
        parent blueprints.

        This will be an empty list if there is no current blueprint, or
        if URL matching failed.

        .. versionadded:: 2.0.1
        """"""
        name = self.blueprint

        if name is None:
            return []

        return _split_blueprint_path(name)

    def _load_form_data(self) -> None:
        super()._load_form_data()

        # In debug mode we're replacing the files multidict with an ad-hoc
        # subclass that raises a different error for key errors.
        if (
            current_app
            and current_app.debug
            and self.mimetype != ""multipart/form-data""
            and not self.files
        ):
            from .debughelpers import attach_enctype_error_multidict

            attach_enctype_error_multidict(self)

    def on_json_loading_failed(self, e: ValueError | None) -> t.Any:
        try:
            return super().on_json_loading_failed(e)
        except BadRequest as ebr:
            if current_app and current_app.debug:
                raise

            raise BadRequest() from ebr",False
45410cff31060f374e09c0fb922eb08160d67d01,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\wrappers.py,method,max_content_length,Request.max_content_length,60,86,"The maximum number of bytes that will be read during this request. If
this limit is exceeded, a 413 :exc:`~werkzeug.exceptions.RequestEntityTooLarge`
error is raised. If it is set to ``None``, no limit is enforced at the
Flask application level. However, if it is ``None`` and the request has
no ``Content-Length`` header and the WSGI server does not indicate that
it terminates the stream, then no data is read to avoid an infinite
stream.

Each request defaults to the :data:`MAX_CONTENT_LENGTH` config, which
defaults to ``None``. It can be set on a specific ``request`` to apply
the limit to that specific view. This should be set appropriately based
on an application's or view's specific needs.

.. versionchanged:: 3.1
    This can be set per-request.

.. versionchanged:: 0.6
    This is configurable through Flask config.","    def max_content_length(self) -> int | None:
        """"""The maximum number of bytes that will be read during this request. If
        this limit is exceeded, a 413 :exc:`~werkzeug.exceptions.RequestEntityTooLarge`
        error is raised. If it is set to ``None``, no limit is enforced at the
        Flask application level. However, if it is ``None`` and the request has
        no ``Content-Length`` header and the WSGI server does not indicate that
        it terminates the stream, then no data is read to avoid an infinite
        stream.

        Each request defaults to the :data:`MAX_CONTENT_LENGTH` config, which
        defaults to ``None``. It can be set on a specific ``request`` to apply
        the limit to that specific view. This should be set appropriately based
        on an application's or view's specific needs.

        .. versionchanged:: 3.1
            This can be set per-request.

        .. versionchanged:: 0.6
            This is configurable through Flask config.
        """"""
        if self._max_content_length is not None:
            return self._max_content_length

        if not current_app:
            return super().max_content_length

        return current_app.config[""MAX_CONTENT_LENGTH""]  # type: ignore[no-any-return]",False
b9bd53a3f09cc9efcf56c136b4acb7fc46b08abd,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\wrappers.py,method,max_content_length,Request.max_content_length,89,90,,"    def max_content_length(self, value: int | None) -> None:
        self._max_content_length = value",False
aa7a37acd24116cf44872f6bc255ad4c5f589748,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\wrappers.py,method,max_form_memory_size,Request.max_form_memory_size,93,113,"The maximum size in bytes any non-file form field may be in a
``multipart/form-data`` body. If this limit is exceeded, a 413
:exc:`~werkzeug.exceptions.RequestEntityTooLarge` error is raised. If it
is set to ``None``, no limit is enforced at the Flask application level.

Each request defaults to the :data:`MAX_FORM_MEMORY_SIZE` config, which
defaults to ``500_000``. It can be set on a specific ``request`` to
apply the limit to that specific view. This should be set appropriately
based on an application's or view's specific needs.

.. versionchanged:: 3.1
    This is configurable through Flask config.","    def max_form_memory_size(self) -> int | None:
        """"""The maximum size in bytes any non-file form field may be in a
        ``multipart/form-data`` body. If this limit is exceeded, a 413
        :exc:`~werkzeug.exceptions.RequestEntityTooLarge` error is raised. If it
        is set to ``None``, no limit is enforced at the Flask application level.

        Each request defaults to the :data:`MAX_FORM_MEMORY_SIZE` config, which
        defaults to ``500_000``. It can be set on a specific ``request`` to
        apply the limit to that specific view. This should be set appropriately
        based on an application's or view's specific needs.

        .. versionchanged:: 3.1
            This is configurable through Flask config.
        """"""
        if self._max_form_memory_size is not None:
            return self._max_form_memory_size

        if not current_app:
            return super().max_form_memory_size

        return current_app.config[""MAX_FORM_MEMORY_SIZE""]  # type: ignore[no-any-return]",False
b8777aec823ef8bb6d7b4459cb4690e9d1965abf,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\wrappers.py,method,max_form_memory_size,Request.max_form_memory_size,116,117,,"    def max_form_memory_size(self, value: int | None) -> None:
        self._max_form_memory_size = value",False
17d7a93271b1c4ddd7d7d42afb3e3030f615072a,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\wrappers.py,method,max_form_parts,Request.max_form_parts,120,140,"The maximum number of fields that may be present in a
``multipart/form-data`` body. If this limit is exceeded, a 413
:exc:`~werkzeug.exceptions.RequestEntityTooLarge` error is raised. If it
is set to ``None``, no limit is enforced at the Flask application level.

Each request defaults to the :data:`MAX_FORM_PARTS` config, which
defaults to ``1_000``. It can be set on a specific ``request`` to apply
the limit to that specific view. This should be set appropriately based
on an application's or view's specific needs.

.. versionchanged:: 3.1
    This is configurable through Flask config.","    def max_form_parts(self) -> int | None:
        """"""The maximum number of fields that may be present in a
        ``multipart/form-data`` body. If this limit is exceeded, a 413
        :exc:`~werkzeug.exceptions.RequestEntityTooLarge` error is raised. If it
        is set to ``None``, no limit is enforced at the Flask application level.

        Each request defaults to the :data:`MAX_FORM_PARTS` config, which
        defaults to ``1_000``. It can be set on a specific ``request`` to apply
        the limit to that specific view. This should be set appropriately based
        on an application's or view's specific needs.

        .. versionchanged:: 3.1
            This is configurable through Flask config.
        """"""
        if self._max_form_parts is not None:
            return self._max_form_parts

        if not current_app:
            return super().max_form_parts

        return current_app.config[""MAX_FORM_PARTS""]  # type: ignore[no-any-return]",False
c168c8c48bf5653c1506a70cbd14edae1142a180,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\wrappers.py,method,max_form_parts,Request.max_form_parts,143,144,,"    def max_form_parts(self, value: int | None) -> None:
        self._max_form_parts = value",False
03a9bfaff5bdc090fab55d82e3d9603cff0a048e,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\wrappers.py,method,endpoint,Request.endpoint,147,159,"The endpoint that matched the request URL.

This will be ``None`` if matching failed or has not been
performed yet.

This in combination with :attr:`view_args` can be used to
reconstruct the same URL or a modified URL.","    def endpoint(self) -> str | None:
        """"""The endpoint that matched the request URL.

        This will be ``None`` if matching failed or has not been
        performed yet.

        This in combination with :attr:`view_args` can be used to
        reconstruct the same URL or a modified URL.
        """"""
        if self.url_rule is not None:
            return self.url_rule.endpoint  # type: ignore[no-any-return]

        return None",False
0e75b263d01b7e4283297353ac357e3b3ff953b0,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\wrappers.py,method,blueprint,Request.blueprint,162,178,"The registered name of the current blueprint.

This will be ``None`` if the endpoint is not part of a
blueprint, or if URL matching failed or has not been performed
yet.

This does not necessarily match the name the blueprint was
created with. It may have been nested, or registered with a
different name.","    def blueprint(self) -> str | None:
        """"""The registered name of the current blueprint.

        This will be ``None`` if the endpoint is not part of a
        blueprint, or if URL matching failed or has not been performed
        yet.

        This does not necessarily match the name the blueprint was
        created with. It may have been nested, or registered with a
        different name.
        """"""
        endpoint = self.endpoint

        if endpoint is not None and ""."" in endpoint:
            return endpoint.rpartition(""."")[0]

        return None",False
73bc4b0e4ff8ed444e205cde1027ee17aedde06a,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\wrappers.py,method,blueprints,Request.blueprints,181,195,"The registered names of the current blueprint upwards through
parent blueprints.

This will be an empty list if there is no current blueprint, or
if URL matching failed.

.. versionadded:: 2.0.1","    def blueprints(self) -> list[str]:
        """"""The registered names of the current blueprint upwards through
        parent blueprints.

        This will be an empty list if there is no current blueprint, or
        if URL matching failed.

        .. versionadded:: 2.0.1
        """"""
        name = self.blueprint

        if name is None:
            return []

        return _split_blueprint_path(name)",False
195fbd923a23cb6c06f8d4c429968ad7dd526495,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\wrappers.py,method,_load_form_data,Request._load_form_data,197,210,,"    def _load_form_data(self) -> None:
        super()._load_form_data()

        # In debug mode we're replacing the files multidict with an ad-hoc
        # subclass that raises a different error for key errors.
        if (
            current_app
            and current_app.debug
            and self.mimetype != ""multipart/form-data""
            and not self.files
        ):
            from .debughelpers import attach_enctype_error_multidict

            attach_enctype_error_multidict(self)",False
4a06c290ff1bf27267c211443014ee89ab18af2e,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\wrappers.py,method,on_json_loading_failed,Request.on_json_loading_failed,212,219,,"    def on_json_loading_failed(self, e: ValueError | None) -> t.Any:
        try:
            return super().on_json_loading_failed(e)
        except BadRequest as ebr:
            if current_app and current_app.debug:
                raise

            raise BadRequest() from ebr",False
e65430f9b3da8a52b9d290a20e1bb8415b691793,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\wrappers.py,class,Response,Response,222,257,"The response object that is used by default in Flask.  Works like the
response object from Werkzeug but is set to have an HTML mimetype by
default.  Quite often you don't have to create this object yourself because
:meth:`~flask.Flask.make_response` will take care of that for you.

If you want to replace the response object used you can subclass this and
set :attr:`~flask.Flask.response_class` to your subclass.

.. versionchanged:: 1.0
    JSON support is added to the response, like the request. This is useful
    when testing to get the test client response data as JSON.

.. versionchanged:: 1.0

    Added :attr:`max_cookie_size`.","class Response(ResponseBase):
    """"""The response object that is used by default in Flask.  Works like the
    response object from Werkzeug but is set to have an HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.response_class` to your subclass.

    .. versionchanged:: 1.0
        JSON support is added to the response, like the request. This is useful
        when testing to get the test client response data as JSON.

    .. versionchanged:: 1.0

        Added :attr:`max_cookie_size`.
    """"""

    default_mimetype: str | None = ""text/html""

    json_module = json

    autocorrect_location_header = False

    @property
    def max_cookie_size(self) -> int:  # type: ignore
        """"""Read-only view of the :data:`MAX_COOKIE_SIZE` config key.

        See :attr:`~werkzeug.wrappers.Response.max_cookie_size` in
        Werkzeug's docs.
        """"""
        if current_app:
            return current_app.config[""MAX_COOKIE_SIZE""]  # type: ignore[no-any-return]

        # return Werkzeug's default when not in an app context
        return super().max_cookie_size",False
4c7ffd07096fd2a38dd7309e6f20d20fe704f990,d:\499\src\flask-3.1.2\flask-3.1.2\src\flask\wrappers.py,method,max_cookie_size,Response.max_cookie_size,247,257,"Read-only view of the :data:`MAX_COOKIE_SIZE` config key.

See :attr:`~werkzeug.wrappers.Response.max_cookie_size` in
Werkzeug's docs.","    def max_cookie_size(self) -> int:  # type: ignore
        """"""Read-only view of the :data:`MAX_COOKIE_SIZE` config key.

        See :attr:`~werkzeug.wrappers.Response.max_cookie_size` in
        Werkzeug's docs.
        """"""
        if current_app:
            return current_app.config[""MAX_COOKIE_SIZE""]  # type: ignore[no-any-return]

        # return Werkzeug's default when not in an app context
        return super().max_cookie_size",False
