{"chunk_id": "a689a867fc1fd922c6ae51cb5e7909605ae5d9eb", "file_path": "d:\\499\\docs\\api.rst", "symbol_type": "doc", "name": "API", "qualname": "api.rst#API", "start_line": 2, "end_line": 9, "docstring": null, "code": "===\n\n.. module:: flask\n\nThis part of the documentation covers all the interfaces of Flask. For\nparts where Flask depends on external libraries, we document the most\nimportant right here and provide links to the canonical documentation.", "code_truncated": false}
{"chunk_id": "3f3b4bd23d19daff4c00e3a8b58ee6e3750ed7df", "file_path": "d:\\499\\docs\\api.rst", "symbol_type": "doc", "name": "Application Object", "qualname": "api.rst#Application Object", "start_line": 12, "end_line": 17, "docstring": null, "code": "------------------\n\n.. autoclass:: Flask\n   :members:\n   :inherited-members:", "code_truncated": false}
{"chunk_id": "fe09b7a26fcb1183c906186ed5c7ca6377e2fe14", "file_path": "d:\\499\\docs\\api.rst", "symbol_type": "doc", "name": "Blueprint Objects", "qualname": "api.rst#Blueprint Objects", "start_line": 20, "end_line": 24, "docstring": null, "code": "-----------------\n\n.. autoclass:: Blueprint\n   :members:\n   :inherited-members:", "code_truncated": false}
{"chunk_id": "d56191798bf10c0375ef91b891f3418632e2103e", "file_path": "d:\\499\\docs\\api.rst", "symbol_type": "doc", "name": "Incoming Request Data", "qualname": "api.rst#Incoming Request Data", "start_line": 27, "end_line": 43, "docstring": null, "code": "---------------------\n\n.. autoclass:: Request\n    :members:\n    :inherited-members:\n    :exclude-members: json_module\n\n.. data:: request\n\n    A proxy to the request data for the current request, an instance of\n    :class:`.Request`.\n\n    This is only available when a :doc:`request context </appcontext>` is\n    active.\n\n    This is a proxy. See :ref:`context-visibility` for more information.", "code_truncated": false}
{"chunk_id": "cdbdd848622fd72228ce8a7b5297337960321cfa", "file_path": "d:\\499\\docs\\api.rst", "symbol_type": "doc", "name": "Response Objects", "qualname": "api.rst#Response Objects", "start_line": 46, "end_line": 51, "docstring": null, "code": "----------------\n\n.. autoclass:: flask.Response\n    :members:\n    :inherited-members:\n    :exclude-members: json_module", "code_truncated": false}
{"chunk_id": "8ba361a240d1982b668a83f8eeff69174b353f72", "file_path": "d:\\499\\docs\\api.rst", "symbol_type": "doc", "name": "Sessions", "qualname": "api.rst#Sessions", "start_line": 54, "end_line": 90, "docstring": null, "code": "--------\n\nIf you have set :attr:`Flask.secret_key` (or configured it from\n:data:`SECRET_KEY`) you can use sessions in Flask applications. A session makes\nit possible to remember information from one request to another. The way Flask\ndoes this is by using a signed cookie. The user can look at the session\ncontents, but can't modify it unless they know the secret key, so make sure to\nset that to something complex and unguessable.\n\nTo access the current session you can use the :data:`.session` proxy.\n\n.. data:: session\n\n    A proxy to the session data for the current request, an instance of\n    :class:`.SessionMixin`.\n\n    This is only available when a :doc:`request context </appcontext>` is\n    active.\n\n    This is a proxy. See :ref:`context-visibility` for more information.\n\n    The session object works like a dict but tracks assignment and access to its\n    keys. It cannot track modifications to mutable values, you need to set\n    :attr:`~.SessionMixin.modified` manually when modifying a list, dict, etc.\n\n    .. code-block:: python\n\n          # appending to a list is not detected\n          session[\"numbers\"].append(42)\n          # so mark it as modified yourself\n          session.modified = True\n\n    The session is persisted across requests using a cookie. By default the\n    users's browser will clear the cookie when it is closed. Set\n    :attr:`~.SessionMixin.permanent` to ``True`` to persist the cookie for\n    :data:`PERMANENT_SESSION_LIFETIME`.", "code_truncated": false}
{"chunk_id": "1ade0fefba4b1a607e881e840e63e6868965cf44", "file_path": "d:\\499\\docs\\api.rst", "symbol_type": "doc", "name": "Session Interface", "qualname": "api.rst#Session Interface", "start_line": 93, "end_line": 122, "docstring": null, "code": "-----------------\n\n.. versionadded:: 0.8\n\nThe session interface provides a simple way to replace the session\nimplementation that Flask is using.\n\n.. currentmodule:: flask.sessions\n\n.. autoclass:: SessionInterface\n   :members:\n\n.. autoclass:: SecureCookieSessionInterface\n   :members:\n\n.. autoclass:: SecureCookieSession\n   :members:\n\n.. autoclass:: NullSession\n   :members:\n\n.. autoclass:: SessionMixin\n   :members:\n\n.. admonition:: Notice\n\n    The :data:`PERMANENT_SESSION_LIFETIME` config can be an integer or ``timedelta``.\n    The :attr:`~flask.Flask.permanent_session_lifetime` attribute is always a\n    ``timedelta``.", "code_truncated": false}
{"chunk_id": "284e02c98453b712377c9a51b3480cbd078d861e", "file_path": "d:\\499\\docs\\api.rst", "symbol_type": "doc", "name": "Test Client", "qualname": "api.rst#Test Client", "start_line": 125, "end_line": 131, "docstring": null, "code": "-----------\n\n.. currentmodule:: flask.testing\n\n.. autoclass:: FlaskClient\n   :members:", "code_truncated": false}
{"chunk_id": "a21bce2678312b81e721be92fc8f8cfc95551f5a", "file_path": "d:\\499\\docs\\api.rst", "symbol_type": "doc", "name": "Test CLI Runner", "qualname": "api.rst#Test CLI Runner", "start_line": 134, "end_line": 140, "docstring": null, "code": "---------------\n\n.. currentmodule:: flask.testing\n\n.. autoclass:: FlaskCliRunner\n    :members:", "code_truncated": false}
{"chunk_id": "ed3eba241917d57b514d27e353ec8ddbbf3be8a7", "file_path": "d:\\499\\docs\\api.rst", "symbol_type": "doc", "name": "Application Globals", "qualname": "api.rst#Application Globals", "start_line": 143, "end_line": 173, "docstring": null, "code": "-------------------\n\n.. currentmodule:: flask\n\nTo share data that is valid for one request only from one function to\nanother, a global variable is not good enough because it would break in\nthreaded environments. Flask provides you with a special object that\nensures it is only valid for the active request and that will return\ndifferent values for each request. In a nutshell: it does the right\nthing, like it does for :data:`.request` and :data:`.session`.\n\n.. data:: g\n\n    A proxy to a namespace object used to store data during a single request or\n    app context. An instance of :attr:`.Flask.app_ctx_globals_class`, which\n    defaults to :class:`._AppCtxGlobals`.\n\n    This is a good place to store resources during a request. For example, a\n    :meth:`~.Flask.before_request` function could load a user object from a\n    session id, then set ``g.user`` to be used in the view function.\n\n    This is only available when an :doc:`app context </appcontext>` is active.\n\n    This is a proxy. See :ref:`context-visibility` for more information.\n\n    .. versionchanged:: 0.10\n        Bound to the application context instead of the request context.\n\n.. autoclass:: flask.ctx._AppCtxGlobals\n    :members:", "code_truncated": false}
{"chunk_id": "ab10945011d713a972f46f9f70507512b90b2cb3", "file_path": "d:\\499\\docs\\api.rst", "symbol_type": "doc", "name": "Useful Functions and Classes", "qualname": "api.rst#Useful Functions and Classes", "start_line": 176, "end_line": 210, "docstring": null, "code": "----------------------------\n\n.. data:: current_app\n\n    A proxy to the :class:`.Flask` application handling the current request or\n    other activity.\n\n    This is useful to access the application without needing to import it, or if\n    it can't be imported, such as when using the application factory pattern or\n    in blueprints and extensions.\n\n    This is only available when an :doc:`app context </appcontext>` is active.\n\n    This is a proxy. See :ref:`context-visibility` for more information.\n\n.. autofunction:: has_request_context\n\n.. autofunction:: copy_current_request_context\n\n.. autofunction:: has_app_context\n\n.. autofunction:: url_for\n\n.. autofunction:: abort\n\n.. autofunction:: redirect\n\n.. autofunction:: make_response\n\n.. autofunction:: after_this_request\n\n.. autofunction:: send_file\n\n.. autofunction:: send_from_directory", "code_truncated": false}
{"chunk_id": "782f744112a1258e2dea2bd8877bb10cb2271aa4", "file_path": "d:\\499\\docs\\api.rst", "symbol_type": "doc", "name": "Message Flashing", "qualname": "api.rst#Message Flashing", "start_line": 213, "end_line": 218, "docstring": null, "code": "----------------\n\n.. autofunction:: flash\n\n.. autofunction:: get_flashed_messages", "code_truncated": false}
{"chunk_id": "fbd87be76e29e9913e8259191b165b5cb3a8b354", "file_path": "d:\\499\\docs\\api.rst", "symbol_type": "doc", "name": "JSON Support", "qualname": "api.rst#JSON Support", "start_line": 221, "end_line": 261, "docstring": null, "code": "------------\n\n.. module:: flask.json\n\nFlask uses Python's built-in :mod:`json` module for handling JSON by\ndefault. The JSON implementation can be changed by assigning a different\nprovider to :attr:`flask.Flask.json_provider_class` or\n:attr:`flask.Flask.json`. The functions provided by ``flask.json`` will\nuse methods on ``app.json`` if an app context is active.\n\nJinja's ``|tojson`` filter is configured to use the app's JSON provider.\nThe filter marks the output with ``|safe``. Use it to render data inside\nHTML ``<script>`` tags.\n\n.. sourcecode:: html+jinja\n\n    <script>\n        const names = {{ names|tojson }};\n        renderChart(names, {{ axis_data|tojson }});\n    </script>\n\n.. autofunction:: jsonify\n\n.. autofunction:: dumps\n\n.. autofunction:: dump\n\n.. autofunction:: loads\n\n.. autofunction:: load\n\n.. autoclass:: flask.json.provider.JSONProvider\n    :members:\n    :member-order: bysource\n\n.. autoclass:: flask.json.provider.DefaultJSONProvider\n    :members:\n    :member-order: bysource\n\n.. automodule:: flask.json.tag", "code_truncated": false}
{"chunk_id": "e324d671c9d1464b00fc8104f383dc5286dd0209", "file_path": "d:\\499\\docs\\api.rst", "symbol_type": "doc", "name": "Template Rendering", "qualname": "api.rst#Template Rendering", "start_line": 264, "end_line": 276, "docstring": null, "code": "------------------\n\n.. currentmodule:: flask\n\n.. autofunction:: render_template\n\n.. autofunction:: render_template_string\n\n.. autofunction:: stream_template\n\n.. autofunction:: stream_template_string\n\n.. autofunction:: get_template_attribute", "code_truncated": false}
{"chunk_id": "e7c5cab5c59c8ce5f4de521a288eb5217e9e6f38", "file_path": "d:\\499\\docs\\api.rst", "symbol_type": "doc", "name": "Configuration", "qualname": "api.rst#Configuration", "start_line": 279, "end_line": 283, "docstring": null, "code": "-------------\n\n.. autoclass:: Config\n   :members:", "code_truncated": false}
{"chunk_id": "4c01e9f103fce3c201a60e8e5003b553de8c0d36", "file_path": "d:\\499\\docs\\api.rst", "symbol_type": "doc", "name": "Stream Helpers", "qualname": "api.rst#Stream Helpers", "start_line": 286, "end_line": 288, "docstring": null, "code": "--------------\n\n.. autofunction:: stream_with_context", "code_truncated": false}
{"chunk_id": "d07f4fc95e5d6d972eea01c5fce8b381d03741dd", "file_path": "d:\\499\\docs\\api.rst", "symbol_type": "doc", "name": "Useful Internals", "qualname": "api.rst#Useful Internals", "start_line": 291, "end_line": 322, "docstring": null, "code": "----------------\n\n.. autoclass:: flask.ctx.AppContext\n   :members:\n\n.. data:: flask.globals.app_ctx\n\n    A proxy to the active :class:`.AppContext`.\n\n    This is an internal object that is essential to how Flask handles requests.\n    Accessing this should not be needed in most cases. Most likely you want\n    :data:`.current_app`, :data:`.g`, :data:`.request`, and :data:`.session` instead.\n\n    This is only available when a :doc:`request context </appcontext>` is\n    active.\n\n    This is a proxy. See :ref:`context-visibility` for more information.\n\n.. class:: flask.ctx.RequestContext\n\n    .. deprecated:: 3.2\n        Merged with :class:`AppContext`. This alias will be removed in Flask 4.0.\n\n.. data:: flask.globals.request_ctx\n\n    .. deprecated:: 3.2\n        Merged with :data:`.app_ctx`. This alias will be removed in Flask 4.0.\n\n.. autoclass:: flask.blueprints.BlueprintSetupState\n   :members:\n\n.. _core-signals-list:", "code_truncated": false}
{"chunk_id": "975a14e5adcd8a15b4fc0e5b9ccfc04b4328b391", "file_path": "d:\\499\\docs\\api.rst", "symbol_type": "doc", "name": "Signals", "qualname": "api.rst#Signals", "start_line": 325, "end_line": 512, "docstring": null, "code": "-------\n\nSignals are provided by the `Blinker`_ library. See :doc:`signals` for an introduction.\n\n.. _blinker: https://blinker.readthedocs.io/\n\n.. data:: template_rendered\n\n   This signal is sent when a template was successfully rendered. The\n   signal is invoked with the instance of the template as `template`\n   and the context as dictionary (named `context`).\n\n   Example subscriber::\n\n        def log_template_renders(sender, template, context, **extra):\n            sender.logger.debug('Rendering template \"%s\" with context %s',\n                                template.name or 'string template',\n                                context)\n\n        from flask import template_rendered\n        template_rendered.connect(log_template_renders, app)\n\n.. data:: flask.before_render_template\n   :noindex:\n\n   This signal is sent before template rendering process. The\n   signal is invoked with the instance of the template as `template`\n   and the context as dictionary (named `context`).\n\n   Example subscriber::\n\n        def log_template_renders(sender, template, context, **extra):\n            sender.logger.debug('Rendering template \"%s\" with context %s',\n                                template.name or 'string template',\n                                context)\n\n        from flask import before_render_template\n        before_render_template.connect(log_template_renders, app)\n\n.. data:: request_started\n\n   This signal is sent when the request context is set up, before\n   any request processing happens. Because the request context is already\n   bound, the subscriber can access the request with the standard global\n   proxies such as :class:`~flask.request`.\n\n   Example subscriber::\n\n        def log_request(sender, **extra):\n            sender.logger.debug('Request context is set up')\n\n        from flask import request_started\n        request_started.connect(log_request, app)\n\n.. data:: request_finished\n\n   This signal is sent right before the response is sent to the client.\n   It is passed the response to be sent named `response`.\n\n   Example subscriber::\n\n        def log_response(sender, response, **extra):\n            sender.logger.debug('Request context is about to close down. '\n                                'Response: %s', response)\n\n        from flask import request_finished\n        request_finished.connect(log_response, app)\n\n.. data:: got_request_exception\n\n    This signal is sent when an unhandled exception happens during\n    request processing, including when debugging. The exception is\n    passed to the subscriber as ``exception``.\n\n    This signal is not sent for\n    :exc:`~werkzeug.exceptions.HTTPException`, or other exceptions that\n    have error handlers registered, unless the exception was raised from\n    an error handler.\n\n    This example shows how to do some extra logging if a theoretical\n    ``SecurityException`` was raised:\n\n    .. code-block:: python\n\n        from flask import got_request_exception\n\n        def log_security_exception(sender, exception, **extra):\n            if not isinstance(exception, SecurityException):\n                return\n\n            security_logger.exception(\n                f\"SecurityException at {request.url!r}\",\n                exc_info=exception,\n            )\n\n        got_request_exception.connect(log_security_exception, app)\n\n.. data:: request_tearing_down\n\n   This signal is sent when the request is tearing down. This is always\n   called, even if an exception is caused. Currently functions listening\n   to this signal are called after the regular teardown handlers, but this\n   is not something you can rely on.\n\n   Example subscriber::\n\n        def close_db_connection(sender, **extra):\n            session.close()\n\n        from flask import request_tearing_down\n        request_tearing_down.connect(close_db_connection, app)\n\n   As of Flask 0.9, this will also be passed an `exc` keyword argument\n   that has a reference to the exception that caused the teardown if\n   there was one.\n\n.. data:: appcontext_tearing_down\n\n   This signal is sent when the app context is tearing down. This is always\n   called, even if an exception is caused. Currently functions listening\n   to this signal are called after the regular teardown handlers, but this\n   is not something you can rely on.\n\n   Example subscriber::\n\n        def close_db_connection(sender, **extra):\n            session.close()\n\n        from flask import appcontext_tearing_down\n        appcontext_tearing_down.connect(close_db_connection, app)\n\n   This will also be passed an `exc` keyword argument that has a reference\n   to the exception that caused the teardown if there was one.\n\n.. data:: appcontext_pushed\n\n   This signal is sent when an application context is pushed. The sender\n   is the application. This is usually useful for unittests in order to\n   temporarily hook in information. For instance it can be used to\n   set a resource early onto the `g` object.\n\n   Example usage::\n\n        from contextlib import contextmanager\n        from flask import appcontext_pushed\n\n        @contextmanager\n        def user_set(app, user):\n            def handler(sender, **kwargs):\n                g.user = user\n            with appcontext_pushed.connected_to(handler, app):\n                yield\n\n   And in the testcode::\n\n        def test_user_me(self):\n            with user_set(app, 'john'):\n                c = app.test_client()\n                resp = c.get('/users/me')\n                assert resp.data == 'username=john'\n\n   .. versionadded:: 0.10\n\n.. data:: appcontext_popped\n\n   This signal is sent when an application context is popped. The sender\n   is the application. This usually falls in line with the\n   :data:`appcontext_tearing_down` signal.\n\n   .. versionadded:: 0.10\n\n.. data:: message_flashed\n\n   This signal is sent when the application is flashing a message. The\n   messages is sent as `message` keyword argument and the category as\n   `category`.\n\n   Example subscriber::\n\n        recorded = []\n        def record(sender, message, category, **extra):\n            recorded.append((message, category))\n\n        from flask import message_flashed\n        message_flashed.connect(record, app)\n\n   .. versionadded:: 0.10", "code_truncated": false}
{"chunk_id": "8f11ba86f0036688382d51ab94239a054a8c7563", "file_path": "d:\\499\\docs\\api.rst", "symbol_type": "doc", "name": "Class-Based Views", "qualname": "api.rst#Class-Based Views", "start_line": 515, "end_line": 527, "docstring": null, "code": "-----------------\n\n.. versionadded:: 0.7\n\n.. currentmodule:: None\n\n.. autoclass:: flask.views.View\n   :members:\n\n.. autoclass:: flask.views.MethodView\n   :members:\n\n.. _url-route-registrations:", "code_truncated": false}
{"chunk_id": "a695150ab80429420b93aaa65773c3ae5290c3e4", "file_path": "d:\\499\\docs\\api.rst", "symbol_type": "doc", "name": "URL Route Registrations", "qualname": "api.rst#URL Route Registrations", "start_line": 530, "end_line": 638, "docstring": null, "code": "-----------------------\n\nGenerally there are three ways to define rules for the routing system:\n\n1.  You can use the :meth:`flask.Flask.route` decorator.\n2.  You can use the :meth:`flask.Flask.add_url_rule` function.\n3.  You can directly access the underlying Werkzeug routing system\n    which is exposed as :attr:`flask.Flask.url_map`.\n\nVariable parts in the route can be specified with angular brackets\n(``/user/<username>``). By default a variable part in the URL accepts any\nstring without a slash however a different converter can be specified as\nwell by using ``<converter:name>``.\n\nVariable parts are passed to the view function as keyword arguments.\n\nThe following converters are available:\n\n=========== ===============================================\n`string`    accepts any text without a slash (the default)\n`int`       accepts integers\n`float`     like `int` but for floating point values\n`path`      like the default but also accepts slashes\n`any`       matches one of the items provided\n`uuid`      accepts UUID strings\n=========== ===============================================\n\nCustom converters can be defined using :attr:`flask.Flask.url_map`.\n\nHere are some examples::\n\n    @app.route('/')\n    def index():\n        pass\n\n    @app.route('/<username>')\n    def show_user(username):\n        pass\n\n    @app.route('/post/<int:post_id>')\n    def show_post(post_id):\n        pass\n\nAn important detail to keep in mind is how Flask deals with trailing\nslashes. The idea is to keep each URL unique so the following rules\napply:\n\n1. If a rule ends with a slash and is requested without a slash by the\n   user, the user is automatically redirected to the same page with a\n   trailing slash attached.\n2. If a rule does not end with a trailing slash and the user requests the\n   page with a trailing slash, a 404 not found is raised.\n\nThis is consistent with how web servers deal with static files. This\nalso makes it possible to use relative link targets safely.\n\nYou can also define multiple rules for the same function. They have to be\nunique however. Defaults can also be specified. Here for example is a\ndefinition for a URL that accepts an optional page::\n\n    @app.route('/users/', defaults={'page': 1})\n    @app.route('/users/page/<int:page>')\n    def show_users(page):\n        pass\n\nThis specifies that ``/users/`` will be the URL for page one and\n``/users/page/N`` will be the URL for page ``N``.\n\nIf a URL contains a default value, it will be redirected to its simpler\nform with a 308 redirect. In the above example, ``/users/page/1`` will\nbe redirected to ``/users/``. If your route handles ``GET`` and ``POST``\nrequests, make sure the default route only handles ``GET``, as redirects\ncan't preserve form data. ::\n\n   @app.route('/region/', defaults={'id': 1})\n   @app.route('/region/<int:id>', methods=['GET', 'POST'])\n   def region(id):\n      pass\n\nHere are the parameters that :meth:`~flask.Flask.route` and\n:meth:`~flask.Flask.add_url_rule` accept. The only difference is that\nwith the route parameter the view function is defined with the decorator\ninstead of the `view_func` parameter.\n\n=============== ==========================================================\n`rule`          the URL rule as string\n`endpoint`      the endpoint for the registered URL rule. Flask itself\n                assumes that the name of the view function is the name\n                of the endpoint if not explicitly stated.\n`view_func`     the function to call when serving a request to the\n                provided endpoint. If this is not provided one can\n                specify the function later by storing it in the\n                :attr:`~flask.Flask.view_functions` dictionary with the\n                endpoint as key.\n`defaults`      A dictionary with defaults for this rule. See the\n                example above for how defaults work.\n`subdomain`     specifies the rule for the subdomain in case subdomain\n                matching is in use. If not specified the default\n                subdomain is assumed.\n`**options`     the options to be forwarded to the underlying\n                :class:`~werkzeug.routing.Rule` object. A change to\n                Werkzeug is handling of method options. methods is a list\n                of methods this rule should be limited to (``GET``, ``POST``\n                etc.). By default a rule just listens for ``GET`` (and\n                implicitly ``HEAD``). Starting with Flask 0.6, ``OPTIONS`` is\n                implicitly added and handled by the standard request\n                handling. They have to be specified as keyword arguments.\n=============== ==========================================================", "code_truncated": false}
{"chunk_id": "2220a9eaec2c9069c57b411715bf14cd91dcd846", "file_path": "d:\\499\\docs\\api.rst", "symbol_type": "doc", "name": "View Function Options", "qualname": "api.rst#View Function Options", "start_line": 641, "end_line": 681, "docstring": null, "code": "---------------------\n\nFor internal usage the view functions can have some attributes attached to\ncustomize behavior the view function would normally not have control over.\nThe following attributes can be provided optionally to either override\nsome defaults to :meth:`~flask.Flask.add_url_rule` or general behavior:\n\n-   `__name__`: The name of a function is by default used as endpoint. If\n    endpoint is provided explicitly this value is used. Additionally this\n    will be prefixed with the name of the blueprint by default which\n    cannot be customized from the function itself.\n\n-   `methods`: If methods are not provided when the URL rule is added,\n    Flask will look on the view function object itself if a `methods`\n    attribute exists. If it does, it will pull the information for the\n    methods from there.\n\n-   `provide_automatic_options`: if this attribute is set Flask will\n    either force enable or disable the automatic implementation of the\n    HTTP ``OPTIONS`` response. This can be useful when working with\n    decorators that want to customize the ``OPTIONS`` response on a per-view\n    basis.\n\n-   `required_methods`: if this attribute is set, Flask will always add\n    these methods when registering a URL rule even if the methods were\n    explicitly overridden in the ``route()`` call.\n\nFull example::\n\n    def index():\n        if request.method == 'OPTIONS':\n            # custom options handling here\n            ...\n        return 'Hello World!'\n    index.provide_automatic_options = False\n    index.methods = ['GET', 'OPTIONS']\n\n    app.add_url_rule('/', index)\n\n.. versionadded:: 0.8\n   The `provide_automatic_options` functionality was added.", "code_truncated": false}
{"chunk_id": "3db0ec35a78eaa9788d2ae69ce4a679f9338194f", "file_path": "d:\\499\\docs\\api.rst", "symbol_type": "doc", "name": "Command Line Interface", "qualname": "api.rst#Command Line Interface", "start_line": 684, "end_line": 708, "docstring": null, "code": "----------------------\n\n.. currentmodule:: flask.cli\n\n.. autoclass:: FlaskGroup\n   :members:\n\n.. autoclass:: AppGroup\n   :members:\n\n.. autoclass:: ScriptInfo\n   :members:\n\n.. autofunction:: load_dotenv\n\n.. autofunction:: with_appcontext\n\n.. autofunction:: pass_script_info\n\n   Marks a function so that an instance of :class:`ScriptInfo` is passed\n   as first argument to the click callback.\n\n.. autodata:: run_command\n\n.. autodata:: shell_command", "code_truncated": false}
{"chunk_id": "f8dd91a297c6172877e258fde6e4d1188369dd14", "file_path": "d:\\499\\docs\\appcontext.rst", "symbol_type": "doc", "name": "The App and Request Context", "qualname": "appcontext.rst#The App and Request Context", "start_line": 2, "end_line": 14, "docstring": null, "code": "===========================\n\nThe context keeps track of data and objects during a request, CLI command, or\nother activity. Rather than passing this data around to every function, the\n:data:`.current_app`, :data:`.g`, :data:`.request`, and :data:`.session` proxies\nare accessed instead.\n\nWhen handling a request, the context is referred to as the \"request context\"\nbecause it contains request data in addition to application data. Otherwise,\nsuch as during a CLI command, it is referred to as the \"app context\". During an\napp context, :data:`.current_app` and :data:`.g` are available, while during a\nrequest context :data:`.request` and :data:`.session` are also available.", "code_truncated": false}
{"chunk_id": "6f77919e51e6a19501f93f16ac94f08827e28d64", "file_path": "d:\\499\\docs\\appcontext.rst", "symbol_type": "doc", "name": "Purpose of the Context", "qualname": "appcontext.rst#Purpose of the Context", "start_line": 17, "end_line": 40, "docstring": null, "code": "----------------------\n\nThe context and proxies help solve two development issues: circular imports, and\npassing around global data during a request.\n\nThe :class:`.Flask` application object has attributes, such as\n:attr:`~.Flask.config`, that are useful to access within views and other\nfunctions. However, importing the ``app`` instance within the modules in your\nproject is prone to circular import issues. When using the\n:doc:`app factory pattern </patterns/appfactories>` or writing reusable\n:doc:`blueprints </blueprints>` or :doc:`extensions </extensions>` there won't\nbe an ``app`` instance to import at all.\n\nWhen the application handles a request, it creates a :class:`.Request` object.\nBecause a *worker* handles only one request at a time, the request data can be\nconsidered global to that worker during that request. Passing it as an argument\nthrough every function during the request becomes verbose and redundant.\n\nFlask solves these issues with the *active context* pattern. Rather than\nimporting an ``app`` directly, or having to pass it and the request through to\nevery single function, you import and access the proxies, which point to the\ncurrently active application and request data. This is sometimes referred to\nas \"context local\" data.", "code_truncated": false}
{"chunk_id": "a7e5533b3cf46084f6b873b7cb5cd524bd3b4a79", "file_path": "d:\\499\\docs\\appcontext.rst", "symbol_type": "doc", "name": "Context During Setup", "qualname": "appcontext.rst#Context During Setup", "start_line": 43, "end_line": 73, "docstring": null, "code": "--------------------\n\nIf you try to access :data:`.current_app`, :data:`.g`, or anything that uses it,\noutside an app context, you'll get this error message:\n\n.. code-block:: pytb\n\n    RuntimeError: Working outside of application context.\n\n    Attempted to use functionality that expected a current application to be\n    set. To solve this, set up an app context using 'with app.app_context()'.\n    See the documentation on app context for more information.\n\nIf you see that error while configuring your application, such as when\ninitializing an extension, you can push a context manually since you have direct\naccess to the ``app``. Use :meth:`.Flask.app_context` in a ``with`` block.\n\n.. code-block:: python\n\n    def create_app():\n        app = Flask(__name__)\n\n        with app.app_context():\n            init_db()\n\n        return app\n\nIf you see that error somewhere else in your code not related to setting up the\napplication, it most likely indicates that you should move that code into a view\nfunction or CLI command.", "code_truncated": false}
{"chunk_id": "b5c48237ff46027cb663b1f8d52d2a116dec3b2a", "file_path": "d:\\499\\docs\\appcontext.rst", "symbol_type": "doc", "name": "Context During Testing", "qualname": "appcontext.rst#Context During Testing", "start_line": 76, "end_line": 113, "docstring": null, "code": "----------------------\n\nSee :doc:`/testing` for detailed information about managing the context during\ntests.\n\nIf you try to access :data:`.request`, :data:`.session`, or anything that uses\nit, outside a request context, you'll get this error message:\n\n.. code-block:: pytb\n\n    RuntimeError: Working outside of request context.\n\n    Attempted to use functionality that expected an active HTTP request. See the\n    documentation on request context for more information.\n\nThis will probably only happen during tests. If you see that error somewhere\nelse in your code not related to testing, it most likely indicates that you\nshould move that code into a view function.\n\nThe primary way to solve this is to use :meth:`.Flask.test_client` to simulate\na full request.\n\nIf you only want to unit test one function, rather than a full request, use\n:meth:`.Flask.test_request_context` in a ``with`` block.\n\n.. code-block:: python\n\n    def generate_report(year):\n        format = request.args.get(\"format\")\n        ...\n\n    with app.test_request_context(\n        \"/make_report/2017\", query_string={\"format\": \"short\"}\n    ):\n        generate_report()\n\n\n.. _context-visibility:", "code_truncated": false}
{"chunk_id": "cb02893fa7cd6c34657e299cbc40dbccc8548625", "file_path": "d:\\499\\docs\\appcontext.rst", "symbol_type": "doc", "name": "Visibility of the Context", "qualname": "appcontext.rst#Visibility of the Context", "start_line": 116, "end_line": 142, "docstring": null, "code": "-------------------------\n\nThe context will have the same lifetime as an activity, such as a request, CLI\ncommand, or ``with`` block. Various callbacks and signals registered with the\napp will be run during the context.\n\nWhen a Flask application handles a request, it pushes a request context\nto set the active application and request data. When it handles a CLI command,\nit pushes an app context to set the active application. When the activity ends,\nit pops that context. Proxy objects like :data:`.request`, :data:`.session`,\n:data:`.g`, and :data:`.current_app`, are accessible while the context is pushed\nand active, and are not accessible after the context is popped.\n\nThe context is unique to each thread (or other worker type). The proxies cannot\nbe passed to another worker, which has a different context space and will not\nknow about the active context in the parent's space.\n\nBesides being scoped to each worker, the proxy object has a separate type and\nidentity than the proxied real object. In some cases you'll need access to the\nreal object, rather than the proxy. Use the\n:meth:`~.LocalProxy._get_current_object` method in those cases.\n\n.. code-block:: python\n\n    app = current_app._get_current_object()\n    my_signal.send(app)", "code_truncated": false}
{"chunk_id": "8925e5ef210b8d675220e419262df0fd950ee8df", "file_path": "d:\\499\\docs\\appcontext.rst", "symbol_type": "doc", "name": "Lifecycle of the Context", "qualname": "appcontext.rst#Lifecycle of the Context", "start_line": 145, "end_line": 167, "docstring": null, "code": "------------------------\n\nFlask dispatches a request in multiple stages which can affect the request,\nresponse, and how errors are handled. See :doc:`/lifecycle` for a list of all\nthe steps, callbacks, and signals during each request. The following are the\nsteps directly related to the context.\n\n-   The app context is pushed, the proxies are available.\n-   The :data:`.appcontext_pushed` signal is sent.\n-   The request is dispatched.\n-   Any :meth:`.Flask.teardown_request` decorated functions are called.\n-   The :data:`.request_tearing_down` signal is sent.\n-   Any :meth:`.Flask.teardown_appcontext` decorated functions are called.\n-   The :data:`.appcontext_tearing_down` signal is sent.\n-   The app context is popped, the proxies are no longer available.\n-   The :data:`.appcontext_popped` signal is sent.\n\nThe teardown callbacks are called by the context when it is popped. They are\ncalled even if there is an unhandled exception during dispatch. They may be\ncalled multiple times in some test scenarios. This means there is no guarantee\nthat any other parts of the request dispatch have run. Be sure to write these\nfunctions in a way that does not depend on other callbacks and will not fail.", "code_truncated": false}
{"chunk_id": "d46cb22899d3684efcd3ef0f962c8af554355cae", "file_path": "d:\\499\\docs\\appcontext.rst", "symbol_type": "doc", "name": "How the Context Works", "qualname": "appcontext.rst#How the Context Works", "start_line": 170, "end_line": 186, "docstring": null, "code": "---------------------\n\nContext locals are implemented using Python's :mod:`contextvars` and Werkzeug's\n:class:`~werkzeug.local.LocalProxy`. Python's contextvars are a low level\nstructure to manage data local to a thread or coroutine. ``LocalProxy`` wraps\nthe contextvar so that access to any attributes and methods is forwarded to the\nobject stored in the contextvar.\n\nThe context is tracked like a stack, with the active context at the top of the\nstack. Flask manages pushing and popping contexts during requests, CLI commands,\ntesting, ``with`` blocks, etc. The proxies access attributes on the active\ncontext.\n\nBecause it is a stack, other contexts may be pushed to change the proxies during\nan already active context. This is not a common pattern, but can be used in\nadvanced use cases. For example, a Flask application can be used as WSGI\nmiddleware, calling another wrapped Flask app from a view.", "code_truncated": false}
{"chunk_id": "3a9f27c840a4970bffdb18af19c46a9dc475c6dd", "file_path": "d:\\499\\docs\\async-await.rst", "symbol_type": "doc", "name": "INTRO", "qualname": "async-await.rst#INTRO", "start_line": 1, "end_line": 1, "docstring": null, "code": ".. _async_await:", "code_truncated": false}
{"chunk_id": "a8b91b3bceebbac6b48e8de05dfb140c16560ed1", "file_path": "d:\\499\\docs\\async-await.rst", "symbol_type": "doc", "name": "Using ``async`` and ``await``", "qualname": "async-await.rst#Using ``async`` and ``await``", "start_line": 4, "end_line": 25, "docstring": null, "code": "=============================\n\n.. versionadded:: 2.0\n\nRoutes, error handlers, before request, after request, and teardown\nfunctions can all be coroutine functions if Flask is installed with the\n``async`` extra (``pip install flask[async]``). This allows views to be\ndefined with ``async def`` and use ``await``.\n\n.. code-block:: python\n\n    @app.route(\"/get-data\")\n    async def get_data():\n        data = await async_db_query(...)\n        return jsonify(data)\n\nPluggable class-based views also support handlers that are implemented as\ncoroutines. This applies to the :meth:`~flask.views.View.dispatch_request`\nmethod in views that inherit from the :class:`flask.views.View` class, as\nwell as all the HTTP method handlers in views that inherit from the\n:class:`flask.views.MethodView` class.", "code_truncated": false}
{"chunk_id": "fdff1edd3e9666d9b6b9f0d4c9a461e6417a3ab9", "file_path": "d:\\499\\docs\\async-await.rst", "symbol_type": "doc", "name": "Performance", "qualname": "async-await.rst#Performance", "start_line": 28, "end_line": 46, "docstring": null, "code": "-----------\n\nAsync functions require an event loop to run. Flask, as a WSGI\napplication, uses one worker to handle one request/response cycle.\nWhen a request comes in to an async view, Flask will start an event loop\nin a thread, run the view function there, then return the result.\n\nEach request still ties up one worker, even for async views. The upside\nis that you can run async code within a view, for example to make\nmultiple concurrent database queries, HTTP requests to an external API,\netc. However, the number of requests your application can handle at one\ntime will remain the same.\n\n**Async is not inherently faster than sync code.** Async is beneficial\nwhen performing concurrent IO-bound tasks, but will probably not improve\nCPU-bound tasks. Traditional Flask views will still be appropriate for\nmost use cases, but Flask's async support enables writing and using\ncode that wasn't possible natively before.", "code_truncated": false}
{"chunk_id": "d5b386bff847181b638984d32cfdd7bba4b20523", "file_path": "d:\\499\\docs\\async-await.rst", "symbol_type": "doc", "name": "Background tasks", "qualname": "async-await.rst#Background tasks", "start_line": 49, "end_line": 63, "docstring": null, "code": "----------------\n\nAsync functions will run in an event loop until they complete, at\nwhich stage the event loop will stop. This means any additional\nspawned tasks that haven't completed when the async function completes\nwill be cancelled. Therefore you cannot spawn background tasks, for\nexample via ``asyncio.create_task``.\n\nIf you wish to use background tasks it is best to use a task queue to\ntrigger background work, rather than spawn tasks in a view\nfunction. With that in mind you can spawn asyncio tasks by serving\nFlask with an ASGI server and utilising the asgiref WsgiToAsgi adapter\nas described in :doc:`deploying/asgi`. This works as the adapter creates\nan event loop that runs continually.", "code_truncated": false}
{"chunk_id": "ac56dbb89b157e864d8da212992c8453a27e9186", "file_path": "d:\\499\\docs\\async-await.rst", "symbol_type": "doc", "name": "When to use Quart instead", "qualname": "async-await.rst#When to use Quart instead", "start_line": 66, "end_line": 84, "docstring": null, "code": "-------------------------\n\nFlask's async support is less performant than async-first frameworks due\nto the way it is implemented. If you have a mainly async codebase it\nwould make sense to consider `Quart`_. Quart is a reimplementation of\nFlask based on the `ASGI`_ standard instead of WSGI. This allows it to\nhandle many concurrent requests, long running requests, and websockets\nwithout requiring multiple worker processes or threads.\n\nIt has also already been possible to :doc:`run Flask with Gevent </gevent>` to\nget many of the benefits of async request handling. Gevent patches low-level\nPython functions to accomplish this, whereas ``async``/``await`` and ASGI use\nstandard, modern Python capabilities. Deciding whether you should use gevent\nwith Flask, or Quart, or something else is ultimately up to understanding the\nspecific needs of your project.\n\n.. _Quart: https://quart.palletsprojects.com\n.. _ASGI: https://asgi.readthedocs.io", "code_truncated": false}
{"chunk_id": "6785926419c0830535569cfd1a8a51fd86300fd2", "file_path": "d:\\499\\docs\\async-await.rst", "symbol_type": "doc", "name": "Extensions", "qualname": "async-await.rst#Extensions", "start_line": 87, "end_line": 112, "docstring": null, "code": "----------\n\nFlask extensions predating Flask's async support do not expect async views.\nIf they provide decorators to add functionality to views, those will probably\nnot work with async views because they will not await the function or be\nawaitable. Other functions they provide will not be awaitable either and\nwill probably be blocking if called within an async view.\n\nExtension authors can support async functions by utilising the\n:meth:`flask.Flask.ensure_sync` method. For example, if the extension\nprovides a view function decorator add ``ensure_sync`` before calling\nthe decorated function,\n\n.. code-block:: python\n\n    def extension(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            ...  # Extension logic\n            return current_app.ensure_sync(func)(*args, **kwargs)\n\n        return wrapper\n\nCheck the changelog of the extension you want to use to see if they've\nimplemented async support, or make a feature request or PR to them.", "code_truncated": false}
{"chunk_id": "ecaab2df20aa28e0fe92572ac0cc8c360def1b9e", "file_path": "d:\\499\\docs\\async-await.rst", "symbol_type": "doc", "name": "Other event loops", "qualname": "async-await.rst#Other event loops", "start_line": 115, "end_line": 119, "docstring": null, "code": "-----------------\n\nAt the moment Flask only supports :mod:`asyncio`. It's possible to override\n:meth:`flask.Flask.ensure_sync` to change how async functions are wrapped to use\na different library. See :ref:`gevent-asyncio` for an example.", "code_truncated": false}
{"chunk_id": "f83efc8ed07aee206dee1b205acbd1942fef6871", "file_path": "d:\\499\\docs\\blueprints.rst", "symbol_type": "doc", "name": "Modular Applications with Blueprints", "qualname": "blueprints.rst#Modular Applications with Blueprints", "start_line": 2, "end_line": 14, "docstring": null, "code": "====================================\n\n.. currentmodule:: flask\n\n.. versionadded:: 0.7\n\nFlask uses a concept of *blueprints* for making application components and\nsupporting common patterns within an application or across applications.\nBlueprints can greatly simplify how large applications work and provide a\ncentral means for Flask extensions to register operations on applications.\nA :class:`Blueprint` object works similarly to a :class:`Flask`\napplication object, but it is not actually an application.  Rather it is a\n*blueprint* of how to construct or extend an application.", "code_truncated": false}
{"chunk_id": "7350dabf9d0e8b1e3dad4c96a4876498ab540355", "file_path": "d:\\499\\docs\\blueprints.rst", "symbol_type": "doc", "name": "Why Blueprints?", "qualname": "blueprints.rst#Why Blueprints?", "start_line": 17, "end_line": 46, "docstring": null, "code": "---------------\n\nBlueprints in Flask are intended for these cases:\n\n* Factor an application into a set of blueprints.  This is ideal for\n  larger applications; a project could instantiate an application object,\n  initialize several extensions, and register a collection of blueprints.\n* Register a blueprint on an application at a URL prefix and/or subdomain.\n  Parameters in the URL prefix/subdomain become common view arguments\n  (with defaults) across all view functions in the blueprint.\n* Register a blueprint multiple times on an application with different URL\n  rules.\n* Provide template filters, static files, templates, and other utilities\n  through blueprints.  A blueprint does not have to implement applications\n  or view functions.\n* Register a blueprint on an application for any of these cases when\n  initializing a Flask extension.\n\nA blueprint in Flask is not a pluggable app because it is not actually an\napplication -- it's a set of operations which can be registered on an\napplication, even multiple times.  Why not have multiple application\nobjects?  You can do that (see :doc:`/patterns/appdispatch`), but your\napplications will have separate configs and will be managed at the WSGI\nlayer.\n\nBlueprints instead provide separation at the Flask level, share\napplication config, and can change an application object as necessary with\nbeing registered. The downside is that you cannot unregister a blueprint\nonce an application was created without having to destroy the whole\napplication object.", "code_truncated": false}
{"chunk_id": "da8580f4dc5ecf5fe9f84dfb42248aec2e8e2793", "file_path": "d:\\499\\docs\\blueprints.rst", "symbol_type": "doc", "name": "The Concept of Blueprints", "qualname": "blueprints.rst#The Concept of Blueprints", "start_line": 49, "end_line": 54, "docstring": null, "code": "-------------------------\n\nThe basic concept of blueprints is that they record operations to execute\nwhen registered on an application.  Flask associates view functions with\nblueprints when dispatching requests and generating URLs from one endpoint\nto another.", "code_truncated": false}
{"chunk_id": "2f392c7f16d974dc397281032ba69ec80f5966e4", "file_path": "d:\\499\\docs\\blueprints.rst", "symbol_type": "doc", "name": "My First Blueprint", "qualname": "blueprints.rst#My First Blueprint", "start_line": 57, "end_line": 82, "docstring": null, "code": "------------------\n\nThis is what a very basic blueprint looks like.  In this case we want to\nimplement a blueprint that does simple rendering of static templates::\n\n    from flask import Blueprint, render_template, abort\n    from jinja2 import TemplateNotFound\n\n    simple_page = Blueprint('simple_page', __name__,\n                            template_folder='templates')\n\n    @simple_page.route('/', defaults={'page': 'index'})\n    @simple_page.route('/<page>')\n    def show(page):\n        try:\n            return render_template(f'pages/{page}.html')\n        except TemplateNotFound:\n            abort(404)\n\nWhen you bind a function with the help of the ``@simple_page.route``\ndecorator, the blueprint will record the intention of registering the\nfunction ``show`` on the application when it's later registered.\nAdditionally it will prefix the endpoint of the function with the\nname of the blueprint which was given to the :class:`Blueprint`\nconstructor (in this case also ``simple_page``). The blueprint's name\ndoes not modify the URL, only the endpoint.", "code_truncated": false}
{"chunk_id": "87eb13979801e3933e27f0821dba80a1a98f8349", "file_path": "d:\\499\\docs\\blueprints.rst", "symbol_type": "doc", "name": "Registering Blueprints", "qualname": "blueprints.rst#Registering Blueprints", "start_line": 85, "end_line": 121, "docstring": null, "code": "----------------------\n\nSo how do you register that blueprint?  Like this::\n\n    from flask import Flask\n    from yourapplication.simple_page import simple_page\n\n    app = Flask(__name__)\n    app.register_blueprint(simple_page)\n\nIf you check the rules registered on the application, you will find\nthese::\n\n    >>> app.url_map\n    Map([<Rule '/static/<filename>' (HEAD, OPTIONS, GET) -> static>,\n     <Rule '/<page>' (HEAD, OPTIONS, GET) -> simple_page.show>,\n     <Rule '/' (HEAD, OPTIONS, GET) -> simple_page.show>])\n\nThe first one is obviously from the application itself for the static\nfiles.  The other two are for the `show` function of the ``simple_page``\nblueprint.  As you can see, they are also prefixed with the name of the\nblueprint and separated by a dot (``.``).\n\nBlueprints however can also be mounted at different locations::\n\n    app.register_blueprint(simple_page, url_prefix='/pages')\n\nAnd sure enough, these are the generated rules::\n\n    >>> app.url_map\n    Map([<Rule '/static/<filename>' (HEAD, OPTIONS, GET) -> static>,\n     <Rule '/pages/<page>' (HEAD, OPTIONS, GET) -> simple_page.show>,\n     <Rule '/pages/' (HEAD, OPTIONS, GET) -> simple_page.show>])\n\nOn top of that you can register blueprints multiple times though not every\nblueprint might respond properly to that.  In fact it depends on how the\nblueprint is implemented if it can be mounted more than once.", "code_truncated": false}
{"chunk_id": "2afbfbea94bb8e865e4b0dd70daf01bfe0d0bb37", "file_path": "d:\\499\\docs\\blueprints.rst", "symbol_type": "doc", "name": "Nesting Blueprints", "qualname": "blueprints.rst#Nesting Blueprints", "start_line": 124, "end_line": 159, "docstring": null, "code": "------------------\n\nIt is possible to register a blueprint on another blueprint.\n\n.. code-block:: python\n\n    parent = Blueprint('parent', __name__, url_prefix='/parent')\n    child = Blueprint('child', __name__, url_prefix='/child')\n    parent.register_blueprint(child)\n    app.register_blueprint(parent)\n\nThe child blueprint will gain the parent's name as a prefix to its\nname, and child URLs will be prefixed with the parent's URL prefix.\n\n.. code-block:: python\n\n    url_for('parent.child.create')\n    /parent/child/create\n\nIn addition a child blueprint's will gain their parent's subdomain,\nwith their subdomain as prefix if present i.e.\n\n.. code-block:: python\n\n    parent = Blueprint('parent', __name__, subdomain='parent')\n    child = Blueprint('child', __name__, subdomain='child')\n    parent.register_blueprint(child)\n    app.register_blueprint(parent)\n\n    url_for('parent.child.create', _external=True)\n    \"child.parent.domain.tld\"\n\nBlueprint-specific before request functions, etc. registered with the\nparent will trigger for the child. If a child does not have an error\nhandler that can handle a given exception, the parent's will be tried.", "code_truncated": false}
{"chunk_id": "bb4fe68da8b37a74bea8a0d702011dedcb5d571b", "file_path": "d:\\499\\docs\\blueprints.rst", "symbol_type": "doc", "name": "Blueprint Resources", "qualname": "blueprints.rst#Blueprint Resources", "start_line": 162, "end_line": 165, "docstring": null, "code": "-------------------\n\nBlueprints can provide resources as well.  Sometimes you might want to\nintroduce a blueprint only for the resources it provides.", "code_truncated": false}
{"chunk_id": "9898c0ed33473df90d150feda6b3e3198824961e", "file_path": "d:\\499\\docs\\blueprints.rst", "symbol_type": "doc", "name": "Blueprint Resource Folder", "qualname": "blueprints.rst#Blueprint Resource Folder", "start_line": 168, "end_line": 189, "docstring": null, "code": "`````````````````````````\n\nLike for regular applications, blueprints are considered to be contained\nin a folder.  While multiple blueprints can originate from the same folder,\nit does not have to be the case and it's usually not recommended.\n\nThe folder is inferred from the second argument to :class:`Blueprint` which\nis usually `__name__`.  This argument specifies what logical Python\nmodule or package corresponds to the blueprint.  If it points to an actual\nPython package that package (which is a folder on the filesystem) is the\nresource folder.  If it's a module, the package the module is contained in\nwill be the resource folder.  You can access the\n:attr:`Blueprint.root_path` property to see what the resource folder is::\n\n    >>> simple_page.root_path\n    '/Users/username/TestProject/yourapplication'\n\nTo quickly open sources from this folder you can use the\n:meth:`~Blueprint.open_resource` function::\n\n    with simple_page.open_resource('static/style.css') as f:\n        code = f.read()", "code_truncated": false}
{"chunk_id": "6953aae65609f0bf548aee9f79fd892db0dd1a4b", "file_path": "d:\\499\\docs\\blueprints.rst", "symbol_type": "doc", "name": "Static Files", "qualname": "blueprints.rst#Static Files", "start_line": 192, "end_line": 217, "docstring": null, "code": "````````````\n\nA blueprint can expose a folder with static files by providing the path\nto the folder on the filesystem with the ``static_folder`` argument.\nIt is either an absolute path or relative to the blueprint's location::\n\n    admin = Blueprint('admin', __name__, static_folder='static')\n\nBy default the rightmost part of the path is where it is exposed on the\nweb. This can be changed with the ``static_url_path`` argument. Because the\nfolder is called ``static`` here it will be available at the\n``url_prefix`` of the blueprint + ``/static``. If the blueprint\nhas the prefix ``/admin``, the static URL will be ``/admin/static``.\n\nThe endpoint is named ``blueprint_name.static``. You can generate URLs\nto it with :func:`url_for` like you would with the static folder of the\napplication::\n\n    url_for('admin.static', filename='style.css')\n\nHowever, if the blueprint does not have a ``url_prefix``, it is not\npossible to access the blueprint's static folder. This is because the\nURL would be ``/static`` in this case, and the application's ``/static``\nroute takes precedence. Unlike template folders, blueprint static\nfolders are not searched if the file does not exist in the application\nstatic folder.", "code_truncated": false}
{"chunk_id": "5aea8c247b9ef5d6b867939202ce040a2dedc900", "file_path": "d:\\499\\docs\\blueprints.rst", "symbol_type": "doc", "name": "Templates", "qualname": "blueprints.rst#Templates", "start_line": 220, "end_line": 263, "docstring": null, "code": "`````````\n\nIf you want the blueprint to expose templates you can do that by providing\nthe `template_folder` parameter to the :class:`Blueprint` constructor::\n\n    admin = Blueprint('admin', __name__, template_folder='templates')\n\nFor static files, the path can be absolute or relative to the blueprint\nresource folder.\n\nThe template folder is added to the search path of templates but with a lower\npriority than the actual application's template folder. That way you can\neasily override templates that a blueprint provides in the actual application.\nThis also means that if you don't want a blueprint template to be accidentally\noverridden, make sure that no other blueprint or actual application template\nhas the same relative path. When multiple blueprints provide the same relative\ntemplate path the first blueprint registered takes precedence over the others.\n\n\nSo if you have a blueprint in the folder ``yourapplication/admin`` and you\nwant to render the template ``'admin/index.html'`` and you have provided\n``templates`` as a `template_folder` you will have to create a file like\nthis: :file:`yourapplication/admin/templates/admin/index.html`. The reason\nfor the extra ``admin`` folder is to avoid getting our template overridden\nby a template named ``index.html`` in the actual application template\nfolder.\n\nTo further reiterate this: if you have a blueprint named ``admin`` and you\nwant to render a template called :file:`index.html` which is specific to this\nblueprint, the best idea is to lay out your templates like this::\n\n    yourpackage/\n        blueprints/\n            admin/\n                templates/\n                    admin/\n                        index.html\n                __init__.py\n\nAnd then when you want to render the template, use :file:`admin/index.html` as\nthe name to look up the template by.  If you encounter problems loading\nthe correct templates enable the ``EXPLAIN_TEMPLATE_LOADING`` config\nvariable which will instruct Flask to print out the steps it goes through\nto locate templates on every ``render_template`` call.", "code_truncated": false}
{"chunk_id": "b42c1d1737637af4aceca188a68d56c2b3896a82", "file_path": "d:\\499\\docs\\blueprints.rst", "symbol_type": "doc", "name": "Building URLs", "qualname": "blueprints.rst#Building URLs", "start_line": 266, "end_line": 282, "docstring": null, "code": "-------------\n\nIf you want to link from one page to another you can use the\n:func:`url_for` function just like you normally would do just that you\nprefix the URL endpoint with the name of the blueprint and a dot (``.``)::\n\n    url_for('admin.index')\n\nAdditionally if you are in a view function of a blueprint or a rendered\ntemplate and you want to link to another endpoint of the same blueprint,\nyou can use relative redirects by prefixing the endpoint with a dot only::\n\n    url_for('.index')\n\nThis will link to ``admin.index`` for instance in case the current request\nwas dispatched to any other admin blueprint endpoint.", "code_truncated": false}
{"chunk_id": "38efa1a851c084849bfaa1e9b7cbd85590a90890", "file_path": "d:\\499\\docs\\blueprints.rst", "symbol_type": "doc", "name": "Blueprint Error Handlers", "qualname": "blueprints.rst#Blueprint Error Handlers", "start_line": 285, "end_line": 315, "docstring": null, "code": "------------------------\n\nBlueprints support the ``errorhandler`` decorator just like the :class:`Flask`\napplication object, so it is easy to make Blueprint-specific custom error\npages.\n\nHere is an example for a \"404 Page Not Found\" exception::\n\n    @simple_page.errorhandler(404)\n    def page_not_found(e):\n        return render_template('pages/404.html')\n\nMost errorhandlers will simply work as expected; however, there is a caveat\nconcerning handlers for 404 and 405 exceptions.  These errorhandlers are only\ninvoked from an appropriate ``raise`` statement or a call to ``abort`` in another\nof the blueprint's view functions; they are not invoked by, e.g., an invalid URL\naccess.  This is because the blueprint does not \"own\" a certain URL space, so\nthe application instance has no way of knowing which blueprint error handler it\nshould run if given an invalid URL.  If you would like to execute different\nhandling strategies for these errors based on URL prefixes, they may be defined\nat the application level using the ``request`` proxy object::\n\n    @app.errorhandler(404)\n    @app.errorhandler(405)\n    def _handle_api_error(ex):\n        if request.path.startswith('/api/'):\n            return jsonify(error=str(ex)), ex.code\n        else:\n            return ex\n\nSee :doc:`/errorhandling`.", "code_truncated": false}
{"chunk_id": "e81e3c4350e22fca921d28275d908f64e74d3bc6", "file_path": "d:\\499\\docs\\changes.rst", "symbol_type": "doc", "name": "Changes", "qualname": "changes.rst#Changes", "start_line": 2, "end_line": 4, "docstring": null, "code": "=======\n\n.. include:: ../CHANGES.rst", "code_truncated": false}
{"chunk_id": "40d95626d10738fb436fbe4df395ba382f142663", "file_path": "d:\\499\\docs\\cli.rst", "symbol_type": "doc", "name": "INTRO", "qualname": "cli.rst#INTRO", "start_line": 1, "end_line": 1, "docstring": null, "code": ".. currentmodule:: flask", "code_truncated": false}
{"chunk_id": "878b1cf15723ed4bfbf3071dfe6030dc4e7c3332", "file_path": "d:\\499\\docs\\cli.rst", "symbol_type": "doc", "name": "Command Line Interface", "qualname": "cli.rst#Command Line Interface", "start_line": 4, "end_line": 12, "docstring": null, "code": "======================\n\nInstalling Flask installs the ``flask`` script, a `Click`_ command line\ninterface, in your virtualenv. Executed from the terminal, this script gives\naccess to built-in, extension, and application-defined commands. The ``--help``\noption will give more information about any commands and options.\n\n.. _Click: https://click.palletsprojects.com/", "code_truncated": false}
{"chunk_id": "e70abab06484e05cc134f1a519904fa4c4b70dc5", "file_path": "d:\\499\\docs\\cli.rst", "symbol_type": "doc", "name": "Application Discovery", "qualname": "cli.rst#Application Discovery", "start_line": 15, "end_line": 66, "docstring": null, "code": "---------------------\n\nThe ``flask`` command is installed by Flask, not your application; it must be\ntold where to find your application in order to use it. The ``--app``\noption is used to specify how to load the application.\n\nWhile ``--app`` supports a variety of options for specifying your\napplication, most use cases should be simple. Here are the typical values:\n\n(nothing)\n    The name \"app\" or \"wsgi\" is imported (as a \".py\" file, or package),\n    automatically detecting an app (``app`` or ``application``) or\n    factory (``create_app`` or ``make_app``).\n\n``--app hello``\n    The given name is imported, automatically detecting an app (``app``\n    or ``application``) or factory (``create_app`` or ``make_app``).\n\n----\n\n``--app`` has three parts: an optional path that sets the current working\ndirectory, a Python file or dotted import path, and an optional variable\nname of the instance or factory. If the name is a factory, it can optionally\nbe followed by arguments in parentheses. The following values demonstrate these\nparts:\n\n``--app src/hello``\n    Sets the current working directory to ``src`` then imports ``hello``.\n\n``--app hello.web``\n    Imports the path ``hello.web``.\n\n``--app hello:app2``\n    Uses the ``app2`` Flask instance in ``hello``.\n\n``--app 'hello:create_app(\"dev\")'``\n    The ``create_app`` factory in ``hello`` is called with the string ``'dev'``\n    as the argument.\n\nIf ``--app`` is not set, the command will try to import \"app\" or\n\"wsgi\" (as a \".py\" file, or package) and try to detect an application\ninstance or factory.\n\nWithin the given import, the command looks for an application instance named\n``app`` or ``application``, then any application instance. If no instance is\nfound, the command looks for a factory function named ``create_app`` or\n``make_app`` that returns an instance.\n\nIf parentheses follow the factory name, their contents are parsed as\nPython literals and passed as arguments and keyword arguments to the\nfunction. This means that strings must still be in quotes.", "code_truncated": false}
{"chunk_id": "378f31bce2d5c7ccd01d92e6eca860abf7766c18", "file_path": "d:\\499\\docs\\cli.rst", "symbol_type": "doc", "name": "Run the Development Server", "qualname": "cli.rst#Run the Development Server", "start_line": 69, "end_line": 87, "docstring": null, "code": "--------------------------\n\nThe :func:`run <cli.run_command>` command will start the development server. It\nreplaces the :meth:`Flask.run` method in most cases. ::\n\n    $ flask --app hello run\n     * Serving Flask app \"hello\"\n     * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n\n.. warning:: Do not use this command to run your application in production.\n    Only use the development server during development. The development server\n    is provided for convenience, but is not designed to be particularly secure,\n    stable, or efficient. See :doc:`/deploying/index` for how to run in production.\n\nIf another program is already using port 5000, you'll see\n``OSError: [Errno 98]`` or ``OSError: [WinError 10013]`` when the\nserver tries to start. See :ref:`address-already-in-use` for how to\nhandle that.", "code_truncated": false}
{"chunk_id": "7c6057c887265c80ccd7b81330d1dd730a8f2eab", "file_path": "d:\\499\\docs\\cli.rst", "symbol_type": "doc", "name": "Debug Mode", "qualname": "cli.rst#Debug Mode", "start_line": 90, "end_line": 113, "docstring": null, "code": "~~~~~~~~~~\n\nIn debug mode, the ``flask run`` command will enable the interactive debugger and the\nreloader by default, and make errors easier to see and debug. To enable debug mode, use\nthe ``--debug`` option.\n\n.. code-block:: console\n\n     $ flask --app hello run --debug\n      * Serving Flask app \"hello\"\n      * Debug mode: on\n      * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n      * Restarting with inotify reloader\n      * Debugger is active!\n      * Debugger PIN: 223-456-919\n\nThe ``--debug`` option can also be passed to the top level ``flask`` command to enable\ndebug mode for any command. The following two ``run`` calls are equivalent.\n\n.. code-block:: console\n\n    $ flask --app hello --debug run\n    $ flask --app hello run --debug", "code_truncated": false}
{"chunk_id": "0a7033337b39dc09dd1df9b3d1a09cc9ffba592a", "file_path": "d:\\499\\docs\\cli.rst", "symbol_type": "doc", "name": "Watch and Ignore Files with the Reloader", "qualname": "cli.rst#Watch and Ignore Files with the Reloader", "start_line": 116, "end_line": 131, "docstring": null, "code": "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWhen using debug mode, the reloader will trigger whenever your Python code or imported\nmodules change. The reloader can watch additional files with the ``--extra-files``\noption. Multiple paths are separated with ``:``, or ``;`` on Windows.\n\n.. code-block:: text\n\n    $ flask run --extra-files file1:dirA/file2:dirB/\n     * Running on http://127.0.0.1:8000/\n     * Detected change in '/path/to/file1', reloading\n\nThe reloader can also ignore files using :mod:`fnmatch` patterns with the\n``--exclude-patterns`` option. Multiple patterns are separated with ``:``, or ``;`` on\nWindows.", "code_truncated": false}
{"chunk_id": "6edb5f466b19c2b87bfbdac87279b61cc31f58cc", "file_path": "d:\\499\\docs\\cli.rst", "symbol_type": "doc", "name": "Open a Shell", "qualname": "cli.rst#Open a Shell", "start_line": 134, "end_line": 149, "docstring": null, "code": "------------\n\nTo explore the data in your application, you can start an interactive Python\nshell with the :func:`shell <cli.shell_command>` command. An application\ncontext will be active, and the app instance will be imported. ::\n\n    $ flask shell\n    Python 3.10.0 (default, Oct 27 2021, 06:59:51) [GCC 11.1.0] on linux\n    App: example [production]\n    Instance: /home/david/Projects/pallets/flask/instance\n    >>>\n\nUse :meth:`~Flask.shell_context_processor` to add other automatic imports.\n\n\n.. _dotenv:", "code_truncated": false}
{"chunk_id": "fc57171558f7f7674729e60658f6ef046815656c", "file_path": "d:\\499\\docs\\cli.rst", "symbol_type": "doc", "name": "Environment Variables From dotenv", "qualname": "cli.rst#Environment Variables From dotenv", "start_line": 152, "end_line": 183, "docstring": null, "code": "---------------------------------\n\nThe ``flask`` command supports setting any option for any command with\nenvironment variables. The variables are named like ``FLASK_OPTION`` or\n``FLASK_COMMAND_OPTION``, for example ``FLASK_APP`` or\n``FLASK_RUN_PORT``.\n\nRather than passing options every time you run a command, or environment\nvariables every time you open a new terminal, you can use Flask's dotenv\nsupport to set environment variables automatically.\n\nIf `python-dotenv`_ is installed, running the ``flask`` command will set\nenvironment variables defined in the files ``.env`` and ``.flaskenv``.\nYou can also specify an extra file to load with the ``--env-file``\noption. Dotenv files can be used to avoid having to set ``--app`` or\n``FLASK_APP`` manually, and to set configuration using environment\nvariables similar to how some deployment services work.\n\nVariables set on the command line are used over those set in :file:`.env`,\nwhich are used over those set in :file:`.flaskenv`. :file:`.flaskenv` should be\nused for public variables, such as ``FLASK_APP``, while :file:`.env` should not\nbe committed to your repository so that it can set private variables.\n\nDirectories are scanned upwards from the directory you call ``flask``\nfrom to locate the files.\n\nThe files are only loaded by the ``flask`` command or calling\n:meth:`~Flask.run`. If you would like to load these files when running in\nproduction, you should call :func:`~cli.load_dotenv` manually.\n\n.. _python-dotenv: https://github.com/theskumar/python-dotenv#readme", "code_truncated": false}
{"chunk_id": "5bb8a2934de1df913421f6072ca84263538be805", "file_path": "d:\\499\\docs\\cli.rst", "symbol_type": "doc", "name": "Setting Command Options", "qualname": "cli.rst#Setting Command Options", "start_line": 186, "end_line": 229, "docstring": null, "code": "~~~~~~~~~~~~~~~~~~~~~~~\n\nClick is configured to load default values for command options from\nenvironment variables. The variables use the pattern\n``FLASK_COMMAND_OPTION``. For example, to set the port for the run\ncommand, instead of ``flask run --port 8000``:\n\n.. tabs::\n\n   .. group-tab:: Bash\n\n      .. code-block:: text\n\n         $ export FLASK_RUN_PORT=8000\n         $ flask run\n          * Running on http://127.0.0.1:8000/\n\n   .. group-tab:: Fish\n\n      .. code-block:: text\n\n         $ set -x FLASK_RUN_PORT 8000\n         $ flask run\n          * Running on http://127.0.0.1:8000/\n\n   .. group-tab:: CMD\n\n      .. code-block:: text\n\n         > set FLASK_RUN_PORT=8000\n         > flask run\n          * Running on http://127.0.0.1:8000/\n\n   .. group-tab:: Powershell\n\n      .. code-block:: text\n\n         > $env:FLASK_RUN_PORT = 8000\n         > flask run\n          * Running on http://127.0.0.1:8000/\n\nThese can be added to the ``.flaskenv`` file just like ``FLASK_APP`` to\ncontrol default command options.", "code_truncated": false}
{"chunk_id": "8c193ca5b8186f005dc760069f37f10e3b1c2403", "file_path": "d:\\499\\docs\\cli.rst", "symbol_type": "doc", "name": "Disable dotenv", "qualname": "cli.rst#Disable dotenv", "start_line": 232, "end_line": 278, "docstring": null, "code": "~~~~~~~~~~~~~~\n\nThe ``flask`` command will show a message if it detects dotenv files but\npython-dotenv is not installed.\n\n.. code-block:: bash\n\n    $ flask run\n     * Tip: There are .env files present. Do \"pip install python-dotenv\" to use them.\n\nYou can tell Flask not to load dotenv files even when python-dotenv is\ninstalled by setting the ``FLASK_SKIP_DOTENV`` environment variable.\nThis can be useful if you want to load them manually, or if you're using\na project runner that loads them already. Keep in mind that the\nenvironment variables must be set before the app loads or it won't\nconfigure as expected.\n\n.. tabs::\n\n   .. group-tab:: Bash\n\n      .. code-block:: text\n\n         $ export FLASK_SKIP_DOTENV=1\n         $ flask run\n\n   .. group-tab:: Fish\n\n      .. code-block:: text\n\n         $ set -x FLASK_SKIP_DOTENV 1\n         $ flask run\n\n   .. group-tab:: CMD\n\n      .. code-block:: text\n\n         > set FLASK_SKIP_DOTENV=1\n         > flask run\n\n   .. group-tab:: Powershell\n\n      .. code-block:: text\n\n         > $env:FLASK_SKIP_DOTENV = 1\n         > flask run", "code_truncated": false}
{"chunk_id": "4f2a8d9e6d8ef558b706235c98b7acd8dc5ca3b6", "file_path": "d:\\499\\docs\\cli.rst", "symbol_type": "doc", "name": "Environment Variables From virtualenv", "qualname": "cli.rst#Environment Variables From virtualenv", "start_line": 281, "end_line": 316, "docstring": null, "code": "-------------------------------------\n\nIf you do not want to install dotenv support, you can still set environment\nvariables by adding them to the end of the virtualenv's :file:`activate`\nscript. Activating the virtualenv will set the variables.\n\n.. tabs::\n\n   .. group-tab:: Bash\n\n      Unix Bash, :file:`.venv/bin/activate`::\n\n          $ export FLASK_APP=hello\n\n   .. group-tab:: Fish\n\n      Fish, :file:`.venv/bin/activate.fish`::\n\n          $ set -x FLASK_APP hello\n\n   .. group-tab:: CMD\n\n      Windows CMD, :file:`.venv\\\\Scripts\\\\activate.bat`::\n\n          > set FLASK_APP=hello\n\n   .. group-tab:: Powershell\n\n      Windows Powershell, :file:`.venv\\\\Scripts\\\\activate.ps1`::\n\n          > $env:FLASK_APP = \"hello\"\n\nIt is preferred to use dotenv support over this, since :file:`.flaskenv` can be\ncommitted to the repository so that it works automatically wherever the project\nis checked out.", "code_truncated": false}
{"chunk_id": "616117def12060892cb103439569db5c076f8226", "file_path": "d:\\499\\docs\\cli.rst", "symbol_type": "doc", "name": "Custom Commands", "qualname": "cli.rst#Custom Commands", "start_line": 319, "end_line": 364, "docstring": null, "code": "---------------\n\nThe ``flask`` command is implemented using `Click`_. See that project's\ndocumentation for full information about writing commands.\n\nThis example adds the command ``create-user`` that takes the argument\n``name``. ::\n\n    import click\n    from flask import Flask\n\n    app = Flask(__name__)\n\n    @app.cli.command(\"create-user\")\n    @click.argument(\"name\")\n    def create_user(name):\n        ...\n\n::\n\n    $ flask create-user admin\n\nThis example adds the same command, but as ``user create``, a command in a\ngroup. This is useful if you want to organize multiple related commands. ::\n\n    import click\n    from flask import Flask\n    from flask.cli import AppGroup\n\n    app = Flask(__name__)\n    user_cli = AppGroup('user')\n\n    @user_cli.command('create')\n    @click.argument('name')\n    def create_user(name):\n        ...\n\n    app.cli.add_command(user_cli)\n\n::\n\n    $ flask user create demo\n\nSee :ref:`testing-cli` for an overview of how to test your custom\ncommands.", "code_truncated": false}
{"chunk_id": "862ab25eb0c26db7daa8dcc080dc74e89a4bf5a8", "file_path": "d:\\499\\docs\\cli.rst", "symbol_type": "doc", "name": "Registering Commands with Blueprints", "qualname": "cli.rst#Registering Commands with Blueprints", "start_line": 367, "end_line": 419, "docstring": null, "code": "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf your application uses blueprints, you can optionally register CLI\ncommands directly onto them. When your blueprint is registered onto your\napplication, the associated commands will be available to the ``flask``\ncommand. By default, those commands will be nested in a group matching\nthe name of the blueprint.\n\n.. code-block:: python\n\n    from flask import Blueprint\n\n    bp = Blueprint('students', __name__)\n\n    @bp.cli.command('create')\n    @click.argument('name')\n    def create(name):\n        ...\n\n    app.register_blueprint(bp)\n\n.. code-block:: text\n\n    $ flask students create alice\n\nYou can alter the group name by specifying the ``cli_group`` parameter\nwhen creating the :class:`Blueprint` object, or later with\n:meth:`app.register_blueprint(bp, cli_group='...') <Flask.register_blueprint>`.\nThe following are equivalent:\n\n.. code-block:: python\n\n    bp = Blueprint('students', __name__, cli_group='other')\n    # or\n    app.register_blueprint(bp, cli_group='other')\n\n.. code-block:: text\n\n    $ flask other create alice\n\nSpecifying ``cli_group=None`` will remove the nesting and merge the\ncommands directly to the application's level:\n\n.. code-block:: python\n\n    bp = Blueprint('students', __name__, cli_group=None)\n    # or\n    app.register_blueprint(bp, cli_group=None)\n\n.. code-block:: text\n\n    $ flask create alice", "code_truncated": false}
{"chunk_id": "81a3de023132aa6f8235dd56296f587e56fbcb6a", "file_path": "d:\\499\\docs\\cli.rst", "symbol_type": "doc", "name": "Application Context", "qualname": "cli.rst#Application Context", "start_line": 422, "end_line": 442, "docstring": null, "code": "~~~~~~~~~~~~~~~~~~~\n\nCommands added using the Flask app's :attr:`~Flask.cli` or\n:class:`~flask.cli.FlaskGroup` :meth:`~cli.AppGroup.command` decorator\nwill be executed with an application context pushed, so your custom\ncommands and parameters have access to the app and its configuration. The\n:func:`~cli.with_appcontext` decorator can be used to get the same\nbehavior, but is not needed in most cases.\n\n.. code-block:: python\n\n    import click\n    from flask.cli import with_appcontext\n\n    @click.command()\n    @with_appcontext\n    def do_work():\n        ...\n\n    app.cli.add_command(do_work)", "code_truncated": false}
{"chunk_id": "c486fde108ee93e6e175a8b561ec5d0aedf63679", "file_path": "d:\\499\\docs\\cli.rst", "symbol_type": "doc", "name": "Plugins", "qualname": "cli.rst#Plugins", "start_line": 445, "end_line": 471, "docstring": null, "code": "-------\n\nFlask will automatically load commands specified in the ``flask.commands``\n`entry point`_. This is useful for extensions that want to add commands when\nthey are installed. Entry points are specified in :file:`pyproject.toml`:\n\n.. code-block:: toml\n\n    [project.entry-points.\"flask.commands\"]\n    my-command = \"my_extension.commands:cli\"\n\n.. _entry point: https://packaging.python.org/tutorials/packaging-projects/#entry-points\n\nInside :file:`my_extension/commands.py` you can then export a Click\nobject::\n\n    import click\n\n    @click.command()\n    def cli():\n        ...\n\nOnce that package is installed in the same virtualenv as your Flask project,\nyou can run ``flask my-command`` to invoke the command.\n\n\n.. _custom-scripts:", "code_truncated": false}
{"chunk_id": "25582660e1c7aabebeb8c2d347cbe87c772a0465", "file_path": "d:\\499\\docs\\cli.rst", "symbol_type": "doc", "name": "Custom Scripts", "qualname": "cli.rst#Custom Scripts", "start_line": 474, "end_line": 519, "docstring": null, "code": "--------------\n\nWhen you are using the app factory pattern, it may be more convenient to define\nyour own Click script. Instead of using ``--app`` and letting Flask load\nyour application, you can create your own Click object and export it as a\n`console script`_ entry point.\n\nCreate an instance of :class:`~cli.FlaskGroup` and pass it the factory::\n\n    import click\n    from flask import Flask\n    from flask.cli import FlaskGroup\n\n    def create_app():\n        app = Flask('wiki')\n        # other setup\n        return app\n\n    @click.group(cls=FlaskGroup, create_app=create_app)\n    def cli():\n        \"\"\"Management script for the Wiki application.\"\"\"\n\nDefine the entry point in :file:`pyproject.toml`:\n\n.. code-block:: toml\n\n    [project.scripts]\n    wiki = \"wiki:cli\"\n\nInstall the application in the virtualenv in editable mode and the custom\nscript is available. Note that you don't need to set ``--app``. ::\n\n    $ pip install -e .\n    $ wiki run\n\n.. admonition:: Errors in Custom Scripts\n\n    When using a custom script, if you introduce an error in your\n    module-level code, the reloader will fail because it can no longer\n    load the entry point.\n\n    The ``flask`` command, being separate from your code, does not have\n    this issue and is recommended in most cases.\n\n.. _console script: https://packaging.python.org/tutorials/packaging-projects/#console-scripts", "code_truncated": false}
{"chunk_id": "b8492a2eedfae5491ee04f4c44c2aef313747ad3", "file_path": "d:\\499\\docs\\cli.rst", "symbol_type": "doc", "name": "PyCharm Integration", "qualname": "cli.rst#PyCharm Integration", "start_line": 522, "end_line": 556, "docstring": null, "code": "-------------------\n\nPyCharm Professional provides a special Flask run configuration to run the development\nserver. For the Community Edition, and for other commands besides ``run``, you need to\ncreate a custom run configuration. These instructions should be similar for any other\nIDE you use.\n\nIn PyCharm, with your project open, click on *Run* from the menu bar and go to *Edit\nConfigurations*. You'll see a screen similar to this:\n\n.. image:: _static/pycharm-run-config.png\n    :align: center\n    :class: screenshot\n    :alt: Screenshot of PyCharm run configuration.\n\nOnce you create a configuration for the ``flask run``, you can copy and change it to\ncall any other command.\n\nClick the *+ (Add New Configuration)* button and select *Python*. Give the configuration\na name such as \"flask run\".\n\nClick the *Script path* dropdown and change it to *Module name*, then input ``flask``.\n\nThe *Parameters* field is set to the CLI command to execute along with any arguments.\nThis example uses ``--app hello run --debug``, which will run the development server in\ndebug mode. ``--app hello`` should be the import or file with your Flask app.\n\nIf you installed your project as a package in your virtualenv, you may uncheck the\n*PYTHONPATH* options. This will more accurately match how you deploy later.\n\nClick *OK* to save and close the configuration. Select the configuration in the main\nPyCharm window and click the play button next to it to run the server.\n\nNow that you have a configuration for ``flask run``, you can copy that configuration and\nchange the *Parameters* argument to run a different CLI command.", "code_truncated": false}
{"chunk_id": "1af46f9e0d144354ec6d066663eb27d53c5f6e3d", "file_path": "d:\\499\\docs\\config.rst", "symbol_type": "doc", "name": "Configuration Handling", "qualname": "config.rst#Configuration Handling", "start_line": 2, "end_line": 20, "docstring": null, "code": "======================\n\nApplications need some kind of configuration.  There are different settings\nyou might want to change depending on the application environment like\ntoggling the debug mode, setting the secret key, and other such\nenvironment-specific things.\n\nThe way Flask is designed usually requires the configuration to be\navailable when the application starts up.  You can hard code the\nconfiguration in the code, which for many small applications is not\nactually that bad, but there are better ways.\n\nIndependent of how you load your config, there is a config object\navailable which holds the loaded configuration values:\nThe :attr:`~flask.Flask.config` attribute of the :class:`~flask.Flask`\nobject.  This is the place where Flask itself puts certain configuration\nvalues and also where extensions can put their configuration values.  But\nthis is also where you can have your own configuration.", "code_truncated": false}
{"chunk_id": "17462d178f1f4ced8d2d768ff3c462c0fdba3c0e", "file_path": "d:\\499\\docs\\config.rst", "symbol_type": "doc", "name": "Configuration Basics", "qualname": "config.rst#Configuration Basics", "start_line": 23, "end_line": 43, "docstring": null, "code": "--------------------\n\nThe :attr:`~flask.Flask.config` is actually a subclass of a dictionary and\ncan be modified just like any dictionary::\n\n    app = Flask(__name__)\n    app.config['TESTING'] = True\n\nCertain configuration values are also forwarded to the\n:attr:`~flask.Flask` object so you can read and write them from there::\n\n    app.testing = True\n\nTo update multiple keys at once you can use the :meth:`dict.update`\nmethod::\n\n    app.config.update(\n        TESTING=True,\n        SECRET_KEY='192b9bdd22ab9ed4d12e236c78afcb9a393ec15f71bbf5dc987d54727823bcbf'\n    )", "code_truncated": false}
{"chunk_id": "8db49142332b61110230ff65976b53b7ef414e14", "file_path": "d:\\499\\docs\\config.rst", "symbol_type": "doc", "name": "Debug Mode", "qualname": "config.rst#Debug Mode", "start_line": 46, "end_line": 61, "docstring": null, "code": "----------\n\nThe :data:`DEBUG` config value is special because it may behave inconsistently if\nchanged after the app has begun setting up. In order to set debug mode reliably, use the\n``--debug`` option on the ``flask`` or ``flask run`` command. ``flask run`` will use the\ninteractive debugger and reloader by default in debug mode.\n\n.. code-block:: text\n\n    $ flask --app hello run --debug\n\nUsing the option is recommended. While it is possible to set :data:`DEBUG` in your\nconfig or code, this is strongly discouraged. It can't be read early by the\n``flask run`` command, and some systems or extensions may have already configured\nthemselves based on a previous value.", "code_truncated": false}
{"chunk_id": "bc6ef1952c983b8ae2df2541620e44769a487573", "file_path": "d:\\499\\docs\\config.rst", "symbol_type": "doc", "name": "Builtin Configuration Values", "qualname": "config.rst#Builtin Configuration Values", "start_line": 64, "end_line": 451, "docstring": null, "code": "----------------------------\n\nThe following configuration values are used internally by Flask:\n\n.. py:data:: DEBUG\n\n    Whether debug mode is enabled. When using ``flask run`` to start the development\n    server, an interactive debugger will be shown for unhandled exceptions, and the\n    server will be reloaded when code changes. The :attr:`~flask.Flask.debug` attribute\n    maps to this config key. This is set with the ``FLASK_DEBUG`` environment variable.\n    It may not behave as expected if set in code.\n\n    **Do not enable debug mode when deploying in production.**\n\n    Default: ``False``\n\n.. py:data:: TESTING\n\n    Enable testing mode. Exceptions are propagated rather than handled by the\n    the app's error handlers. Extensions may also change their behavior to\n    facilitate easier testing. You should enable this in your own tests.\n\n    Default: ``False``\n\n.. py:data:: PROPAGATE_EXCEPTIONS\n\n    Exceptions are re-raised rather than being handled by the app's error\n    handlers. If not set, this is implicitly true if ``TESTING`` or ``DEBUG``\n    is enabled.\n\n    Default: ``None``\n\n.. py:data:: TRAP_HTTP_EXCEPTIONS\n\n    If there is no handler for an ``HTTPException``-type exception, re-raise it\n    to be handled by the interactive debugger instead of returning it as a\n    simple error response.\n\n    Default: ``False``\n\n.. py:data:: TRAP_BAD_REQUEST_ERRORS\n\n    Trying to access a key that doesn't exist from request dicts like ``args``\n    and ``form`` will return a 400 Bad Request error page. Enable this to treat\n    the error as an unhandled exception instead so that you get the interactive\n    debugger. This is a more specific version of ``TRAP_HTTP_EXCEPTIONS``. If\n    unset, it is enabled in debug mode.\n\n    Default: ``None``\n\n.. py:data:: SECRET_KEY\n\n    A secret key that will be used for securely signing the session cookie\n    and can be used for any other security related needs by extensions or your\n    application. It should be a long random ``bytes`` or ``str``. For\n    example, copy the output of this to your config::\n\n        $ python -c 'import secrets; print(secrets.token_hex())'\n        '192b9bdd22ab9ed4d12e236c78afcb9a393ec15f71bbf5dc987d54727823bcbf'\n\n    **Do not reveal the secret key when posting questions or committing code.**\n\n    Default: ``None``\n\n.. py:data:: SECRET_KEY_FALLBACKS\n\n    A list of old secret keys that can still be used for unsigning. This allows\n    a project to implement key rotation without invalidating active sessions or\n    other recently-signed secrets.\n\n    Keys should be removed after an appropriate period of time, as checking each\n    additional key adds some overhead.\n\n    Order should not matter, but the default implementation will test the last\n    key in the list first, so it might make sense to order oldest to newest.\n\n    Flask's built-in secure cookie session supports this. Extensions that use\n    :data:`SECRET_KEY` may not support this yet.\n\n    Default: ``None``\n\n    .. versionadded:: 3.1\n\n.. py:data:: SESSION_COOKIE_NAME\n\n    The name of the session cookie. Can be changed in case you already have a\n    cookie with the same name.\n\n    Default: ``'session'``\n\n.. py:data:: SESSION_COOKIE_DOMAIN\n\n    The value of the ``Domain`` parameter on the session cookie. If not set, browsers\n    will only send the cookie to the exact domain it was set from. Otherwise, they\n    will send it to any subdomain of the given value as well.\n\n    Not setting this value is more restricted and secure than setting it.\n\n    Default: ``None``\n\n    .. warning::\n        If this is changed after the browser created a cookie is created with\n        one setting, it may result in another being created. Browsers may send\n        send both in an undefined order. In that case, you may want to change\n        :data:`SESSION_COOKIE_NAME` as well or otherwise invalidate old sessions.\n\n    .. versionchanged:: 2.3\n        Not set by default, does not fall back to ``SERVER_NAME``.\n\n.. py:data:: SESSION_COOKIE_PATH\n\n    The path that the session cookie will be valid for. If not set, the cookie\n    will be valid underneath ``APPLICATION_ROOT`` or ``/`` if that is not set.\n\n    Default: ``None``\n\n.. py:data:: SESSION_COOKIE_HTTPONLY\n\n    Browsers will not allow JavaScript access to cookies marked as \"HTTP only\"\n    for security.\n\n    Default: ``True``\n\n.. py:data:: SESSION_COOKIE_SECURE\n\n    Browsers will only send cookies with requests over HTTPS if the cookie is\n    marked \"secure\". The application must be served over HTTPS for this to make\n    sense.\n\n    Default: ``False``\n\n.. py:data:: SESSION_COOKIE_PARTITIONED\n\n    Browsers will send cookies based on the top-level document's domain, rather\n    than only the domain of the document setting the cookie. This prevents third\n    party cookies set in iframes from \"leaking\" between separate sites.\n\n    Browsers are beginning to disallow non-partitioned third party cookies, so\n    you need to mark your cookies partitioned if you expect them to work in such\n    embedded situations.\n\n    Enabling this implicitly enables :data:`SESSION_COOKIE_SECURE` as well, as\n    it is only valid when served over HTTPS.\n\n    Default: ``False``\n\n    .. versionadded:: 3.1\n\n.. py:data:: SESSION_COOKIE_SAMESITE\n\n    Restrict how cookies are sent with requests from external sites. Can\n    be set to ``'Lax'`` (recommended) or ``'Strict'``.\n    See :ref:`security-cookie`.\n\n    Default: ``None``\n\n    .. versionadded:: 1.0\n\n.. py:data:: PERMANENT_SESSION_LIFETIME\n\n    If ``session.permanent`` is true, the cookie's expiration will be set this\n    number of seconds in the future. Can either be a\n    :class:`datetime.timedelta` or an ``int``.\n\n    Flask's default cookie implementation validates that the cryptographic\n    signature is not older than this value.\n\n    Default: ``timedelta(days=31)`` (``2678400`` seconds)\n\n.. py:data:: SESSION_REFRESH_EACH_REQUEST\n\n    Control whether the cookie is sent with every response when\n    ``session.permanent`` is true. Sending the cookie every time (the default)\n    can more reliably keep the session from expiring, but uses more bandwidth.\n    Non-permanent sessions are not affected.\n\n    Default: ``True``\n\n.. py:data:: USE_X_SENDFILE\n\n    When serving files, set the ``X-Sendfile`` header instead of serving the\n    data with Flask. Some web servers, such as Apache, recognize this and serve\n    the data more efficiently. This only makes sense when using such a server.\n\n    Default: ``False``\n\n.. py:data:: SEND_FILE_MAX_AGE_DEFAULT\n\n    When serving files, set the cache control max age to this number of\n    seconds. Can be a :class:`datetime.timedelta` or an ``int``.\n    Override this value on a per-file basis using\n    :meth:`~flask.Flask.get_send_file_max_age` on the application or\n    blueprint.\n\n    If ``None``, ``send_file`` tells the browser to use conditional\n    requests will be used instead of a timed cache, which is usually\n    preferable.\n\n    Default: ``None``\n\n.. py:data:: TRUSTED_HOSTS\n\n    Validate :attr:`.Request.host` and other attributes that use it against\n    these trusted values. Raise a :exc:`~werkzeug.exceptions.SecurityError` if\n    the host is invalid, which results in a 400 error. If it is ``None``, all\n    hosts are valid. Each value is either an exact match, or can start with\n    a dot ``.`` to match any subdomain.\n\n    Validation is done during routing against this value. ``before_request`` and\n    ``after_request`` callbacks will still be called.\n\n    Default: ``None``\n\n    .. versionadded:: 3.1\n\n.. py:data:: SERVER_NAME\n\n    Inform the application what host and port it is bound to.\n\n    Must be set if ``subdomain_matching`` is enabled, to be able to extract the\n    subdomain from the request.\n\n    Must be set for ``url_for`` to generate external URLs outside of a\n    request context.\n\n    Default: ``None``\n\n    .. versionchanged:: 3.1\n        Does not restrict requests to only this domain, for both\n        ``subdomain_matching`` and \n...<truncated>...\n", "code_truncated": true}
{"chunk_id": "fc8a2685e34b71a89e566a8958f00c41dba29ebf", "file_path": "d:\\499\\docs\\config.rst", "symbol_type": "doc", "name": "Configuring from Python Files", "qualname": "config.rst#Configuring from Python Files", "start_line": 454, "end_line": 520, "docstring": null, "code": "-----------------------------\n\nConfiguration becomes more useful if you can store it in a separate file, ideally\nlocated outside the actual application package. You can deploy your application, then\nseparately configure it for the specific deployment.\n\nA common pattern is this::\n\n    app = Flask(__name__)\n    app.config.from_object('yourapplication.default_settings')\n    app.config.from_envvar('YOURAPPLICATION_SETTINGS')\n\nThis first loads the configuration from the\n`yourapplication.default_settings` module and then overrides the values\nwith the contents of the file the :envvar:`YOURAPPLICATION_SETTINGS`\nenvironment variable points to.  This environment variable can be set\nin the shell before starting the server:\n\n.. tabs::\n\n   .. group-tab:: Bash\n\n      .. code-block:: text\n\n         $ export YOURAPPLICATION_SETTINGS=/path/to/settings.cfg\n         $ flask run\n          * Running on http://127.0.0.1:5000/\n\n   .. group-tab:: Fish\n\n      .. code-block:: text\n\n         $ set -x YOURAPPLICATION_SETTINGS /path/to/settings.cfg\n         $ flask run\n          * Running on http://127.0.0.1:5000/\n\n   .. group-tab:: CMD\n\n      .. code-block:: text\n\n         > set YOURAPPLICATION_SETTINGS=\\path\\to\\settings.cfg\n         > flask run\n          * Running on http://127.0.0.1:5000/\n\n   .. group-tab:: Powershell\n\n      .. code-block:: text\n\n         > $env:YOURAPPLICATION_SETTINGS = \"\\path\\to\\settings.cfg\"\n         > flask run\n          * Running on http://127.0.0.1:5000/\n\nThe configuration files themselves are actual Python files.  Only values\nin uppercase are actually stored in the config object later on.  So make\nsure to use uppercase letters for your config keys.\n\nHere is an example of a configuration file::\n\n    # Example configuration\n    SECRET_KEY = '192b9bdd22ab9ed4d12e236c78afcb9a393ec15f71bbf5dc987d54727823bcbf'\n\nMake sure to load the configuration very early on, so that extensions have\nthe ability to access the configuration when starting up.  There are other\nmethods on the config object as well to load from individual files.  For a\ncomplete reference, read the :class:`~flask.Config` object's\ndocumentation.", "code_truncated": false}
{"chunk_id": "e9d8bba837a778d2b16aba5f4197138601921ed5", "file_path": "d:\\499\\docs\\config.rst", "symbol_type": "doc", "name": "Configuring from Data Files", "qualname": "config.rst#Configuring from Data Files", "start_line": 523, "end_line": 540, "docstring": null, "code": "---------------------------\n\nIt is also possible to load configuration from a file in a format of\nyour choice using :meth:`~flask.Config.from_file`. For example to load\nfrom a TOML file:\n\n.. code-block:: python\n\n    import tomllib\n    app.config.from_file(\"config.toml\", load=tomllib.load, text=False)\n\nOr from a JSON file:\n\n.. code-block:: python\n\n    import json\n    app.config.from_file(\"config.json\", load=json.load)", "code_truncated": false}
{"chunk_id": "2dc5f2d35e4e3f428dc2ace365f8081685cb7bcd", "file_path": "d:\\499\\docs\\config.rst", "symbol_type": "doc", "name": "Configuring from Environment Variables", "qualname": "config.rst#Configuring from Environment Variables", "start_line": 543, "end_line": 632, "docstring": null, "code": "--------------------------------------\n\nIn addition to pointing to configuration files using environment\nvariables, you may find it useful (or necessary) to control your\nconfiguration values directly from the environment. Flask can be\ninstructed to load all environment variables starting with a specific\nprefix into the config using :meth:`~flask.Config.from_prefixed_env`.\n\nEnvironment variables can be set in the shell before starting the\nserver:\n\n.. tabs::\n\n   .. group-tab:: Bash\n\n      .. code-block:: text\n\n         $ export FLASK_SECRET_KEY=\"5f352379324c22463451387a0aec5d2f\"\n         $ export FLASK_MAIL_ENABLED=false\n         $ flask run\n          * Running on http://127.0.0.1:5000/\n\n   .. group-tab:: Fish\n\n      .. code-block:: text\n\n         $ set -x FLASK_SECRET_KEY \"5f352379324c22463451387a0aec5d2f\"\n         $ set -x FLASK_MAIL_ENABLED false\n         $ flask run\n          * Running on http://127.0.0.1:5000/\n\n   .. group-tab:: CMD\n\n      .. code-block:: text\n\n         > set FLASK_SECRET_KEY=\"5f352379324c22463451387a0aec5d2f\"\n         > set FLASK_MAIL_ENABLED=false\n         > flask run\n          * Running on http://127.0.0.1:5000/\n\n   .. group-tab:: Powershell\n\n      .. code-block:: text\n\n         > $env:FLASK_SECRET_KEY = \"5f352379324c22463451387a0aec5d2f\"\n         > $env:FLASK_MAIL_ENABLED = \"false\"\n         > flask run\n          * Running on http://127.0.0.1:5000/\n\nThe variables can then be loaded and accessed via the config with a key\nequal to the environment variable name without the prefix i.e.\n\n.. code-block:: python\n\n    app.config.from_prefixed_env()\n    app.config[\"SECRET_KEY\"]  # Is \"5f352379324c22463451387a0aec5d2f\"\n\nThe prefix is ``FLASK_`` by default. This is configurable via the\n``prefix`` argument of :meth:`~flask.Config.from_prefixed_env`.\n\nValues will be parsed to attempt to convert them to a more specific type\nthan strings. By default :func:`json.loads` is used, so any valid JSON\nvalue is possible, including lists and dicts. This is configurable via\nthe ``loads`` argument of :meth:`~flask.Config.from_prefixed_env`.\n\nWhen adding a boolean value with the default JSON parsing, only \"true\"\nand \"false\", lowercase, are valid values. Keep in mind that any\nnon-empty string is considered ``True`` by Python.\n\nIt is possible to set keys in nested dictionaries by separating the\nkeys with double underscore (``__``). Any intermediate keys that don't\nexist on the parent dict will be initialized to an empty dict.\n\n.. code-block:: text\n\n    $ export FLASK_MYAPI__credentials__username=user123\n\n.. code-block:: python\n\n    app.config[\"MYAPI\"][\"credentials\"][\"username\"]  # Is \"user123\"\n\nOn Windows, environment variable keys are always uppercase, therefore\nthe above example would end up as ``MYAPI__CREDENTIALS__USERNAME``.\n\nFor even more config loading features, including merging and\ncase-insensitive Windows support, try a dedicated library such as\nDynaconf_, which includes integration with Flask.\n\n.. _Dynaconf: https://www.dynaconf.com/", "code_truncated": false}
{"chunk_id": "01f4a5e371f6cd14723a30c1b302891a37994e24", "file_path": "d:\\499\\docs\\config.rst", "symbol_type": "doc", "name": "Configuration Best Practices", "qualname": "config.rst#Configuration Best Practices", "start_line": 635, "end_line": 655, "docstring": null, "code": "----------------------------\n\nThe downside with the approach mentioned earlier is that it makes testing\na little harder.  There is no single 100% solution for this problem in\ngeneral, but there are a couple of things you can keep in mind to improve\nthat experience:\n\n1.  Create your application in a function and register blueprints on it.\n    That way you can create multiple instances of your application with\n    different configurations attached which makes unit testing a lot\n    easier.  You can use this to pass in configuration as needed.\n\n2.  Do not write code that needs the configuration at import time.  If you\n    limit yourself to request-only accesses to the configuration you can\n    reconfigure the object later on as needed.\n\n3.  Make sure to load the configuration very early on, so that\n    extensions can access the configuration when calling ``init_app``.\n\n\n.. _config-dev-prod:", "code_truncated": false}
{"chunk_id": "05bdb040b2408a856b4b2e77e4280ebb848ca195", "file_path": "d:\\499\\docs\\config.rst", "symbol_type": "doc", "name": "Development / Production", "qualname": "config.rst#Development / Production", "start_line": 658, "end_line": 758, "docstring": null, "code": "------------------------\n\nMost applications need more than one configuration.  There should be at\nleast separate configurations for the production server and the one used\nduring development.  The easiest way to handle this is to use a default\nconfiguration that is always loaded and part of the version control, and a\nseparate configuration that overrides the values as necessary as mentioned\nin the example above::\n\n    app = Flask(__name__)\n    app.config.from_object('yourapplication.default_settings')\n    app.config.from_envvar('YOURAPPLICATION_SETTINGS')\n\nThen you just have to add a separate :file:`config.py` file and export\n``YOURAPPLICATION_SETTINGS=/path/to/config.py`` and you are done.  However\nthere are alternative ways as well.  For example you could use imports or\nsubclassing.\n\nWhat is very popular in the Django world is to make the import explicit in\nthe config file by adding ``from yourapplication.default_settings\nimport *`` to the top of the file and then overriding the changes by hand.\nYou could also inspect an environment variable like\n``YOURAPPLICATION_MODE`` and set that to `production`, `development` etc\nand import different hard-coded files based on that.\n\nAn interesting pattern is also to use classes and inheritance for\nconfiguration::\n\n    class Config(object):\n        TESTING = False\n\n    class ProductionConfig(Config):\n        DATABASE_URI = 'mysql://user@localhost/foo'\n\n    class DevelopmentConfig(Config):\n        DATABASE_URI = \"sqlite:////tmp/foo.db\"\n\n    class TestingConfig(Config):\n        DATABASE_URI = 'sqlite:///:memory:'\n        TESTING = True\n\nTo enable such a config you just have to call into\n:meth:`~flask.Config.from_object`::\n\n    app.config.from_object('configmodule.ProductionConfig')\n\nNote that :meth:`~flask.Config.from_object` does not instantiate the class\nobject. If you need to instantiate the class, such as to access a property,\nthen you must do so before calling :meth:`~flask.Config.from_object`::\n\n    from configmodule import ProductionConfig\n    app.config.from_object(ProductionConfig())\n\n    # Alternatively, import via string:\n    from werkzeug.utils import import_string\n    cfg = import_string('configmodule.ProductionConfig')()\n    app.config.from_object(cfg)\n\nInstantiating the configuration object allows you to use ``@property`` in\nyour configuration classes::\n\n    class Config(object):\n        \"\"\"Base config, uses staging database server.\"\"\"\n        TESTING = False\n        DB_SERVER = '192.168.1.56'\n\n        @property\n        def DATABASE_URI(self):  # Note: all caps\n            return f\"mysql://user@{self.DB_SERVER}/foo\"\n\n    class ProductionConfig(Config):\n        \"\"\"Uses production database server.\"\"\"\n        DB_SERVER = '192.168.19.32'\n\n    class DevelopmentConfig(Config):\n        DB_SERVER = 'localhost'\n\n    class TestingConfig(Config):\n        DB_SERVER = 'localhost'\n        DATABASE_URI = 'sqlite:///:memory:'\n\nThere are many different ways and it's up to you how you want to manage\nyour configuration files.  However here a list of good recommendations:\n\n-   Keep a default configuration in version control.  Either populate the\n    config with this default configuration or import it in your own\n    configuration files before overriding values.\n-   Use an environment variable to switch between the configurations.\n    This can be done from outside the Python interpreter and makes\n    development and deployment much easier because you can quickly and\n    easily switch between different configs without having to touch the\n    code at all.  If you are working often on different projects you can\n    even create your own script for sourcing that activates a virtualenv\n    and exports the development configuration for you.\n-   Use a tool like `fabric`_ to push code and configuration separately\n    to the production server(s).\n\n.. _fabric: https://www.fabfile.org/\n\n\n.. _instance-folders:", "code_truncated": false}
{"chunk_id": "173ccf506b3f5597139062640eea4df89584758f", "file_path": "d:\\499\\docs\\config.rst", "symbol_type": "doc", "name": "Instance Folders", "qualname": "config.rst#Instance Folders", "start_line": 761, "end_line": 839, "docstring": null, "code": "----------------\n\n.. versionadded:: 0.8\n\nFlask 0.8 introduces instance folders.  Flask for a long time made it\npossible to refer to paths relative to the application's folder directly\n(via :attr:`Flask.root_path`).  This was also how many developers loaded\nconfigurations stored next to the application.  Unfortunately however this\nonly works well if applications are not packages in which case the root\npath refers to the contents of the package.\n\nWith Flask 0.8 a new attribute was introduced:\n:attr:`Flask.instance_path`.  It refers to a new concept called the\ninstance folder.  The instance folder is designed to not be under\nversion control and be deployment specific.  It's the perfect place to\ndrop things that either change at runtime or configuration files.\n\nYou can either explicitly provide the path of the instance folder when\ncreating the Flask application or you can let Flask autodetect the\ninstance folder.  For explicit configuration use the `instance_path`\nparameter::\n\n    app = Flask(__name__, instance_path='/path/to/instance/folder')\n\nPlease keep in mind that this path *must* be absolute when provided.\n\nIf the `instance_path` parameter is not provided the following default\nlocations are used:\n\n-   Uninstalled module::\n\n        /myapp.py\n        /instance\n\n-   Uninstalled package::\n\n        /myapp\n            /__init__.py\n        /instance\n\n-   Installed module or package::\n\n        $PREFIX/lib/pythonX.Y/site-packages/myapp\n        $PREFIX/var/myapp-instance\n\n    ``$PREFIX`` is the prefix of your Python installation.  This can be\n    ``/usr`` or the path to your virtualenv.  You can print the value of\n    ``sys.prefix`` to see what the prefix is set to.\n\nSince the config object provided loading of configuration files from\nrelative filenames we made it possible to change the loading via filenames\nto be relative to the instance path if wanted.  The behavior of relative\npaths in config files can be flipped between relative to the application\nroot (the default) to relative to instance folder via the\n`instance_relative_config` switch to the application constructor::\n\n    app = Flask(__name__, instance_relative_config=True)\n\nHere is a full example of how to configure Flask to preload the config\nfrom a module and then override the config from a file in the instance\nfolder if it exists::\n\n    app = Flask(__name__, instance_relative_config=True)\n    app.config.from_object('yourapplication.default_settings')\n    app.config.from_pyfile('application.cfg', silent=True)\n\nThe path to the instance folder can be found via the\n:attr:`Flask.instance_path`.  Flask also provides a shortcut to open a\nfile from the instance folder with :meth:`Flask.open_instance_resource`.\n\nExample usage for both::\n\n    filename = os.path.join(app.instance_path, 'application.cfg')\n    with open(filename) as f:\n        config = f.read()\n\n    # or via open_instance_resource:\n    with app.open_instance_resource('application.cfg') as f:\n        config = f.read()", "code_truncated": false}
{"chunk_id": "6ab3a935b0fb057aa7b9d056fb9a4f3ffcda6249", "file_path": "d:\\499\\docs\\contributing.rst", "symbol_type": "doc", "name": "Contributing", "qualname": "contributing.rst#Contributing", "start_line": 2, "end_line": 8, "docstring": null, "code": "============\n\nSee the Pallets `detailed contributing documentation <contrib_>`_ for many ways\nto contribute, including reporting issues, requesting features, asking or\nanswering questions, and making PRs.\n\n.. _contrib: https://palletsprojects.com/contributing/", "code_truncated": false}
{"chunk_id": "695012fd9cf45a9d481546843e873a52562d50d0", "file_path": "d:\\499\\docs\\debugging.rst", "symbol_type": "doc", "name": "Debugging Application Errors", "qualname": "debugging.rst#Debugging Application Errors", "start_line": 2, "end_line": 3, "docstring": null, "code": "============================", "code_truncated": false}
{"chunk_id": "49010abf485f4ae3c6e678a4fe342e8154906312", "file_path": "d:\\499\\docs\\debugging.rst", "symbol_type": "doc", "name": "In Production", "qualname": "debugging.rst#In Production", "start_line": 6, "end_line": 21, "docstring": null, "code": "-------------\n\n**Do not run the development server, or enable the built-in debugger, in\na production environment.** The debugger allows executing arbitrary\nPython code from the browser. It's protected by a pin, but that should\nnot be relied on for security.\n\nUse an error logging tool, such as Sentry, as described in\n:ref:`error-logging-tools`, or enable logging and notifications as\ndescribed in :doc:`/logging`.\n\nIf you have access to the server, you could add some code to start an\nexternal debugger if ``request.remote_addr`` matches your IP. Some IDE\ndebuggers also have a remote mode so breakpoints on the server can be\ninteracted with locally. Only enable a debugger temporarily.", "code_truncated": false}
{"chunk_id": "f3168171488dc04a6b3e6ba9dbfc867f3423468a", "file_path": "d:\\499\\docs\\debugging.rst", "symbol_type": "doc", "name": "The Built-In Debugger", "qualname": "debugging.rst#The Built-In Debugger", "start_line": 24, "end_line": 58, "docstring": null, "code": "---------------------\n\nThe built-in Werkzeug development server provides a debugger which shows\nan interactive traceback in the browser when an unhandled error occurs\nduring a request. This debugger should only be used during development.\n\n.. image:: _static/debugger.png\n   :align: center\n   :class: screenshot\n   :alt: screenshot of debugger in action\n\n.. warning::\n\n    The debugger allows executing arbitrary Python code from the\n    browser. It is protected by a pin, but still represents a major\n    security risk. Do not run the development server or debugger in a\n    production environment.\n\nThe debugger is enabled by default when the development server is run in debug mode.\n\n.. code-block:: text\n\n    $ flask --app hello run --debug\n\nWhen running from Python code, passing ``debug=True`` enables debug mode, which is\nmostly equivalent.\n\n.. code-block:: python\n\n    app.run(debug=True)\n\n:doc:`/server` and :doc:`/cli` have more information about running the debugger and\ndebug mode. More information about the debugger can be found in the `Werkzeug\ndocumentation <https://werkzeug.palletsprojects.com/debug/>`__.", "code_truncated": false}
{"chunk_id": "052d72a8c45997b6522e3a638f947301febf9102", "file_path": "d:\\499\\docs\\debugging.rst", "symbol_type": "doc", "name": "External Debuggers", "qualname": "debugging.rst#External Debuggers", "start_line": 61, "end_line": 99, "docstring": null, "code": "------------------\n\nExternal debuggers, such as those provided by IDEs, can offer a more\npowerful debugging experience than the built-in debugger. They can also\nbe used to step through code during a request before an error is raised,\nor if no error is raised. Some even have a remote mode so you can debug\ncode running on another machine.\n\nWhen using an external debugger, the app should still be in debug mode, otherwise Flask\nturns unhandled errors into generic 500 error pages. However, the built-in debugger and\nreloader should be disabled so they don't interfere with the external debugger.\n\n.. code-block:: text\n\n    $ flask --app hello run --debug --no-debugger --no-reload\n\nWhen running from Python:\n\n.. code-block:: python\n\n    app.run(debug=True, use_debugger=False, use_reloader=False)\n\nDisabling these isn't required, an external debugger will continue to work with the\nfollowing caveats.\n\n-   If the built-in debugger is not disabled, it will catch unhandled exceptions before\n    the external debugger can.\n-   If the reloader is not disabled, it could cause an unexpected reload if code changes\n    during a breakpoint.\n-   The development server will still catch unhandled exceptions if the built-in\n    debugger is disabled, otherwise it would crash on any error. If you want that (and\n    usually you don't) pass ``passthrough_errors=True`` to ``app.run``.\n\n    .. code-block:: python\n\n        app.run(\n            debug=True, passthrough_errors=True,\n            use_debugger=False, use_reloader=False\n        )", "code_truncated": false}
{"chunk_id": "55873988bba4a93c50802da5f82d5719f3b2213e", "file_path": "d:\\499\\docs\\deploying\\apache-httpd.rst", "symbol_type": "doc", "name": "Apache httpd", "qualname": "deploying\\apache-httpd.rst#Apache httpd", "start_line": 2, "end_line": 17, "docstring": null, "code": "============\n\n`Apache httpd`_ is a fast, production level HTTP server. When serving\nyour application with one of the WSGI servers listed in :doc:`index`, it\nis often good or necessary to put a dedicated HTTP server in front of\nit. This \"reverse proxy\" can handle incoming requests, TLS, and other\nsecurity and performance concerns better than the WSGI server.\n\nhttpd can be installed using your system package manager, or a pre-built\nexecutable for Windows. Installing and running httpd itself is outside\nthe scope of this doc. This page outlines the basics of configuring\nhttpd to proxy your application. Be sure to read its documentation to\nunderstand what features are available.\n\n.. _Apache httpd: https://httpd.apache.org/", "code_truncated": false}
{"chunk_id": "db94f6e04b2a5b4d9f6beba8801daece11a7dd4a", "file_path": "d:\\499\\docs\\deploying\\apache-httpd.rst", "symbol_type": "doc", "name": "Domain Name", "qualname": "deploying\\apache-httpd.rst#Domain Name", "start_line": 20, "end_line": 39, "docstring": null, "code": "-----------\n\nAcquiring and configuring a domain name is outside the scope of this\ndoc. In general, you will buy a domain name from a registrar, pay for\nserver space with a hosting provider, and then point your registrar\nat the hosting provider's name servers.\n\nTo simulate this, you can also edit your ``hosts`` file, located at\n``/etc/hosts`` on Linux. Add a line that associates a name with the\nlocal IP.\n\nModern Linux systems may be configured to treat any domain name that\nends with ``.localhost`` like this without adding it to the ``hosts``\nfile.\n\n.. code-block:: python\n    :caption: ``/etc/hosts``\n\n    127.0.0.1 hello.localhost", "code_truncated": false}
{"chunk_id": "b235058f94c9dd4c3be6136d1afb511c9215fbd1", "file_path": "d:\\499\\docs\\deploying\\apache-httpd.rst", "symbol_type": "doc", "name": "Configuration", "qualname": "deploying\\apache-httpd.rst#Configuration", "start_line": 42, "end_line": 66, "docstring": null, "code": "-------------\n\nThe httpd configuration is located at ``/etc/httpd/conf/httpd.conf`` on\nLinux. It may be different depending on your operating system. Check the\ndocs and look for ``httpd.conf``.\n\nRemove or comment out any existing ``DocumentRoot`` directive. Add the\nconfig lines below. We'll assume the WSGI server is listening locally at\n``http://127.0.0.1:8000``.\n\n.. code-block:: apache\n    :caption: ``/etc/httpd/conf/httpd.conf``\n\n    LoadModule proxy_module modules/mod_proxy.so\n    LoadModule proxy_http_module modules/mod_proxy_http.so\n    ProxyPass / http://127.0.0.1:8000/\n    RequestHeader set X-Forwarded-Proto http\n    RequestHeader set X-Forwarded-Prefix /\n\nThe ``LoadModule`` lines might already exist. If so, make sure they are\nuncommented instead of adding them manually.\n\nThen :doc:`proxy_fix` so that your application uses the ``X-Forwarded``\nheaders. ``X-Forwarded-For`` and ``X-Forwarded-Host`` are automatically\nset by ``ProxyPass``.", "code_truncated": false}
{"chunk_id": "ddfdea5ed9ddaca6acdf44ed2ed5d55df6a97feb", "file_path": "d:\\499\\docs\\deploying\\asgi.rst", "symbol_type": "doc", "name": "ASGI", "qualname": "deploying\\asgi.rst#ASGI", "start_line": 2, "end_line": 27, "docstring": null, "code": "====\n\nIf you'd like to use an ASGI server you will need to utilise WSGI to\nASGI middleware. The asgiref\n`WsgiToAsgi <https://github.com/django/asgiref#wsgi-to-asgi-adapter>`_\nadapter is recommended as it integrates with the event loop used for\nFlask's :ref:`async_await` support. You can use the adapter by\nwrapping the Flask app,\n\n.. code-block:: python\n\n    from asgiref.wsgi import WsgiToAsgi\n    from flask import Flask\n\n    app = Flask(__name__)\n\n    ...\n\n    asgi_app = WsgiToAsgi(app)\n\nand then serving the ``asgi_app`` with the ASGI server, e.g. using\n`Hypercorn <https://github.com/pgjones/hypercorn>`_,\n\n.. sourcecode:: text\n\n    $ hypercorn module:asgi_app", "code_truncated": false}
{"chunk_id": "74da2a1905c44518004d67fed01e255374b6110e", "file_path": "d:\\499\\docs\\deploying\\eventlet.rst", "symbol_type": "doc", "name": "INTRO", "qualname": "deploying\\eventlet.rst#INTRO", "start_line": 1, "end_line": 1, "docstring": null, "code": ":orphan:", "code_truncated": false}
{"chunk_id": "b4be0a0182b8db645399ccdd7202a16fb185648e", "file_path": "d:\\499\\docs\\deploying\\eventlet.rst", "symbol_type": "doc", "name": "eventlet", "qualname": "deploying\\eventlet.rst#eventlet", "start_line": 4, "end_line": 8, "docstring": null, "code": "========\n\n`Eventlet is no longer maintained.`__ Use :doc:`/deploying/gevent` instead.\n\n__ https://eventlet.readthedocs.io", "code_truncated": false}
{"chunk_id": "e107086624d548cc53917b59c3f0cd426991e7ee", "file_path": "d:\\499\\docs\\deploying\\gevent.rst", "symbol_type": "doc", "name": "gevent", "qualname": "deploying\\gevent.rst#gevent", "start_line": 2, "end_line": 19, "docstring": null, "code": "======\n\nPrefer using :doc:`gunicorn` or :doc:`uwsgi` with gevent workers rather\nthan using `gevent`_ directly. Gunicorn and uWSGI provide much more\nconfigurable and production-tested servers.\n\n`gevent`_ allows writing asynchronous, coroutine-based code that looks\nlike standard synchronous Python. It uses `greenlet`_ to enable task\nswitching without writing ``async/await`` or using ``asyncio``. This is\nnot the same as Python's ``async/await``, or the ASGI server spec.\n\ngevent provides a WSGI server that can handle many connections at once\ninstead of one per worker process. See :doc:`/gevent` for more\ninformation about enabling it in your application.\n\n.. _gevent: https://www.gevent.org/\n.. _greenlet: https://greenlet.readthedocs.io/en/latest/", "code_truncated": false}
{"chunk_id": "322c09fc74a50a520358f3078a2a90b9d67d6437", "file_path": "d:\\499\\docs\\deploying\\gevent.rst", "symbol_type": "doc", "name": "Installing", "qualname": "deploying\\gevent.rst#Installing", "start_line": 22, "end_line": 36, "docstring": null, "code": "----------\n\nWhen using gevent, greenlet>=1.0 is required. When using PyPy,\nPyPy>=7.3.7 is required.\n\nCreate a virtualenv, install your application, then install ``gevent``.\n\n.. code-block:: text\n\n    $ cd hello-app\n    $ python -m venv .venv\n    $ . .venv/bin/activate\n    $ pip install .  # install your application\n    $ pip install gevent", "code_truncated": false}
{"chunk_id": "ceeb29376d22b072f634d66610d995af586d3124", "file_path": "d:\\499\\docs\\deploying\\gevent.rst", "symbol_type": "doc", "name": "Running", "qualname": "deploying\\gevent.rst#Running", "start_line": 39, "end_line": 59, "docstring": null, "code": "-------\n\nTo use gevent to serve your application, write a script that imports its\n``WSGIServer``, as well as your app or app factory.\n\n.. code-block:: python\n    :caption: ``wsgi.py``\n\n    from gevent.pywsgi import WSGIServer\n    from hello import create_app\n\n    app = create_app()\n    http_server = WSGIServer((\"127.0.0.1\", 8000), app)\n    http_server.serve_forever()\n\n.. code-block:: text\n\n    $ python wsgi.py\n\nNo output is shown when the server starts.", "code_truncated": false}
{"chunk_id": "d658969b70c54450ff48ed2addc4a0de760db9ca", "file_path": "d:\\499\\docs\\deploying\\gevent.rst", "symbol_type": "doc", "name": "Binding Externally", "qualname": "deploying\\gevent.rst#Binding Externally", "start_line": 62, "end_line": 76, "docstring": null, "code": "------------------\n\ngevent should not be run as root because it would cause your\napplication code to run as root, which is not secure. However, this\nmeans it will not be possible to bind to port 80 or 443. Instead, a\nreverse proxy such as :doc:`nginx` or :doc:`apache-httpd` should be used\nin front of gevent.\n\nYou can bind to all external IPs on a non-privileged port by using\n``0.0.0.0`` in the server arguments shown in the previous section. Don't\ndo this when using a reverse proxy setup, otherwise it will be possible\nto bypass the proxy.\n\n``0.0.0.0`` is not a valid address to navigate to, you'd use a specific\nIP address in your browser.", "code_truncated": false}
{"chunk_id": "0c989282d37f066698328534d061d8c702f6a6b6", "file_path": "d:\\499\\docs\\deploying\\gunicorn.rst", "symbol_type": "doc", "name": "Gunicorn", "qualname": "deploying\\gunicorn.rst#Gunicorn", "start_line": 2, "end_line": 19, "docstring": null, "code": "========\n\n`Gunicorn`_ is a pure Python WSGI server with simple configuration and\nmultiple worker implementations for performance tuning.\n\n*   It tends to integrate easily with hosting platforms.\n*   It does not support Windows (but does run on WSL).\n*   It is easy to install as it does not require additional dependencies\n    or compilation.\n*   It has built-in async worker support using gevent.\n\nThis page outlines the basics of running Gunicorn. Be sure to read its\n`documentation`_ and use ``gunicorn --help`` to understand what features\nare available.\n\n.. _Gunicorn: https://gunicorn.org/\n.. _documentation: https://docs.gunicorn.org/", "code_truncated": false}
{"chunk_id": "5f5d9600ca86418ab2416584a5b38b8e6b03b20f", "file_path": "d:\\499\\docs\\deploying\\gunicorn.rst", "symbol_type": "doc", "name": "Installing", "qualname": "deploying\\gunicorn.rst#Installing", "start_line": 22, "end_line": 37, "docstring": null, "code": "----------\n\nGunicorn is easy to install, as it does not require external\ndependencies or compilation. It runs on Windows only under WSL.\n\nCreate a virtualenv, install your application, then install\n``gunicorn``.\n\n.. code-block:: text\n\n    $ cd hello-app\n    $ python -m venv .venv\n    $ . .venv/bin/activate\n    $ pip install .  # install your application\n    $ pip install gunicorn", "code_truncated": false}
{"chunk_id": "4a3db41fd1376fb8d2ec5837b8abd6d3d71f7b8d", "file_path": "d:\\499\\docs\\deploying\\gunicorn.rst", "symbol_type": "doc", "name": "Running", "qualname": "deploying\\gunicorn.rst#Running", "start_line": 40, "end_line": 72, "docstring": null, "code": "-------\n\nThe only required argument to Gunicorn tells it how to load your Flask\napplication. The syntax is ``{module_import}:{app_variable}``.\n``module_import`` is the dotted import name to the module with your\napplication. ``app_variable`` is the variable with the application. It\ncan also be a function call (with any arguments) if you're using the\napp factory pattern.\n\n.. code-block:: text\n\n    # equivalent to 'from hello import app'\n    $ gunicorn -w 4 'hello:app'\n\n    # equivalent to 'from hello import create_app; create_app()'\n    $ gunicorn -w 4 'hello:create_app()'\n\n    Starting gunicorn 20.1.0\n    Listening at: http://127.0.0.1:8000 (x)\n    Using worker: sync\n    Booting worker with pid: x\n    Booting worker with pid: x\n    Booting worker with pid: x\n    Booting worker with pid: x\n\nThe ``-w`` option specifies the number of processes to run; a starting\nvalue could be ``CPU * 2``. The default is only 1 worker, which is\nprobably not what you want for the default worker type.\n\nLogs for each request aren't shown by default, only worker info and\nerrors are shown. To show access logs on stdout, use the\n``--access-logfile=-`` option.", "code_truncated": false}
{"chunk_id": "0e472728a031721e3a5a171ab395736a95f0a506", "file_path": "d:\\499\\docs\\deploying\\gunicorn.rst", "symbol_type": "doc", "name": "Binding Externally", "qualname": "deploying\\gunicorn.rst#Binding Externally", "start_line": 75, "end_line": 94, "docstring": null, "code": "------------------\n\nGunicorn should not be run as root because it would cause your\napplication code to run as root, which is not secure. However, this\nmeans it will not be possible to bind to port 80 or 443. Instead, a\nreverse proxy such as :doc:`nginx` or :doc:`apache-httpd` should be used\nin front of Gunicorn.\n\nYou can bind to all external IPs on a non-privileged port using the\n``-b 0.0.0.0`` option. Don't do this when using a reverse proxy setup,\notherwise it will be possible to bypass the proxy.\n\n.. code-block:: text\n\n    $ gunicorn -w 4 -b 0.0.0.0 'hello:create_app()'\n    Listening at: http://0.0.0.0:8000 (x)\n\n``0.0.0.0`` is not a valid address to navigate to, you'd use a specific\nIP address in your browser.", "code_truncated": false}
{"chunk_id": "40d9a5c5a41afe66815266f41fdadb50e5899b7f", "file_path": "d:\\499\\docs\\deploying\\gunicorn.rst", "symbol_type": "doc", "name": "Async with gevent", "qualname": "deploying\\gunicorn.rst#Async with gevent", "start_line": 97, "end_line": 116, "docstring": null, "code": "-----------------\n\nThe default sync worker is appropriate for most use cases. If you need numerous,\nlong running, concurrent connections, Gunicorn provides an asynchronous worker\nusing `gevent`_. This is not the same as Python's ``async/await``, or the ASGI\nserver spec. See :doc:`/gevent` for more information about enabling it in your\napplication.\n\n.. _gevent: https://www.gevent.org/\n\nWhen using gevent, greenlet>=1.0 is required. When using PyPy, PyPy>=7.3.7 is\nrequired.\n\n.. code-block:: text\n\n    $ gunicorn -k gevent 'hello:create_app()'\n    Starting gunicorn 20.1.0\n    Listening at: http://127.0.0.1:8000 (x)\n    Using worker: gevent\n    Booting worker with pid: x", "code_truncated": false}
{"chunk_id": "9f19a3c878c97462f55f06b84f0de020c34890c4", "file_path": "d:\\499\\docs\\deploying\\index.rst", "symbol_type": "doc", "name": "Deploying to Production", "qualname": "deploying\\index.rst#Deploying to Production", "start_line": 2, "end_line": 15, "docstring": null, "code": "=======================\n\nAfter developing your application, you'll want to make it available\npublicly to other users. When you're developing locally, you're probably\nusing the built-in development server, debugger, and reloader. These\nshould not be used in production. Instead, you should use a dedicated\nWSGI server or hosting platform, some of which will be described here.\n\n\"Production\" means \"not development\", which applies whether you're\nserving your application publicly to millions of users or privately /\nlocally to a single user. **Do not use the development server when\ndeploying to production. It is intended for use only during local\ndevelopment. It is not designed to be particularly secure, stable, or\nefficient.**", "code_truncated": false}
{"chunk_id": "6fa43d34430e690d3e67659191ccf302d6b1cf83", "file_path": "d:\\499\\docs\\deploying\\index.rst", "symbol_type": "doc", "name": "Self-Hosted Options", "qualname": "deploying\\index.rst#Self-Hosted Options", "start_line": 18, "end_line": 55, "docstring": null, "code": "-------------------\n\nFlask is a WSGI *application*. A WSGI *server* is used to run the\napplication, converting incoming HTTP requests to the standard WSGI\nenviron, and converting outgoing WSGI responses to HTTP responses.\n\nThe primary goal of these docs is to familiarize you with the concepts\ninvolved in running a WSGI application using a production WSGI server\nand HTTP server. There are many WSGI servers and HTTP servers, with many\nconfiguration possibilities. The pages below discuss the most common\nservers, and show the basics of running each one. The next section\ndiscusses platforms that can manage this for you.\n\n.. toctree::\n    :maxdepth: 1\n\n    gunicorn\n    waitress\n    mod_wsgi\n    uwsgi\n    gevent\n    asgi\n\nWSGI servers have HTTP servers built-in. However, a dedicated HTTP\nserver may be safer, more efficient, or more capable. Putting an HTTP\nserver in front of the WSGI server is called a \"reverse proxy.\"\n\n.. toctree::\n    :maxdepth: 1\n\n    proxy_fix\n    nginx\n    apache-httpd\n\nThis list is not exhaustive, and you should evaluate these and other\nservers based on your application's needs. Different servers will have\ndifferent capabilities, configuration, and support.", "code_truncated": false}
{"chunk_id": "c3a73398d9e0ddebab835d00f33d11aa7c8b1121", "file_path": "d:\\499\\docs\\deploying\\index.rst", "symbol_type": "doc", "name": "Hosting Platforms", "qualname": "deploying\\index.rst#Hosting Platforms", "start_line": 58, "end_line": 78, "docstring": null, "code": "-----------------\n\nThere are many services available for hosting web applications without\nneeding to maintain your own server, networking, domain, etc. Some\nservices may have a free tier up to a certain time or bandwidth. Many of\nthese services use one of the WSGI servers described above, or a similar\ninterface. The links below are for some of the most common platforms,\nwhich have instructions for Flask, WSGI, or Python.\n\n- `PythonAnywhere <https://help.pythonanywhere.com/pages/Flask/>`_\n- `Google App Engine <https://cloud.google.com/appengine/docs/standard/python3/building-app>`_\n- `Google Cloud Run <https://cloud.google.com/run/docs/quickstarts/build-and-deploy/deploy-python-service>`_\n- `AWS Elastic Beanstalk <https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create-deploy-python-flask.html>`_\n- `Microsoft Azure <https://docs.microsoft.com/en-us/azure/app-service/quickstart-python>`_\n\nThis list is not exhaustive, and you should evaluate these and other\nservices based on your application's needs. Different services will have\ndifferent capabilities, configuration, pricing, and support.\n\nYou'll probably need to :doc:`proxy_fix` when using most hosting\nplatforms.", "code_truncated": false}
{"chunk_id": "b4701f6fd88bca61207cb683cf8461f1d4dd95c0", "file_path": "d:\\499\\docs\\deploying\\mod_wsgi.rst", "symbol_type": "doc", "name": "mod_wsgi", "qualname": "deploying\\mod_wsgi.rst#mod_wsgi", "start_line": 2, "end_line": 21, "docstring": null, "code": "========\n\n`mod_wsgi`_ is a WSGI server integrated with the `Apache httpd`_ server.\nThe modern `mod_wsgi-express`_ command makes it easy to configure and\nstart the server without needing to write Apache httpd configuration.\n\n*   Tightly integrated with Apache httpd.\n*   Supports Windows directly.\n*   Requires a compiler and the Apache development headers to install.\n*   Does not require a reverse proxy setup.\n\nThis page outlines the basics of running mod_wsgi-express, not the more\ncomplex installation and configuration with httpd. Be sure to read the\n`mod_wsgi-express`_, `mod_wsgi`_, and `Apache httpd`_ documentation to\nunderstand what features are available.\n\n.. _mod_wsgi-express: https://pypi.org/project/mod-wsgi/\n.. _mod_wsgi: https://modwsgi.readthedocs.io/\n.. _Apache httpd: https://httpd.apache.org/", "code_truncated": false}
{"chunk_id": "245e8290990deb855dce663a38bea0334b0acdd7", "file_path": "d:\\499\\docs\\deploying\\mod_wsgi.rst", "symbol_type": "doc", "name": "Installing", "qualname": "deploying\\mod_wsgi.rst#Installing", "start_line": 24, "end_line": 40, "docstring": null, "code": "----------\n\nInstalling mod_wsgi requires a compiler and the Apache server and\ndevelopment headers installed. You will get an error if they are not.\nHow to install them depends on the OS and package manager that you use.\n\nCreate a virtualenv, install your application, then install\n``mod_wsgi``.\n\n.. code-block:: text\n\n    $ cd hello-app\n    $ python -m venv .venv\n    $ . .venv/bin/activate\n    $ pip install .  # install your application\n    $ pip install mod_wsgi", "code_truncated": false}
{"chunk_id": "14e555849e748a78223340e1bc6ada4bd238c410", "file_path": "d:\\499\\docs\\deploying\\mod_wsgi.rst", "symbol_type": "doc", "name": "Running", "qualname": "deploying\\mod_wsgi.rst#Running", "start_line": 43, "end_line": 76, "docstring": null, "code": "-------\n\nThe only argument to ``mod_wsgi-express`` specifies a script containing\nyour Flask application, which must be called ``application``. You can\nwrite a small script to import your app with this name, or to create it\nif using the app factory pattern.\n\n.. code-block:: python\n    :caption: ``wsgi.py``\n\n    from hello import app\n\n    application = app\n\n.. code-block:: python\n    :caption: ``wsgi.py``\n\n    from hello import create_app\n\n    application = create_app()\n\nNow run the ``mod_wsgi-express start-server`` command.\n\n.. code-block:: text\n\n    $ mod_wsgi-express start-server wsgi.py --processes 4\n\nThe ``--processes`` option specifies the number of worker processes to\nrun; a starting value could be ``CPU * 2``.\n\nLogs for each request aren't show in the terminal. If an error occurs,\nits information is written to the error log file shown when starting the\nserver.", "code_truncated": false}
{"chunk_id": "1511f0de91279bc8cee770b6ed029c154a571424", "file_path": "d:\\499\\docs\\deploying\\mod_wsgi.rst", "symbol_type": "doc", "name": "Binding Externally", "qualname": "deploying\\mod_wsgi.rst#Binding Externally", "start_line": 79, "end_line": 94, "docstring": null, "code": "------------------\n\nUnlike the other WSGI servers in these docs, mod_wsgi can be run as\nroot to bind to privileged ports like 80 and 443. However, it must be\nconfigured to drop permissions to a different user and group for the\nworker processes.\n\nFor example, if you created a ``hello`` user and group, you should\ninstall your virtualenv and application as that user, then tell\nmod_wsgi to drop to that user after starting.\n\n.. code-block:: text\n\n    $ sudo /home/hello/.venv/bin/mod_wsgi-express start-server \\\n        /home/hello/wsgi.py \\\n        --user hello --group hello --port 80 --processes 4", "code_truncated": false}
{"chunk_id": "89d5935bc68be4f13c2664c0c0428bc73c3f32aa", "file_path": "d:\\499\\docs\\deploying\\nginx.rst", "symbol_type": "doc", "name": "nginx", "qualname": "deploying\\nginx.rst#nginx", "start_line": 2, "end_line": 17, "docstring": null, "code": "=====\n\n`nginx`_ is a fast, production level HTTP server. When serving your\napplication with one of the WSGI servers listed in :doc:`index`, it is\noften good or necessary to put a dedicated HTTP server in front of it.\nThis \"reverse proxy\" can handle incoming requests, TLS, and other\nsecurity and performance concerns better than the WSGI server.\n\nNginx can be installed using your system package manager, or a pre-built\nexecutable for Windows. Installing and running Nginx itself is outside\nthe scope of this doc. This page outlines the basics of configuring\nNginx to proxy your application. Be sure to read its documentation to\nunderstand what features are available.\n\n.. _nginx: https://nginx.org/", "code_truncated": false}
{"chunk_id": "23e128dc23552f08bf2942bc90e0f6a44706c966", "file_path": "d:\\499\\docs\\deploying\\nginx.rst", "symbol_type": "doc", "name": "Domain Name", "qualname": "deploying\\nginx.rst#Domain Name", "start_line": 20, "end_line": 39, "docstring": null, "code": "-----------\n\nAcquiring and configuring a domain name is outside the scope of this\ndoc. In general, you will buy a domain name from a registrar, pay for\nserver space with a hosting provider, and then point your registrar\nat the hosting provider's name servers.\n\nTo simulate this, you can also edit your ``hosts`` file, located at\n``/etc/hosts`` on Linux. Add a line that associates a name with the\nlocal IP.\n\nModern Linux systems may be configured to treat any domain name that\nends with ``.localhost`` like this without adding it to the ``hosts``\nfile.\n\n.. code-block:: python\n    :caption: ``/etc/hosts``\n\n    127.0.0.1 hello.localhost", "code_truncated": false}
{"chunk_id": "ecd0f4b6be2d8dfa352628ccd431454f17b38cc3", "file_path": "d:\\499\\docs\\deploying\\nginx.rst", "symbol_type": "doc", "name": "Configuration", "qualname": "deploying\\nginx.rst#Configuration", "start_line": 42, "end_line": 69, "docstring": null, "code": "-------------\n\nThe nginx configuration is located at ``/etc/nginx/nginx.conf`` on\nLinux. It may be different depending on your operating system. Check the\ndocs and look for ``nginx.conf``.\n\nRemove or comment out any existing ``server`` section. Add a ``server``\nsection and use the ``proxy_pass`` directive to point to the address the\nWSGI server is listening on. We'll assume the WSGI server is listening\nlocally at ``http://127.0.0.1:8000``.\n\n.. code-block:: nginx\n    :caption: ``/etc/nginx.conf``\n\n    server {\n        listen 80;\n        server_name _;\n\n        location / {\n            proxy_pass http://127.0.0.1:8000/;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n            proxy_set_header X-Forwarded-Host $host;\n            proxy_set_header X-Forwarded-Prefix /;\n        }\n    }\n\nThen :doc:`proxy_fix` so that your application uses these headers.", "code_truncated": false}
{"chunk_id": "049ca72f59b272668cf6851c340e924ed1ce9359", "file_path": "d:\\499\\docs\\deploying\\proxy_fix.rst", "symbol_type": "doc", "name": "Tell Flask it is Behind a Proxy", "qualname": "deploying\\proxy_fix.rst#Tell Flask it is Behind a Proxy", "start_line": 2, "end_line": 33, "docstring": null, "code": "===============================\n\nWhen using a reverse proxy, or many Python hosting platforms, the proxy\nwill intercept and forward all external requests to the local WSGI\nserver.\n\nFrom the WSGI server and Flask application's perspectives, requests are\nnow coming from the HTTP server to the local address, rather than from\nthe remote address to the external server address.\n\nHTTP servers should set ``X-Forwarded-`` headers to pass on the real\nvalues to the application. The application can then be told to trust and\nuse those values by wrapping it with the\n:doc:`werkzeug:middleware/proxy_fix` middleware provided by Werkzeug.\n\nThis middleware should only be used if the application is actually\nbehind a proxy, and should be configured with the number of proxies that\nare chained in front of it. Not all proxies set all the headers. Since\nincoming headers can be faked, you must set how many proxies are setting\neach header so the middleware knows what to trust.\n\n.. code-block:: python\n\n    from werkzeug.middleware.proxy_fix import ProxyFix\n\n    app.wsgi_app = ProxyFix(\n        app.wsgi_app, x_for=1, x_proto=1, x_host=1, x_prefix=1\n    )\n\nRemember, only apply this middleware if you are behind a proxy, and set\nthe correct number of proxies that set each header. It can be a security\nissue if you get this configuration wrong.", "code_truncated": false}
{"chunk_id": "559bc8bd303e03c81aa8f4288060261353699b0c", "file_path": "d:\\499\\docs\\deploying\\uwsgi.rst", "symbol_type": "doc", "name": "uWSGI", "qualname": "deploying\\uwsgi.rst#uWSGI", "start_line": 2, "end_line": 17, "docstring": null, "code": "=====\n\n`uWSGI`_ is a fast, compiled server suite with extensive configuration\nand capabilities beyond a basic server.\n\n*   It can be very performant due to being a compiled program.\n*   It is complex to configure beyond the basic application, and has so\n    many options that it can be difficult for beginners to understand.\n*   It does not support Windows (but does run on WSL).\n*   It requires a compiler to install in some cases.\n\nThis page outlines the basics of running uWSGI. Be sure to read its\ndocumentation to understand what features are available.\n\n.. _uWSGI: https://uwsgi-docs.readthedocs.io/en/latest/", "code_truncated": false}
{"chunk_id": "bff01c67e910b41594c30532b33be01658904cd6", "file_path": "d:\\499\\docs\\deploying\\uwsgi.rst", "symbol_type": "doc", "name": "Installing", "qualname": "deploying\\uwsgi.rst#Installing", "start_line": 20, "end_line": 47, "docstring": null, "code": "----------\n\nuWSGI has multiple ways to install it. The most straightforward is to\ninstall the ``pyuwsgi`` package, which provides precompiled wheels for\ncommon platforms. However, it does not provide SSL support, which can be\nprovided with a reverse proxy instead.\n\nCreate a virtualenv, install your application, then install ``pyuwsgi``.\n\n.. code-block:: text\n\n    $ cd hello-app\n    $ python -m venv .venv\n    $ . .venv/bin/activate\n    $ pip install .  # install your application\n    $ pip install pyuwsgi\n\nIf you have a compiler available, you can install the ``uwsgi`` package\ninstead. Or install the ``pyuwsgi`` package from sdist instead of wheel.\nEither method will include SSL support.\n\n.. code-block:: text\n\n    $ pip install uwsgi\n\n    # or\n    $ pip install --no-binary pyuwsgi pyuwsgi", "code_truncated": false}
{"chunk_id": "fc118b0a47428e438a9614f4ebd47fa3f327ea93", "file_path": "d:\\499\\docs\\deploying\\uwsgi.rst", "symbol_type": "doc", "name": "Running", "qualname": "deploying\\uwsgi.rst#Running", "start_line": 50, "end_line": 87, "docstring": null, "code": "-------\n\nThe most basic way to run uWSGI is to tell it to start an HTTP server\nand import your application.\n\n.. code-block:: text\n\n    $ uwsgi --http 127.0.0.1:8000 --master -p 4 -w hello:app\n\n    *** Starting uWSGI 2.0.20 (64bit) on [x] ***\n    *** Operational MODE: preforking ***\n    mounting hello:app on /\n    spawned uWSGI master process (pid: x)\n    spawned uWSGI worker 1 (pid: x, cores: 1)\n    spawned uWSGI worker 2 (pid: x, cores: 1)\n    spawned uWSGI worker 3 (pid: x, cores: 1)\n    spawned uWSGI worker 4 (pid: x, cores: 1)\n    spawned uWSGI http 1 (pid: x)\n\nIf you're using the app factory pattern, you'll need to create a small\nPython file to create the app, then point uWSGI at that.\n\n.. code-block:: python\n    :caption: ``wsgi.py``\n\n    from hello import create_app\n\n    app = create_app()\n\n.. code-block:: text\n\n    $ uwsgi --http 127.0.0.1:8000 --master -p 4 -w wsgi:app\n\nThe ``--http`` option starts an HTTP server at 127.0.0.1 port 8000. The\n``--master`` option specifies the standard worker manager. The ``-p``\noption starts 4 worker processes; a starting value could be ``CPU * 2``.\nThe ``-w`` option tells uWSGI how to import your application", "code_truncated": false}
{"chunk_id": "5cd73270ba3296f16a13c281f23286c159a5f29a", "file_path": "d:\\499\\docs\\deploying\\uwsgi.rst", "symbol_type": "doc", "name": "Binding Externally", "qualname": "deploying\\uwsgi.rst#Binding Externally", "start_line": 90, "end_line": 117, "docstring": null, "code": "------------------\n\nuWSGI should not be run as root with the configuration shown in this doc\nbecause it would cause your application code to run as root, which is\nnot secure. However, this means it will not be possible to bind to port\n80 or 443. Instead, a reverse proxy such as :doc:`nginx` or\n:doc:`apache-httpd` should be used in front of uWSGI. It is possible to\nrun uWSGI as root securely, but that is beyond the scope of this doc.\n\nuWSGI has optimized integration with `Nginx uWSGI`_ and\n`Apache mod_proxy_uwsgi`_, and possibly other servers, instead of using\na standard HTTP proxy. That configuration is beyond the scope of this\ndoc, see the links for more information.\n\n.. _Nginx uWSGI: https://uwsgi-docs.readthedocs.io/en/latest/Nginx.html\n.. _Apache mod_proxy_uwsgi: https://uwsgi-docs.readthedocs.io/en/latest/Apache.html#mod-proxy-uwsgi\n\nYou can bind to all external IPs on a non-privileged port using the\n``--http 0.0.0.0:8000`` option. Don't do this when using a reverse proxy\nsetup, otherwise it will be possible to bypass the proxy.\n\n.. code-block:: text\n\n    $ uwsgi --http 0.0.0.0:8000 --master -p 4 -w wsgi:app\n\n``0.0.0.0`` is not a valid address to navigate to, you'd use a specific\nIP address in your browser.", "code_truncated": false}
{"chunk_id": "b5c033bceb24b2da805e114b2d7d7e9a833b6199", "file_path": "d:\\499\\docs\\deploying\\uwsgi.rst", "symbol_type": "doc", "name": "Async with gevent", "qualname": "deploying\\uwsgi.rst#Async with gevent", "start_line": 120, "end_line": 143, "docstring": null, "code": "-----------------\n\nThe default sync worker is appropriate for most use cases. If you need numerous,\nlong running, concurrent connections, uWSGI provides an asynchronous worker\nusing `gevent`_. This is not the same as Python's ``async/await``, or the ASGI\nserver spec. See :doc:`/gevent` for more information about enabling it in your\napplication.\n\n.. _gevent: https://www.gevent.org/\n\nWhen using gevent, greenlet>=1.0 is required. When using PyPy, PyPy>=7.3.7 is\nrequired.\n\n.. code-block:: text\n\n    $ uwsgi --http 127.0.0.1:8000 --master --gevent 100 -w wsgi:app\n\n    *** Starting uWSGI 2.0.20 (64bit) on [x] ***\n    *** Operational MODE: async ***\n    mounting hello:app on /\n    spawned uWSGI master process (pid: x)\n    spawned uWSGI worker 1 (pid: x, cores: 100)\n    spawned uWSGI http 1 (pid: x)\n    *** running gevent loop engine [addr:x] ***", "code_truncated": false}
{"chunk_id": "48eb342d9af11969738614a34466dc4b5ed37996", "file_path": "d:\\499\\docs\\deploying\\waitress.rst", "symbol_type": "doc", "name": "Waitress", "qualname": "deploying\\waitress.rst#Waitress", "start_line": 2, "end_line": 19, "docstring": null, "code": "========\n\n`Waitress`_ is a pure Python WSGI server.\n\n*   It is easy to configure.\n*   It supports Windows directly.\n*   It is easy to install as it does not require additional dependencies\n    or compilation.\n*   It does not support streaming requests, full request data is always\n    buffered.\n*   It uses a single process with multiple thread workers.\n\nThis page outlines the basics of running Waitress. Be sure to read its\ndocumentation and ``waitress-serve --help`` to understand what features\nare available.\n\n.. _Waitress: https://docs.pylonsproject.org/projects/waitress/", "code_truncated": false}
{"chunk_id": "7da2e3a3365f9f352e7f1f4ba3b182446e41494d", "file_path": "d:\\499\\docs\\deploying\\waitress.rst", "symbol_type": "doc", "name": "Installing", "qualname": "deploying\\waitress.rst#Installing", "start_line": 22, "end_line": 34, "docstring": null, "code": "----------\n\nCreate a virtualenv, install your application, then install\n``waitress``.\n\n.. code-block:: text\n\n    $ cd hello-app\n    $ python -m venv .venv\n    $ . .venv/bin/activate\n    $ pip install .  # install your application\n    $ pip install waitress", "code_truncated": false}
{"chunk_id": "cfd02a5acc1fa932bdc6ec63b68102c1c53c2c6c", "file_path": "d:\\499\\docs\\deploying\\waitress.rst", "symbol_type": "doc", "name": "Running", "qualname": "deploying\\waitress.rst#Running", "start_line": 37, "end_line": 59, "docstring": null, "code": "-------\n\nThe only required argument to ``waitress-serve`` tells it how to load\nyour Flask application. The syntax is ``{module}:{app}``. ``module`` is\nthe dotted import name to the module with your application. ``app`` is\nthe variable with the application. If you're using the app factory\npattern, use ``--call {module}:{factory}`` instead.\n\n.. code-block:: text\n\n    # equivalent to 'from hello import app'\n    $ waitress-serve --host 127.0.0.1 hello:app\n\n    # equivalent to 'from hello import create_app; create_app()'\n    $ waitress-serve --host 127.0.0.1 --call hello:create_app\n\n    Serving on http://127.0.0.1:8080\n\nThe ``--host`` option binds the server to local ``127.0.0.1`` only.\n\nLogs for each request aren't shown, only errors are shown. Logging can\nbe configured through the Python interface instead of the command line.", "code_truncated": false}
{"chunk_id": "22253d495cd69061f0b7960027cd8157817921ea", "file_path": "d:\\499\\docs\\deploying\\waitress.rst", "symbol_type": "doc", "name": "Binding Externally", "qualname": "deploying\\waitress.rst#Binding Externally", "start_line": 62, "end_line": 75, "docstring": null, "code": "------------------\n\nWaitress should not be run as root because it would cause your\napplication code to run as root, which is not secure. However, this\nmeans it will not be possible to bind to port 80 or 443. Instead, a\nreverse proxy such as :doc:`nginx` or :doc:`apache-httpd` should be used\nin front of Waitress.\n\nYou can bind to all external IPs on a non-privileged port by not\nspecifying the ``--host`` option. Don't do this when using a reverse\nproxy setup, otherwise it will be possible to bypass the proxy.\n\n``0.0.0.0`` is not a valid address to navigate to, you'd use a specific\nIP address in your browser.", "code_truncated": false}
{"chunk_id": "3fc16794af35d29208e7410ab9955c7e49eec8d0", "file_path": "d:\\499\\docs\\design.rst", "symbol_type": "doc", "name": "Design Decisions in Flask", "qualname": "design.rst#Design Decisions in Flask", "start_line": 2, "end_line": 8, "docstring": null, "code": "=========================\n\nIf you are curious why Flask does certain things the way it does and not\ndifferently, this section is for you.  This should give you an idea about\nsome of the design decisions that may appear arbitrary and surprising at\nfirst, especially in direct comparison with other frameworks.", "code_truncated": false}
{"chunk_id": "588de0ab164834e13ae3f7c939015f4727dcb131", "file_path": "d:\\499\\docs\\design.rst", "symbol_type": "doc", "name": "The Explicit Application Object", "qualname": "design.rst#The Explicit Application Object", "start_line": 11, "end_line": 78, "docstring": null, "code": "-------------------------------\n\nA Python web application based on WSGI has to have one central callable\nobject that implements the actual application.  In Flask this is an\ninstance of the :class:`~flask.Flask` class.  Each Flask application has\nto create an instance of this class itself and pass it the name of the\nmodule, but why can't Flask do that itself?\n\nWithout such an explicit application object the following code::\n\n    from flask import Flask\n    app = Flask(__name__)\n\n    @app.route('/')\n    def index():\n        return 'Hello World!'\n\nWould look like this instead::\n\n    from hypothetical_flask import route\n\n    @route('/')\n    def index():\n        return 'Hello World!'\n\nThere are three major reasons for this.  The most important one is that\nimplicit application objects require that there may only be one instance at\nthe time.  There are ways to fake multiple applications with a single\napplication object, like maintaining a stack of applications, but this\ncauses some problems I won't outline here in detail.  Now the question is:\nwhen does a microframework need more than one application at the same\ntime?  A good example for this is unit testing.  When you want to test\nsomething it can be very helpful to create a minimal application to test\nspecific behavior.  When the application object is deleted everything it\nallocated will be freed again.\n\nAnother thing that becomes possible when you have an explicit object lying\naround in your code is that you can subclass the base class\n(:class:`~flask.Flask`) to alter specific behavior.  This would not be\npossible without hacks if the object were created ahead of time for you\nbased on a class that is not exposed to you.\n\nBut there is another very important reason why Flask depends on an\nexplicit instantiation of that class: the package name.  Whenever you\ncreate a Flask instance you usually pass it `__name__` as package name.\nFlask depends on that information to properly load resources relative\nto your module.  With Python's outstanding support for reflection it can\nthen access the package to figure out where the templates and static files\nare stored (see :meth:`~flask.Flask.open_resource`).  Now obviously there\nare frameworks around that do not need any configuration and will still be\nable to load templates relative to your application module.  But they have\nto use the current working directory for that, which is a very unreliable\nway to determine where the application is.  The current working directory\nis process-wide and if you are running multiple applications in one\nprocess (which could happen in a webserver without you knowing) the paths\nwill be off.  Worse: many webservers do not set the working directory to\nthe directory of your application but to the document root which does not\nhave to be the same folder.\n\nThe third reason is \"explicit is better than implicit\".  That object is\nyour WSGI application, you don't have to remember anything else.  If you\nwant to apply a WSGI middleware, just wrap it and you're done (though\nthere are better ways to do that so that you do not lose the reference\nto the application object :meth:`~flask.Flask.wsgi_app`).\n\nFurthermore this design makes it possible to use a factory function to\ncreate the application which is very helpful for unit testing and similar\nthings (:doc:`/patterns/appfactories`).", "code_truncated": false}
{"chunk_id": "397aca0f4015f342fc806d9e71ceeee94b790518", "file_path": "d:\\499\\docs\\design.rst", "symbol_type": "doc", "name": "The Routing System", "qualname": "design.rst#The Routing System", "start_line": 81, "end_line": 94, "docstring": null, "code": "------------------\n\nFlask uses the Werkzeug routing system which was designed to\nautomatically order routes by complexity.  This means that you can declare\nroutes in arbitrary order and they will still work as expected.  This is a\nrequirement if you want to properly implement decorator based routing\nsince decorators could be fired in undefined order when the application is\nsplit into multiple modules.\n\nAnother design decision with the Werkzeug routing system is that routes\nin Werkzeug try to ensure that URLs are unique.  Werkzeug will go quite far\nwith that in that it will automatically redirect to a canonical URL if a route\nis ambiguous.", "code_truncated": false}
{"chunk_id": "9fe7f246f4176762892a568e4eb8b269237d119f", "file_path": "d:\\499\\docs\\design.rst", "symbol_type": "doc", "name": "One Template Engine", "qualname": "design.rst#One Template Engine", "start_line": 97, "end_line": 131, "docstring": null, "code": "-------------------\n\nFlask decides on one template engine: Jinja.  Why doesn't Flask have a\npluggable template engine interface?  You can obviously use a different\ntemplate engine, but Flask will still configure Jinja for you.  While\nthat limitation that Jinja is *always* configured will probably go away,\nthe decision to bundle one template engine and use that will not.\n\nTemplate engines are like programming languages and each of those engines\nhas a certain understanding about how things work.  On the surface they\nall work the same: you tell the engine to evaluate a template with a set\nof variables and take the return value as string.\n\nBut that's about where similarities end. Jinja for example has an\nextensive filter system, a certain way to do template inheritance,\nsupport for reusable blocks (macros) that can be used from inside\ntemplates and also from Python code, supports iterative template\nrendering, configurable syntax and more. On the other hand an engine\nlike Genshi is based on XML stream evaluation, template inheritance by\ntaking the availability of XPath into account and more. Mako on the\nother hand treats templates similar to Python modules.\n\nWhen it comes to connecting a template engine with an application or\nframework there is more than just rendering templates.  For instance,\nFlask uses Jinja's extensive autoescaping support.  Also it provides\nways to access macros from Jinja templates.\n\nA template abstraction layer that would not take the unique features of\nthe template engines away is a science on its own and a too large\nundertaking for a microframework like Flask.\n\nFurthermore extensions can then easily depend on one template language\nbeing present.  You can easily use your own templating language, but an\nextension could still depend on Jinja itself.", "code_truncated": false}
{"chunk_id": "f381a7c86ffe595599be1fd59dd643c0df35982d", "file_path": "d:\\499\\docs\\design.rst", "symbol_type": "doc", "name": "What does \"micro\" mean?", "qualname": "design.rst#What does \"micro\" mean?", "start_line": 134, "end_line": 170, "docstring": null, "code": "-----------------------\n\nMicro does not mean that your whole web application has to fit into a single\nPython file (although it certainly can), nor does it mean that Flask is lacking\nin functionality. The \"micro\" in microframework means Flask aims to keep the\ncore simple but extensible. Flask won't make many decisions for you, such as\nwhat database to use. Those decisions that it does make, such as what\ntemplating engine to use, are easy to change.  Everything else is up to you, so\nthat Flask can be everything you need and nothing you don't.\n\nBy default, Flask does not include a database abstraction layer, form\nvalidation or anything else where different libraries already exist that can\nhandle that. Instead, Flask supports extensions to add such functionality to\nyour application as if it was implemented in Flask itself. Numerous extensions\nprovide database integration, form validation, upload handling, various open\nauthentication technologies, and more. Flask may be \"micro\", but it's ready for\nproduction use on a variety of needs.\n\nWhy does Flask call itself a microframework and yet it depends on two\nlibraries (namely Werkzeug and Jinja).  Why shouldn't it?  If we look\nover to the Ruby side of web development there we have a protocol very\nsimilar to WSGI.  Just that it's called Rack there, but besides that it\nlooks very much like a WSGI rendition for Ruby.  But nearly all\napplications in Ruby land do not work with Rack directly, but on top of a\nlibrary with the same name.  This Rack library has two equivalents in\nPython: WebOb (formerly Paste) and Werkzeug.  Paste is still around but\nfrom my understanding it's sort of deprecated in favour of WebOb.  The\ndevelopment of WebOb and Werkzeug started side by side with similar ideas\nin mind: be a good implementation of WSGI for other applications to take\nadvantage.\n\nFlask is a framework that takes advantage of the work already done by\nWerkzeug to properly interface WSGI (which can be a complex task at\ntimes).  Thanks to recent developments in the Python package\ninfrastructure, packages with dependencies are no longer an issue and\nthere are very few reasons against having libraries that depend on others.", "code_truncated": false}
{"chunk_id": "b43ac3f6c157ea171f5881d3563c8ef59655088c", "file_path": "d:\\499\\docs\\design.rst", "symbol_type": "doc", "name": "Context Locals", "qualname": "design.rst#Context Locals", "start_line": 173, "end_line": 186, "docstring": null, "code": "--------------\n\nFlask uses special context locals and proxies to provide access to the\ncurrent app and request data to any code running during a request, CLI command,\netc. Context locals are specific to the worker handling the activity, such as a\nthread, process, coroutine, or greenlet.\n\nThe context and proxies help solve two development issues: circular imports, and\npassing around global data. :data:`.current_app` can be used to access the\napplication object without needing to import the app object directly, avoiding\ncircular import issues. :data:`.request`, :data:`.session`, and :data:`.g` can\nbe imported to access the current data for the request, rather than needing to\npass them as arguments through every single function in your project.", "code_truncated": false}
{"chunk_id": "5a15fca0a9f5ebc8045161511b3edac905f90f49", "file_path": "d:\\499\\docs\\design.rst", "symbol_type": "doc", "name": "Async/await and ASGI support", "qualname": "design.rst#Async/await and ASGI support", "start_line": 189, "end_line": 205, "docstring": null, "code": "----------------------------\n\nFlask supports ``async`` coroutines for view functions by executing the\ncoroutine on a separate thread instead of using an event loop on the\nmain thread as an async-first (ASGI) framework would. This is necessary\nfor Flask to remain backwards compatible with extensions and code built\nbefore ``async`` was introduced into Python. This compromise introduces\na performance cost compared with the ASGI frameworks, due to the\noverhead of the threads.\n\nDue to how tied to WSGI Flask's code is, it's not clear if it's possible\nto make the ``Flask`` class support ASGI and WSGI at the same time. Work\nis currently being done in Werkzeug to work with ASGI, which may\neventually enable support in Flask as well.\n\nSee :doc:`/async-await` for more discussion.", "code_truncated": false}
{"chunk_id": "94c2427bde16839b0ed5e4c2139f9df3c96ff219", "file_path": "d:\\499\\docs\\design.rst", "symbol_type": "doc", "name": "What Flask is, What Flask is Not", "qualname": "design.rst#What Flask is, What Flask is Not", "start_line": 208, "end_line": 229, "docstring": null, "code": "--------------------------------\n\nFlask will never have a database layer.  It will not have a form library\nor anything else in that direction.  Flask itself just bridges to Werkzeug\nto implement a proper WSGI application and to Jinja to handle templating.\nIt also binds to a few common standard library packages such as logging.\nEverything else is up for extensions.\n\nWhy is this the case?  Because people have different preferences and\nrequirements and Flask could not meet those if it would force any of this\ninto the core.  The majority of web applications will need a template\nengine in some sort.  However not every application needs a SQL database.\n\nAs your codebase grows, you are free to make the design decisions appropriate\nfor your project.  Flask will continue to provide a very simple glue layer to\nthe best that Python has to offer.  You can implement advanced patterns in\nSQLAlchemy or another database tool, introduce non-relational data persistence\nas appropriate, and take advantage of framework-agnostic tools built for WSGI,\nthe Python web interface.\n\nThe idea of Flask is to build a good foundation for all applications.\nEverything else is up to you or extensions.", "code_truncated": false}
{"chunk_id": "9cd88f65edeb7f40e4d83398974810dbb4ae1e08", "file_path": "d:\\499\\docs\\errorhandling.rst", "symbol_type": "doc", "name": "Handling Application Errors", "qualname": "errorhandling.rst#Handling Application Errors", "start_line": 2, "end_line": 28, "docstring": null, "code": "===========================\n\nApplications fail, servers fail. Sooner or later you will see an exception\nin production. Even if your code is 100% correct, you will still see\nexceptions from time to time. Why? Because everything else involved will\nfail. Here are some situations where perfectly fine code can lead to server\nerrors:\n\n-   the client terminated the request early and the application was still\n    reading from the incoming data\n-   the database server was overloaded and could not handle the query\n-   a filesystem is full\n-   a harddrive crashed\n-   a backend server overloaded\n-   a programming error in a library you are using\n-   network connection of the server to another system failed\n\nAnd that's just a small sample of issues you could be facing. So how do we\ndeal with that sort of problem? By default if your application runs in\nproduction mode, and an exception is raised Flask will display a very simple\npage for you and log the exception to the :attr:`~flask.Flask.logger`.\n\nBut there is more you can do, and we will cover some better setups to deal\nwith errors including custom exceptions and 3rd party tools.\n\n\n.. _error-logging-tools:", "code_truncated": false}
{"chunk_id": "f3a1d95324acf3f8c956f719fed53fad3dfa2ff6", "file_path": "d:\\499\\docs\\errorhandling.rst", "symbol_type": "doc", "name": "Error Logging Tools", "qualname": "errorhandling.rst#Error Logging Tools", "start_line": 31, "end_line": 73, "docstring": null, "code": "-------------------\n\nSending error mails, even if just for critical ones, can become\noverwhelming if enough users are hitting the error and log files are\ntypically never looked at. This is why we recommend using `Sentry\n<https://sentry.io/>`_ for dealing with application errors. It's\navailable as a source-available project `on GitHub\n<https://github.com/getsentry/sentry>`_ and is also available as a `hosted version\n<https://sentry.io/signup/>`_ which you can try for free. Sentry\naggregates duplicate errors, captures the full stack trace and local\nvariables for debugging, and sends you mails based on new errors or\nfrequency thresholds.\n\nTo use Sentry you need to install the ``sentry-sdk`` client with extra\n``flask`` dependencies.\n\n.. code-block:: text\n\n    $ pip install sentry-sdk[flask]\n\nAnd then add this to your Flask app:\n\n.. code-block:: python\n\n    import sentry_sdk\n    from sentry_sdk.integrations.flask import FlaskIntegration\n\n    sentry_sdk.init('YOUR_DSN_HERE', integrations=[FlaskIntegration()])\n\nThe ``YOUR_DSN_HERE`` value needs to be replaced with the DSN value you\nget from your Sentry installation.\n\nAfter installation, failures leading to an Internal Server Error\nare automatically reported to Sentry and from there you can\nreceive error notifications.\n\nSee also:\n\n-   Sentry also supports catching errors from a worker queue\n    (RQ, Celery, etc.) in a similar fashion. See the `Python SDK docs\n    <https://docs.sentry.io/platforms/python/>`__ for more information.\n-   `Flask-specific documentation <https://docs.sentry.io/platforms/python/guides/flask/>`__", "code_truncated": false}
{"chunk_id": "41ba7337a058acf48ff7a18b79cbc4b39451c04f", "file_path": "d:\\499\\docs\\errorhandling.rst", "symbol_type": "doc", "name": "Error Handlers", "qualname": "errorhandling.rst#Error Handlers", "start_line": 76, "end_line": 95, "docstring": null, "code": "--------------\n\nWhen an error occurs in Flask, an appropriate `HTTP status code\n<https://developer.mozilla.org/en-US/docs/Web/HTTP/Status>`__ will be\nreturned. 400-499 indicate errors with the client's request data, or\nabout the data requested. 500-599 indicate errors with the server or\napplication itself.\n\nYou might want to show custom error pages to the user when an error occurs.\nThis can be done by registering error handlers.\n\nAn error handler is a function that returns a response when a type of error is\nraised, similar to how a view is a function that returns a response when a\nrequest URL is matched. It is passed the instance of the error being handled,\nwhich is most likely a :exc:`~werkzeug.exceptions.HTTPException`.\n\nThe status code of the response will not be set to the handler's code. Make\nsure to provide the appropriate HTTP status code when returning a response from\na handler.", "code_truncated": false}
{"chunk_id": "a7d0d6fa76db293c1ad10a21d8b6587985b439d3", "file_path": "d:\\499\\docs\\errorhandling.rst", "symbol_type": "doc", "name": "Registering", "qualname": "errorhandling.rst#Registering", "start_line": 98, "end_line": 137, "docstring": null, "code": "```````````\n\nRegister handlers by decorating a function with\n:meth:`~flask.Flask.errorhandler`. Or use\n:meth:`~flask.Flask.register_error_handler` to register the function later.\nRemember to set the error code when returning the response.\n\n.. code-block:: python\n\n    @app.errorhandler(werkzeug.exceptions.BadRequest)\n    def handle_bad_request(e):\n        return 'bad request!', 400\n\n    # or, without the decorator\n    app.register_error_handler(400, handle_bad_request)\n\n:exc:`werkzeug.exceptions.HTTPException` subclasses like\n:exc:`~werkzeug.exceptions.BadRequest` and their HTTP codes are interchangeable\nwhen registering handlers. (``BadRequest.code == 400``)\n\nNon-standard HTTP codes cannot be registered by code because they are not known\nby Werkzeug. Instead, define a subclass of\n:class:`~werkzeug.exceptions.HTTPException` with the appropriate code and\nregister and raise that exception class.\n\n.. code-block:: python\n\n    class InsufficientStorage(werkzeug.exceptions.HTTPException):\n        code = 507\n        description = 'Not enough storage space.'\n\n    app.register_error_handler(InsufficientStorage, handle_507)\n\n    raise InsufficientStorage()\n\nHandlers can be registered for any exception class, not just\n:exc:`~werkzeug.exceptions.HTTPException` subclasses or HTTP status\ncodes. Handlers can be registered for a specific class, or for all subclasses\nof a parent class.", "code_truncated": false}
{"chunk_id": "c858dd7f32dc0e3b6b2d3e4ee5c3e180d46f6920", "file_path": "d:\\499\\docs\\errorhandling.rst", "symbol_type": "doc", "name": "Handling", "qualname": "errorhandling.rst#Handling", "start_line": 140, "end_line": 174, "docstring": null, "code": "````````\n\nWhen building a Flask application you *will* run into exceptions. If some part\nof your code breaks while handling a request (and you have no error handlers\nregistered), a \"500 Internal Server Error\"\n(:exc:`~werkzeug.exceptions.InternalServerError`) will be returned by default.\nSimilarly, \"404 Not Found\"\n(:exc:`~werkzeug.exceptions.NotFound`) error will occur if a request is sent to an unregistered route.\nIf a route receives an unallowed request method, a \"405 Method Not Allowed\"\n(:exc:`~werkzeug.exceptions.MethodNotAllowed`) will be raised. These are all\nsubclasses of :class:`~werkzeug.exceptions.HTTPException` and are provided by\ndefault in Flask.\n\nFlask gives you the ability to raise any HTTP exception registered by\nWerkzeug. However, the default HTTP exceptions return simple exception\npages. You might want to show custom error pages to the user when an error occurs.\nThis can be done by registering error handlers.\n\nWhen Flask catches an exception while handling a request, it is first looked up by code.\nIf no handler is registered for the code, Flask looks up the error by its class hierarchy; the most specific handler is chosen.\nIf no handler is registered, :class:`~werkzeug.exceptions.HTTPException` subclasses show a\ngeneric message about their code, while other exceptions are converted to a\ngeneric \"500 Internal Server Error\".\n\nFor example, if an instance of :exc:`ConnectionRefusedError` is raised,\nand a handler is registered for :exc:`ConnectionError` and\n:exc:`ConnectionRefusedError`, the more specific :exc:`ConnectionRefusedError`\nhandler is called with the exception instance to generate the response.\n\nHandlers registered on the blueprint take precedence over those registered\nglobally on the application, assuming a blueprint is handling the request that\nraises the exception. However, the blueprint cannot handle 404 routing errors\nbecause the 404 occurs at the routing level before the blueprint can be\ndetermined.", "code_truncated": false}
{"chunk_id": "d81a7841d06f9c7263b71aa13dd67bd06476a92f", "file_path": "d:\\499\\docs\\errorhandling.rst", "symbol_type": "doc", "name": "Generic Exception Handlers", "qualname": "errorhandling.rst#Generic Exception Handlers", "start_line": 177, "end_line": 235, "docstring": null, "code": "``````````````````````````\n\nIt is possible to register error handlers for very generic base classes\nsuch as ``HTTPException`` or even ``Exception``. However, be aware that\nthese will catch more than you might expect.\n\nFor example, an error handler for ``HTTPException`` might be useful for turning\nthe default HTML errors pages into JSON. However, this\nhandler will trigger for things you don't cause directly, such as 404\nand 405 errors during routing. Be sure to craft your handler carefully\nso you don't lose information about the HTTP error.\n\n.. code-block:: python\n\n    from flask import json\n    from werkzeug.exceptions import HTTPException\n\n    @app.errorhandler(HTTPException)\n    def handle_exception(e):\n        \"\"\"Return JSON instead of HTML for HTTP errors.\"\"\"\n        # start with the correct headers and status code from the error\n        response = e.get_response()\n        # replace the body with JSON\n        response.data = json.dumps({\n            \"code\": e.code,\n            \"name\": e.name,\n            \"description\": e.description,\n        })\n        response.content_type = \"application/json\"\n        return response\n\nAn error handler for ``Exception`` might seem useful for changing how\nall errors, even unhandled ones, are presented to the user. However,\nthis is similar to doing ``except Exception:`` in Python, it will\ncapture *all* otherwise unhandled errors, including all HTTP status\ncodes.\n\nIn most cases it will be safer to register handlers for more\nspecific exceptions. Since ``HTTPException`` instances are valid WSGI\nresponses, you could also pass them through directly.\n\n.. code-block:: python\n\n    from werkzeug.exceptions import HTTPException\n\n    @app.errorhandler(Exception)\n    def handle_exception(e):\n        # pass through HTTP errors\n        if isinstance(e, HTTPException):\n            return e\n\n        # now you're handling non-HTTP exceptions only\n        return render_template(\"500_generic.html\", e=e), 500\n\nError handlers still respect the exception class hierarchy. If you\nregister handlers for both ``HTTPException`` and ``Exception``, the\n``Exception`` handler will not handle ``HTTPException`` subclasses\nbecause the ``HTTPException`` handler is more specific.", "code_truncated": false}
{"chunk_id": "e5ee69f66081dd9a463bc8a457cab1461a41f412", "file_path": "d:\\499\\docs\\errorhandling.rst", "symbol_type": "doc", "name": "Unhandled Exceptions", "qualname": "errorhandling.rst#Unhandled Exceptions", "start_line": 238, "end_line": 256, "docstring": null, "code": "````````````````````\n\nWhen there is no error handler registered for an exception, a 500\nInternal Server Error will be returned instead. See\n:meth:`flask.Flask.handle_exception` for information about this\nbehavior.\n\nIf there is an error handler registered for ``InternalServerError``,\nthis will be invoked. As of Flask 1.1.0, this error handler will always\nbe passed an instance of ``InternalServerError``, not the original\nunhandled error.\n\nThe original error is available as ``e.original_exception``.\n\nAn error handler for \"500 Internal Server Error\" will be passed uncaught\nexceptions in addition to explicit 500 errors. In debug mode, a handler\nfor \"500 Internal Server Error\" will not be used. Instead, the\ninteractive debugger will be shown.", "code_truncated": false}
{"chunk_id": "46d93f09dc7d2aef75d165b2f9fff849f61c7cb1", "file_path": "d:\\499\\docs\\errorhandling.rst", "symbol_type": "doc", "name": "Custom Error Pages", "qualname": "errorhandling.rst#Custom Error Pages", "start_line": 259, "end_line": 331, "docstring": null, "code": "------------------\n\nSometimes when building a Flask application, you might want to raise a\n:exc:`~werkzeug.exceptions.HTTPException` to signal to the user that\nsomething is wrong with the request. Fortunately, Flask comes with a handy\n:func:`~flask.abort` function that aborts a request with a HTTP error from\nwerkzeug as desired. It will also provide a plain black and white error page\nfor you with a basic description, but nothing fancy.\n\nDepending on the error code it is less or more likely for the user to\nactually see such an error.\n\nConsider the code below, we might have a user profile route, and if the user\nfails to pass a username we can raise a \"400 Bad Request\". If the user passes a\nusername and we can't find it, we raise a \"404 Not Found\".\n\n.. code-block:: python\n\n    from flask import abort, render_template, request\n\n    # a username needs to be supplied in the query args\n    # a successful request would be like /profile?username=jack\n    @app.route(\"/profile\")\n    def user_profile():\n        username = request.arg.get(\"username\")\n        # if a username isn't supplied in the request, return a 400 bad request\n        if username is None:\n            abort(400)\n\n        user = get_user(username=username)\n        # if a user can't be found by their username, return 404 not found\n        if user is None:\n            abort(404)\n\n        return render_template(\"profile.html\", user=user)\n\nHere is another example implementation for a \"404 Page Not Found\" exception:\n\n.. code-block:: python\n\n    from flask import render_template\n\n    @app.errorhandler(404)\n    def page_not_found(e):\n        # note that we set the 404 status explicitly\n        return render_template('404.html'), 404\n\nWhen using :doc:`/patterns/appfactories`:\n\n.. code-block:: python\n\n    from flask import Flask, render_template\n\n    def page_not_found(e):\n      return render_template('404.html'), 404\n\n    def create_app(config_filename):\n        app = Flask(__name__)\n        app.register_error_handler(404, page_not_found)\n        return app\n\nAn example template might be this:\n\n.. code-block:: html+jinja\n\n    {% extends \"layout.html\" %}\n    {% block title %}Page Not Found{% endblock %}\n    {% block body %}\n      <h1>Page Not Found</h1>\n      <p>What you were looking for is just not there.\n      <p><a href=\"{{ url_for('index') }}\">go somewhere nice</a>\n    {% endblock %}", "code_truncated": false}
{"chunk_id": "cf852e1ef3a0110d010936a35648f1e22ef52936", "file_path": "d:\\499\\docs\\errorhandling.rst", "symbol_type": "doc", "name": "Further Examples", "qualname": "errorhandling.rst#Further Examples", "start_line": 334, "end_line": 389, "docstring": null, "code": "````````````````\n\nThe above examples wouldn't actually be an improvement on the default\nexception pages. We can create a custom 500.html template like this:\n\n.. code-block:: html+jinja\n\n    {% extends \"layout.html\" %}\n    {% block title %}Internal Server Error{% endblock %}\n    {% block body %}\n      <h1>Internal Server Error</h1>\n      <p>Oops... we seem to have made a mistake, sorry!</p>\n      <p><a href=\"{{ url_for('index') }}\">Go somewhere nice instead</a>\n    {% endblock %}\n\nIt can be implemented by rendering the template on \"500 Internal Server Error\":\n\n.. code-block:: python\n\n    from flask import render_template\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        # note that we set the 500 status explicitly\n        return render_template('500.html'), 500\n\nWhen using :doc:`/patterns/appfactories`:\n\n.. code-block:: python\n\n    from flask import Flask, render_template\n\n    def internal_server_error(e):\n      return render_template('500.html'), 500\n\n    def create_app():\n        app = Flask(__name__)\n        app.register_error_handler(500, internal_server_error)\n        return app\n\nWhen using :doc:`/blueprints`:\n\n.. code-block:: python\n\n    from flask import Blueprint\n\n    blog = Blueprint('blog', __name__)\n\n    # as a decorator\n    @blog.errorhandler(500)\n    def internal_server_error(e):\n        return render_template('500.html'), 500\n\n    # or with register_error_handler\n    blog.register_error_handler(500, internal_server_error)", "code_truncated": false}
{"chunk_id": "94d7446568e8c60779dcda520cf8662cff306860", "file_path": "d:\\499\\docs\\errorhandling.rst", "symbol_type": "doc", "name": "Blueprint Error Handlers", "qualname": "errorhandling.rst#Blueprint Error Handlers", "start_line": 392, "end_line": 432, "docstring": null, "code": "------------------------\n\nIn :doc:`/blueprints`, most error handlers will work as expected.\nHowever, there is a caveat concerning handlers for 404 and 405\nexceptions. These error handlers are only invoked from an appropriate\n``raise`` statement or a call to ``abort`` in another of the blueprint's\nview functions; they are not invoked by, e.g., an invalid URL access.\n\nThis is because the blueprint does not \"own\" a certain URL space, so\nthe application instance has no way of knowing which blueprint error\nhandler it should run if given an invalid URL. If you would like to\nexecute different handling strategies for these errors based on URL\nprefixes, they may be defined at the application level using the\n``request`` proxy object.\n\n.. code-block:: python\n\n    from flask import jsonify, render_template\n\n    # at the application level\n    # not the blueprint level\n    @app.errorhandler(404)\n    def page_not_found(e):\n        # if a request is in our blog URL space\n        if request.path.startswith('/blog/'):\n            # we return a custom blog 404 page\n            return render_template(\"blog/404.html\"), 404\n        else:\n            # otherwise we return our generic site-wide 404 page\n            return render_template(\"404.html\"), 404\n\n    @app.errorhandler(405)\n    def method_not_allowed(e):\n        # if a request has the wrong method to our API\n        if request.path.startswith('/api/'):\n            # we return a json saying so\n            return jsonify(message=\"Method Not Allowed\"), 405\n        else:\n            # otherwise we return a generic site-wide 405 page\n            return render_template(\"405.html\"), 405", "code_truncated": false}
{"chunk_id": "8702048bc2762c717b5a7032bb6a43374a8cf951", "file_path": "d:\\499\\docs\\errorhandling.rst", "symbol_type": "doc", "name": "Returning API Errors as JSON", "qualname": "errorhandling.rst#Returning API Errors as JSON", "start_line": 435, "end_line": 510, "docstring": null, "code": "----------------------------\n\nWhen building APIs in Flask, some developers realise that the built-in\nexceptions are not expressive enough for APIs and that the content type of\n:mimetype:`text/html` they are emitting is not very useful for API consumers.\n\nUsing the same techniques as above and :func:`~flask.json.jsonify` we can return JSON\nresponses to API errors.  :func:`~flask.abort` is called\nwith a ``description`` parameter. The error handler will\nuse that as the JSON error message, and set the status code to 404.\n\n.. code-block:: python\n\n    from flask import abort, jsonify\n\n    @app.errorhandler(404)\n    def resource_not_found(e):\n        return jsonify(error=str(e)), 404\n\n    @app.route(\"/cheese\")\n    def get_one_cheese():\n        resource = get_resource()\n\n        if resource is None:\n            abort(404, description=\"Resource not found\")\n\n        return jsonify(resource)\n\nWe can also create custom exception classes. For instance, we can\nintroduce a new custom exception for an API that can take a proper human readable message,\na status code for the error and some optional payload to give more context\nfor the error.\n\nThis is a simple example:\n\n.. code-block:: python\n\n    from flask import jsonify, request\n\n    class InvalidAPIUsage(Exception):\n        status_code = 400\n\n        def __init__(self, message, status_code=None, payload=None):\n            super().__init__()\n            self.message = message\n            if status_code is not None:\n                self.status_code = status_code\n            self.payload = payload\n\n        def to_dict(self):\n            rv = dict(self.payload or ())\n            rv['message'] = self.message\n            return rv\n\n    @app.errorhandler(InvalidAPIUsage)\n    def invalid_api_usage(e):\n        return jsonify(e.to_dict()), e.status_code\n\n    # an API app route for getting user information\n    # a correct request might be /api/user?user_id=420\n    @app.route(\"/api/user\")\n    def user_api(user_id):\n        user_id = request.arg.get(\"user_id\")\n        if not user_id:\n            raise InvalidAPIUsage(\"No user id provided!\")\n\n        user = get_user(user_id=user_id)\n        if not user:\n            raise InvalidAPIUsage(\"No such user!\", status_code=404)\n\n        return jsonify(user.to_dict())\n\nA view can now raise that exception with an error message. Additionally\nsome extra payload can be provided as a dictionary through the `payload`\nparameter.", "code_truncated": false}
{"chunk_id": "aa79dca87602e663903d7ca775ea5cb8e37445fa", "file_path": "d:\\499\\docs\\errorhandling.rst", "symbol_type": "doc", "name": "Logging", "qualname": "errorhandling.rst#Logging", "start_line": 513, "end_line": 517, "docstring": null, "code": "-------\n\nSee :doc:`/logging` for information about how to log exceptions, such as\nby emailing them to admins.", "code_truncated": false}
{"chunk_id": "294647ac5c949d7e37eb8668fc4cee0dc758a9c5", "file_path": "d:\\499\\docs\\errorhandling.rst", "symbol_type": "doc", "name": "Debugging", "qualname": "errorhandling.rst#Debugging", "start_line": 520, "end_line": 523, "docstring": null, "code": "---------\n\nSee :doc:`/debugging` for information about how to debug errors in\ndevelopment and production.", "code_truncated": false}
{"chunk_id": "acbf8e0f421ab8d6eb97e7289d745bf1c98f3a34", "file_path": "d:\\499\\docs\\extensiondev.rst", "symbol_type": "doc", "name": "Flask Extension Development", "qualname": "extensiondev.rst#Flask Extension Development", "start_line": 2, "end_line": 23, "docstring": null, "code": "===========================\n\n.. currentmodule:: flask\n\nExtensions are extra packages that add functionality to a Flask\napplication. While `PyPI`_ contains many Flask extensions, you may not\nfind one that fits your need. If this is the case, you can create your\nown, and publish it for others to use as well.\n\nThis guide will show how to create a Flask extension, and some of the\ncommon patterns and requirements involved. Since extensions can do\nanything, this guide won't be able to cover every possibility.\n\nThe best ways to learn about extensions are to look at how other\nextensions you use are written, and discuss with others. Discuss your\ndesign ideas with others on our `Discord Chat`_ or\n`GitHub Discussions`_.\n\nThe best extensions share common patterns, so that anyone familiar with\nusing one extension won't feel completely lost with another. This can\nonly work if collaboration happens early.", "code_truncated": false}
{"chunk_id": "257993a06c3a4d454dfd31af7d0ee58bc6e4a38a", "file_path": "d:\\499\\docs\\extensiondev.rst", "symbol_type": "doc", "name": "Naming", "qualname": "extensiondev.rst#Naming", "start_line": 26, "end_line": 46, "docstring": null, "code": "------\n\nA Flask extension typically has ``flask`` in its name as a prefix or\nsuffix. If it wraps another library, it should include the library name\nas well. This makes it easy to search for extensions, and makes their\npurpose clearer.\n\nA general Python packaging recommendation is that the install name from\nthe package index and the name used in ``import`` statements should be\nrelated. The import name is lowercase, with words separated by\nunderscores (``_``). The install name is either lower case or title\ncase, with words separated by dashes (``-``). If it wraps another\nlibrary, prefer using the same case as that library's name.\n\nHere are some example install and import names:\n\n-   ``Flask-Name`` imported as ``flask_name``\n-   ``flask-name-lower`` imported as ``flask_name_lower``\n-   ``Flask-ComboName`` imported as ``flask_comboname``\n-   ``Name-Flask`` imported as ``name_flask``", "code_truncated": false}
{"chunk_id": "859662c4cdd8f99b1b529ffe1cd79408b0d09270", "file_path": "d:\\499\\docs\\extensiondev.rst", "symbol_type": "doc", "name": "The Extension Class and Initialization", "qualname": "extensiondev.rst#The Extension Class and Initialization", "start_line": 49, "end_line": 96, "docstring": null, "code": "--------------------------------------\n\nAll extensions will need some entry point that initializes the\nextension with the application. The most common pattern is to create a\nclass that represents the extension's configuration and behavior, with\nan ``init_app`` method to apply the extension instance to the given\napplication instance.\n\n.. code-block:: python\n\n    class HelloExtension:\n        def __init__(self, app=None):\n            if app is not None:\n                self.init_app(app)\n\n        def init_app(self, app):\n            app.before_request(...)\n\nIt is important that the app is not stored on the extension, don't do\n``self.app = app``. The only time the extension should have direct\naccess to an app is during ``init_app``, otherwise it should use\n:data:`.current_app`.\n\nThis allows the extension to support the application factory pattern,\navoids circular import issues when importing the extension instance\nelsewhere in a user's code, and makes testing with different\nconfigurations easier.\n\n.. code-block:: python\n\n    hello = HelloExtension()\n\n    def create_app():\n        app = Flask(__name__)\n        hello.init_app(app)\n        return app\n\nAbove, the ``hello`` extension instance exists independently of the\napplication. This means that other modules in a user's project can do\n``from project import hello`` and use the extension in blueprints before\nthe app exists.\n\nThe :attr:`Flask.extensions` dict can be used to store a reference to\nthe extension on the application, or some other state specific to the\napplication. Be aware that this is a single namespace, so use a name\nunique to your extension, such as the extension's name without the\n\"flask\" prefix.", "code_truncated": false}
{"chunk_id": "b58d94fd77f05e6ea0fba2cc71016f3c61695775", "file_path": "d:\\499\\docs\\extensiondev.rst", "symbol_type": "doc", "name": "Adding Behavior", "qualname": "extensiondev.rst#Adding Behavior", "start_line": 99, "end_line": 119, "docstring": null, "code": "---------------\n\nThere are many ways that an extension can add behavior. Any setup\nmethods that are available on the :class:`Flask` object can be used\nduring an extension's ``init_app`` method.\n\nA common pattern is to use :meth:`~Flask.before_request` to initialize\nsome data or a connection at the beginning of each request, then\n:meth:`~Flask.teardown_request` to clean it up at the end. This can be\nstored on :data:`.g`, discussed more below.\n\nA more lazy approach is to provide a method that initializes and caches\nthe data or connection. For example, a ``ext.get_db`` method could\ncreate a database connection the first time it's called, so that a view\nthat doesn't use the database doesn't create a connection.\n\nBesides doing something before and after every view, your extension\nmight want to add some specific views as well. In this case, you could\ndefine a :class:`Blueprint`, then call :meth:`~Flask.register_blueprint`\nduring ``init_app`` to add the blueprint to the app.", "code_truncated": false}
{"chunk_id": "113323d2e3b417f5300a31e9ac36181165ab28af", "file_path": "d:\\499\\docs\\extensiondev.rst", "symbol_type": "doc", "name": "Configuration Techniques", "qualname": "extensiondev.rst#Configuration Techniques", "start_line": 122, "end_line": 159, "docstring": null, "code": "------------------------\n\nThere can be multiple levels and sources of configuration for an\nextension. You should consider what parts of your extension fall into\neach one.\n\n-   Configuration per application instance, through ``app.config``\n    values. This is configuration that could reasonably change for each\n    deployment of an application. A common example is a URL to an\n    external resource, such as a database. Configuration keys should\n    start with the extension's name so that they don't interfere with\n    other extensions.\n-   Configuration per extension instance, through ``__init__``\n    arguments. This configuration usually affects how the extension\n    is used, such that it wouldn't make sense to change it per\n    deployment.\n-   Configuration per extension instance, through instance attributes\n    and decorator methods. It might be more ergonomic to assign to\n    ``ext.value``, or use a ``@ext.register`` decorator to register a\n    function, after the extension instance has been created.\n-   Global configuration through class attributes. Changing a class\n    attribute like ``Ext.connection_class`` can customize default\n    behavior without making a subclass. This could be combined\n    per-extension configuration to override defaults.\n-   Subclassing and overriding methods and attributes. Making the API of\n    the extension itself something that can be overridden provides a\n    very powerful tool for advanced customization.\n\nThe :class:`~flask.Flask` object itself uses all of these techniques.\n\nIt's up to you to decide what configuration is appropriate for your\nextension, based on what you need and what you want to support.\n\nConfiguration should not be changed after the application setup phase is\ncomplete and the server begins handling requests. Configuration is\nglobal, any changes to it are not guaranteed to be visible to other\nworkers.", "code_truncated": false}
{"chunk_id": "c8b517ab2213737b64ebd12e45d88e30c937bf3e", "file_path": "d:\\499\\docs\\extensiondev.rst", "symbol_type": "doc", "name": "Data During a Request", "qualname": "extensiondev.rst#Data During a Request", "start_line": 162, "end_line": 188, "docstring": null, "code": "---------------------\n\nWhen writing a Flask application, the :data:`~flask.g` object is used to\nstore information during a request. For example the\n:doc:`tutorial <tutorial/database>` stores a connection to a SQLite\ndatabase as ``g.db``. Extensions can also use this, with some care.\nSince ``g`` is a single global namespace, extensions must use unique\nnames that won't collide with user data. For example, use the extension\nname as a prefix, or as a namespace.\n\n.. code-block:: python\n\n    # an internal prefix with the extension name\n    g._hello_user_id = 2\n\n    # or an internal prefix as a namespace\n    from types import SimpleNamespace\n    g._hello = SimpleNamespace()\n    g._hello.user_id = 2\n\nThe data in ``g`` lasts for an application context. An application context is\nactive during a request, CLI command, or ``with app.app_context()`` block. If\nyou're storing something that should be closed, use\n:meth:`~flask.Flask.teardown_appcontext` to ensure that it gets closed when the\napp context ends. If it should only be valid during a request, or would not be\nused in the CLI outside a request, use :meth:`~flask.Flask.teardown_request`.", "code_truncated": false}
{"chunk_id": "d1d0d16b06b44c18859b720f0230c24c31058be7", "file_path": "d:\\499\\docs\\extensiondev.rst", "symbol_type": "doc", "name": "Views and Models", "qualname": "extensiondev.rst#Views and Models", "start_line": 191, "end_line": 250, "docstring": null, "code": "----------------\n\nYour extension views might want to interact with specific models in your\ndatabase, or some other extension or data connected to your application.\nFor example, let's consider a ``Flask-SimpleBlog`` extension that works\nwith Flask-SQLAlchemy to provide a ``Post`` model and views to write\nand read posts.\n\nThe ``Post`` model needs to subclass the Flask-SQLAlchemy ``db.Model``\nobject, but that's only available once you've created an instance of\nthat extension, not when your extension is defining its views. So how\ncan the view code, defined before the model exists, access the model?\n\nOne method could be to use :doc:`views`. During ``__init__``, create\nthe model, then create the views by passing the model to the view\nclass's :meth:`~views.View.as_view` method.\n\n.. code-block:: python\n\n    class PostAPI(MethodView):\n        def __init__(self, model):\n            self.model = model\n\n        def get(self, id):\n            post = self.model.query.get(id)\n            return jsonify(post.to_json())\n\n    class BlogExtension:\n        def __init__(self, db):\n            class Post(db.Model):\n                id = db.Column(primary_key=True)\n                title = db.Column(db.String, nullable=False)\n\n            self.post_model = Post\n\n        def init_app(self, app):\n            api_view = PostAPI.as_view(model=self.post_model)\n\n    db = SQLAlchemy()\n    blog = BlogExtension(db)\n    db.init_app(app)\n    blog.init_app(app)\n\nAnother technique could be to use an attribute on the extension, such as\n``self.post_model`` from above. Add the extension to ``app.extensions``\nin ``init_app``, then access\n``current_app.extensions[\"simple_blog\"].post_model`` from views.\n\nYou may also want to provide base classes so that users can provide\ntheir own ``Post`` model that conforms to the API your extension\nexpects. So they could implement ``class Post(blog.BasePost)``, then\nset it as ``blog.post_model``.\n\nAs you can see, this can get a bit complex. Unfortunately, there's no\nperfect solution here, only different strategies and tradeoffs depending\non your needs and how much customization you want to offer. Luckily,\nthis sort of resource dependency is not a common need for most\nextensions. Remember, if you need help with design, ask on our\n`Discord Chat`_ or `GitHub Discussions`_.", "code_truncated": false}
{"chunk_id": "fc7a7779ae77dd518fa31894e112112141432c41", "file_path": "d:\\499\\docs\\extensiondev.rst", "symbol_type": "doc", "name": "Recommended Extension Guidelines", "qualname": "extensiondev.rst#Recommended Extension Guidelines", "start_line": 253, "end_line": 305, "docstring": null, "code": "--------------------------------\n\nFlask previously had the concept of \"approved extensions\", where the\nFlask maintainers evaluated the quality, support, and compatibility of\nthe extensions before listing them. While the list became too difficult\nto maintain over time, the guidelines are still relevant to all\nextensions maintained and developed today, as they help the Flask\necosystem remain consistent and compatible.\n\n1.  An extension requires a maintainer. In the event an extension author\n    would like to move beyond the project, the project should find a new\n    maintainer and transfer access to the repository, documentation,\n    PyPI, and any other services. The `Pallets-Eco`_ organization on\n    GitHub allows for community maintenance with oversight from the\n    Pallets maintainers.\n2.  The naming scheme is *Flask-ExtensionName* or *ExtensionName-Flask*.\n    It must provide exactly one package or module named\n    ``flask_extension_name``.\n3.  The extension must use an open source license. The Python web\n    ecosystem tends to prefer BSD or MIT. It must be open source and\n    publicly available.\n4.  The extension's API must have the following characteristics:\n\n    -   It must support multiple applications running in the same Python\n        process. Use ``current_app`` instead of ``self.app``, store\n        configuration and state per application instance.\n    -   It must be possible to use the factory pattern for creating\n        applications. Use the ``ext.init_app()`` pattern.\n\n5.  From a clone of the repository, an extension with its dependencies\n    must be installable in editable mode with ``pip install -e .``.\n6.  It must ship tests that can be invoked with a common tool like\n    ``tox -e py``, ``nox -s test`` or ``pytest``. If not using ``tox``,\n    the test dependencies should be specified in a requirements file.\n    The tests must be part of the sdist distribution.\n7.  A link to the documentation or project website must be in the PyPI\n    metadata or the readme. The documentation should use the Flask theme\n    from the `Official Pallets Themes`_.\n8.  The extension's dependencies should not use upper bounds or assume\n    any particular version scheme, but should use lower bounds to\n    indicate minimum compatibility support. For example,\n    ``sqlalchemy>=1.4``.\n9.  Indicate the versions of Python supported using ``python_requires=\">=version\"``.\n    Flask and Pallets policy is to support all Python versions that are not\n    within six months of end of life (EOL). See Python's `EOL calendar`_ for\n    timing.\n\n.. _PyPI: https://pypi.org/search/?c=Framework+%3A%3A+Flask\n.. _Discord Chat: https://discord.gg/pallets\n.. _GitHub Discussions: https://github.com/pallets/flask/discussions\n.. _Official Pallets Themes: https://pypi.org/project/Pallets-Sphinx-Themes/\n.. _Pallets-Eco: https://github.com/pallets-eco\n.. _EOL calendar: https://devguide.python.org/versions/", "code_truncated": false}
{"chunk_id": "55eb2960f49627e41e555a99c4abda69bbc5c952", "file_path": "d:\\499\\docs\\extensions.rst", "symbol_type": "doc", "name": "Extensions", "qualname": "extensions.rst#Extensions", "start_line": 2, "end_line": 8, "docstring": null, "code": "==========\n\nExtensions are extra packages that add functionality to a Flask\napplication. For example, an extension might add support for sending\nemail or connecting to a database. Some extensions add entire new\nframeworks to help build certain types of applications, like a REST API.", "code_truncated": false}
{"chunk_id": "e6dc11aaecde9953053fb9e5ee4306d1d334519c", "file_path": "d:\\499\\docs\\extensions.rst", "symbol_type": "doc", "name": "Finding Extensions", "qualname": "extensions.rst#Finding Extensions", "start_line": 11, "end_line": 15, "docstring": null, "code": "------------------\n\nFlask extensions are usually named \"Flask-Foo\" or \"Foo-Flask\". You can\nsearch PyPI for packages tagged with `Framework :: Flask <pypi_>`_.", "code_truncated": false}
{"chunk_id": "fb5a75c02eb2abf68d21ce7fb7f71f7fb574f6fc", "file_path": "d:\\499\\docs\\extensions.rst", "symbol_type": "doc", "name": "Using Extensions", "qualname": "extensions.rst#Using Extensions", "start_line": 18, "end_line": 37, "docstring": null, "code": "----------------\n\nConsult each extension's documentation for installation, configuration,\nand usage instructions. Generally, extensions pull their own\nconfiguration from :attr:`app.config <flask.Flask.config>` and are\npassed an application instance during initialization. For example,\nan extension called \"Flask-Foo\" might be used like this::\n\n    from flask_foo import Foo\n\n    foo = Foo()\n\n    app = Flask(__name__)\n    app.config.update(\n        FOO_BAR='baz',\n        FOO_SPAM='eggs',\n    )\n\n    foo.init_app(app)", "code_truncated": false}
{"chunk_id": "a04c0a04bc1ac6e10978cf3766ff077fe76a44c8", "file_path": "d:\\499\\docs\\extensions.rst", "symbol_type": "doc", "name": "Building Extensions", "qualname": "extensions.rst#Building Extensions", "start_line": 40, "end_line": 48, "docstring": null, "code": "-------------------\n\nWhile `PyPI <pypi_>`_ contains many Flask extensions, you may not find\nan extension that fits your need. If this is the case, you can create\nyour own, and publish it for others to use as well. Read\n:doc:`extensiondev` to develop your own Flask extension.\n\n\n.. _pypi: https://pypi.org/search/?c=Framework+%3A%3A+Flask", "code_truncated": false}
{"chunk_id": "f46211c4e8bc19b3e2f696667dca6611056d8a30", "file_path": "d:\\499\\docs\\gevent.rst", "symbol_type": "doc", "name": "Async with Gevent", "qualname": "gevent.rst#Async with Gevent", "start_line": 2, "end_line": 20, "docstring": null, "code": "=================\n\n`Gevent`_ patches Python's standard library to run within special async workers\ncalled `greenlets`_. Gevent has existed since long before Python's native\nasyncio was available, and Flask has always worked with it.\n\n.. _gevent: https://www.gevent.org\n.. _greenlets: https://greenlet.readthedocs.io\n\nGevent is a reliable way to handle numerous, long lived, concurrent connections,\nand to achieve similar capabilities to ASGI and asyncio. This works without\nneeding to write ``async def`` or ``await`` anywhere, but relies on gevent and\ngreenlet's low level manipulation of the Python interpreter.\n\nDeciding whether you should use gevent with Flask, or `Quart`_, or something\nelse, is ultimately up to understanding the specific needs of your project.\n\n.. _quart: https://quart.palletsprojects.com", "code_truncated": false}
{"chunk_id": "90aee9e5e00cf4374efc596f49a351a4aa684b9f", "file_path": "d:\\499\\docs\\gevent.rst", "symbol_type": "doc", "name": "Enabling gevent", "qualname": "gevent.rst#Enabling gevent", "start_line": 23, "end_line": 62, "docstring": null, "code": "---------------\n\nYou need to apply gevent's patching as early as possible in your code. This\nenables gevent's underlying event loop and converts many Python internals to run\ninside it. Add the following at the top of your project's module or top\n``__init__.py``:\n\n.. code-block:: python\n\n    import gevent.monkey\n    gevent.monkey.patch_all()\n\nWhen deploying in production, use :doc:`/deploying/gunicorn` or\n:doc:`/deploying/uwsgi` with a gevent worker, as described on those pages.\n\nTo run concurrent tasks within your own code, such as views, use\n|gevent.spawn|_:\n\n.. |gevent.spawn| replace:: ``gevent.spawn()``\n.. _gevent.spawn: https://www.gevent.org/api/gevent.html#gevent.spawn\n\n.. code-block:: python\n\n    @app.post(\"/send\")\n    def send_email():\n        gevent.spawn(email.send, to=\"example@example.example\", text=\"example\")\n        return \"Email is being sent.\"\n\nIf you need to access :data:`request` or other Flask context globals within the\nspawned function, decorate the function with :func:`.stream_with_context` or\n:func:`.copy_current_request_context`. Prefer passing the exact data you need\nwhen spawning the function, rather than using the decorators.\n\n.. note::\n\n    When using gevent, greenlet>=1.0 is required. When using PyPy, PyPy>=7.3.7\n    is required.\n\n\n.. _gevent-asyncio:", "code_truncated": false}
{"chunk_id": "8af2ad148a652cdef480f4ff2f16dad7de13e5d0", "file_path": "d:\\499\\docs\\gevent.rst", "symbol_type": "doc", "name": "Combining with ``async``/``await``", "qualname": "gevent.rst#Combining with ``async``/``await``", "start_line": 65, "end_line": 101, "docstring": null, "code": "----------------------------------\n\nGevent's patching does not interact well with Flask's built-in asyncio support.\nIf you want to use Gevent and asyncio in the same app, you'll need to override\n:meth:`flask.Flask.async_to_sync` to run async functions inside gevent.\n\n.. code-block:: python\n\n    import gevent.monkey\n    gevent.monkey.patch_all()\n\n    import asyncio\n    from flask import Flask, request\n\n    loop = asyncio.EventLoop()\n    gevent.spawn(loop.run_forever)\n\n    class GeventFlask(Flask):\n        def async_to_sync(self, func):\n            def run(*args, **kwargs):\n                coro = func(*args, **kwargs)\n                future = asyncio.run_coroutine_threadsafe(coro, loop)\n                return future.result()\n\n            return run\n\n    app = GeventFlask(__name__)\n\n    @app.get(\"/\")\n    async def greet():\n        await asyncio.sleep(1)\n        return f\"Hello, {request.args.get(\"name\", \"World\")}!\"\n\nThis starts an asyncio event loop in a gevent worker. Async functions are\nscheduled on that event loop. This may still have limitations, and may need to\nbe modified further when using other asyncio implementations.", "code_truncated": false}
{"chunk_id": "a83416ac9be82fd9738ede757c34b8c267bdfea1", "file_path": "d:\\499\\docs\\gevent.rst", "symbol_type": "doc", "name": "libuv", "qualname": "gevent.rst#libuv", "start_line": 104, "end_line": 125, "docstring": null, "code": "~~~~~\n\n`libuv`_ is another event loop implementation that `gevent supports`_. There's\nalso a project called `uvloop`_ that enables libuv in asyncio. If you want to\nuse libuv, use gevent's support, not uvloop. It may be possible to further\nmodify the ``async_to_sync`` code from the previous section to work with uvloop,\nbut that's not currently known.\n\n.. _libuv: https://libuv.org/\n.. _gevent supports: https://www.gevent.org/loop_impls.html\n.. _uvloop: https://uvloop.readthedocs.io/\n\nTo enable gevent's libuv support, add the following at the *very* top of your\ncode, before ``gevent.monkey.patch_all()``:\n\n.. code-block:: python\n\n    import gevent\n    gevent.config.loop = \"libuv\"\n\n    import gevent.monkey\n    gevent.monkey.patch_all()", "code_truncated": false}
{"chunk_id": "a8c3a90a0fae061d7c9bbef35ef07580c6e02303", "file_path": "d:\\499\\docs\\index.rst", "symbol_type": "doc", "name": "INTRO", "qualname": "index.rst#INTRO", "start_line": 1, "end_line": 1, "docstring": null, "code": ".. rst-class:: hide-header", "code_truncated": false}
{"chunk_id": "5c61764df1218c3aa441416b0c8c6f78df40f6f8", "file_path": "d:\\499\\docs\\index.rst", "symbol_type": "doc", "name": "Welcome to Flask", "qualname": "index.rst#Welcome to Flask", "start_line": 4, "end_line": 29, "docstring": null, "code": "================\n\n.. image:: _static/flask-name.svg\n    :align: center\n    :height: 200px\n\nWelcome to Flask's documentation. Flask is a lightweight WSGI web application framework.\nIt is designed to make getting started quick and easy, with the ability to scale up to\ncomplex applications.\n\nGet started with :doc:`installation`\nand then get an overview with the :doc:`quickstart`. There is also a\nmore detailed :doc:`tutorial/index` that shows how to create a small but\ncomplete application with Flask. Common patterns are described in the\n:doc:`patterns/index` section. The rest of the docs describe each\ncomponent of Flask in detail, with a full reference in the :doc:`api`\nsection.\n\nFlask depends on the `Werkzeug`_ WSGI toolkit, the `Jinja`_ template engine, and the\n`Click`_ CLI toolkit. Be sure to check their documentation as well as Flask's when\nlooking for information.\n\n.. _Werkzeug: https://werkzeug.palletsprojects.com\n.. _Jinja: https://jinja.palletsprojects.com\n.. _Click: https://click.palletsprojects.com", "code_truncated": false}
{"chunk_id": "c67b758985d61521f829647d38dcd07128b1294b", "file_path": "d:\\499\\docs\\index.rst", "symbol_type": "doc", "name": "User's Guide", "qualname": "index.rst#User's Guide", "start_line": 32, "end_line": 65, "docstring": null, "code": "------------\n\nFlask provides configuration and conventions, with sensible defaults, to get started.\nThis section of the documentation explains the different parts of the Flask framework\nand how they can be used, customized, and extended. Beyond Flask itself, look for\ncommunity-maintained extensions to add even more functionality.\n\n.. toctree::\n   :maxdepth: 2\n\n   installation\n   quickstart\n   tutorial/index\n   templating\n   testing\n   errorhandling\n   debugging\n   logging\n   config\n   signals\n   views\n   lifecycle\n   appcontext\n   blueprints\n   extensions\n   cli\n   server\n   shell\n   patterns/index\n   web-security\n   deploying/index\n   gevent\n   async-await", "code_truncated": false}
{"chunk_id": "eba93508f31947af3f31085abf4841c4f74ecedc", "file_path": "d:\\499\\docs\\index.rst", "symbol_type": "doc", "name": "API Reference", "qualname": "index.rst#API Reference", "start_line": 68, "end_line": 77, "docstring": null, "code": "-------------\n\nIf you are looking for information on a specific function, class or\nmethod, this part of the documentation is for you.\n\n.. toctree::\n   :maxdepth: 2\n\n   api", "code_truncated": false}
{"chunk_id": "195817214d37863272a2e31265a267aaf12512d8", "file_path": "d:\\499\\docs\\index.rst", "symbol_type": "doc", "name": "Additional Notes", "qualname": "index.rst#Additional Notes", "start_line": 80, "end_line": 89, "docstring": null, "code": "----------------\n\n.. toctree::\n   :maxdepth: 2\n\n   design\n   extensiondev\n   contributing\n   license\n   changes", "code_truncated": false}
{"chunk_id": "21d5a52b507e0b46f73ec8b3675724fdd909fca5", "file_path": "d:\\499\\docs\\installation.rst", "symbol_type": "doc", "name": "Installation", "qualname": "installation.rst#Installation", "start_line": 2, "end_line": 3, "docstring": null, "code": "============", "code_truncated": false}
{"chunk_id": "c916bf2a90d304338adda05defe498d0e1b9b21b", "file_path": "d:\\499\\docs\\installation.rst", "symbol_type": "doc", "name": "Python Version", "qualname": "installation.rst#Python Version", "start_line": 6, "end_line": 9, "docstring": null, "code": "--------------\n\nWe recommend using the latest version of Python. Flask supports Python 3.10 and newer.", "code_truncated": false}
{"chunk_id": "baa43f83a648d830e935b5d02b8c0fe11e43fb09", "file_path": "d:\\499\\docs\\installation.rst", "symbol_type": "doc", "name": "Dependencies", "qualname": "installation.rst#Dependencies", "start_line": 12, "end_line": 34, "docstring": null, "code": "------------\n\nThese distributions will be installed automatically when installing Flask.\n\n* `Werkzeug`_ implements WSGI, the standard Python interface between\n  applications and servers.\n* `Jinja`_ is a template language that renders the pages your application\n  serves.\n* `MarkupSafe`_ comes with Jinja. It escapes untrusted input when rendering\n  templates to avoid injection attacks.\n* `ItsDangerous`_ securely signs data to ensure its integrity. This is used\n  to protect Flask's session cookie.\n* `Click`_ is a framework for writing command line applications. It provides\n  the ``flask`` command and allows adding custom management commands.\n* `Blinker`_ provides support for :doc:`signals`.\n\n.. _Werkzeug: https://palletsprojects.com/p/werkzeug/\n.. _Jinja: https://palletsprojects.com/p/jinja/\n.. _MarkupSafe: https://palletsprojects.com/p/markupsafe/\n.. _ItsDangerous: https://palletsprojects.com/p/itsdangerous/\n.. _Click: https://palletsprojects.com/p/click/\n.. _Blinker: https://blinker.readthedocs.io/", "code_truncated": false}
{"chunk_id": "f753690a4865b7db23cc07cf4b9114ce860c349d", "file_path": "d:\\499\\docs\\installation.rst", "symbol_type": "doc", "name": "Optional dependencies", "qualname": "installation.rst#Optional dependencies", "start_line": 37, "end_line": 49, "docstring": null, "code": "~~~~~~~~~~~~~~~~~~~~~\n\nThese distributions will not be installed automatically. Flask will detect and\nuse them if you install them.\n\n* `python-dotenv`_ enables support for :ref:`dotenv` when running ``flask``\n  commands.\n* `Watchdog`_ provides a faster, more efficient reloader for the development\n  server.\n\n.. _python-dotenv: https://github.com/theskumar/python-dotenv#readme\n.. _watchdog: https://pythonhosted.org/watchdog/", "code_truncated": false}
{"chunk_id": "163b6047c12f0aaac2a47e4111c7f6256c219d22", "file_path": "d:\\499\\docs\\installation.rst", "symbol_type": "doc", "name": "greenlet", "qualname": "installation.rst#greenlet", "start_line": 52, "end_line": 60, "docstring": null, "code": "~~~~~~~~\n\nYou may choose to use :doc:`/gevent` with your application. In this case,\ngreenlet>=1.0 is required. When using PyPy, PyPy>=7.3.7 is required.\n\nThese are not minimum supported versions, they only indicate the first\nversions that added necessary features. You should use the latest\nversions of each.", "code_truncated": false}
{"chunk_id": "563e4d19a3200336c82e341d8dc117cbd563a92f", "file_path": "d:\\499\\docs\\installation.rst", "symbol_type": "doc", "name": "Virtual environments", "qualname": "installation.rst#Virtual environments", "start_line": 63, "end_line": 81, "docstring": null, "code": "--------------------\n\nUse a virtual environment to manage the dependencies for your project, both in\ndevelopment and in production.\n\nWhat problem does a virtual environment solve? The more Python projects you\nhave, the more likely it is that you need to work with different versions of\nPython libraries, or even Python itself. Newer versions of libraries for one\nproject can break compatibility in another project.\n\nVirtual environments are independent groups of Python libraries, one for each\nproject. Packages installed for one project will not affect other projects or\nthe operating system's packages.\n\nPython comes bundled with the :mod:`venv` module to create virtual\nenvironments.\n\n\n.. _install-create-env:", "code_truncated": false}
{"chunk_id": "a264eb82e7180a00f445434d877c54762a25bdc4", "file_path": "d:\\499\\docs\\installation.rst", "symbol_type": "doc", "name": "Create an environment", "qualname": "installation.rst#Create an environment", "start_line": 84, "end_line": 107, "docstring": null, "code": "~~~~~~~~~~~~~~~~~~~~~\n\nCreate a project folder and a :file:`.venv` folder within:\n\n.. tabs::\n\n   .. group-tab:: macOS/Linux\n\n      .. code-block:: text\n\n         $ mkdir myproject\n         $ cd myproject\n         $ python3 -m venv .venv\n\n   .. group-tab:: Windows\n\n      .. code-block:: text\n\n         > mkdir myproject\n         > cd myproject\n         > py -3 -m venv .venv\n\n\n.. _install-activate-env:", "code_truncated": false}
{"chunk_id": "e9779d31f2b45319cb93f85615d45f12187469fe", "file_path": "d:\\499\\docs\\installation.rst", "symbol_type": "doc", "name": "Activate the environment", "qualname": "installation.rst#Activate the environment", "start_line": 110, "end_line": 130, "docstring": null, "code": "~~~~~~~~~~~~~~~~~~~~~~~~\n\nBefore you work on your project, activate the corresponding environment:\n\n.. tabs::\n\n   .. group-tab:: macOS/Linux\n\n      .. code-block:: text\n\n         $ . .venv/bin/activate\n\n   .. group-tab:: Windows\n\n      .. code-block:: text\n\n         > .venv\\Scripts\\activate\n\nYour shell prompt will change to show the name of the activated\nenvironment.", "code_truncated": false}
{"chunk_id": "2be1c9af1fd09ff4203e6998b6e6d29ecd1bf442", "file_path": "d:\\499\\docs\\installation.rst", "symbol_type": "doc", "name": "Install Flask", "qualname": "installation.rst#Install Flask", "start_line": 133, "end_line": 143, "docstring": null, "code": "-------------\n\nWithin the activated environment, use the following command to install\nFlask:\n\n.. code-block:: sh\n\n    $ pip install Flask\n\nFlask is now installed. Check out the :doc:`/quickstart` or go to the\n:doc:`Documentation Overview </index>`.", "code_truncated": false}
{"chunk_id": "e488906a83cfd88de6e36d7a254046bab8185ea9", "file_path": "d:\\499\\docs\\license.rst", "symbol_type": "doc", "name": "BSD-3-Clause License", "qualname": "license.rst#BSD-3-Clause License", "start_line": 2, "end_line": 5, "docstring": null, "code": "====================\n\n.. literalinclude:: ../LICENSE.txt\n    :language: text", "code_truncated": false}
{"chunk_id": "3b4027f1d93cf95d55416555be53b960832d3cb7", "file_path": "d:\\499\\docs\\lifecycle.rst", "symbol_type": "doc", "name": "Application Structure and Lifecycle", "qualname": "lifecycle.rst#Application Structure and Lifecycle", "start_line": 2, "end_line": 8, "docstring": null, "code": "===================================\n\nFlask makes it pretty easy to write a web application. But there are quite a few\ndifferent parts to an application and to each request it handles. Knowing what happens\nduring application setup, serving, and handling requests will help you know what's\npossible in Flask and how to structure your application.", "code_truncated": false}
{"chunk_id": "daa76bb80df5703fdefee189eac6329ad4a5a22d", "file_path": "d:\\499\\docs\\lifecycle.rst", "symbol_type": "doc", "name": "Application Setup", "qualname": "lifecycle.rst#Application Setup", "start_line": 11, "end_line": 62, "docstring": null, "code": "-----------------\n\nThe first step in creating a Flask application is creating the application object. Each\nFlask application is an instance of the :class:`.Flask` class, which collects all\nconfiguration, extensions, and views.\n\n.. code-block:: python\n\n    from flask import Flask\n\n    app = Flask(__name__)\n    app.config.from_mapping(\n        SECRET_KEY=\"dev\",\n    )\n    app.config.from_prefixed_env()\n\n    @app.route(\"/\")\n    def index():\n        return \"Hello, World!\"\n\nThis is known as the \"application setup phase\", it's the code you write that's outside\nany view functions or other handlers. It can be split up between different modules and\nsub-packages, but all code that you want to be part of your application must be imported\nin order for it to be registered.\n\nAll application setup must be completed before you start serving your application and\nhandling requests. This is because WSGI servers divide work between multiple workers, or\ncan be distributed across multiple machines. If the configuration changed in one worker,\nthere's no way for Flask to ensure consistency between other workers.\n\nFlask tries to help developers catch some of these setup ordering issues by showing an\nerror if setup-related methods are called after requests are handled. In that case\nyou'll see this error:\n\n    The setup method 'route' can no longer be called on the application. It has already\n    handled its first request, any changes will not be applied consistently.\n    Make sure all imports, decorators, functions, etc. needed to set up the application\n    are done before running it.\n\nHowever, it is not possible for Flask to detect all cases of out-of-order setup. In\ngeneral, don't do anything to modify the ``Flask`` app object and ``Blueprint`` objects\nfrom within view functions that run during requests. This includes:\n\n-   Adding routes, view functions, and other request handlers with ``@app.route``,\n    ``@app.errorhandler``, ``@app.before_request``, etc.\n-   Registering blueprints.\n-   Loading configuration with ``app.config``.\n-   Setting up the Jinja template environment with ``app.jinja_env``.\n-   Setting a session interface, instead of the default itsdangerous cookie.\n-   Setting a JSON provider with ``app.json``, instead of the default provider.\n-   Creating and initializing Flask extensions.", "code_truncated": false}
{"chunk_id": "a8f4adae92dbd752a6f724cc841a3207cb252e72", "file_path": "d:\\499\\docs\\lifecycle.rst", "symbol_type": "doc", "name": "Serving the Application", "qualname": "lifecycle.rst#Serving the Application", "start_line": 65, "end_line": 88, "docstring": null, "code": "-----------------------\n\nFlask is a WSGI application framework. The other half of WSGI is the WSGI server. During\ndevelopment, Flask, through Werkzeug, provides a development WSGI server with the\n``flask run`` CLI command. When you are done with development, use a production server\nto serve your application, see :doc:`deploying/index`.\n\nRegardless of what server you're using, it will follow the :pep:`3333` WSGI spec. The\nWSGI server will be told how to access your Flask application object, which is the WSGI\napplication. Then it will start listening for HTTP requests, translate the request data\ninto a WSGI environ, and call the WSGI application with that data. The WSGI application\nwill return data that is translated into an HTTP response.\n\n#.  Browser or other client makes HTTP request.\n#.  WSGI server receives request.\n#.  WSGI server converts HTTP data to WSGI ``environ`` dict.\n#.  WSGI server calls WSGI application with the ``environ``.\n#.  Flask, the WSGI application, does all its internal processing to route the request\n    to a view function, handle errors, etc.\n#.  Flask translates View function return into WSGI response data, passes it to WSGI\n    server.\n#.  WSGI server creates and send an HTTP response.\n#.  Client receives the HTTP response.", "code_truncated": false}
{"chunk_id": "a5134f1dc377434a57073a9731d9377bab38467e", "file_path": "d:\\499\\docs\\lifecycle.rst", "symbol_type": "doc", "name": "Middleware", "qualname": "lifecycle.rst#Middleware", "start_line": 91, "end_line": 108, "docstring": null, "code": "~~~~~~~~~~\n\nThe WSGI application above is a callable that behaves in a certain way. Middleware\nis a WSGI application that wraps another WSGI application. It's a similar concept to\nPython decorators. The outermost middleware will be called by the server. It can modify\nthe data passed to it, then call the WSGI application (or further middleware) that it\nwraps, and so on. And it can take the return value of that call and modify it further.\n\nFrom the WSGI server's perspective, there is one WSGI application, the one it calls\ndirectly. Typically, Flask is the \"real\" application at the end of the chain of\nmiddleware. But even Flask can call further WSGI applications, although that's an\nadvanced, uncommon use case.\n\nA common middleware you'll see used with Flask is Werkzeug's\n:class:`~werkzeug.middleware.proxy_fix.ProxyFix`, which modifies the request to look\nlike it came directly from a client even if it passed through HTTP proxies on the way.\nThere are other middleware that can handle serving static files, authentication, etc.", "code_truncated": false}
{"chunk_id": "f4b14c45e315d68f17d421c4d80ff7cfb25656ac", "file_path": "d:\\499\\docs\\lifecycle.rst", "symbol_type": "doc", "name": "How a Request is Handled", "qualname": "lifecycle.rst#How a Request is Handled", "start_line": 111, "end_line": 171, "docstring": null, "code": "------------------------\n\nFor us, the interesting part of the steps above is when Flask gets called by the WSGI\nserver (or middleware). At that point, it will do quite a lot to handle the request and\ngenerate the response. At the most basic, it will match the URL to a view function, call\nthe view function, and pass the return value back to the server. But there are many more\nparts that you can use to customize its behavior.\n\n#.  WSGI server calls the Flask object, which calls :meth:`.Flask.wsgi_app`.\n#.  An :class:`.AppContext` object is created. This converts the WSGI ``environ``\n    dict into a :class:`.Request` object.\n#.  The :doc:`app context <appcontext>` is pushed, which makes\n    :data:`.current_app`, :data:`.g`, :data:`.request`, and :data:`.session`\n    available.\n#.  The :data:`.appcontext_pushed` signal is sent.\n#.  The URL is matched against the URL rules registered with the :meth:`~.Flask.route`\n    decorator during application setup. If there is no match, the error - usually a 404,\n    405, or redirect - is stored to be handled later.\n#.  The :data:`.request_started` signal is sent.\n#.  Any :meth:`~.Flask.url_value_preprocessor` decorated functions are called.\n#.  Any :meth:`~.Flask.before_request` decorated functions are called. If any of\n    these function returns a value it is treated as the response immediately.\n#.  If the URL didn't match a route a few steps ago, that error is raised now.\n#.  The :meth:`~.Flask.route` decorated view function associated with the matched URL\n    is called and returns a value to be used as the response.\n#.  If any step so far raised an exception, and there is an :meth:`~.Flask.errorhandler`\n    decorated function that matches the exception class or HTTP error code, it is\n    called to handle the error and return a response.\n#.  Whatever returned a response value - a before request function, the view, or an\n    error handler, that value is converted to a :class:`.Response` object.\n#.  Any :func:`~.after_this_request` decorated functions are called, which can modify\n    the response object. They are then cleared.\n#.  Any :meth:`~.Flask.after_request` decorated functions are called, which can modify\n    the response object.\n#.  The session is saved, persisting any modified session data using the app's\n    :attr:`~.Flask.session_interface`.\n#.  The :data:`.request_finished` signal is sent.\n#.  If any step so far raised an exception, and it was not handled by an error handler\n    function, it is handled now. HTTP exceptions are treated as responses with their\n    corresponding status code, other exceptions are converted to a generic 500 response.\n    The :data:`.got_request_exception` signal is sent.\n#.  The response object's status, headers, and body are returned to the WSGI server.\n#.  Any :meth:`~.Flask.teardown_request` decorated functions are called.\n#.  The :data:`.request_tearing_down` signal is sent.\n#.  Any :meth:`~.Flask.teardown_appcontext` decorated functions are called.\n#.  The :data:`.appcontext_tearing_down` signal is sent.\n#.  The app context is popped, :data:`.current_app`, :data:`.g`, :data:`.request`,\n    and :data:`.session` are no longer available.\n#.  The :data:`.appcontext_popped` signal is sent.\n\nWhen executing a CLI command or plain app context without request data, the same\norder of steps is followed, omitting the steps that refer to the request.\n\nA :class:`Blueprint` can add handlers for these events that are specific to the\nblueprint. The handlers for a blueprint will run if the blueprint\nowns the route that matches the request.\n\nThere are even more decorators and customization points than this, but that aren't part\nof every request lifecycle. They're more specific to certain things you might use during\na request, such as templates, building URLs, or handling JSON data. See the rest of this\ndocumentation, as well as the :doc:`api` to explore further.", "code_truncated": false}
{"chunk_id": "8218f038803ca6014814850e18cd01f4d9dec5e4", "file_path": "d:\\499\\docs\\logging.rst", "symbol_type": "doc", "name": "Logging", "qualname": "logging.rst#Logging", "start_line": 2, "end_line": 25, "docstring": null, "code": "=======\n\nFlask uses standard Python :mod:`logging`. Messages about your Flask\napplication are logged with :meth:`app.logger <flask.Flask.logger>`,\nwhich takes the same name as :attr:`app.name <flask.Flask.name>`. This\nlogger can also be used to log your own messages.\n\n.. code-block:: python\n\n    @app.route('/login', methods=['POST'])\n    def login():\n        user = get_user(request.form['username'])\n\n        if user.check_password(request.form['password']):\n            login_user(user)\n            app.logger.info('%s logged in successfully', user.username)\n            return redirect(url_for('index'))\n        else:\n            app.logger.info('%s failed to log in', user.username)\n            abort(401)\n\nIf you don't configure logging, Python's default log level is usually\n'warning'. Nothing below the configured level will be visible.", "code_truncated": false}
{"chunk_id": "5879fbd968106b3fd5fbcb518be7b4cbf5e9067c", "file_path": "d:\\499\\docs\\logging.rst", "symbol_type": "doc", "name": "Basic Configuration", "qualname": "logging.rst#Basic Configuration", "start_line": 28, "end_line": 57, "docstring": null, "code": "-------------------\n\nWhen you want to configure logging for your project, you should do it as soon\nas possible when the program starts. If :meth:`app.logger <flask.Flask.logger>`\nis accessed before logging is configured, it will add a default handler. If\npossible, configure logging before creating the application object.\n\nThis example uses :func:`~logging.config.dictConfig` to create a logging\nconfiguration similar to Flask's default, except for all logs::\n\n    from logging.config import dictConfig\n\n    dictConfig({\n        'version': 1,\n        'formatters': {'default': {\n            'format': '[%(asctime)s] %(levelname)s in %(module)s: %(message)s',\n        }},\n        'handlers': {'wsgi': {\n            'class': 'logging.StreamHandler',\n            'stream': 'ext://flask.logging.wsgi_errors_stream',\n            'formatter': 'default'\n        }},\n        'root': {\n            'level': 'INFO',\n            'handlers': ['wsgi']\n        }\n    })\n\n    app = Flask(__name__)", "code_truncated": false}
{"chunk_id": "7694aeb491b2c39d0ac91418fe7458cdb82cc427", "file_path": "d:\\499\\docs\\logging.rst", "symbol_type": "doc", "name": "Default Configuration", "qualname": "logging.rst#Default Configuration", "start_line": 60, "end_line": 67, "docstring": null, "code": "`````````````````````\n\nIf you do not configure logging yourself, Flask will add a\n:class:`~logging.StreamHandler` to :meth:`app.logger <flask.Flask.logger>`\nautomatically. During requests, it will write to the stream specified by the\nWSGI server in ``environ['wsgi.errors']`` (which is usually\n:data:`sys.stderr`). Outside a request, it will log to :data:`sys.stderr`.", "code_truncated": false}
{"chunk_id": "4efedcdafd1d1c71c90a3051d60fd223352012ba", "file_path": "d:\\499\\docs\\logging.rst", "symbol_type": "doc", "name": "Removing the Default Handler", "qualname": "logging.rst#Removing the Default Handler", "start_line": 70, "end_line": 79, "docstring": null, "code": "````````````````````````````\n\nIf you configured logging after accessing\n:meth:`app.logger <flask.Flask.logger>`, and need to remove the default\nhandler, you can import and remove it::\n\n    from flask.logging import default_handler\n\n    app.logger.removeHandler(default_handler)", "code_truncated": false}
{"chunk_id": "78e377424a628486049960120adbd6db912f56ec", "file_path": "d:\\499\\docs\\logging.rst", "symbol_type": "doc", "name": "Email Errors to Admins", "qualname": "logging.rst#Email Errors to Admins", "start_line": 82, "end_line": 112, "docstring": null, "code": "----------------------\n\nWhen running the application on a remote server for production, you probably\nwon't be looking at the log messages very often. The WSGI server will probably\nsend log messages to a file, and you'll only check that file if a user tells\nyou something went wrong.\n\nTo be proactive about discovering and fixing bugs, you can configure a\n:class:`logging.handlers.SMTPHandler` to send an email when errors and higher\nare logged. ::\n\n    import logging\n    from logging.handlers import SMTPHandler\n\n    mail_handler = SMTPHandler(\n        mailhost='127.0.0.1',\n        fromaddr='server-error@example.com',\n        toaddrs=['admin@example.com'],\n        subject='Application Error'\n    )\n    mail_handler.setLevel(logging.ERROR)\n    mail_handler.setFormatter(logging.Formatter(\n        '[%(asctime)s] %(levelname)s in %(module)s: %(message)s'\n    ))\n\n    if not app.debug:\n        app.logger.addHandler(mail_handler)\n\nThis requires that you have an SMTP server set up on the same server. See the\nPython docs for more information about configuring the handler.", "code_truncated": false}
{"chunk_id": "b0f2892f0c488c246541b2a2a23f86fe8ef6cf34", "file_path": "d:\\499\\docs\\logging.rst", "symbol_type": "doc", "name": "Injecting Request Information", "qualname": "logging.rst#Injecting Request Information", "start_line": 115, "end_line": 143, "docstring": null, "code": "-----------------------------\n\nSeeing more information about the request, such as the IP address, may help\ndebugging some errors. You can subclass :class:`logging.Formatter` to inject\nyour own fields that can be used in messages. You can change the formatter for\nFlask's default handler, the mail handler defined above, or any other\nhandler. ::\n\n    from flask import has_request_context, request\n    from flask.logging import default_handler\n\n    class RequestFormatter(logging.Formatter):\n        def format(self, record):\n            if has_request_context():\n                record.url = request.url\n                record.remote_addr = request.remote_addr\n            else:\n                record.url = None\n                record.remote_addr = None\n\n            return super().format(record)\n\n    formatter = RequestFormatter(\n        '[%(asctime)s] %(remote_addr)s requested %(url)s\\n'\n        '%(levelname)s in %(module)s: %(message)s'\n    )\n    default_handler.setFormatter(formatter)\n    mail_handler.setFormatter(formatter)", "code_truncated": false}
{"chunk_id": "28bf1b5b539433fe0ab336876b8cf0ea531f94a2", "file_path": "d:\\499\\docs\\logging.rst", "symbol_type": "doc", "name": "Other Libraries", "qualname": "logging.rst#Other Libraries", "start_line": 146, "end_line": 168, "docstring": null, "code": "---------------\n\nOther libraries may use logging extensively, and you want to see relevant\nmessages from those logs too. The simplest way to do this is to add handlers\nto the root logger instead of only the app logger. ::\n\n    from flask.logging import default_handler\n\n    root = logging.getLogger()\n    root.addHandler(default_handler)\n    root.addHandler(mail_handler)\n\nDepending on your project, it may be more useful to configure each logger you\ncare about separately, instead of configuring only the root logger. ::\n\n    for logger in (\n        logging.getLogger(app.name),\n        logging.getLogger('sqlalchemy'),\n        logging.getLogger('other_package'),\n    ):\n        logger.addHandler(default_handler)\n        logger.addHandler(mail_handler)", "code_truncated": false}
{"chunk_id": "07190762653f7fcd1fbbadda4c3378b27472c503", "file_path": "d:\\499\\docs\\logging.rst", "symbol_type": "doc", "name": "Werkzeug", "qualname": "logging.rst#Werkzeug", "start_line": 171, "end_line": 176, "docstring": null, "code": "````````\n\nWerkzeug logs basic request/response information to the ``'werkzeug'`` logger.\nIf the root logger has no handlers configured, Werkzeug adds a\n:class:`~logging.StreamHandler` to its logger.", "code_truncated": false}
{"chunk_id": "4c34bc75178c61ed548cd5adfb37515a613c3a52", "file_path": "d:\\499\\docs\\logging.rst", "symbol_type": "doc", "name": "Flask Extensions", "qualname": "logging.rst#Flask Extensions", "start_line": 179, "end_line": 183, "docstring": null, "code": "````````````````\n\nDepending on the situation, an extension may choose to log to\n:meth:`app.logger <flask.Flask.logger>` or its own named logger. Consult each\nextension's documentation for details.", "code_truncated": false}
{"chunk_id": "32df76ed583771e7d789046f47f64f8893a2599e", "file_path": "d:\\499\\docs\\patterns\\appdispatch.rst", "symbol_type": "doc", "name": "Application Dispatching", "qualname": "patterns\\appdispatch.rst#Application Dispatching", "start_line": 2, "end_line": 15, "docstring": null, "code": "=======================\n\nApplication dispatching is the process of combining multiple Flask\napplications on the WSGI level.  You can combine not only Flask\napplications but any WSGI application.  This would allow you to run a\nDjango and a Flask application in the same interpreter side by side if\nyou want.  The usefulness of this depends on how the applications work\ninternally.\n\nThe fundamental difference from :doc:`packages` is that in this case you\nare running the same or different Flask applications that are entirely\nisolated from each other. They run different configurations and are\ndispatched on the WSGI level.", "code_truncated": false}
{"chunk_id": "8b7294bf255ac9cc6ddcf3c8ba11cda4c3df98be", "file_path": "d:\\499\\docs\\patterns\\appdispatch.rst", "symbol_type": "doc", "name": "Working with this Document", "qualname": "patterns\\appdispatch.rst#Working with this Document", "start_line": 18, "end_line": 34, "docstring": null, "code": "--------------------------\n\nEach of the techniques and examples below results in an ``application``\nobject that can be run with any WSGI server. For development, use the\n``flask run`` command to start a development server. For production, see\n:doc:`/deploying/index`.\n\n.. code-block:: python\n\n    from flask import Flask\n\n    app = Flask(__name__)\n\n    @app.route('/')\n    def hello_world():\n        return 'Hello World!'", "code_truncated": false}
{"chunk_id": "c8bc208f20988be6787170235a2a847bf2c0ecf1", "file_path": "d:\\499\\docs\\patterns\\appdispatch.rst", "symbol_type": "doc", "name": "Combining Applications", "qualname": "patterns\\appdispatch.rst#Combining Applications", "start_line": 37, "end_line": 58, "docstring": null, "code": "----------------------\n\nIf you have entirely separated applications and you want them to work next\nto each other in the same Python interpreter process you can take\nadvantage of the :class:`werkzeug.wsgi.DispatcherMiddleware`.  The idea\nhere is that each Flask application is a valid WSGI application and they\nare combined by the dispatcher middleware into a larger one that is\ndispatched based on prefix.\n\nFor example you could have your main application run on ``/`` and your\nbackend interface on ``/backend``.\n\n.. code-block:: python\n\n    from werkzeug.middleware.dispatcher import DispatcherMiddleware\n    from frontend_app import application as frontend\n    from backend_app import application as backend\n\n    application = DispatcherMiddleware(frontend, {\n        '/backend': backend\n    })", "code_truncated": false}
{"chunk_id": "49b134f9ebbd20f7619b7b7925f523ecd470636d", "file_path": "d:\\499\\docs\\patterns\\appdispatch.rst", "symbol_type": "doc", "name": "Dispatch by Subdomain", "qualname": "patterns\\appdispatch.rst#Dispatch by Subdomain", "start_line": 61, "end_line": 131, "docstring": null, "code": "---------------------\n\nSometimes you might want to use multiple instances of the same application\nwith different configurations.  Assuming the application is created inside\na function and you can call that function to instantiate it, that is\nreally easy to implement.  In order to develop your application to support\ncreating new instances in functions have a look at the\n:doc:`appfactories` pattern.\n\nA very common example would be creating applications per subdomain.  For\ninstance you configure your webserver to dispatch all requests for all\nsubdomains to your application and you then use the subdomain information\nto create user-specific instances.  Once you have your server set up to\nlisten on all subdomains you can use a very simple WSGI application to do\nthe dynamic application creation.\n\nThe perfect level for abstraction in that regard is the WSGI layer.  You\nwrite your own WSGI application that looks at the request that comes and\ndelegates it to your Flask application.  If that application does not\nexist yet, it is dynamically created and remembered.\n\n.. code-block:: python\n\n    from threading import Lock\n\n    class SubdomainDispatcher:\n\n        def __init__(self, domain, create_app):\n            self.domain = domain\n            self.create_app = create_app\n            self.lock = Lock()\n            self.instances = {}\n\n        def get_application(self, host):\n            host = host.split(':')[0]\n            assert host.endswith(self.domain), 'Configuration error'\n            subdomain = host[:-len(self.domain)].rstrip('.')\n            with self.lock:\n                app = self.instances.get(subdomain)\n                if app is None:\n                    app = self.create_app(subdomain)\n                    self.instances[subdomain] = app\n                return app\n\n        def __call__(self, environ, start_response):\n            app = self.get_application(environ['HTTP_HOST'])\n            return app(environ, start_response)\n\n\nThis dispatcher can then be used like this:\n\n.. code-block:: python\n\n    from myapplication import create_app, get_user_for_subdomain\n    from werkzeug.exceptions import NotFound\n\n    def make_app(subdomain):\n        user = get_user_for_subdomain(subdomain)\n        if user is None:\n            # if there is no user for that subdomain we still have\n            # to return a WSGI application that handles that request.\n            # We can then just return the NotFound() exception as\n            # application which will render a default 404 page.\n            # You might also redirect the user to the main page then\n            return NotFound()\n\n        # otherwise create the application for the specific user\n        return create_app(user)\n\n    application = SubdomainDispatcher('example.com', make_app)", "code_truncated": false}
{"chunk_id": "cd024db9221a2e4f3d5bff5c234660d2ba6f643f", "file_path": "d:\\499\\docs\\patterns\\appdispatch.rst", "symbol_type": "doc", "name": "Dispatch by Path", "qualname": "patterns\\appdispatch.rst#Dispatch by Path", "start_line": 134, "end_line": 189, "docstring": null, "code": "----------------\n\nDispatching by a path on the URL is very similar.  Instead of looking at\nthe ``Host`` header to figure out the subdomain one simply looks at the\nrequest path up to the first slash.\n\n.. code-block:: python\n\n    from threading import Lock\n    from wsgiref.util import shift_path_info\n\n    class PathDispatcher:\n\n        def __init__(self, default_app, create_app):\n            self.default_app = default_app\n            self.create_app = create_app\n            self.lock = Lock()\n            self.instances = {}\n\n        def get_application(self, prefix):\n            with self.lock:\n                app = self.instances.get(prefix)\n                if app is None:\n                    app = self.create_app(prefix)\n                    if app is not None:\n                        self.instances[prefix] = app\n                return app\n\n        def __call__(self, environ, start_response):\n            app = self.get_application(_peek_path_info(environ))\n            if app is not None:\n                shift_path_info(environ)\n            else:\n                app = self.default_app\n            return app(environ, start_response)\n\n    def _peek_path_info(environ):\n        segments = environ.get(\"PATH_INFO\", \"\").lstrip(\"/\").split(\"/\", 1)\n        if segments:\n            return segments[0]\n\n        return None\n\nThe big difference between this and the subdomain one is that this one\nfalls back to another application if the creator function returns ``None``.\n\n.. code-block:: python\n\n    from myapplication import create_app, default_app, get_user_for_prefix\n\n    def make_app(prefix):\n        user = get_user_for_prefix(prefix)\n        if user is not None:\n            return create_app(user)\n\n    application = PathDispatcher(default_app, make_app)", "code_truncated": false}
{"chunk_id": "61517760d86a38fc3723dd47bd060b909a463225", "file_path": "d:\\499\\docs\\patterns\\appfactories.rst", "symbol_type": "doc", "name": "Application Factories", "qualname": "patterns\\appfactories.rst#Application Factories", "start_line": 2, "end_line": 20, "docstring": null, "code": "=====================\n\nIf you are already using packages and blueprints for your application\n(:doc:`/blueprints`) there are a couple of really nice ways to further improve\nthe experience.  A common pattern is creating the application object when\nthe blueprint is imported.  But if you move the creation of this object\ninto a function, you can then create multiple instances of this app later.\n\nSo why would you want to do this?\n\n1.  Testing.  You can have instances of the application with different\n    settings to test every case.\n2.  Multiple instances.  Imagine you want to run different versions of the\n    same application.  Of course you could have multiple instances with\n    different configs set up in your webserver, but if you use factories,\n    you can have multiple instances of the same application running in the\n    same application process which can be handy.\n\nSo how would you then actually implement that?", "code_truncated": false}
{"chunk_id": "76efac04b1ecd0da0e3a73212ed4fed6cea9d452", "file_path": "d:\\499\\docs\\patterns\\appfactories.rst", "symbol_type": "doc", "name": "Basic Factories", "qualname": "patterns\\appfactories.rst#Basic Factories", "start_line": 23, "end_line": 53, "docstring": null, "code": "---------------\n\nThe idea is to set up the application in a function.  Like this::\n\n    def create_app(config_filename):\n        app = Flask(__name__)\n        app.config.from_pyfile(config_filename)\n\n        from yourapplication.model import db\n        db.init_app(app)\n\n        from yourapplication.views.admin import admin\n        from yourapplication.views.frontend import frontend\n        app.register_blueprint(admin)\n        app.register_blueprint(frontend)\n\n        return app\n\nThe downside is that you cannot use the application object in the blueprints\nat import time.  You can however use it from within a request.  How do you\nget access to the application with the config?  Use\n:data:`~flask.current_app`::\n\n    from flask import current_app, Blueprint, render_template\n    admin = Blueprint('admin', __name__, url_prefix='/admin')\n\n    @admin.route('/')\n    def index():\n        return render_template(current_app.config['INDEX_TEMPLATE'])\n\nHere we look up the name of a template in the config.", "code_truncated": false}
{"chunk_id": "6dabd0f5877ab25d406e418250a1ad64dd69c2c9", "file_path": "d:\\499\\docs\\patterns\\appfactories.rst", "symbol_type": "doc", "name": "Factories & Extensions", "qualname": "patterns\\appfactories.rst#Factories & Extensions", "start_line": 56, "end_line": 85, "docstring": null, "code": "----------------------\n\nIt's preferable to create your extensions and app factories so that the\nextension object does not initially get bound to the application.\n\nUsing `Flask-SQLAlchemy <https://flask-sqlalchemy.palletsprojects.com/>`_,\nas an example, you should not do something along those lines::\n\n    def create_app(config_filename):\n        app = Flask(__name__)\n        app.config.from_pyfile(config_filename)\n\n        db = SQLAlchemy(app)\n\nBut, rather, in model.py (or equivalent)::\n\n    db = SQLAlchemy()\n\nand in your application.py (or equivalent)::\n\n    def create_app(config_filename):\n        app = Flask(__name__)\n        app.config.from_pyfile(config_filename)\n\n        from yourapplication.model import db\n        db.init_app(app)\n\nUsing this design pattern, no application-specific state is stored on the\nextension object, so one extension object can be used for multiple apps.\nFor more information about the design of extensions refer to :doc:`/extensiondev`.", "code_truncated": false}
{"chunk_id": "35f326cbb96d9c9443fbf2f2b0fb84da93d3b9d1", "file_path": "d:\\499\\docs\\patterns\\appfactories.rst", "symbol_type": "doc", "name": "Using Applications", "qualname": "patterns\\appfactories.rst#Using Applications", "start_line": 88, "end_line": 105, "docstring": null, "code": "------------------\n\nTo run such an application, you can use the :command:`flask` command:\n\n.. code-block:: text\n\n    $ flask --app hello run\n\nFlask will automatically detect the factory if it is named\n``create_app`` or ``make_app`` in ``hello``. You can also pass arguments\nto the factory like this:\n\n.. code-block:: text\n\n    $ flask --app 'hello:create_app(local_auth=True)' run\n\nThen the ``create_app`` factory in ``hello`` is called with the keyword\nargument ``local_auth=True``. See :doc:`/cli` for more detail.", "code_truncated": false}
{"chunk_id": "220660b82736339ade6b65ac6e44ad255d16e2a9", "file_path": "d:\\499\\docs\\patterns\\appfactories.rst", "symbol_type": "doc", "name": "Factory Improvements", "qualname": "patterns\\appfactories.rst#Factory Improvements", "start_line": 108, "end_line": 118, "docstring": null, "code": "--------------------\n\nThe factory function above is not very clever, but you can improve it.\nThe following changes are straightforward to implement:\n\n1.  Make it possible to pass in configuration values for unit tests so that\n    you don't have to create config files on the filesystem.\n2.  Call a function from a blueprint when the application is setting up so\n    that you have a place to modify attributes of the application (like\n    hooking in before/after request handlers etc.)\n3.  Add in WSGI middlewares when the application is being created if necessary.", "code_truncated": false}
{"chunk_id": "18f2cb1a8823484c743743f49355deb6c8476a45", "file_path": "d:\\499\\docs\\patterns\\caching.rst", "symbol_type": "doc", "name": "Caching", "qualname": "patterns\\caching.rst#Caching", "start_line": 2, "end_line": 16, "docstring": null, "code": "=======\n\nWhen your application runs slow, throw some caches in.  Well, at least\nit's the easiest way to speed up things.  What does a cache do?  Say you\nhave a function that takes some time to complete but the results would\nstill be good enough if they were 5 minutes old.  So then the idea is that\nyou actually put the result of that calculation into a cache for some\ntime.\n\nFlask itself does not provide caching for you, but `Flask-Caching`_, an\nextension for Flask does. Flask-Caching supports various backends, and it is\neven possible to develop your own caching backend.\n\n\n.. _Flask-Caching: https://flask-caching.readthedocs.io/en/latest/", "code_truncated": false}
{"chunk_id": "37122fae5f319b78ac69958cfc21c9e792ea28f8", "file_path": "d:\\499\\docs\\patterns\\celery.rst", "symbol_type": "doc", "name": "Background Tasks with Celery", "qualname": "patterns\\celery.rst#Background Tasks with Celery", "start_line": 2, "end_line": 20, "docstring": null, "code": "============================\n\nIf your application has a long running task, such as processing some uploaded data or\nsending email, you don't want to wait for it to finish during a request. Instead, use a\ntask queue to send the necessary data to another process that will run the task in the\nbackground while the request returns immediately.\n\n`Celery`_ is a powerful task queue that can be used for simple background tasks as well\nas complex multi-stage programs and schedules. This guide will show you how to configure\nCelery using Flask. Read Celery's `First Steps with Celery`_ guide to learn how to use\nCelery itself.\n\n.. _Celery: https://celery.readthedocs.io\n.. _First Steps with Celery: https://celery.readthedocs.io/en/latest/getting-started/first-steps-with-celery.html\n\nThe Flask repository contains `an example <https://github.com/pallets/flask/tree/main/examples/celery>`_\nbased on the information on this page, which also shows how to use JavaScript to submit\ntasks and poll for progress and results.", "code_truncated": false}
{"chunk_id": "0dbac3ea68065006cf0ebfae431d06bcb3038712", "file_path": "d:\\499\\docs\\patterns\\celery.rst", "symbol_type": "doc", "name": "Install", "qualname": "patterns\\celery.rst#Install", "start_line": 23, "end_line": 30, "docstring": null, "code": "-------\n\nInstall Celery from PyPI, for example using pip:\n\n.. code-block:: text\n\n    $ pip install celery", "code_truncated": false}
{"chunk_id": "520ef0fd171669a254cff369d2c53cfb64bd0883", "file_path": "d:\\499\\docs\\patterns\\celery.rst", "symbol_type": "doc", "name": "Integrate Celery with Flask", "qualname": "patterns\\celery.rst#Integrate Celery with Flask", "start_line": 33, "end_line": 96, "docstring": null, "code": "---------------------------\n\nYou can use Celery without any integration with Flask, but it's convenient to configure\nit through Flask's config, and to let tasks access the Flask application.\n\nCelery uses similar ideas to Flask, with a ``Celery`` app object that has configuration\nand registers tasks. While creating a Flask app, use the following code to create and\nconfigure a Celery app as well.\n\n.. code-block:: python\n\n    from celery import Celery, Task\n\n    def celery_init_app(app: Flask) -> Celery:\n        class FlaskTask(Task):\n            def __call__(self, *args: object, **kwargs: object) -> object:\n                with app.app_context():\n                    return self.run(*args, **kwargs)\n\n        celery_app = Celery(app.name, task_cls=FlaskTask)\n        celery_app.config_from_object(app.config[\"CELERY\"])\n        celery_app.set_default()\n        app.extensions[\"celery\"] = celery_app\n        return celery_app\n\nThis creates and returns a ``Celery`` app object. Celery `configuration`_ is taken from\nthe ``CELERY`` key in the Flask configuration. The Celery app is set as the default, so\nthat it is seen during each request. The ``Task`` subclass automatically runs task\nfunctions with a Flask app context active, so that services like your database\nconnections are available.\n\n.. _configuration: https://celery.readthedocs.io/en/stable/userguide/configuration.html\n\nHere's a basic ``example.py`` that configures Celery to use Redis for communication. We\nenable a result backend, but ignore results by default. This allows us to store results\nonly for tasks where we care about the result.\n\n.. code-block:: python\n\n    from flask import Flask\n\n    app = Flask(__name__)\n    app.config.from_mapping(\n        CELERY=dict(\n            broker_url=\"redis://localhost\",\n            result_backend=\"redis://localhost\",\n            task_ignore_result=True,\n        ),\n    )\n    celery_app = celery_init_app(app)\n\nPoint the ``celery worker`` command at this and it will find the ``celery_app`` object.\n\n.. code-block:: text\n\n    $ celery -A example worker --loglevel INFO\n\nYou can also run the ``celery beat`` command to run tasks on a schedule. See Celery's\ndocs for more information about defining schedules.\n\n.. code-block:: text\n\n    $ celery -A example beat --loglevel INFO", "code_truncated": false}
{"chunk_id": "50dd54042446718c3d46a1fc5ec43fa28891242f", "file_path": "d:\\499\\docs\\patterns\\celery.rst", "symbol_type": "doc", "name": "Application Factory", "qualname": "patterns\\celery.rst#Application Factory", "start_line": 99, "end_line": 137, "docstring": null, "code": "-------------------\n\nWhen using the Flask application factory pattern, call the ``celery_init_app`` function\ninside the factory. It sets ``app.extensions[\"celery\"]`` to the Celery app object, which\ncan be used to get the Celery app from the Flask app returned by the factory.\n\n.. code-block:: python\n\n    def create_app() -> Flask:\n        app = Flask(__name__)\n        app.config.from_mapping(\n            CELERY=dict(\n                broker_url=\"redis://localhost\",\n                result_backend=\"redis://localhost\",\n                task_ignore_result=True,\n            ),\n        )\n        app.config.from_prefixed_env()\n        celery_init_app(app)\n        return app\n\nTo use ``celery`` commands, Celery needs an app object, but that's no longer directly\navailable. Create a ``make_celery.py`` file that calls the Flask app factory and gets\nthe Celery app from the returned Flask app.\n\n.. code-block:: python\n\n    from example import create_app\n\n    flask_app = create_app()\n    celery_app = flask_app.extensions[\"celery\"]\n\nPoint the ``celery`` command to this file.\n\n.. code-block:: text\n\n    $ celery -A make_celery worker --loglevel INFO\n    $ celery -A make_celery beat --loglevel INFO", "code_truncated": false}
{"chunk_id": "aee0cfba062bc5ad7010a525298baf213b75b3ff", "file_path": "d:\\499\\docs\\patterns\\celery.rst", "symbol_type": "doc", "name": "Defining Tasks", "qualname": "patterns\\celery.rst#Defining Tasks", "start_line": 140, "end_line": 164, "docstring": null, "code": "--------------\n\nUsing ``@celery_app.task`` to decorate task functions requires access to the\n``celery_app`` object, which won't be available when using the factory pattern. It also\nmeans that the decorated tasks are tied to the specific Flask and Celery app instances,\nwhich could be an issue during testing if you change configuration for a test.\n\nInstead, use Celery's ``@shared_task`` decorator. This creates task objects that will\naccess whatever the \"current app\" is, which is a similar concept to Flask's blueprints\nand app context. This is why we called ``celery_app.set_default()`` above.\n\nHere's an example task that adds two numbers together and returns the result.\n\n.. code-block:: python\n\n    from celery import shared_task\n\n    @shared_task(ignore_result=False)\n    def add_together(a: int, b: int) -> int:\n        return a + b\n\nEarlier, we configured Celery to ignore task results by default. Since we want to know\nthe return value of this task, we set ``ignore_result=False``. On the other hand, a task\nthat didn't need a result, such as sending an email, wouldn't set this.", "code_truncated": false}
{"chunk_id": "a3f4a9186c93bad3e018ec6b4dc274668226056d", "file_path": "d:\\499\\docs\\patterns\\celery.rst", "symbol_type": "doc", "name": "Calling Tasks", "qualname": "patterns\\celery.rst#Calling Tasks", "start_line": 167, "end_line": 190, "docstring": null, "code": "-------------\n\nThe decorated function becomes a task object with methods to call it in the background.\nThe simplest way is to use the ``delay(*args, **kwargs)`` method. See Celery's docs for\nmore methods.\n\nA Celery worker must be running to run the task. Starting a worker is shown in the\nprevious sections.\n\n.. code-block:: python\n\n    from flask import request\n\n    @app.post(\"/add\")\n    def start_add() -> dict[str, object]:\n        a = request.form.get(\"a\", type=int)\n        b = request.form.get(\"b\", type=int)\n        result = add_together.delay(a, b)\n        return {\"result_id\": result.id}\n\nThe route doesn't get the task's result immediately. That would defeat the purpose by\nblocking the response. Instead, we return the running task's result id, which we can use\nlater to get the result.", "code_truncated": false}
{"chunk_id": "70b0d250847d6c5814370d1b3bebe0caa8143041", "file_path": "d:\\499\\docs\\patterns\\celery.rst", "symbol_type": "doc", "name": "Getting Results", "qualname": "patterns\\celery.rst#Getting Results", "start_line": 193, "end_line": 218, "docstring": null, "code": "---------------\n\nTo fetch the result of the task we started above, we'll add another route that takes the\nresult id we returned before. We return whether the task is finished (ready), whether it\nfinished successfully, and what the return value (or error) was if it is finished.\n\n.. code-block:: python\n\n    from celery.result import AsyncResult\n\n    @app.get(\"/result/<id>\")\n    def task_result(id: str) -> dict[str, object]:\n        result = AsyncResult(id)\n        return {\n            \"ready\": result.ready(),\n            \"successful\": result.successful(),\n            \"value\": result.result if result.ready() else None,\n        }\n\nNow you can start the task using the first route, then poll for the result using the\nsecond route. This keeps the Flask request workers from being blocked waiting for tasks\nto finish.\n\nThe Flask repository contains `an example <https://github.com/pallets/flask/tree/main/examples/celery>`_\nusing JavaScript to submit tasks and poll for progress and results.", "code_truncated": false}
{"chunk_id": "c9125a9638f5a74c7d0b738992c851163dee697b", "file_path": "d:\\499\\docs\\patterns\\celery.rst", "symbol_type": "doc", "name": "Passing Data to Tasks", "qualname": "patterns\\celery.rst#Passing Data to Tasks", "start_line": 221, "end_line": 242, "docstring": null, "code": "---------------------\n\nThe \"add\" task above took two integers as arguments. To pass arguments to tasks, Celery\nhas to serialize them to a format that it can pass to other processes. Therefore,\npassing complex objects is not recommended. For example, it would be impossible to pass\na SQLAlchemy model object, since that object is probably not serializable and is tied to\nthe session that queried it.\n\nPass the minimal amount of data necessary to fetch or recreate any complex data within\nthe task. Consider a task that will run when the logged in user asks for an archive of\ntheir data. The Flask request knows the logged in user, and has the user object queried\nfrom the database. It got that by querying the database for a given id, so the task can\ndo the same thing. Pass the user's id rather than the user object.\n\n.. code-block:: python\n\n    @shared_task\n    def generate_user_archive(user_id: str) -> None:\n        user = db.session.get(User, user_id)\n        ...\n\n    generate_user_archive.delay(current_user.id)", "code_truncated": false}
{"chunk_id": "4786bb41dcf1494473f935c1687ab4dd1ea42f18", "file_path": "d:\\499\\docs\\patterns\\deferredcallbacks.rst", "symbol_type": "doc", "name": "Deferred Request Callbacks", "qualname": "patterns\\deferredcallbacks.rst#Deferred Request Callbacks", "start_line": 2, "end_line": 44, "docstring": null, "code": "==========================\n\nOne of the design principles of Flask is that response objects are created and\npassed down a chain of potential callbacks that can modify them or replace\nthem. When the request handling starts, there is no response object yet. It is\ncreated as necessary either by a view function or by some other component in\nthe system.\n\nWhat happens if you want to modify the response at a point where the response\ndoes not exist yet?  A common example for that would be a\n:meth:`~flask.Flask.before_request` callback that wants to set a cookie on the\nresponse object.\n\nOne way is to avoid the situation. Very often that is possible. For instance\nyou can try to move that logic into a :meth:`~flask.Flask.after_request`\ncallback instead. However, sometimes moving code there makes it\nmore complicated or awkward to reason about.\n\nAs an alternative, you can use :func:`~flask.after_this_request` to register\ncallbacks that will execute after only the current request. This way you can\ndefer code execution from anywhere in the application, based on the current\nrequest.\n\nAt any time during a request, we can register a function to be called at the\nend of the request. For example you can remember the current language of the\nuser in a cookie in a :meth:`~flask.Flask.before_request` callback::\n\n    from flask import request, after_this_request\n\n    @app.before_request\n    def detect_user_language():\n        language = request.cookies.get('user_lang')\n\n        if language is None:\n            language = guess_language_from_request()\n\n            # when the response exists, set a cookie with the language\n            @after_this_request\n            def remember_language(response):\n                response.set_cookie('user_lang', language)\n                return response\n\n        g.language = language", "code_truncated": false}
{"chunk_id": "99f37bff59c3a0eb5a8a3bf2065b2319b1577065", "file_path": "d:\\499\\docs\\patterns\\favicon.rst", "symbol_type": "doc", "name": "Adding a favicon", "qualname": "patterns\\favicon.rst#Adding a favicon", "start_line": 2, "end_line": 50, "docstring": null, "code": "================\n\nA \"favicon\" is an icon used by browsers for tabs and bookmarks. This helps\nto distinguish your website and to give it a unique brand.\n\nA common question is how to add a favicon to a Flask application. First, of\ncourse, you need an icon. It should be 16  16 pixels and in the ICO file\nformat. This is not a requirement but a de-facto standard supported by all\nrelevant browsers. Put the icon in your static directory as\n:file:`favicon.ico`.\n\nNow, to get browsers to find your icon, the correct way is to add a link\ntag in your HTML. So, for example:\n\n.. sourcecode:: html+jinja\n\n    <link rel=\"shortcut icon\" href=\"{{ url_for('static', filename='favicon.ico') }}\">\n\nThat's all you need for most browsers, however some really old ones do not\nsupport this standard. The old de-facto standard is to serve this file,\nwith this name, at the website root. If your application is not mounted at\nthe root path of the domain you either need to configure the web server to\nserve the icon at the root or if you can't do that you're out of luck. If\nhowever your application is the root you can simply route a redirect::\n\n    app.add_url_rule(\n        \"/favicon.ico\",\n        endpoint=\"favicon\",\n        redirect_to=url_for(\"static\", filename=\"favicon.ico\"),\n    )\n\nIf you want to save the extra redirect request you can also write a view\nusing :func:`~flask.send_from_directory`::\n\n    import os\n    from flask import send_from_directory\n\n    @app.route('/favicon.ico')\n    def favicon():\n        return send_from_directory(os.path.join(app.root_path, 'static'),\n                                   'favicon.ico', mimetype='image/vnd.microsoft.icon')\n\nWe can leave out the explicit mimetype and it will be guessed, but we may\nas well specify it to avoid the extra guessing, as it will always be the\nsame.\n\nThe above will serve the icon via your application and if possible it's\nbetter to configure your dedicated web server to serve it; refer to the\nweb server's documentation.", "code_truncated": false}
{"chunk_id": "8d8f39a2528245015765cd2f44c521bf45c494d1", "file_path": "d:\\499\\docs\\patterns\\favicon.rst", "symbol_type": "doc", "name": "See also", "qualname": "patterns\\favicon.rst#See also", "start_line": 53, "end_line": 56, "docstring": null, "code": "--------\n\n* The `Favicon <https://en.wikipedia.org/wiki/Favicon>`_ article on\n  Wikipedia", "code_truncated": false}
{"chunk_id": "aa56632513da0ec7934d91acb545eab0aa9e26eb", "file_path": "d:\\499\\docs\\patterns\\fileuploads.rst", "symbol_type": "doc", "name": "Uploading Files", "qualname": "patterns\\fileuploads.rst#Uploading Files", "start_line": 2, "end_line": 12, "docstring": null, "code": "===============\n\nAh yes, the good old problem of file uploads.  The basic idea of file\nuploads is actually quite simple.  It basically works like this:\n\n1. A ``<form>`` tag is marked with ``enctype=multipart/form-data``\n   and an ``<input type=file>`` is placed in that form.\n2. The application accesses the file from the :attr:`~flask.request.files`\n   dictionary on the request object.\n3. use the :meth:`~werkzeug.datastructures.FileStorage.save` method of the file to save\n   the file permanently somewhere on the filesystem.", "code_truncated": false}
{"chunk_id": "9d6933869ddb42b5be001aeeb7f46fb0770b9306", "file_path": "d:\\499\\docs\\patterns\\fileuploads.rst", "symbol_type": "doc", "name": "A Gentle Introduction", "qualname": "patterns\\fileuploads.rst#A Gentle Introduction", "start_line": 15, "end_line": 126, "docstring": null, "code": "---------------------\n\nLet's start with a very basic application that uploads a file to a\nspecific upload folder and displays a file to the user.  Let's look at the\nbootstrapping code for our application::\n\n    import os\n    from flask import Flask, flash, request, redirect, url_for\n    from werkzeug.utils import secure_filename\n\n    UPLOAD_FOLDER = '/path/to/the/uploads'\n    ALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}\n\n    app = Flask(__name__)\n    app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\nSo first we need a couple of imports.  Most should be straightforward, the\n:func:`werkzeug.secure_filename` is explained a little bit later.  The\n``UPLOAD_FOLDER`` is where we will store the uploaded files and the\n``ALLOWED_EXTENSIONS`` is the set of allowed file extensions.\n\nWhy do we limit the extensions that are allowed?  You probably don't want\nyour users to be able to upload everything there if the server is directly\nsending out the data to the client.  That way you can make sure that users\nare not able to upload HTML files that would cause XSS problems (see\n:ref:`security-xss`).  Also make sure to disallow ``.php`` files if the server\nexecutes them, but who has PHP installed on their server, right?  :)\n\nNext the functions that check if an extension is valid and that uploads\nthe file and redirects the user to the URL for the uploaded file::\n\n    def allowed_file(filename):\n        return '.' in filename and \\\n               filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\n\n    @app.route('/', methods=['GET', 'POST'])\n    def upload_file():\n        if request.method == 'POST':\n            # check if the post request has the file part\n            if 'file' not in request.files:\n                flash('No file part')\n                return redirect(request.url)\n            file = request.files['file']\n            # If the user does not select a file, the browser submits an\n            # empty file without a filename.\n            if file.filename == '':\n                flash('No selected file')\n                return redirect(request.url)\n            if file and allowed_file(file.filename):\n                filename = secure_filename(file.filename)\n                file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\n                return redirect(url_for('download_file', name=filename))\n        return '''\n        <!doctype html>\n        <title>Upload new File</title>\n        <h1>Upload new File</h1>\n        <form method=post enctype=multipart/form-data>\n          <input type=file name=file>\n          <input type=submit value=Upload>\n        </form>\n        '''\n\nSo what does that :func:`~werkzeug.utils.secure_filename` function actually do?\nNow the problem is that there is that principle called \"never trust user\ninput\".  This is also true for the filename of an uploaded file.  All\nsubmitted form data can be forged, and filenames can be dangerous.  For\nthe moment just remember: always use that function to secure a filename\nbefore storing it directly on the filesystem.\n\n.. admonition:: Information for the Pros\n\n   So you're interested in what that :func:`~werkzeug.utils.secure_filename`\n   function does and what the problem is if you're not using it?  So just\n   imagine someone would send the following information as `filename` to\n   your application::\n\n      filename = \"../../../../home/username/.bashrc\"\n\n   Assuming the number of ``../`` is correct and you would join this with\n   the ``UPLOAD_FOLDER`` the user might have the ability to modify a file on\n   the server's filesystem he or she should not modify.  This does require some\n   knowledge about how the application looks like, but trust me, hackers\n   are patient :)\n\n   Now let's look how that function works:\n\n   >>> secure_filename('../../../../home/username/.bashrc')\n   'home_username_.bashrc'\n\nWe want to be able to serve the uploaded files so they can be downloaded\nby users. We'll define a ``download_file`` view to serve files in the\nupload folder by name. ``url_for(\"download_file\", name=name)`` generates\ndownload URLs.\n\n.. code-block:: python\n\n    from flask import send_from_directory\n\n    @app.route('/uploads/<name>')\n    def download_file(name):\n        return send_from_directory(app.config[\"UPLOAD_FOLDER\"], name)\n\nIf you're using middleware or the HTTP server to serve files, you can\nregister the ``download_file`` endpoint as ``build_only`` so ``url_for``\nwill work without a view function.\n\n.. code-block:: python\n\n    app.add_url_rule(\n        \"/uploads/<name>\", endpoint=\"download_file\", build_only=True\n    )", "code_truncated": false}
{"chunk_id": "23c8923abb60b32b20d10843fdd1d0aa5dc0ce00", "file_path": "d:\\499\\docs\\patterns\\fileuploads.rst", "symbol_type": "doc", "name": "Improving Uploads", "qualname": "patterns\\fileuploads.rst#Improving Uploads", "start_line": 129, "end_line": 159, "docstring": null, "code": "-----------------\n\n.. versionadded:: 0.6\n\nSo how exactly does Flask handle uploads?  Well it will store them in the\nwebserver's memory if the files are reasonably small, otherwise in a\ntemporary location (as returned by :func:`tempfile.gettempdir`).  But how\ndo you specify the maximum file size after which an upload is aborted?  By\ndefault Flask will happily accept file uploads with an unlimited amount of\nmemory, but you can limit that by setting the ``MAX_CONTENT_LENGTH``\nconfig key::\n\n    from flask import Flask, Request\n\n    app = Flask(__name__)\n    app.config['MAX_CONTENT_LENGTH'] = 16 * 1000 * 1000\n\nThe code above will limit the maximum allowed payload to 16 megabytes.\nIf a larger file is transmitted, Flask will raise a\n:exc:`~werkzeug.exceptions.RequestEntityTooLarge` exception.\n\n.. admonition:: Connection Reset Issue\n\n    When using the local development server, you may get a connection\n    reset error instead of a 413 response. You will get the correct\n    status response when running the app with a production WSGI server.\n\nThis feature was added in Flask 0.6 but can be achieved in older versions\nas well by subclassing the request object.  For more information on that\nconsult the Werkzeug documentation on file handling.", "code_truncated": false}
{"chunk_id": "8da5789bd13eacfc577701d27ef44d8be473c48a", "file_path": "d:\\499\\docs\\patterns\\fileuploads.rst", "symbol_type": "doc", "name": "Upload Progress Bars", "qualname": "patterns\\fileuploads.rst#Upload Progress Bars", "start_line": 162, "end_line": 168, "docstring": null, "code": "--------------------\n\nA while ago many developers had the idea to read the incoming file in\nsmall chunks and store the upload progress in the database to be able to\npoll the progress with JavaScript from the client. The client asks the\nserver every 5 seconds how much it has transmitted, but this is\nsomething it should already know.", "code_truncated": false}
{"chunk_id": "d6395cf1580a2c23c61b6aefe351cb3cfe92de95", "file_path": "d:\\499\\docs\\patterns\\fileuploads.rst", "symbol_type": "doc", "name": "An Easier Solution", "qualname": "patterns\\fileuploads.rst#An Easier Solution", "start_line": 171, "end_line": 182, "docstring": null, "code": "------------------\n\nNow there are better solutions that work faster and are more reliable. There\nare JavaScript libraries like jQuery_ that have form plugins to ease the\nconstruction of progress bar.\n\nBecause the common pattern for file uploads exists almost unchanged in all\napplications dealing with uploads, there are also some Flask extensions that\nimplement a full fledged upload mechanism that allows controlling which\nfile extensions are allowed to be uploaded.\n\n.. _jQuery: https://jquery.com/", "code_truncated": false}
{"chunk_id": "52081ffd1cba0fb5f29e0a82b1fc763d17e2797a", "file_path": "d:\\499\\docs\\patterns\\flashing.rst", "symbol_type": "doc", "name": "Message Flashing", "qualname": "patterns\\flashing.rst#Message Flashing", "start_line": 2, "end_line": 12, "docstring": null, "code": "================\n\nGood applications and user interfaces are all about feedback.  If the user\ndoes not get enough feedback they will probably end up hating the\napplication.  Flask provides a really simple way to give feedback to a\nuser with the flashing system.  The flashing system basically makes it\npossible to record a message at the end of a request and access it next\nrequest and only next request.  This is usually combined with a layout\ntemplate that does this. Note that browsers and sometimes web servers enforce\na limit on cookie sizes. This means that flashing messages that are too\nlarge for session cookies causes message flashing to fail silently.", "code_truncated": false}
{"chunk_id": "7759d2dd99fb63306acc8abfa97428316d5f0744", "file_path": "d:\\499\\docs\\patterns\\flashing.rst", "symbol_type": "doc", "name": "Simple Flashing", "qualname": "patterns\\flashing.rst#Simple Flashing", "start_line": 15, "end_line": 89, "docstring": null, "code": "---------------\n\nSo here is a full example::\n\n    from flask import Flask, flash, redirect, render_template, \\\n         request, url_for\n\n    app = Flask(__name__)\n    app.secret_key = b'_5#y2L\"F4Q8z\\n\\xec]/'\n\n    @app.route('/')\n    def index():\n        return render_template('index.html')\n\n    @app.route('/login', methods=['GET', 'POST'])\n    def login():\n        error = None\n        if request.method == 'POST':\n            if request.form['username'] != 'admin' or \\\n                    request.form['password'] != 'secret':\n                error = 'Invalid credentials'\n            else:\n                flash('You were successfully logged in')\n                return redirect(url_for('index'))\n        return render_template('login.html', error=error)\n\nAnd here is the :file:`layout.html` template which does the magic:\n\n.. sourcecode:: html+jinja\n\n   <!doctype html>\n   <title>My Application</title>\n   {% with messages = get_flashed_messages() %}\n     {% if messages %}\n       <ul class=flashes>\n       {% for message in messages %}\n         <li>{{ message }}</li>\n       {% endfor %}\n       </ul>\n     {% endif %}\n   {% endwith %}\n   {% block body %}{% endblock %}\n\nHere is the :file:`index.html` template which inherits from :file:`layout.html`:\n\n.. sourcecode:: html+jinja\n\n   {% extends \"layout.html\" %}\n   {% block body %}\n     <h1>Overview</h1>\n     <p>Do you want to <a href=\"{{ url_for('login') }}\">log in?</a>\n   {% endblock %}\n\nAnd here is the :file:`login.html` template which also inherits from\n:file:`layout.html`:\n\n.. sourcecode:: html+jinja\n\n   {% extends \"layout.html\" %}\n   {% block body %}\n     <h1>Login</h1>\n     {% if error %}\n       <p class=error><strong>Error:</strong> {{ error }}\n     {% endif %}\n     <form method=post>\n       <dl>\n         <dt>Username:\n         <dd><input type=text name=username value=\"{{\n             request.form.username }}\">\n         <dt>Password:\n         <dd><input type=password name=password>\n       </dl>\n       <p><input type=submit value=Login>\n     </form>\n   {% endblock %}", "code_truncated": false}
{"chunk_id": "7789a23fade2ca94f10b52565f17dd042c11e661", "file_path": "d:\\499\\docs\\patterns\\flashing.rst", "symbol_type": "doc", "name": "Flashing With Categories", "qualname": "patterns\\flashing.rst#Flashing With Categories", "start_line": 92, "end_line": 124, "docstring": null, "code": "------------------------\n\n.. versionadded:: 0.3\n\nIt is also possible to provide categories when flashing a message.  The\ndefault category if nothing is provided is ``'message'``.  Alternative\ncategories can be used to give the user better feedback.  For example\nerror messages could be displayed with a red background.\n\nTo flash a message with a different category, just use the second argument\nto the :func:`~flask.flash` function::\n\n    flash('Invalid password provided', 'error')\n\nInside the template you then have to tell the\n:func:`~flask.get_flashed_messages` function to also return the\ncategories.  The loop looks slightly different in that situation then:\n\n.. sourcecode:: html+jinja\n\n   {% with messages = get_flashed_messages(with_categories=true) %}\n     {% if messages %}\n       <ul class=flashes>\n       {% for category, message in messages %}\n         <li class=\"{{ category }}\">{{ message }}</li>\n       {% endfor %}\n       </ul>\n     {% endif %}\n   {% endwith %}\n\nThis is just one example of how to render these flashed messages.  One\nmight also use the category to add a prefix such as\n``<strong>Error:</strong>`` to the message.", "code_truncated": false}
{"chunk_id": "aff1fcaec777ce65a6e4303e1cdc7366360a59cb", "file_path": "d:\\499\\docs\\patterns\\flashing.rst", "symbol_type": "doc", "name": "Filtering Flash Messages", "qualname": "patterns\\flashing.rst#Filtering Flash Messages", "start_line": 127, "end_line": 148, "docstring": null, "code": "------------------------\n\n.. versionadded:: 0.9\n\nOptionally you can pass a list of categories which filters the results of\n:func:`~flask.get_flashed_messages`.  This is useful if you wish to\nrender each category in a separate block.\n\n.. sourcecode:: html+jinja\n\n    {% with errors = get_flashed_messages(category_filter=[\"error\"]) %}\n    {% if errors %}\n    <div class=\"alert-message block-message error\">\n      <a class=\"close\" href=\"#\"></a>\n      <ul>\n        {%- for msg in errors %}\n        <li>{{ msg }}</li>\n        {% endfor -%}\n      </ul>\n    </div>\n    {% endif %}\n    {% endwith %}", "code_truncated": false}
{"chunk_id": "e235ce7063009d26a8beb4c1869692c6dce400ad", "file_path": "d:\\499\\docs\\patterns\\index.rst", "symbol_type": "doc", "name": "Patterns for Flask", "qualname": "patterns\\index.rst#Patterns for Flask", "start_line": 2, "end_line": 40, "docstring": null, "code": "==================\n\nCertain features and interactions are common enough that you will find\nthem in most web applications. For example, many applications use a\nrelational database and user authentication. They will open a database\nconnection at the beginning of the request and get the information for\nthe logged in user. At the end of the request, the database connection\nis closed.\n\nThese types of patterns may be a bit outside the scope of Flask itself,\nbut Flask makes it easy to implement them. Some common patterns are\ncollected in the following pages.\n\n.. toctree::\n   :maxdepth: 2\n\n   packages\n   appfactories\n   appdispatch\n   urlprocessors\n   sqlite3\n   sqlalchemy\n   fileuploads\n   caching\n   viewdecorators\n   wtforms\n   templateinheritance\n   flashing\n   javascript\n   lazyloading\n   mongoengine\n   favicon\n   streaming\n   deferredcallbacks\n   methodoverrides\n   requestchecksum\n   celery\n   subclassing\n   singlepageapplications", "code_truncated": false}
{"chunk_id": "955eb2aeadb9e9372a123ac8129d59929f7eb15c", "file_path": "d:\\499\\docs\\patterns\\javascript.rst", "symbol_type": "doc", "name": "JavaScript, ``fetch``, and JSON", "qualname": "patterns\\javascript.rst#JavaScript, ``fetch``, and JSON", "start_line": 2, "end_line": 22, "docstring": null, "code": "===============================\n\nYou may want to make your HTML page dynamic, by changing data without\nreloading the entire page. Instead of submitting an HTML ``<form>`` and\nperforming a redirect to re-render the template, you can add\n`JavaScript`_ that calls |fetch|_ and replaces content on the page.\n\n|fetch|_ is the modern, built-in JavaScript solution to making\nrequests from a page. You may have heard of other \"AJAX\" methods and\nlibraries, such as |XHR|_ or `jQuery`_. These are no longer needed in\nmodern browsers, although you may choose to use them or another library\ndepending on your application's requirements. These docs will only focus\non built-in JavaScript features.\n\n.. _JavaScript: https://developer.mozilla.org/Web/JavaScript\n.. |fetch| replace:: ``fetch()``\n.. _fetch: https://developer.mozilla.org/Web/API/Fetch_API\n.. |XHR| replace:: ``XMLHttpRequest()``\n.. _XHR: https://developer.mozilla.org/Web/API/XMLHttpRequest\n.. _jQuery: https://jquery.com/", "code_truncated": false}
{"chunk_id": "6e800024d3dadc7de91f3646b59d113b530a0ab2", "file_path": "d:\\499\\docs\\patterns\\javascript.rst", "symbol_type": "doc", "name": "Rendering Templates", "qualname": "patterns\\javascript.rst#Rendering Templates", "start_line": 25, "end_line": 60, "docstring": null, "code": "-------------------\n\nIt is important to understand the difference between templates and\nJavaScript. Templates are rendered on the server, before the response is\nsent to the user's browser. JavaScript runs in the user's browser, after\nthe template is rendered and sent. Therefore, it is impossible to use\nJavaScript to affect how the Jinja template is rendered, but it is\npossible to render data into the JavaScript that will run.\n\nTo provide data to JavaScript when rendering the template, use the\n:func:`~jinja-filters.tojson` filter in a ``<script>`` block. This will\nconvert the data to a valid JavaScript object, and ensure that any\nunsafe HTML characters are rendered safely. If you do not use the\n``tojson`` filter, you will get a ``SyntaxError`` in the browser\nconsole.\n\n.. code-block:: python\n\n    data = generate_report()\n    return render_template(\"report.html\", chart_data=data)\n\n.. code-block:: jinja\n\n    <script>\n        const chart_data = {{ chart_data|tojson }}\n        chartLib.makeChart(chart_data)\n    </script>\n\nA less common pattern is to add the data to a ``data-`` attribute on an\nHTML tag. In this case, you must use single quotes around the value, not\ndouble quotes, otherwise you will produce invalid or unsafe HTML.\n\n.. code-block:: jinja\n\n    <div data-chart='{{ chart_data|tojson }}'></div>", "code_truncated": false}
{"chunk_id": "80d137e0d1b327c8392ac5aeec9a841c3cb8b84b", "file_path": "d:\\499\\docs\\patterns\\javascript.rst", "symbol_type": "doc", "name": "Generating URLs", "qualname": "patterns\\javascript.rst#Generating URLs", "start_line": 63, "end_line": 95, "docstring": null, "code": "---------------\n\nThe other way to get data from the server to JavaScript is to make a\nrequest for it. First, you need to know the URL to request.\n\nThe simplest way to generate URLs is to continue to use\n:func:`~flask.url_for` when rendering the template. For example:\n\n.. code-block:: javascript\n\n    const user_url = {{ url_for(\"user\", id=current_user.id)|tojson }}\n    fetch(user_url).then(...)\n\nHowever, you might need to generate a URL based on information you only\nknow in JavaScript. As discussed above, JavaScript runs in the user's\nbrowser, not as part of the template rendering, so you can't use\n``url_for`` at that point.\n\nIn this case, you need to know the \"root URL\" under which your\napplication is served. In simple setups, this is ``/``, but it might\nalso be something else, like ``https://example.com/myapp/``.\n\nA simple way to tell your JavaScript code about this root is to set it\nas a global variable when rendering the template. Then you can use it\nwhen generating URLs from JavaScript.\n\n.. code-block:: javascript\n\n    const SCRIPT_ROOT = {{ request.script_root|tojson }}\n    let user_id = ...  // do something to get a user id from the page\n    let user_url = `${SCRIPT_ROOT}/user/${user_id}`\n    fetch(user_url).then(...)", "code_truncated": false}
{"chunk_id": "1b1f1ca9594623eff88fb45fe9b863207e2ab354", "file_path": "d:\\499\\docs\\patterns\\javascript.rst", "symbol_type": "doc", "name": "Making a Request with ``fetch``", "qualname": "patterns\\javascript.rst#Making a Request with ``fetch``", "start_line": 98, "end_line": 158, "docstring": null, "code": "-------------------------------\n\n|fetch|_ takes two arguments, a URL and an object with other options,\nand returns a |Promise|_. We won't cover all the available options, and\nwill only use ``then()`` on the promise, not other callbacks or\n``await`` syntax. Read the linked MDN docs for more information about\nthose features.\n\nBy default, the GET method is used. If the response contains JSON, it\ncan be used with a ``then()`` callback chain.\n\n.. code-block:: javascript\n\n    const room_url = {{ url_for(\"room_detail\", id=room.id)|tojson }}\n    fetch(room_url)\n        .then(response => response.json())\n        .then(data => {\n            // data is a parsed JSON object\n        })\n\nTo send data, use a data method such as POST, and pass the ``body``\noption. The most common types for data are form data or JSON data.\n\nTo send form data, pass a populated |FormData|_ object. This uses the\nsame format as an HTML form, and would be accessed with ``request.form``\nin a Flask view.\n\n.. code-block:: javascript\n\n    let data = new FormData()\n    data.append(\"name\", \"Flask Room\")\n    data.append(\"description\", \"Talk about Flask here.\")\n    fetch(room_url, {\n        \"method\": \"POST\",\n        \"body\": data,\n    }).then(...)\n\nIn general, prefer sending request data as form data, as would be used\nwhen submitting an HTML form. JSON can represent more complex data, but\nunless you need that it's better to stick with the simpler format. When\nsending JSON data, the ``Content-Type: application/json`` header must be\nsent as well, otherwise Flask will return a 415 Unsupported Media Type\nerror.\n\n.. code-block:: javascript\n\n    let data = {\n        \"name\": \"Flask Room\",\n        \"description\": \"Talk about Flask here.\",\n    }\n    fetch(room_url, {\n        \"method\": \"POST\",\n        \"headers\": {\"Content-Type\": \"application/json\"},\n        \"body\": JSON.stringify(data),\n    }).then(...)\n\n.. |Promise| replace:: ``Promise``\n.. _Promise: https://developer.mozilla.org/Web/JavaScript/Reference/Global_Objects/Promise\n.. |FormData| replace:: ``FormData``\n.. _FormData: https://developer.mozilla.org/en-US/docs/Web/API/FormData", "code_truncated": false}
{"chunk_id": "b70b21d67abb46801724e360f214b05ce4783926", "file_path": "d:\\499\\docs\\patterns\\javascript.rst", "symbol_type": "doc", "name": "Following Redirects", "qualname": "patterns\\javascript.rst#Following Redirects", "start_line": 161, "end_line": 180, "docstring": null, "code": "-------------------\n\nA response might be a redirect, for example if you logged in with\nJavaScript instead of a traditional HTML form, and your view returned\na redirect instead of JSON. JavaScript requests do follow redirects, but\nthey don't change the page. If you want to make the page change you can\ninspect the response and apply the redirect manually.\n\n.. code-block:: javascript\n\n    fetch(\"/login\", {\"body\": ...}).then(\n        response => {\n            if (response.redirected) {\n                window.location = response.url\n            } else {\n                showLoginError()\n            }\n        }\n    )", "code_truncated": false}
{"chunk_id": "62c9bf99d4791a379a7ce4aa5f59eb92fcdcf599", "file_path": "d:\\499\\docs\\patterns\\javascript.rst", "symbol_type": "doc", "name": "Replacing Content", "qualname": "patterns\\javascript.rst#Replacing Content", "start_line": 183, "end_line": 203, "docstring": null, "code": "-----------------\n\nA response might be new HTML, either a new section of the page to add or\nreplace, or an entirely new page. In general, if you're returning the\nentire page, it would be better to handle that with a redirect as shown\nin the previous section. The following example shows how to replace a\n``<div>`` with the HTML returned by a request.\n\n.. code-block:: html\n\n    <div id=\"geology-fact\">\n        {{ include \"geology_fact.html\" }}\n    </div>\n    <script>\n        const geology_url = {{ url_for(\"geology_fact\")|tojson }}\n        const geology_div = getElementById(\"geology-fact\")\n        fetch(geology_url)\n            .then(response => response.text)\n            .then(text => geology_div.innerHTML = text)\n    </script>", "code_truncated": false}
{"chunk_id": "660e6f6ea9bbae0ea090f794693207c6fa9236c7", "file_path": "d:\\499\\docs\\patterns\\javascript.rst", "symbol_type": "doc", "name": "Return JSON from Views", "qualname": "patterns\\javascript.rst#Return JSON from Views", "start_line": 206, "end_line": 241, "docstring": null, "code": "----------------------\n\nTo return a JSON object from your API view, you can directly return a\ndict from the view. It will be serialized to JSON automatically.\n\n.. code-block:: python\n\n    @app.route(\"/user/<int:id>\")\n    def user_detail(id):\n        user = User.query.get_or_404(id)\n        return {\n            \"username\": User.username,\n            \"email\": User.email,\n            \"picture\": url_for(\"static\", filename=f\"users/{id}/profile.png\"),\n        }\n\nIf you want to return another JSON type, use the\n:func:`~flask.json.jsonify` function, which creates a response object\nwith the given data serialized to JSON.\n\n.. code-block:: python\n\n    from flask import jsonify\n\n    @app.route(\"/users\")\n    def user_list():\n        users = User.query.order_by(User.name).all()\n        return jsonify([u.to_json() for u in users])\n\nIt is usually not a good idea to return file data in a JSON response.\nJSON cannot represent binary data directly, so it must be base64\nencoded, which can be slow, takes more bandwidth to send, and is not as\neasy to cache. Instead, serve files using one view, and generate a URL\nto the desired file to include in the JSON. Then the client can make a\nseparate request to get the linked resource after getting the JSON.", "code_truncated": false}
{"chunk_id": "9138ab7d0f126b83befa9c5d2ed02660763cae13", "file_path": "d:\\499\\docs\\patterns\\javascript.rst", "symbol_type": "doc", "name": "Receiving JSON in Views", "qualname": "patterns\\javascript.rst#Receiving JSON in Views", "start_line": 244, "end_line": 261, "docstring": null, "code": "-----------------------\n\nUse the :attr:`~flask.Request.json` property of the\n:data:`~flask.request` object to decode the request's body as JSON. If\nthe body is not valid JSON, a 400 Bad Request error will be raised. If\nthe ``Content-Type`` header is not set to ``application/json``, a 415\nUnsupported Media Type error will be raised.\n\n.. code-block:: python\n\n    from flask import request\n\n    @app.post(\"/user/<int:id>\")\n    def user_update(id):\n        user = User.query.get_or_404(id)\n        user.update_from_json(request.json)\n        db.session.commit()\n        return user.to_json()", "code_truncated": false}
{"chunk_id": "ca502951dca7f01e955af9cc2216440e2942ea70", "file_path": "d:\\499\\docs\\patterns\\jquery.rst", "symbol_type": "doc", "name": "INTRO", "qualname": "patterns\\jquery.rst#INTRO", "start_line": 1, "end_line": 1, "docstring": null, "code": ":orphan:", "code_truncated": false}
{"chunk_id": "ffff51ba89192a9956408500169c621c8f5299a5", "file_path": "d:\\499\\docs\\patterns\\jquery.rst", "symbol_type": "doc", "name": "AJAX with jQuery", "qualname": "patterns\\jquery.rst#AJAX with jQuery", "start_line": 4, "end_line": 6, "docstring": null, "code": "================\n\nObsolete, see :doc:`/patterns/javascript` instead.", "code_truncated": false}
{"chunk_id": "b8ba60a112ff513bbc44016e7bf2e8d2da12952b", "file_path": "d:\\499\\docs\\patterns\\lazyloading.rst", "symbol_type": "doc", "name": "Lazily Loading Views", "qualname": "patterns\\lazyloading.rst#Lazily Loading Views", "start_line": 2, "end_line": 17, "docstring": null, "code": "====================\n\nFlask is usually used with the decorators.  Decorators are simple and you\nhave the URL right next to the function that is called for that specific\nURL.  However there is a downside to this approach: it means all your code\nthat uses decorators has to be imported upfront or Flask will never\nactually find your function.\n\nThis can be a problem if your application has to import quick.  It might\nhave to do that on systems like Google's App Engine or other systems.  So\nif you suddenly notice that your application outgrows this approach you\ncan fall back to a centralized URL mapping.\n\nThe system that enables having a central URL map is the\n:meth:`~flask.Flask.add_url_rule` function.  Instead of using decorators,\nyou have a file that sets up the application with all URLs.", "code_truncated": false}
{"chunk_id": "25ee5502825f37cffc812679c1a87096e0e728d9", "file_path": "d:\\499\\docs\\patterns\\lazyloading.rst", "symbol_type": "doc", "name": "Converting to Centralized URL Map", "qualname": "patterns\\lazyloading.rst#Converting to Centralized URL Map", "start_line": 20, "end_line": 51, "docstring": null, "code": "---------------------------------\n\nImagine the current application looks somewhat like this::\n\n    from flask import Flask\n    app = Flask(__name__)\n\n    @app.route('/')\n    def index():\n        pass\n\n    @app.route('/user/<username>')\n    def user(username):\n        pass\n\nThen, with the centralized approach you would have one file with the views\n(:file:`views.py`) but without any decorator::\n\n    def index():\n        pass\n\n    def user(username):\n        pass\n\nAnd then a file that sets up an application which maps the functions to\nURLs::\n\n    from flask import Flask\n    from yourapplication import views\n    app = Flask(__name__)\n    app.add_url_rule('/', view_func=views.index)\n    app.add_url_rule('/user/<username>', view_func=views.user)", "code_truncated": false}
{"chunk_id": "7d5835da5a5dad40af31caaa718bbe8c8d535baf", "file_path": "d:\\499\\docs\\patterns\\lazyloading.rst", "symbol_type": "doc", "name": "Loading Late", "qualname": "patterns\\lazyloading.rst#Loading Late", "start_line": 54, "end_line": 109, "docstring": null, "code": "------------\n\nSo far we only split up the views and the routing, but the module is still\nloaded upfront.  The trick is to actually load the view function as needed.\nThis can be accomplished with a helper class that behaves just like a\nfunction but internally imports the real function on first use::\n\n    from werkzeug.utils import import_string, cached_property\n\n    class LazyView(object):\n\n        def __init__(self, import_name):\n            self.__module__, self.__name__ = import_name.rsplit('.', 1)\n            self.import_name = import_name\n\n        @cached_property\n        def view(self):\n            return import_string(self.import_name)\n\n        def __call__(self, *args, **kwargs):\n            return self.view(*args, **kwargs)\n\nWhat's important here is is that `__module__` and `__name__` are properly\nset.  This is used by Flask internally to figure out how to name the\nURL rules in case you don't provide a name for the rule yourself.\n\nThen you can define your central place to combine the views like this::\n\n    from flask import Flask\n    from yourapplication.helpers import LazyView\n    app = Flask(__name__)\n    app.add_url_rule('/',\n                     view_func=LazyView('yourapplication.views.index'))\n    app.add_url_rule('/user/<username>',\n                     view_func=LazyView('yourapplication.views.user'))\n\nYou can further optimize this in terms of amount of keystrokes needed to\nwrite this by having a function that calls into\n:meth:`~flask.Flask.add_url_rule` by prefixing a string with the project\nname and a dot, and by wrapping `view_func` in a `LazyView` as needed.  ::\n\n    def url(import_name, url_rules=[], **options):\n        view = LazyView(f\"yourapplication.{import_name}\")\n        for url_rule in url_rules:\n            app.add_url_rule(url_rule, view_func=view, **options)\n\n    # add a single route to the index view\n    url('views.index', ['/'])\n\n    # add two routes to a single function endpoint\n    url_rules = ['/user/','/user/<username>']\n    url('views.user', url_rules)\n\nOne thing to keep in mind is that before and after request handlers have\nto be in a file that is imported upfront to work properly on the first\nrequest.  The same goes for any kind of remaining decorator.", "code_truncated": false}
{"chunk_id": "05e7995db8e956822b6ca37041bc4c6ba5ef38b7", "file_path": "d:\\499\\docs\\patterns\\methodoverrides.rst", "symbol_type": "doc", "name": "Adding HTTP Method Overrides", "qualname": "patterns\\methodoverrides.rst#Adding HTTP Method Overrides", "start_line": 2, "end_line": 42, "docstring": null, "code": "============================\n\nSome HTTP proxies do not support arbitrary HTTP methods or newer HTTP\nmethods (such as PATCH). In that case it's possible to \"proxy\" HTTP\nmethods through another HTTP method in total violation of the protocol.\n\nThe way this works is by letting the client do an HTTP POST request and\nset the ``X-HTTP-Method-Override`` header. Then the method is replaced\nwith the header value before being passed to Flask.\n\nThis can be accomplished with an HTTP middleware::\n\n    class HTTPMethodOverrideMiddleware(object):\n        allowed_methods = frozenset([\n            'GET',\n            'HEAD',\n            'POST',\n            'DELETE',\n            'PUT',\n            'PATCH',\n            'OPTIONS'\n        ])\n        bodyless_methods = frozenset(['GET', 'HEAD', 'OPTIONS', 'DELETE'])\n\n        def __init__(self, app):\n            self.app = app\n\n        def __call__(self, environ, start_response):\n            method = environ.get('HTTP_X_HTTP_METHOD_OVERRIDE', '').upper()\n            if method in self.allowed_methods:\n                environ['REQUEST_METHOD'] = method\n            if method in self.bodyless_methods:\n                environ['CONTENT_LENGTH'] = '0'\n            return self.app(environ, start_response)\n\nTo use this with Flask, wrap the app object with the middleware::\n\n    from flask import Flask\n\n    app = Flask(__name__)\n    app.wsgi_app = HTTPMethodOverrideMiddleware(app.wsgi_app)", "code_truncated": false}
{"chunk_id": "0a57ffeb5fe830395ae0bd68942f82869a7e21c1", "file_path": "d:\\499\\docs\\patterns\\mongoengine.rst", "symbol_type": "doc", "name": "MongoDB with MongoEngine", "qualname": "patterns\\mongoengine.rst#MongoDB with MongoEngine", "start_line": 2, "end_line": 14, "docstring": null, "code": "========================\n\nUsing a document database like MongoDB is a common alternative to\nrelational SQL databases. This pattern shows how to use\n`MongoEngine`_, a document mapper library, to integrate with MongoDB.\n\nA running MongoDB server and `Flask-MongoEngine`_ are required. ::\n\n    pip install flask-mongoengine\n\n.. _MongoEngine: http://mongoengine.org\n.. _Flask-MongoEngine: https://flask-mongoengine.readthedocs.io", "code_truncated": false}
{"chunk_id": "a38240e24eaf8a46ab153d50dbcb0f206414a2c8", "file_path": "d:\\499\\docs\\patterns\\mongoengine.rst", "symbol_type": "doc", "name": "Configuration", "qualname": "patterns\\mongoengine.rst#Configuration", "start_line": 17, "end_line": 30, "docstring": null, "code": "-------------\n\nBasic setup can be done by defining ``MONGODB_SETTINGS`` on\n``app.config`` and creating a ``MongoEngine`` instance. ::\n\n    from flask import Flask\n    from flask_mongoengine import MongoEngine\n\n    app = Flask(__name__)\n    app.config['MONGODB_SETTINGS'] = {\n        \"db\": \"myapp\",\n    }\n    db = MongoEngine(app)", "code_truncated": false}
{"chunk_id": "1b2ef3a5ebf2ebafec2573eca03521ab81a9ef2c", "file_path": "d:\\499\\docs\\patterns\\mongoengine.rst", "symbol_type": "doc", "name": "Mapping Documents", "qualname": "patterns\\mongoengine.rst#Mapping Documents", "start_line": 33, "end_line": 59, "docstring": null, "code": "-----------------\n\nTo declare a model that represents a Mongo document, create a class that\ninherits from ``Document`` and declare each of the fields. ::\n\n    import mongoengine as me\n\n    class Movie(me.Document):\n        title = me.StringField(required=True)\n        year = me.IntField()\n        rated = me.StringField()\n        director = me.StringField()\n        actors = me.ListField()\n\nIf the document has nested fields, use ``EmbeddedDocument`` to\ndefined the fields of the embedded document and\n``EmbeddedDocumentField`` to declare it on the parent document. ::\n\n    class Imdb(me.EmbeddedDocument):\n        imdb_id = me.StringField()\n        rating = me.DecimalField()\n        votes = me.IntField()\n\n    class Movie(me.Document):\n        ...\n        imdb = me.EmbeddedDocumentField(Imdb)", "code_truncated": false}
{"chunk_id": "ccd75386d058a5535b68e98b62b773bf2e61026d", "file_path": "d:\\499\\docs\\patterns\\mongoengine.rst", "symbol_type": "doc", "name": "Creating Data", "qualname": "patterns\\mongoengine.rst#Creating Data", "start_line": 62, "end_line": 75, "docstring": null, "code": "-------------\n\nInstantiate your document class with keyword arguments for the fields.\nYou can also assign values to the field attributes after instantiation.\nThen call ``doc.save()``. ::\n\n    bttf = Movie(title=\"Back To The Future\", year=1985)\n    bttf.actors = [\n        \"Michael J. Fox\",\n        \"Christopher Lloyd\"\n    ]\n    bttf.imdb = Imdb(imdb_id=\"tt0088763\", rating=8.5)\n    bttf.save()", "code_truncated": false}
{"chunk_id": "11159893bce1e84d00a295089e778d787a4c454f", "file_path": "d:\\499\\docs\\patterns\\mongoengine.rst", "symbol_type": "doc", "name": "Queries", "qualname": "patterns\\mongoengine.rst#Queries", "start_line": 78, "end_line": 93, "docstring": null, "code": "-------\n\nUse the class ``objects`` attribute to make queries. A keyword argument\nlooks for an equal value on the field. ::\n\n    bttf = Movie.objects(title=\"Back To The Future\").get_or_404()\n\nQuery operators may be used by concatenating them with the field name\nusing a double-underscore. ``objects``, and queries returned by\ncalling it, are iterable. ::\n\n    some_theron_movie = Movie.objects(actors__in=[\"Charlize Theron\"]).first()\n\n    for recents in Movie.objects(year__gte=2017):\n        print(recents.title)", "code_truncated": false}
{"chunk_id": "465e4e93fed903d8170655abe3165ba921d08bf7", "file_path": "d:\\499\\docs\\patterns\\mongoengine.rst", "symbol_type": "doc", "name": "Documentation", "qualname": "patterns\\mongoengine.rst#Documentation", "start_line": 96, "end_line": 103, "docstring": null, "code": "-------------\n\nThere are many more ways to define and query documents with MongoEngine.\nFor more information, check out the `official documentation\n<MongoEngine_>`_.\n\nFlask-MongoEngine adds helpful utilities on top of MongoEngine. Check\nout their `documentation <Flask-MongoEngine_>`_ as well.", "code_truncated": false}
{"chunk_id": "6d86d2ffa84f535edbb40bad699ff32756d1b169", "file_path": "d:\\499\\docs\\patterns\\packages.rst", "symbol_type": "doc", "name": "Large Applications as Packages", "qualname": "patterns\\packages.rst#Large Applications as Packages", "start_line": 2, "end_line": 19, "docstring": null, "code": "==============================\n\nImagine a simple flask application structure that looks like this::\n\n    /yourapplication\n        yourapplication.py\n        /static\n            style.css\n        /templates\n            layout.html\n            index.html\n            login.html\n            ...\n\nWhile this is fine for small applications, for larger applications\nit's a good idea to use a package instead of a module.\nThe :doc:`/tutorial/index` is structured to use the package pattern,\nsee the :gh:`example code <examples/tutorial>`.", "code_truncated": false}
{"chunk_id": "24f9b49816e871df3f86e48b1792e135c8b92e49", "file_path": "d:\\499\\docs\\patterns\\packages.rst", "symbol_type": "doc", "name": "Simple Packages", "qualname": "patterns\\packages.rst#Simple Packages", "start_line": 22, "end_line": 125, "docstring": null, "code": "---------------\n\nTo convert that into a larger one, just create a new folder\n:file:`yourapplication` inside the existing one and move everything below it.\nThen rename :file:`yourapplication.py` to :file:`__init__.py`.  (Make sure to delete\nall ``.pyc`` files first, otherwise things would most likely break)\n\nYou should then end up with something like that::\n\n    /yourapplication\n        /yourapplication\n            __init__.py\n            /static\n                style.css\n            /templates\n                layout.html\n                index.html\n                login.html\n                ...\n\nBut how do you run your application now?  The naive ``python\nyourapplication/__init__.py`` will not work.  Let's just say that Python\ndoes not want modules in packages to be the startup file.  But that is not\na big problem, just add a new file called :file:`pyproject.toml` next to the inner\n:file:`yourapplication` folder with the following contents:\n\n.. code-block:: toml\n\n    [project]\n    name = \"yourapplication\"\n    dependencies = [\n        \"flask\",\n    ]\n\n    [build-system]\n    requires = [\"flit_core<4\"]\n    build-backend = \"flit_core.buildapi\"\n\nInstall your application so it is importable:\n\n.. code-block:: text\n\n    $ pip install -e .\n\nTo use the ``flask`` command and run your application you need to set\nthe ``--app`` option that tells Flask where to find the application\ninstance:\n\n.. code-block:: text\n\n    $ flask --app yourapplication run\n\nWhat did we gain from this?  Now we can restructure the application a bit\ninto multiple modules.  The only thing you have to remember is the\nfollowing quick checklist:\n\n1. the `Flask` application object creation has to be in the\n   :file:`__init__.py` file.  That way each module can import it safely and the\n   `__name__` variable will resolve to the correct package.\n2. all the view functions (the ones with a :meth:`~flask.Flask.route`\n   decorator on top) have to be imported in the :file:`__init__.py` file.\n   Not the object itself, but the module it is in. Import the view module\n   **after the application object is created**.\n\nHere's an example :file:`__init__.py`::\n\n    from flask import Flask\n    app = Flask(__name__)\n\n    import yourapplication.views\n\nAnd this is what :file:`views.py` would look like::\n\n    from yourapplication import app\n\n    @app.route('/')\n    def index():\n        return 'Hello World!'\n\nYou should then end up with something like that::\n\n    /yourapplication\n        pyproject.toml\n        /yourapplication\n            __init__.py\n            views.py\n            /static\n                style.css\n            /templates\n                layout.html\n                index.html\n                login.html\n                ...\n\n.. admonition:: Circular Imports\n\n   Every Python programmer hates them, and yet we just added some:\n   circular imports (That's when two modules depend on each other.  In this\n   case :file:`views.py` depends on :file:`__init__.py`).  Be advised that this is a\n   bad idea in general but here it is actually fine.  The reason for this is\n   that we are not actually using the views in :file:`__init__.py` and just\n   ensuring the module is imported and we are doing that at the bottom of\n   the file.", "code_truncated": false}
{"chunk_id": "9aacb64c295dc3dab2ee7327126827915e262f1a", "file_path": "d:\\499\\docs\\patterns\\packages.rst", "symbol_type": "doc", "name": "Working with Blueprints", "qualname": "patterns\\packages.rst#Working with Blueprints", "start_line": 128, "end_line": 133, "docstring": null, "code": "-----------------------\n\nIf you have larger applications it's recommended to divide them into\nsmaller groups where each group is implemented with the help of a\nblueprint.  For a gentle introduction into this topic refer to the\n:doc:`/blueprints` chapter of the documentation.", "code_truncated": false}
{"chunk_id": "d0bb16c41c127de530691c95255c24e78c522734", "file_path": "d:\\499\\docs\\patterns\\requestchecksum.rst", "symbol_type": "doc", "name": "Request Content Checksums", "qualname": "patterns\\requestchecksum.rst#Request Content Checksums", "start_line": 2, "end_line": 55, "docstring": null, "code": "=========================\n\nVarious pieces of code can consume the request data and preprocess it.\nFor instance JSON data ends up on the request object already read and\nprocessed, form data ends up there as well but goes through a different\ncode path.  This seems inconvenient when you want to calculate the\nchecksum of the incoming request data.  This is necessary sometimes for\nsome APIs.\n\nFortunately this is however very simple to change by wrapping the input\nstream.\n\nThe following example calculates the SHA1 checksum of the incoming data as\nit gets read and stores it in the WSGI environment::\n\n    import hashlib\n\n    class ChecksumCalcStream(object):\n\n        def __init__(self, stream):\n            self._stream = stream\n            self._hash = hashlib.sha1()\n\n        def read(self, bytes):\n            rv = self._stream.read(bytes)\n            self._hash.update(rv)\n            return rv\n\n        def readline(self, size_hint):\n            rv = self._stream.readline(size_hint)\n            self._hash.update(rv)\n            return rv\n\n    def generate_checksum(request):\n        env = request.environ\n        stream = ChecksumCalcStream(env['wsgi.input'])\n        env['wsgi.input'] = stream\n        return stream._hash\n\nTo use this, all you need to do is to hook the calculating stream in\nbefore the request starts consuming data.  (Eg: be careful accessing\n``request.form`` or anything of that nature.  ``before_request_handlers``\nfor instance should be careful not to access it).\n\nExample usage::\n\n    @app.route('/special-api', methods=['POST'])\n    def special_api():\n        hash = generate_checksum(request)\n        # Accessing this parses the input stream\n        files = request.files\n        # At this point the hash is fully constructed.\n        checksum = hash.hexdigest()\n        return f\"Hash was: {checksum}\"", "code_truncated": false}
{"chunk_id": "3f77decb139b2c3fb7442577db0e723008a687b2", "file_path": "d:\\499\\docs\\patterns\\singlepageapplications.rst", "symbol_type": "doc", "name": "Single-Page Applications", "qualname": "patterns\\singlepageapplications.rst#Single-Page Applications", "start_line": 2, "end_line": 24, "docstring": null, "code": "========================\n\nFlask can be used to serve Single-Page Applications (SPA) by placing static\nfiles produced by your frontend framework in a subfolder inside of your\nproject. You will also need to create a catch-all endpoint that routes all\nrequests to your SPA.\n\nThe following example demonstrates how to serve an SPA along with an API::\n\n    from flask import Flask, jsonify\n\n    app = Flask(__name__, static_folder='app', static_url_path=\"/app\")\n\n\n    @app.route(\"/heartbeat\")\n    def heartbeat():\n        return jsonify({\"status\": \"healthy\"})\n\n\n    @app.route('/', defaults={'path': ''})\n    @app.route('/<path:path>')\n    def catch_all(path):\n        return app.send_static_file(\"index.html\")", "code_truncated": false}
{"chunk_id": "9ee9e4ace90f971332a02c54d36ef9570ba774b9", "file_path": "d:\\499\\docs\\patterns\\sqlalchemy.rst", "symbol_type": "doc", "name": "SQLAlchemy in Flask", "qualname": "patterns\\sqlalchemy.rst#SQLAlchemy in Flask", "start_line": 2, "end_line": 10, "docstring": null, "code": "===================\n\nMany people prefer `SQLAlchemy`_ for database access.  In this case it's\nencouraged to use a package instead of a module for your flask application\nand drop the models into a separate module (:doc:`packages`). While that\nis not necessary, it makes a lot of sense.\n\nThere are four very common ways to use SQLAlchemy.  I will outline each\nof them here:", "code_truncated": false}
{"chunk_id": "c81cd6395848b1597798e2a3b1eceea9ca91eca1", "file_path": "d:\\499\\docs\\patterns\\sqlalchemy.rst", "symbol_type": "doc", "name": "Flask-SQLAlchemy Extension", "qualname": "patterns\\sqlalchemy.rst#Flask-SQLAlchemy Extension", "start_line": 13, "end_line": 24, "docstring": null, "code": "--------------------------\n\nBecause SQLAlchemy is a common database abstraction layer and object\nrelational mapper that requires a little bit of configuration effort,\nthere is a Flask extension that handles that for you.  This is recommended\nif you want to get started quickly.\n\nYou can download `Flask-SQLAlchemy`_ from `PyPI\n<https://pypi.org/project/Flask-SQLAlchemy/>`_.\n\n.. _Flask-SQLAlchemy: https://flask-sqlalchemy.palletsprojects.com/", "code_truncated": false}
{"chunk_id": "acaffd0fc1aa4a14ec5eb8f40061bf0aa19e0eaa", "file_path": "d:\\499\\docs\\patterns\\sqlalchemy.rst", "symbol_type": "doc", "name": "Declarative", "qualname": "patterns\\sqlalchemy.rst#Declarative", "start_line": 27, "end_line": 109, "docstring": null, "code": "-----------\n\nThe declarative extension in SQLAlchemy is the most recent method of using\nSQLAlchemy.  It allows you to define tables and models in one go, similar\nto how Django works.  In addition to the following text I recommend the\nofficial documentation on the `declarative`_ extension.\n\nHere's the example :file:`database.py` module for your application::\n\n    from sqlalchemy import create_engine\n    from sqlalchemy.orm import scoped_session, sessionmaker, declarative_base\n\n    engine = create_engine('sqlite:////tmp/test.db')\n    db_session = scoped_session(sessionmaker(autocommit=False,\n                                             autoflush=False,\n                                             bind=engine))\n    Base = declarative_base()\n    Base.query = db_session.query_property()\n\n    def init_db():\n        # import all modules here that might define models so that\n        # they will be registered properly on the metadata.  Otherwise\n        # you will have to import them first before calling init_db()\n        import yourapplication.models\n        Base.metadata.create_all(bind=engine)\n\nTo define your models, just subclass the `Base` class that was created by\nthe code above.  If you are wondering why we don't have to care about\nthreads here (like we did in the SQLite3 example above with the\n:data:`~flask.g` object): that's because SQLAlchemy does that for us\nalready with the :class:`~sqlalchemy.orm.scoped_session`.\n\nTo use SQLAlchemy in a declarative way with your application, you just\nhave to put the following code into your application module.  Flask will\nautomatically remove database sessions at the end of the request or\nwhen the application shuts down::\n\n    from yourapplication.database import db_session\n\n    @app.teardown_appcontext\n    def shutdown_session(exception=None):\n        db_session.remove()\n\nHere is an example model (put this into :file:`models.py`, e.g.)::\n\n    from sqlalchemy import Column, Integer, String\n    from yourapplication.database import Base\n\n    class User(Base):\n        __tablename__ = 'users'\n        id = Column(Integer, primary_key=True)\n        name = Column(String(50), unique=True)\n        email = Column(String(120), unique=True)\n\n        def __init__(self, name=None, email=None):\n            self.name = name\n            self.email = email\n\n        def __repr__(self):\n            return f'<User {self.name!r}>'\n\nTo create the database you can use the `init_db` function:\n\n>>> from yourapplication.database import init_db\n>>> init_db()\n\nYou can insert entries into the database like this:\n\n>>> from yourapplication.database import db_session\n>>> from yourapplication.models import User\n>>> u = User('admin', 'admin@localhost')\n>>> db_session.add(u)\n>>> db_session.commit()\n\nQuerying is simple as well:\n\n>>> User.query.all()\n[<User 'admin'>]\n>>> User.query.filter(User.name == 'admin').first()\n<User 'admin'>\n\n.. _SQLAlchemy: https://www.sqlalchemy.org/\n.. _declarative: https://docs.sqlalchemy.org/en/latest/orm/extensions/declarative/", "code_truncated": false}
{"chunk_id": "439e536ee72d657e02d5be217d9ba5ef516417eb", "file_path": "d:\\499\\docs\\patterns\\sqlalchemy.rst", "symbol_type": "doc", "name": "Manual Object Relational Mapping", "qualname": "patterns\\sqlalchemy.rst#Manual Object Relational Mapping", "start_line": 112, "end_line": 167, "docstring": null, "code": "--------------------------------\n\nManual object relational mapping has a few upsides and a few downsides\nversus the declarative approach from above.  The main difference is that\nyou define tables and classes separately and map them together.  It's more\nflexible but a little more to type.  In general it works like the\ndeclarative approach, so make sure to also split up your application into\nmultiple modules in a package.\n\nHere is an example :file:`database.py` module for your application::\n\n    from sqlalchemy import create_engine, MetaData\n    from sqlalchemy.orm import scoped_session, sessionmaker\n\n    engine = create_engine('sqlite:////tmp/test.db')\n    metadata = MetaData()\n    db_session = scoped_session(sessionmaker(autocommit=False,\n                                             autoflush=False,\n                                             bind=engine))\n    def init_db():\n        metadata.create_all(bind=engine)\n\nAs in the declarative approach, you need to close the session after each app\ncontext. Put this into your application module::\n\n    from yourapplication.database import db_session\n\n    @app.teardown_appcontext\n    def shutdown_session(exception=None):\n        db_session.remove()\n\nHere is an example table and model (put this into :file:`models.py`)::\n\n    from sqlalchemy import Table, Column, Integer, String\n    from sqlalchemy.orm import mapper\n    from yourapplication.database import metadata, db_session\n\n    class User(object):\n        query = db_session.query_property()\n\n        def __init__(self, name=None, email=None):\n            self.name = name\n            self.email = email\n\n        def __repr__(self):\n            return f'<User {self.name!r}>'\n\n    users = Table('users', metadata,\n        Column('id', Integer, primary_key=True),\n        Column('name', String(50), unique=True),\n        Column('email', String(120), unique=True)\n    )\n    mapper(User, users)\n\nQuerying and inserting works exactly the same as in the example above.", "code_truncated": false}
{"chunk_id": "07373a40eeb008464228a5bb05b6b5a9cdeabe48", "file_path": "d:\\499\\docs\\patterns\\sqlalchemy.rst", "symbol_type": "doc", "name": "SQL Abstraction Layer", "qualname": "patterns\\sqlalchemy.rst#SQL Abstraction Layer", "start_line": 170, "end_line": 213, "docstring": null, "code": "---------------------\n\nIf you just want to use the database system (and SQL) abstraction layer\nyou basically only need the engine::\n\n    from sqlalchemy import create_engine, MetaData, Table\n\n    engine = create_engine('sqlite:////tmp/test.db')\n    metadata = MetaData(bind=engine)\n\nThen you can either declare the tables in your code like in the examples\nabove, or automatically load them::\n\n    from sqlalchemy import Table\n\n    users = Table('users', metadata, autoload=True)\n\nTo insert data you can use the `insert` method.  We have to get a\nconnection first so that we can use a transaction:\n\n>>> con = engine.connect()\n>>> con.execute(users.insert(), name='admin', email='admin@localhost')\n\nSQLAlchemy will automatically commit for us.\n\nTo query your database, you use the engine directly or use a connection:\n\n>>> users.select(users.c.id == 1).execute().first()\n(1, 'admin', 'admin@localhost')\n\nThese results are also dict-like tuples:\n\n>>> r = users.select(users.c.id == 1).execute().first()\n>>> r['name']\n'admin'\n\nYou can also pass strings of SQL statements to the\n:meth:`~sqlalchemy.engine.base.Connection.execute` method:\n\n>>> engine.execute('select * from users where id = :1', [1]).first()\n(1, 'admin', 'admin@localhost')\n\nFor more information about SQLAlchemy, head over to the\n`website <https://www.sqlalchemy.org/>`_.", "code_truncated": false}
{"chunk_id": "07a88c956428510c6f27526a756c9805596e7bd7", "file_path": "d:\\499\\docs\\patterns\\sqlite3.rst", "symbol_type": "doc", "name": "Using SQLite 3 with Flask", "qualname": "patterns\\sqlite3.rst#Using SQLite 3 with Flask", "start_line": 2, "end_line": 46, "docstring": null, "code": "=========================\n\nYou can implement a few functions to work with a SQLite connection during a\nrequest context. The connection is created the first time it's accessed,\nreused on subsequent access, until it is closed when the request context ends.\n\nHere is a simple example of how you can use SQLite 3 with Flask::\n\n    import sqlite3\n    from flask import g\n\n    DATABASE = '/path/to/database.db'\n\n    def get_db():\n        db = getattr(g, '_database', None)\n        if db is None:\n            db = g._database = sqlite3.connect(DATABASE)\n        return db\n\n    @app.teardown_appcontext\n    def close_connection(exception):\n        db = getattr(g, '_database', None)\n        if db is not None:\n            db.close()\n\nNow, to use the database, the application must either have an active\napplication context (which is always true if there is a request in flight)\nor create an application context itself.  At that point the ``get_db``\nfunction can be used to get the current database connection.  Whenever the\ncontext is destroyed the database connection will be terminated.\n\nExample::\n\n    @app.route('/')\n    def index():\n        cur = get_db().cursor()\n        ...\n\n\n.. note::\n\n   Please keep in mind that the teardown request and appcontext functions\n   are always executed, even if a before-request handler failed or was\n   never executed.  Because of this we have to make sure here that the\n   database is there before we close it.", "code_truncated": false}
{"chunk_id": "efdf8cc624f959f935dcb820e403951d622ef62d", "file_path": "d:\\499\\docs\\patterns\\sqlite3.rst", "symbol_type": "doc", "name": "Connect on Demand", "qualname": "patterns\\sqlite3.rst#Connect on Demand", "start_line": 49, "end_line": 58, "docstring": null, "code": "-----------------\n\nThe upside of this approach (connecting on first use) is that this will\nonly open the connection if truly necessary.  If you want to use this\ncode outside a request context you can use it in a Python shell by opening\nthe application context by hand::\n\n    with app.app_context():\n        # now you can use get_db()", "code_truncated": false}
{"chunk_id": "eab8dafed3ddfa697b9a9cd0db2c16df460d3b58", "file_path": "d:\\499\\docs\\patterns\\sqlite3.rst", "symbol_type": "doc", "name": "Easy Querying", "qualname": "patterns\\sqlite3.rst#Easy Querying", "start_line": 61, "end_line": 127, "docstring": null, "code": "-------------\n\nNow in each request handling function you can access `get_db()` to get the\ncurrent open database connection.  To simplify working with SQLite, a\nrow factory function is useful.  It is executed for every result returned\nfrom the database to convert the result.  For instance, in order to get\ndictionaries instead of tuples, this could be inserted into the ``get_db``\nfunction we created above::\n\n    def make_dicts(cursor, row):\n        return dict((cursor.description[idx][0], value)\n                    for idx, value in enumerate(row))\n\n    db.row_factory = make_dicts\n\nThis will make the sqlite3 module return dicts for this database connection, which are much nicer to deal with. Even more simply, we could place this in ``get_db`` instead::\n\n    db.row_factory = sqlite3.Row\n\nThis would use Row objects rather than dicts to return the results of queries. These are ``namedtuple`` s, so we can access them either by index or by key. For example, assuming we have a ``sqlite3.Row`` called ``r`` for the rows ``id``, ``FirstName``, ``LastName``, and ``MiddleInitial``::\n\n    >>> # You can get values based on the row's name\n    >>> r['FirstName']\n    John\n    >>> # Or, you can get them based on index\n    >>> r[1]\n    John\n    # Row objects are also iterable:\n    >>> for value in r:\n    ...     print(value)\n    1\n    John\n    Doe\n    M\n\nAdditionally, it is a good idea to provide a query function that combines\ngetting the cursor, executing and fetching the results::\n\n    def query_db(query, args=(), one=False):\n        cur = get_db().execute(query, args)\n        rv = cur.fetchall()\n        cur.close()\n        return (rv[0] if rv else None) if one else rv\n\nThis handy little function, in combination with a row factory, makes\nworking with the database much more pleasant than it is by just using the\nraw cursor and connection objects.\n\nHere is how you can use it::\n\n    for user in query_db('select * from users'):\n        print(user['username'], 'has the id', user['user_id'])\n\nOr if you just want a single result::\n\n    user = query_db('select * from users where username = ?',\n                    [the_username], one=True)\n    if user is None:\n        print('No such user')\n    else:\n        print(the_username, 'has the id', user['user_id'])\n\nTo pass variable parts to the SQL statement, use a question mark in the\nstatement and pass in the arguments as a list.  Never directly add them to\nthe SQL statement with string formatting because this makes it possible\nto attack the application using `SQL Injections\n<https://en.wikipedia.org/wiki/SQL_injection>`_.", "code_truncated": false}
{"chunk_id": "de7a22615013764cea7c468e6fc184ded15ffb83", "file_path": "d:\\499\\docs\\patterns\\sqlite3.rst", "symbol_type": "doc", "name": "Initial Schemas", "qualname": "patterns\\sqlite3.rst#Initial Schemas", "start_line": 130, "end_line": 147, "docstring": null, "code": "---------------\n\nRelational databases need schemas, so applications often ship a\n`schema.sql` file that creates the database.  It's a good idea to provide\na function that creates the database based on that schema.  This function\ncan do that for you::\n\n    def init_db():\n        with app.app_context():\n            db = get_db()\n            with app.open_resource('schema.sql', mode='r') as f:\n                db.cursor().executescript(f.read())\n            db.commit()\n\nYou can then create such a database from the Python shell:\n\n>>> from yourapplication import init_db\n>>> init_db()", "code_truncated": false}
{"chunk_id": "bc3e10e4e7ecf2485a2b462d8ff78e38eb285184", "file_path": "d:\\499\\docs\\patterns\\streaming.rst", "symbol_type": "doc", "name": "Streaming Contents", "qualname": "patterns\\streaming.rst#Streaming Contents", "start_line": 2, "end_line": 9, "docstring": null, "code": "==================\n\nSometimes you want to send an enormous amount of data to the client, much\nmore than you want to keep in memory.  When you are generating the data on\nthe fly though, how do you send that back to the client without the\nroundtrip to the filesystem?\n\nThe answer is by using generators and direct responses.", "code_truncated": false}
{"chunk_id": "5d7480200e40f11abc23fb13a1890b1fdf0eb76c", "file_path": "d:\\499\\docs\\patterns\\streaming.rst", "symbol_type": "doc", "name": "Basic Usage", "qualname": "patterns\\streaming.rst#Basic Usage", "start_line": 12, "end_line": 27, "docstring": null, "code": "-----------\n\nThis is a basic view function that generates a lot of CSV data on the fly.\nThe trick is to have an inner function that uses a generator to generate\ndata and to then invoke that function and pass it to a response object::\n\n    @app.route('/large.csv')\n    def generate_large_csv():\n        def generate():\n            for row in iter_all_rows():\n                yield f\"{','.join(row)}\\n\"\n        return generate(), {\"Content-Type\": \"text/csv\"}\n\nEach ``yield`` expression is directly sent to the browser.  Note though\nthat some WSGI middlewares might break streaming, so be careful there in\ndebug environments with profilers and other things you might have enabled.", "code_truncated": false}
{"chunk_id": "0fbb9dfa71f16148c8c8a4a536570402a9f21a6f", "file_path": "d:\\499\\docs\\patterns\\streaming.rst", "symbol_type": "doc", "name": "Streaming from Templates", "qualname": "patterns\\streaming.rst#Streaming from Templates", "start_line": 30, "end_line": 47, "docstring": null, "code": "------------------------\n\nThe Jinja template engine supports rendering a template piece by\npiece, returning an iterator of strings. Flask provides the\n:func:`~flask.stream_template` and :func:`~flask.stream_template_string`\nfunctions to make this easier to use.\n\n.. code-block:: python\n\n    from flask import stream_template\n\n    @app.get(\"/timeline\")\n    def timeline():\n        return stream_template(\"timeline.html\")\n\nThe parts yielded by the render stream tend to match statement blocks in\nthe template.", "code_truncated": false}
{"chunk_id": "ddbffa9459d587f5a13ebae00a904a92aee9de6a", "file_path": "d:\\499\\docs\\patterns\\streaming.rst", "symbol_type": "doc", "name": "Streaming with Context", "qualname": "patterns\\streaming.rst#Streaming with Context", "start_line": 50, "end_line": 85, "docstring": null, "code": "----------------------\n\nThe :data:`.request` proxy will not be active while the generator is\nrunning, because the app has already returned control to the WSGI server at that\npoint. If you try to access ``request``, you'll get a ``RuntimeError``.\n\nIf your generator function relies on data in ``request``, use the\n:func:`.stream_with_context` wrapper. This will keep the request context active\nduring the generator.\n\n.. code-block:: python\n\n    from flask import stream_with_context, request\n    from markupsafe import escape\n\n    @app.route('/stream')\n    def streamed_response():\n        def generate():\n            yield '<p>Hello '\n            yield escape(request.args['name'])\n            yield '!</p>'\n        return stream_with_context(generate())\n\nIt can also be used as a decorator.\n\n.. code-block:: python\n\n    @stream_with_context\n    def generate():\n        ...\n\n    return generate()\n\nThe :func:`~flask.stream_template` and\n:func:`~flask.stream_template_string` functions automatically\nuse :func:`~flask.stream_with_context` if a request is active.", "code_truncated": false}
{"chunk_id": "68527413c64da978356dd835ff5cd413c6b84016", "file_path": "d:\\499\\docs\\patterns\\subclassing.rst", "symbol_type": "doc", "name": "Subclassing Flask", "qualname": "patterns\\subclassing.rst#Subclassing Flask", "start_line": 2, "end_line": 17, "docstring": null, "code": "=================\n\nThe :class:`~flask.Flask` class is designed for subclassing.\n\nFor example, you may want to override how request parameters are handled to preserve their order::\n\n    from flask import Flask, Request\n    from werkzeug.datastructures import ImmutableOrderedMultiDict\n    class MyRequest(Request):\n        \"\"\"Request subclass to override request parameter storage\"\"\"\n        parameter_storage_class = ImmutableOrderedMultiDict\n    class MyFlask(Flask):\n        \"\"\"Flask subclass using the custom request class\"\"\"\n        request_class = MyRequest\n\nThis is the recommended approach for overriding or augmenting Flask's internal functionality.", "code_truncated": false}
{"chunk_id": "7aef91b2fbe92cd9e0955f2e3ad10b4de5e293d5", "file_path": "d:\\499\\docs\\patterns\\templateinheritance.rst", "symbol_type": "doc", "name": "Template Inheritance", "qualname": "patterns\\templateinheritance.rst#Template Inheritance", "start_line": 2, "end_line": 10, "docstring": null, "code": "====================\n\nThe most powerful part of Jinja is template inheritance. Template inheritance\nallows you to build a base \"skeleton\" template that contains all the common\nelements of your site and defines **blocks** that child templates can override.\n\nSounds complicated but is very basic. It's easiest to understand it by starting\nwith an example.", "code_truncated": false}
{"chunk_id": "71cb77b84d7fc641b69e748d5b58574d65f4d2af", "file_path": "d:\\499\\docs\\patterns\\templateinheritance.rst", "symbol_type": "doc", "name": "Base Template", "qualname": "patterns\\templateinheritance.rst#Base Template", "start_line": 13, "end_line": 41, "docstring": null, "code": "-------------\n\nThis template, which we'll call :file:`layout.html`, defines a simple HTML skeleton\ndocument that you might use for a simple two-column page. It's the job of\n\"child\" templates to fill the empty blocks with content:\n\n.. sourcecode:: html+jinja\n\n    <!doctype html>\n    <html>\n      <head>\n        {% block head %}\n        <link rel=\"stylesheet\" href=\"{{ url_for('static', filename='style.css') }}\">\n        <title>{% block title %}{% endblock %} - My Webpage</title>\n        {% endblock %}\n      </head>\n      <body>\n        <div id=\"content\">{% block content %}{% endblock %}</div>\n        <div id=\"footer\">\n          {% block footer %}\n          &copy; Copyright 2010 by <a href=\"http://domain.invalid/\">you</a>.\n          {% endblock %}\n        </div>\n      </body>\n    </html>\n\nIn this example, the ``{% block %}`` tags define four blocks that child templates\ncan fill in. All the `block` tag does is tell the template engine that a\nchild template may override those portions of the template.", "code_truncated": false}
{"chunk_id": "2c984a66be5ebb56267369ff373a64f88de136e9", "file_path": "d:\\499\\docs\\patterns\\templateinheritance.rst", "symbol_type": "doc", "name": "Child Template", "qualname": "patterns\\templateinheritance.rst#Child Template", "start_line": 44, "end_line": 68, "docstring": null, "code": "--------------\n\nA child template might look like this:\n\n.. sourcecode:: html+jinja\n\n    {% extends \"layout.html\" %}\n    {% block title %}Index{% endblock %}\n    {% block head %}\n      {{ super() }}\n      <style type=\"text/css\">\n        .important { color: #336699; }\n      </style>\n    {% endblock %}\n    {% block content %}\n      <h1>Index</h1>\n      <p class=\"important\">\n        Welcome on my awesome homepage.\n    {% endblock %}\n\nThe ``{% extends %}`` tag is the key here. It tells the template engine that\nthis template \"extends\" another template.  When the template system evaluates\nthis template, first it locates the parent.  The extends tag must be the\nfirst tag in the template.  To render the contents of a block defined in\nthe parent template, use ``{{ super() }}``.", "code_truncated": false}
{"chunk_id": "29d4f53b8ad3a6f2ae8678e3155e60c12412013f", "file_path": "d:\\499\\docs\\patterns\\urlprocessors.rst", "symbol_type": "doc", "name": "Using URL Processors", "qualname": "patterns\\urlprocessors.rst#Using URL Processors", "start_line": 2, "end_line": 14, "docstring": null, "code": "====================\n\n.. versionadded:: 0.7\n\nFlask 0.7 introduces the concept of URL processors.  The idea is that you\nmight have a bunch of resources with common parts in the URL that you\ndon't always explicitly want to provide.  For instance you might have a\nbunch of URLs that have the language code in it but you don't want to have\nto handle it in every single function yourself.\n\nURL processors are especially helpful when combined with blueprints.  We\nwill handle both application specific URL processors here as well as\nblueprint specifics.", "code_truncated": false}
{"chunk_id": "63a7d675aae7727083cf4aa4e02c02193fb0b878", "file_path": "d:\\499\\docs\\patterns\\urlprocessors.rst", "symbol_type": "doc", "name": "Internationalized Application URLs", "qualname": "patterns\\urlprocessors.rst#Internationalized Application URLs", "start_line": 17, "end_line": 96, "docstring": null, "code": "----------------------------------\n\nConsider an application like this::\n\n    from flask import Flask, g\n\n    app = Flask(__name__)\n\n    @app.route('/<lang_code>/')\n    def index(lang_code):\n        g.lang_code = lang_code\n        ...\n\n    @app.route('/<lang_code>/about')\n    def about(lang_code):\n        g.lang_code = lang_code\n        ...\n\nThis is an awful lot of repetition as you have to handle the language code\nsetting on the :data:`~flask.g` object yourself in every single function.\nSure, a decorator could be used to simplify this, but if you want to\ngenerate URLs from one function to another you would have to still provide\nthe language code explicitly which can be annoying.\n\nFor the latter, this is where :func:`~flask.Flask.url_defaults` functions\ncome in.  They can automatically inject values into a call to\n:func:`~flask.url_for`.  The code below checks if the\nlanguage code is not yet in the dictionary of URL values and if the\nendpoint wants a value named ``'lang_code'``::\n\n    @app.url_defaults\n    def add_language_code(endpoint, values):\n        if 'lang_code' in values or not g.lang_code:\n            return\n        if app.url_map.is_endpoint_expecting(endpoint, 'lang_code'):\n            values['lang_code'] = g.lang_code\n\nThe method :meth:`~werkzeug.routing.Map.is_endpoint_expecting` of the URL\nmap can be used to figure out if it would make sense to provide a language\ncode for the given endpoint.\n\nThe reverse of that function are\n:meth:`~flask.Flask.url_value_preprocessor`\\s.  They are executed right\nafter the request was matched and can execute code based on the URL\nvalues.  The idea is that they pull information out of the values\ndictionary and put it somewhere else::\n\n    @app.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        g.lang_code = values.pop('lang_code', None)\n\nThat way you no longer have to do the `lang_code` assignment to\n:data:`~flask.g` in every function.  You can further improve that by\nwriting your own decorator that prefixes URLs with the language code, but\nthe more beautiful solution is using a blueprint.  Once the\n``'lang_code'`` is popped from the values dictionary and it will no longer\nbe forwarded to the view function reducing the code to this::\n\n    from flask import Flask, g\n\n    app = Flask(__name__)\n\n    @app.url_defaults\n    def add_language_code(endpoint, values):\n        if 'lang_code' in values or not g.lang_code:\n            return\n        if app.url_map.is_endpoint_expecting(endpoint, 'lang_code'):\n            values['lang_code'] = g.lang_code\n\n    @app.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        g.lang_code = values.pop('lang_code', None)\n\n    @app.route('/<lang_code>/')\n    def index():\n        ...\n\n    @app.route('/<lang_code>/about')\n    def about():\n        ...", "code_truncated": false}
{"chunk_id": "5edc3854bc6e299995a238306701c413b39ab299", "file_path": "d:\\499\\docs\\patterns\\urlprocessors.rst", "symbol_type": "doc", "name": "Internationalized Blueprint URLs", "qualname": "patterns\\urlprocessors.rst#Internationalized Blueprint URLs", "start_line": 99, "end_line": 126, "docstring": null, "code": "--------------------------------\n\nBecause blueprints can automatically prefix all URLs with a common string\nit's easy to automatically do that for every function.  Furthermore\nblueprints can have per-blueprint URL processors which removes a whole lot\nof logic from the :meth:`~flask.Flask.url_defaults` function because it no\nlonger has to check if the URL is really interested in a ``'lang_code'``\nparameter::\n\n    from flask import Blueprint, g\n\n    bp = Blueprint('frontend', __name__, url_prefix='/<lang_code>')\n\n    @bp.url_defaults\n    def add_language_code(endpoint, values):\n        values.setdefault('lang_code', g.lang_code)\n\n    @bp.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        g.lang_code = values.pop('lang_code')\n\n    @bp.route('/')\n    def index():\n        ...\n\n    @bp.route('/about')\n    def about():\n        ...", "code_truncated": false}
{"chunk_id": "0e4c4431ea4ff62c7a711b992aada6a7b824774f", "file_path": "d:\\499\\docs\\patterns\\viewdecorators.rst", "symbol_type": "doc", "name": "View Decorators", "qualname": "patterns\\viewdecorators.rst#View Decorators", "start_line": 2, "end_line": 13, "docstring": null, "code": "===============\n\nPython has a really interesting feature called function decorators.  This\nallows some really neat things for web applications.  Because each view in\nFlask is a function, decorators can be used to inject additional\nfunctionality to one or more functions.  The :meth:`~flask.Flask.route`\ndecorator is the one you probably used already.  But there are use cases\nfor implementing your own decorator.  For instance, imagine you have a\nview that should only be used by people that are logged in.  If a user\ngoes to the site and is not logged in, they should be redirected to the\nlogin page.  This is a good example of a use case where a decorator is an\nexcellent solution.", "code_truncated": false}
{"chunk_id": "beb990ae34957b938cc7411ffbc7fdb892888efb", "file_path": "d:\\499\\docs\\patterns\\viewdecorators.rst", "symbol_type": "doc", "name": "Login Required Decorator", "qualname": "patterns\\viewdecorators.rst#Login Required Decorator", "start_line": 16, "end_line": 54, "docstring": null, "code": "------------------------\n\nSo let's implement such a decorator.  A decorator is a function that\nwraps and replaces another function.  Since the original function is\nreplaced, you need to remember to copy the original function's information\nto the new function.  Use :func:`functools.wraps` to handle this for you.\n\nThis example assumes that the login page is called ``'login'`` and that\nthe current user is stored in ``g.user`` and is ``None`` if there is no-one\nlogged in. ::\n\n    from functools import wraps\n    from flask import g, request, redirect, url_for\n\n    def login_required(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            if g.user is None:\n                return redirect(url_for('login', next=request.url))\n            return f(*args, **kwargs)\n        return decorated_function\n\nTo use the decorator, apply it as innermost decorator to a view function.\nWhen applying further decorators, always remember\nthat the :meth:`~flask.Flask.route` decorator is the outermost. ::\n\n    @app.route('/secret_page')\n    @login_required\n    def secret_page():\n        pass\n\n.. note::\n    The ``next`` value will exist in ``request.args`` after a ``GET`` request for\n    the login page.  You'll have to pass it along when sending the ``POST`` request\n    from the login form.  You can do this with a hidden input tag, then retrieve it\n    from ``request.form`` when logging the user in. ::\n\n        <input type=\"hidden\" value=\"{{ request.args.get('next', '') }}\"/>", "code_truncated": false}
{"chunk_id": "3a3074bebaca167139dc3f79ddaf7b3d52f547e7", "file_path": "d:\\499\\docs\\patterns\\viewdecorators.rst", "symbol_type": "doc", "name": "Caching Decorator", "qualname": "patterns\\viewdecorators.rst#Caching Decorator", "start_line": 57, "end_line": 101, "docstring": null, "code": "-----------------\n\nImagine you have a view function that does an expensive calculation and\nbecause of that you would like to cache the generated results for a\ncertain amount of time.  A decorator would be nice for that.  We're\nassuming you have set up a cache like mentioned in :doc:`caching`.\n\nHere is an example cache function.  It generates the cache key from a\nspecific prefix (actually a format string) and the current path of the\nrequest.  Notice that we are using a function that first creates the\ndecorator that then decorates the function.  Sounds awful? Unfortunately\nit is a little bit more complex, but the code should still be\nstraightforward to read.\n\nThe decorated function will then work as follows\n\n1. get the unique cache key for the current request based on the current\n   path.\n2. get the value for that key from the cache. If the cache returned\n   something we will return that value.\n3. otherwise the original function is called and the return value is\n   stored in the cache for the timeout provided (by default 5 minutes).\n\nHere the code::\n\n    from functools import wraps\n    from flask import request\n\n    def cached(timeout=5 * 60, key='view/{}'):\n        def decorator(f):\n            @wraps(f)\n            def decorated_function(*args, **kwargs):\n                cache_key = key.format(request.path)\n                rv = cache.get(cache_key)\n                if rv is not None:\n                    return rv\n                rv = f(*args, **kwargs)\n                cache.set(cache_key, rv, timeout=timeout)\n                return rv\n            return decorated_function\n        return decorator\n\nNotice that this assumes an instantiated ``cache`` object is available, see\n:doc:`caching`.", "code_truncated": false}
{"chunk_id": "e7ada88a704079511a50b0c65d44167c0c3ae5df", "file_path": "d:\\499\\docs\\patterns\\viewdecorators.rst", "symbol_type": "doc", "name": "Templating Decorator", "qualname": "patterns\\viewdecorators.rst#Templating Decorator", "start_line": 104, "end_line": 154, "docstring": null, "code": "--------------------\n\nA common pattern invented by the TurboGears guys a while back is a\ntemplating decorator.  The idea of that decorator is that you return a\ndictionary with the values passed to the template from the view function\nand the template is automatically rendered.  With that, the following\nthree examples do exactly the same::\n\n    @app.route('/')\n    def index():\n        return render_template('index.html', value=42)\n\n    @app.route('/')\n    @templated('index.html')\n    def index():\n        return dict(value=42)\n\n    @app.route('/')\n    @templated()\n    def index():\n        return dict(value=42)\n\nAs you can see, if no template name is provided it will use the endpoint\nof the URL map with dots converted to slashes + ``'.html'``.  Otherwise\nthe provided template name is used.  When the decorated function returns,\nthe dictionary returned is passed to the template rendering function.  If\n``None`` is returned, an empty dictionary is assumed, if something else than\na dictionary is returned we return it from the function unchanged.  That\nway you can still use the redirect function or return simple strings.\n\nHere is the code for that decorator::\n\n    from functools import wraps\n    from flask import request, render_template\n\n    def templated(template=None):\n        def decorator(f):\n            @wraps(f)\n            def decorated_function(*args, **kwargs):\n                template_name = template\n                if template_name is None:\n                    template_name = f\"{request.endpoint.replace('.', '/')}.html\"\n                ctx = f(*args, **kwargs)\n                if ctx is None:\n                    ctx = {}\n                elif not isinstance(ctx, dict):\n                    return ctx\n                return render_template(template_name, **ctx)\n            return decorated_function\n        return decorator", "code_truncated": false}
{"chunk_id": "388432c8a433a35b8e7906f704ab3d3ec76915b4", "file_path": "d:\\499\\docs\\patterns\\viewdecorators.rst", "symbol_type": "doc", "name": "Endpoint Decorator", "qualname": "patterns\\viewdecorators.rst#Endpoint Decorator", "start_line": 157, "end_line": 171, "docstring": null, "code": "------------------\n\nWhen you want to use the werkzeug routing system for more flexibility you\nneed to map the endpoint as defined in the :class:`~werkzeug.routing.Rule`\nto a view function. This is possible with this decorator. For example::\n\n    from flask import Flask\n    from werkzeug.routing import Rule\n\n    app = Flask(__name__)\n    app.url_map.add(Rule('/', endpoint='index'))\n\n    @app.endpoint('index')\n    def my_index():\n        return \"Hello world\"", "code_truncated": false}
{"chunk_id": "27ad49541c39d41e1a4ef451396863ce65691318", "file_path": "d:\\499\\docs\\patterns\\wtforms.rst", "symbol_type": "doc", "name": "Form Validation with WTForms", "qualname": "patterns\\wtforms.rst#Form Validation with WTForms", "start_line": 2, "end_line": 22, "docstring": null, "code": "============================\n\nWhen you have to work with form data submitted by a browser view, code\nquickly becomes very hard to read.  There are libraries out there designed\nto make this process easier to manage.  One of them is `WTForms`_ which we\nwill handle here.  If you find yourself in the situation of having many\nforms, you might want to give it a try.\n\nWhen you are working with WTForms you have to define your forms as classes\nfirst.  I recommend breaking up the application into multiple modules\n(:doc:`packages`) for that and adding a separate module for the\nforms.\n\n.. admonition:: Getting the most out of WTForms with an Extension\n\n   The `Flask-WTF`_ extension expands on this pattern and adds a\n   few little helpers that make working with forms and Flask more\n   fun.  You can get it from `PyPI\n   <https://pypi.org/project/Flask-WTF/>`_.\n\n.. _Flask-WTF: https://flask-wtf.readthedocs.io/", "code_truncated": false}
{"chunk_id": "802ba757eeee50ccdf8027f962cd1d30a4476975", "file_path": "d:\\499\\docs\\patterns\\wtforms.rst", "symbol_type": "doc", "name": "The Forms", "qualname": "patterns\\wtforms.rst#The Forms", "start_line": 25, "end_line": 39, "docstring": null, "code": "---------\n\nThis is an example form for a typical registration page::\n\n    from wtforms import Form, BooleanField, StringField, PasswordField, validators\n\n    class RegistrationForm(Form):\n        username = StringField('Username', [validators.Length(min=4, max=25)])\n        email = StringField('Email Address', [validators.Length(min=6, max=35)])\n        password = PasswordField('New Password', [\n            validators.DataRequired(),\n            validators.EqualTo('confirm', message='Passwords must match')\n        ])\n        confirm = PasswordField('Repeat Password')\n        accept_tos = BooleanField('I accept the TOS', [validators.DataRequired()])", "code_truncated": false}
{"chunk_id": "a261c3c3064ebdd47b3d21c5f89029750144948b", "file_path": "d:\\499\\docs\\patterns\\wtforms.rst", "symbol_type": "doc", "name": "In the View", "qualname": "patterns\\wtforms.rst#In the View", "start_line": 42, "end_line": 69, "docstring": null, "code": "-----------\n\nIn the view function, the usage of this form looks like this::\n\n    @app.route('/register', methods=['GET', 'POST'])\n    def register():\n        form = RegistrationForm(request.form)\n        if request.method == 'POST' and form.validate():\n            user = User(form.username.data, form.email.data,\n                        form.password.data)\n            db_session.add(user)\n            flash('Thanks for registering')\n            return redirect(url_for('login'))\n        return render_template('register.html', form=form)\n\nNotice we're implying that the view is using SQLAlchemy here\n(:doc:`sqlalchemy`), but that's not a requirement, of course.  Adapt\nthe code as necessary.\n\nThings to remember:\n\n1. create the form from the request :attr:`~flask.request.form` value if\n   the data is submitted via the HTTP ``POST`` method and\n   :attr:`~flask.request.args` if the data is submitted as ``GET``.\n2. to validate the data, call the :func:`~wtforms.form.Form.validate`\n   method, which will return ``True`` if the data validates, ``False``\n   otherwise.\n3. to access individual values from the form, access `form.<NAME>.data`.", "code_truncated": false}
{"chunk_id": "ca1fd22b3e068ad8236224d8c8e3941b8b7fd73c", "file_path": "d:\\499\\docs\\patterns\\wtforms.rst", "symbol_type": "doc", "name": "Forms in Templates", "qualname": "patterns\\wtforms.rst#Forms in Templates", "start_line": 72, "end_line": 126, "docstring": null, "code": "------------------\n\nNow to the template side.  When you pass the form to the templates, you can\neasily render them there.  Look at the following example template to see\nhow easy this is.  WTForms does half the form generation for us already.\nTo make it even nicer, we can write a macro that renders a field with\nlabel and a list of errors if there are any.\n\nHere's an example :file:`_formhelpers.html` template with such a macro:\n\n.. sourcecode:: html+jinja\n\n    {% macro render_field(field) %}\n      <dt>{{ field.label }}\n      <dd>{{ field(**kwargs)|safe }}\n      {% if field.errors %}\n        <ul class=errors>\n        {% for error in field.errors %}\n          <li>{{ error }}</li>\n        {% endfor %}\n        </ul>\n      {% endif %}\n      </dd>\n    {% endmacro %}\n\nThis macro accepts a couple of keyword arguments that are forwarded to\nWTForm's field function, which renders the field for us.  The keyword\narguments will be inserted as HTML attributes.  So, for example, you can\ncall ``render_field(form.username, class='username')`` to add a class to\nthe input element.  Note that WTForms returns standard Python strings,\nso we have to tell Jinja that this data is already HTML-escaped with\nthe ``|safe`` filter.\n\nHere is the :file:`register.html` template for the function we used above, which\ntakes advantage of the :file:`_formhelpers.html` template:\n\n.. sourcecode:: html+jinja\n\n    {% from \"_formhelpers.html\" import render_field %}\n    <form method=post>\n      <dl>\n        {{ render_field(form.username) }}\n        {{ render_field(form.email) }}\n        {{ render_field(form.password) }}\n        {{ render_field(form.confirm) }}\n        {{ render_field(form.accept_tos) }}\n      </dl>\n      <p><input type=submit value=Register>\n    </form>\n\nFor more information about WTForms, head over to the `WTForms\nwebsite`_.\n\n.. _WTForms: https://wtforms.readthedocs.io/\n.. _WTForms website: https://wtforms.readthedocs.io/", "code_truncated": false}
{"chunk_id": "32265fe033821f6fd6d33f0a542c4c317cae882f", "file_path": "d:\\499\\docs\\quickstart.rst", "symbol_type": "doc", "name": "Quickstart", "qualname": "quickstart.rst#Quickstart", "start_line": 2, "end_line": 6, "docstring": null, "code": "==========\n\nEager to get started? This page gives a good introduction to Flask.\nFollow :doc:`installation` to set up a project and install Flask first.", "code_truncated": false}
{"chunk_id": "b8d264939f986dd785aa678ba5bdd6772ecf3dc9", "file_path": "d:\\499\\docs\\quickstart.rst", "symbol_type": "doc", "name": "A Minimal Application", "qualname": "quickstart.rst#A Minimal Application", "start_line": 9, "end_line": 85, "docstring": null, "code": "---------------------\n\nA minimal Flask application looks something like this:\n\n.. code-block:: python\n\n    from flask import Flask\n\n    app = Flask(__name__)\n\n    @app.route(\"/\")\n    def hello_world():\n        return \"<p>Hello, World!</p>\"\n\nSo what did that code do?\n\n1.  First we imported the :class:`~flask.Flask` class. An instance of\n    this class will be our WSGI application.\n2.  Next we create an instance of this class. The first argument is the\n    name of the application's module or package. ``__name__`` is a\n    convenient shortcut for this that is appropriate for most cases.\n    This is needed so that Flask knows where to look for resources such\n    as templates and static files.\n3.  We then use the :meth:`~flask.Flask.route` decorator to tell Flask\n    what URL should trigger our function.\n4.  The function returns the message we want to display in the user's\n    browser. The default content type is HTML, so HTML in the string\n    will be rendered by the browser.\n\nSave it as :file:`hello.py` or something similar. Make sure to not call\nyour application :file:`flask.py` because this would conflict with Flask\nitself.\n\nTo run the application, use the ``flask`` command or\n``python -m flask``. You need to tell the Flask where your application\nis with the ``--app`` option.\n\n.. code-block:: text\n\n    $ flask --app hello run\n     * Serving Flask app 'hello'\n     * Running on http://127.0.0.1:5000 (Press CTRL+C to quit)\n\n.. admonition:: Application Discovery Behavior\n\n    As a shortcut, if the file is named ``app.py`` or ``wsgi.py``, you\n    don't have to use ``--app``. See :doc:`/cli` for more details.\n\nThis launches a very simple builtin server, which is good enough for\ntesting but probably not what you want to use in production. For\ndeployment options see :doc:`deploying/index`.\n\nNow head over to http://127.0.0.1:5000/, and you should see your hello\nworld greeting.\n\nIf another program is already using port 5000, you'll see\n``OSError: [Errno 98]`` or ``OSError: [WinError 10013]`` when the\nserver tries to start. See :ref:`address-already-in-use` for how to\nhandle that.\n\n.. _public-server:\n\n.. admonition:: Externally Visible Server\n\n   If you run the server you will notice that the server is only accessible\n   from your own computer, not from any other in the network.  This is the\n   default because in debugging mode a user of the application can execute\n   arbitrary Python code on your computer.\n\n   If you have the debugger disabled or trust the users on your network,\n   you can make the server publicly available simply by adding\n   ``--host=0.0.0.0`` to the command line::\n\n       $ flask run --host=0.0.0.0\n\n   This tells your operating system to listen on all public IPs.", "code_truncated": false}
{"chunk_id": "5f8c8a591bc479a1686302aca6a8081f98d2b952", "file_path": "d:\\499\\docs\\quickstart.rst", "symbol_type": "doc", "name": "Debug Mode", "qualname": "quickstart.rst#Debug Mode", "start_line": 88, "end_line": 126, "docstring": null, "code": "----------\n\nThe ``flask run`` command can do more than just start the development\nserver. By enabling debug mode, the server will automatically reload if\ncode changes, and will show an interactive debugger in the browser if an\nerror occurs during a request.\n\n.. image:: _static/debugger.png\n    :align: center\n    :class: screenshot\n    :alt: The interactive debugger in action.\n\n.. warning::\n\n    The debugger allows executing arbitrary Python code from the\n    browser. It is protected by a pin, but still represents a major\n    security risk. Do not run the development server or debugger in a\n    production environment.\n\nTo enable debug mode, use the ``--debug`` option.\n\n.. code-block:: text\n\n    $ flask --app hello run --debug\n     * Serving Flask app 'hello'\n     * Debug mode: on\n     * Running on http://127.0.0.1:5000 (Press CTRL+C to quit)\n     * Restarting with stat\n     * Debugger is active!\n     * Debugger PIN: nnn-nnn-nnn\n\nSee also:\n\n-   :doc:`/server` and :doc:`/cli` for information about running in debug mode.\n-   :doc:`/debugging` for information about using the built-in debugger\n    and other debuggers.\n-   :doc:`/logging` and :doc:`/errorhandling` to log errors and display\n    nice error pages.", "code_truncated": false}
{"chunk_id": "3f4c35aa993725f9557f7ebf3271d1976f552b91", "file_path": "d:\\499\\docs\\quickstart.rst", "symbol_type": "doc", "name": "HTML Escaping", "qualname": "quickstart.rst#HTML Escaping", "start_line": 129, "end_line": 152, "docstring": null, "code": "-------------\n\nWhen returning HTML (the default response type in Flask), any\nuser-provided values rendered in the output must be escaped to protect\nfrom injection attacks. HTML templates rendered with Jinja, introduced\nlater, will do this automatically.\n\n:func:`~markupsafe.escape`, shown here, can be used manually. It is\nomitted in most examples for brevity, but you should always be aware of\nhow you're using untrusted data.\n\n.. code-block:: python\n\n    from flask import request\n    from markupsafe import escape\n\n    @app.route(\"/hello\")\n    def hello():\n        name = request.args.get(\"name\", \"Flask\")\n        return f\"Hello, {escape(name)}!\"\n\nIf a user submits ``/hello?name=<script>alert(\"bad\")</script>``, escaping causes\nit to be rendered as text, rather than running the script in the user's browser.", "code_truncated": false}
{"chunk_id": "7d1019f76b38b9cdbbb008c08f4b1fa63c4496b3", "file_path": "d:\\499\\docs\\quickstart.rst", "symbol_type": "doc", "name": "Routing", "qualname": "quickstart.rst#Routing", "start_line": 155, "end_line": 172, "docstring": null, "code": "-------\n\nModern web applications use meaningful URLs to help users. Users are more\nlikely to like a page and come back if the page uses a meaningful URL they can\nremember and use to directly visit a page.\n\nUse the :meth:`~flask.Flask.route` decorator to bind a function to a URL. ::\n\n    @app.route('/')\n    def index():\n        return 'Index Page'\n\n    @app.route('/hello')\n    def hello():\n        return 'Hello, World'\n\nYou can do more! You can make parts of the URL dynamic and attach multiple\nrules to a function.", "code_truncated": false}
{"chunk_id": "cd2ff35c1454d20400088fe184398bf98581d8f9", "file_path": "d:\\499\\docs\\quickstart.rst", "symbol_type": "doc", "name": "Variable Rules", "qualname": "quickstart.rst#Variable Rules", "start_line": 175, "end_line": 208, "docstring": null, "code": "``````````````\n\nYou can add variable sections to a URL by marking sections with\n``<variable_name>``. Your function then receives the ``<variable_name>``\nas a keyword argument. Optionally, you can use a converter to specify the type\nof the argument like ``<converter:variable_name>``. ::\n\n    from markupsafe import escape\n\n    @app.route('/user/<username>')\n    def show_user_profile(username):\n        # show the user profile for that user\n        return f'User {escape(username)}'\n\n    @app.route('/post/<int:post_id>')\n    def show_post(post_id):\n        # show the post with the given id, the id is an integer\n        return f'Post {post_id}'\n\n    @app.route('/path/<path:subpath>')\n    def show_subpath(subpath):\n        # show the subpath after /path/\n        return f'Subpath {escape(subpath)}'\n\nConverter types:\n\n========== ==========================================\n``string`` (default) accepts any text without a slash\n``int``    accepts positive integers\n``float``  accepts positive floating point values\n``path``   like ``string`` but also accepts slashes\n``uuid``   accepts UUID strings\n========== ==========================================", "code_truncated": false}
{"chunk_id": "1ffebb224443dc05f89cd7607f3681365e6dc40b", "file_path": "d:\\499\\docs\\quickstart.rst", "symbol_type": "doc", "name": "Unique URLs / Redirection Behavior", "qualname": "quickstart.rst#Unique URLs / Redirection Behavior", "start_line": 211, "end_line": 235, "docstring": null, "code": "``````````````````````````````````\n\nThe following two rules differ in their use of a trailing slash. ::\n\n    @app.route('/projects/')\n    def projects():\n        return 'The project page'\n\n    @app.route('/about')\n    def about():\n        return 'The about page'\n\nThe canonical URL for the ``projects`` endpoint has a trailing slash.\nIt's similar to a folder in a file system. If you access the URL without\na trailing slash (``/projects``), Flask redirects you to the canonical URL\nwith the trailing slash (``/projects/``).\n\nThe canonical URL for the ``about`` endpoint does not have a trailing\nslash. It's similar to the pathname of a file. Accessing the URL with a\ntrailing slash (``/about/``) produces a 404 \"Not Found\" error. This helps\nkeep URLs unique for these resources, which helps search engines avoid\nindexing the same page twice.\n\n\n.. _url-building:", "code_truncated": false}
{"chunk_id": "18525e4abf62011742a626cdc5bff3e9e69c4dff", "file_path": "d:\\499\\docs\\quickstart.rst", "symbol_type": "doc", "name": "URL Building", "qualname": "quickstart.rst#URL Building", "start_line": 238, "end_line": 291, "docstring": null, "code": "````````````\n\nTo build a URL to a specific function, use the :func:`~flask.url_for` function.\nIt accepts the name of the function as its first argument and any number of\nkeyword arguments, each corresponding to a variable part of the URL rule.\nUnknown variable parts are appended to the URL as query parameters.\n\nWhy would you want to build URLs using the URL reversing function\n:func:`~flask.url_for` instead of hard-coding them into your templates?\n\n1. Reversing is often more descriptive than hard-coding the URLs.\n2. You can change your URLs in one go instead of needing to remember to\n   manually change hard-coded URLs.\n3. URL building handles escaping of special characters transparently.\n4. The generated paths are always absolute, avoiding unexpected behavior\n   of relative paths in browsers.\n5. If your application is placed outside the URL root, for example, in\n   ``/myapplication`` instead of ``/``, :func:`~flask.url_for` properly\n   handles that for you.\n\nFor example, here we use the :meth:`~flask.Flask.test_request_context` method\nto try out :func:`~flask.url_for`. :meth:`~flask.Flask.test_request_context`\ntells Flask to behave as though it's handling a request even while we use a\nPython shell. See :doc:`/appcontext`.\n\n.. code-block:: python\n\n    from flask import url_for\n\n    @app.route('/')\n    def index():\n        return 'index'\n\n    @app.route('/login')\n    def login():\n        return 'login'\n\n    @app.route('/user/<username>')\n    def profile(username):\n        return f'{username}\\'s profile'\n\n    with app.test_request_context():\n        print(url_for('index'))\n        print(url_for('login'))\n        print(url_for('login', next='/'))\n        print(url_for('profile', username='John Doe'))\n\n.. code-block:: text\n\n    /\n    /login\n    /login?next=/\n    /user/John%20Doe", "code_truncated": false}
{"chunk_id": "46e0245dc43c4f2b32433aa9e46d569b79b5c36c", "file_path": "d:\\499\\docs\\quickstart.rst", "symbol_type": "doc", "name": "HTTP Methods", "qualname": "quickstart.rst#HTTP Methods", "start_line": 294, "end_line": 333, "docstring": null, "code": "````````````\n\nWeb applications use different HTTP methods when accessing URLs. You should\nfamiliarize yourself with the HTTP methods as you work with Flask. By default,\na route only answers to ``GET`` requests. You can use the ``methods`` argument\nof the :meth:`~flask.Flask.route` decorator to handle different HTTP methods.\n::\n\n    from flask import request\n\n    @app.route('/login', methods=['GET', 'POST'])\n    def login():\n        if request.method == 'POST':\n            return do_the_login()\n        else:\n            return show_the_login_form()\n\nThe example above keeps all methods for the route within one function,\nwhich can be useful if each part uses some common data.\n\nYou can also separate views for different methods into different\nfunctions. Flask provides a shortcut for decorating such routes with\n:meth:`~flask.Flask.get`, :meth:`~flask.Flask.post`, etc. for each\ncommon HTTP method.\n\n.. code-block:: python\n\n    @app.get('/login')\n    def login_get():\n        return show_the_login_form()\n\n    @app.post('/login')\n    def login_post():\n        return do_the_login()\n\nIf ``GET`` is present, Flask automatically adds support for the ``HEAD`` method\nand handles ``HEAD`` requests according to the `HTTP RFC`_. Likewise,\n``OPTIONS`` is automatically implemented for you.\n\n.. _HTTP RFC: https://www.ietf.org/rfc/rfc2068.txt", "code_truncated": false}
{"chunk_id": "93490046e7d94f1c2e3315710787da5a5f8d27ba", "file_path": "d:\\499\\docs\\quickstart.rst", "symbol_type": "doc", "name": "Static Files", "qualname": "quickstart.rst#Static Files", "start_line": 336, "end_line": 348, "docstring": null, "code": "------------\n\nDynamic web applications also need static files.  That's usually where\nthe CSS and JavaScript files are coming from.  Ideally your web server is\nconfigured to serve them for you, but during development Flask can do that\nas well.  Just create a folder called :file:`static` in your package or next to\nyour module and it will be available at ``/static`` on the application.\n\nTo generate URLs for static files, use the special ``'static'`` endpoint name::\n\n    url_for('static', filename='style.css')\n\nThe file has to be stored on the filesystem as :file:`static/style.css`.", "code_truncated": false}
{"chunk_id": "41660faaae172031611b75193e99aa002ba35d76", "file_path": "d:\\499\\docs\\quickstart.rst", "symbol_type": "doc", "name": "Rendering Templates", "qualname": "quickstart.rst#Rendering Templates", "start_line": 351, "end_line": 447, "docstring": null, "code": "-------------------\n\nGenerating HTML from within Python is not fun, and actually pretty\ncumbersome because you have to do the HTML escaping on your own to keep\nthe application secure.  Because of that Flask configures the `Jinja\n<https://palletsprojects.com/p/jinja/>`_ template engine for you automatically.\n\nTemplates can be used to generate any type of text file. For web applications, you'll\nprimarily be generating HTML pages, but you can also generate markdown, plain text for\nemails, and anything else.\n\nFor a reference to HTML, CSS, and other web APIs, use the `MDN Web Docs`_.\n\n.. _MDN Web Docs: https://developer.mozilla.org/\n\nTo render a template you can use the :func:`~flask.render_template`\nmethod.  All you have to do is provide the name of the template and the\nvariables you want to pass to the template engine as keyword arguments.\nHere's a simple example of how to render a template::\n\n    from flask import render_template\n\n    @app.route('/hello/')\n    @app.route('/hello/<name>')\n    def hello(name=None):\n        return render_template('hello.html', person=name)\n\nFlask will look for templates in the :file:`templates` folder.  So if your\napplication is a module, this folder is next to that module, if it's a\npackage it's actually inside your package:\n\n**Case 1**: a module::\n\n    /application.py\n    /templates\n        /hello.html\n\n**Case 2**: a package::\n\n    /application\n        /__init__.py\n        /templates\n            /hello.html\n\nFor templates you can use the full power of Jinja templates.  Head over\nto the official `Jinja Template Documentation\n<https://jinja.palletsprojects.com/templates/>`_ for more information.\n\nHere is an example template:\n\n.. sourcecode:: html+jinja\n\n    <!doctype html>\n    <title>Hello from Flask</title>\n    {% if person %}\n      <h1>Hello {{ person }}!</h1>\n    {% else %}\n      <h1>Hello, World!</h1>\n    {% endif %}\n\nInside templates you also have access to the :data:`~flask.Flask.config`,\n:class:`~flask.request`, :class:`~flask.session` and :class:`~flask.g` [#]_ objects\nas well as the :func:`~flask.url_for` and :func:`~flask.get_flashed_messages` functions.\n\nTemplates are especially useful if inheritance is used.  If you want to\nknow how that works, see :doc:`patterns/templateinheritance`. Basically\ntemplate inheritance makes it possible to keep certain elements on each\npage (like header, navigation and footer).\n\nAutomatic escaping is enabled, so if ``person`` contains HTML it will be escaped\nautomatically.  If you can trust a variable and you know that it will be\nsafe HTML (for example because it came from a module that converts wiki\nmarkup to HTML) you can mark it as safe by using the\n:class:`~markupsafe.Markup` class or by using the ``|safe`` filter in the\ntemplate.  Head over to the Jinja 2 documentation for more examples.\n\nHere is a basic introduction to how the :class:`~markupsafe.Markup` class works::\n\n    >>> from markupsafe import Markup\n    >>> Markup('<strong>Hello %s!</strong>') % '<blink>hacker</blink>'\n    Markup('<strong>Hello &lt;blink&gt;hacker&lt;/blink&gt;!</strong>')\n    >>> Markup.escape('<blink>hacker</blink>')\n    Markup('&lt;blink&gt;hacker&lt;/blink&gt;')\n    >>> Markup('<em>Marked up</em> &raquo; HTML').striptags()\n    'Marked up  HTML'\n\n.. versionchanged:: 0.5\n\n   Autoescaping is no longer enabled for all templates.  The following\n   extensions for templates trigger autoescaping: ``.html``, ``.htm``,\n   ``.xml``, ``.xhtml``.  Templates loaded from a string will have\n   autoescaping disabled.\n\n.. [#] Unsure what that :class:`~flask.g` object is? It's something in which\n   you can store information for your own needs. See the documentation\n   for :class:`flask.g` and :doc:`patterns/sqlite3`.", "code_truncated": false}
{"chunk_id": "eb7cd101bbb63b2546cb67d9177a848f14ed44b7", "file_path": "d:\\499\\docs\\quickstart.rst", "symbol_type": "doc", "name": "Accessing Request Data", "qualname": "quickstart.rst#Accessing Request Data", "start_line": 450, "end_line": 504, "docstring": null, "code": "----------------------\n\nFor web applications it's crucial to react to the data a client sends to the\nserver. In Flask this information is provided by the global :data:`.request`\nobject, which is an instance of :class:`.Request`. This object has many\nattributes and methods to work with the incoming request data, but here is a\nbroad overview. First it needs to be imported.\n\n.. code-block:: python\n\n    from flask import request\n\nIf you have some experience with Python you might be wondering how that object\ncan be global when Flask handles multiple requests at a time. The answer is\nthat :data:`.request` is actually a proxy, pointing at whatever request is\ncurrently being handled by a given worker, which is managed internally by Flask\nand Python. See :doc:`/appcontext` for much more information.\n\nThe current request method is available in the :attr:`~.Request.method`\nattribute. To access form data (data transmitted in a ``POST`` or ``PUT``\nrequest), use the :attr:`~flask.Request.form` attribute, which behaves like a\ndict.\n\n.. code-block:: python\n\n    @app.route(\"/login\", methods=[\"GET\", \"POST\"])\n    def login():\n        error = None\n\n        if request.method == \"POST\":\n            if valid_login(request.form[\"username\"], request.form[\"password\"]):\n                return store_login(request.form[\"username\"])\n            else:\n                error = \"Invalid username or password\"\n\n        # Executed if the request method was GET or the credentials were invalid.\n        return render_template(\"login.html\", error=error)\n\nIf the key does not exist in ``form``, a special :exc:`KeyError` is raised. You\ncan catch it like a normal ``KeyError``, otherwise it will return a HTTP 400\nBad Request error page. You can also use the\n:meth:`~werkzeug.datastructures.MultiDict.get` method to get a default\ninstead of an error.\n\nTo access parameters submitted in the URL (``?key=value``), use the\n:attr:`~.Request.args` attribute. Key errors behave the same as ``form``,\nreturning a 400 response if not caught.\n\n.. code-block:: python\n\n    searchword = request.args.get('key', '')\n\nFor a full list of methods and attributes of the request object, see the\n:class:`~.Request` documentation.", "code_truncated": false}
{"chunk_id": "a4b78cdf97e5a4e16b78441aee6759e093d75f7c", "file_path": "d:\\499\\docs\\quickstart.rst", "symbol_type": "doc", "name": "File Uploads", "qualname": "quickstart.rst#File Uploads", "start_line": 507, "end_line": 549, "docstring": null, "code": "````````````\n\nYou can handle uploaded files with Flask easily.  Just make sure not to\nforget to set the ``enctype=\"multipart/form-data\"`` attribute on your HTML\nform, otherwise the browser will not transmit your files at all.\n\nUploaded files are stored in memory or at a temporary location on the\nfilesystem.  You can access those files by looking at the\n:attr:`~flask.request.files` attribute on the request object.  Each\nuploaded file is stored in that dictionary.  It behaves just like a\nstandard Python :class:`file` object, but it also has a\n:meth:`~werkzeug.datastructures.FileStorage.save` method that\nallows you to store that file on the filesystem of the server.\nHere is a simple example showing how that works::\n\n    from flask import request\n\n    @app.route('/upload', methods=['GET', 'POST'])\n    def upload_file():\n        if request.method == 'POST':\n            f = request.files['the_file']\n            f.save('/var/www/uploads/uploaded_file.txt')\n        ...\n\nIf you want to know how the file was named on the client before it was\nuploaded to your application, you can access the\n:attr:`~werkzeug.datastructures.FileStorage.filename` attribute.\nHowever please keep in mind that this value can be forged\nso never ever trust that value.  If you want to use the filename\nof the client to store the file on the server, pass it through the\n:func:`~werkzeug.utils.secure_filename` function that\nWerkzeug provides for you::\n\n    from werkzeug.utils import secure_filename\n\n    @app.route('/upload', methods=['GET', 'POST'])\n    def upload_file():\n        if request.method == 'POST':\n            file = request.files['the_file']\n            file.save(f\"/var/www/uploads/{secure_filename(file.filename)}\")\n        ...\n\nFor some better examples, see :doc:`patterns/fileuploads`.", "code_truncated": false}
{"chunk_id": "3cf10a702b65a62f00ca19541e60ca6bfc064e82", "file_path": "d:\\499\\docs\\quickstart.rst", "symbol_type": "doc", "name": "Cookies", "qualname": "quickstart.rst#Cookies", "start_line": 552, "end_line": 591, "docstring": null, "code": "```````\n\nTo access cookies you can use the :attr:`~flask.Request.cookies`\nattribute.  To set cookies you can use the\n:attr:`~flask.Response.set_cookie` method of response objects.  The\n:attr:`~flask.Request.cookies` attribute of request objects is a\ndictionary with all the cookies the client transmits.  If you want to use\nsessions, do not use the cookies directly but instead use the\n:ref:`sessions` in Flask that add some security on top of cookies for you.\n\nReading cookies::\n\n    from flask import request\n\n    @app.route('/')\n    def index():\n        username = request.cookies.get('username')\n        # use cookies.get(key) instead of cookies[key] to not get a\n        # KeyError if the cookie is missing.\n\nStoring cookies::\n\n    from flask import make_response\n\n    @app.route('/')\n    def index():\n        resp = make_response(render_template(...))\n        resp.set_cookie('username', 'the username')\n        return resp\n\nNote that cookies are set on response objects.  Since you normally\njust return strings from the view functions Flask will convert them into\nresponse objects for you.  If you explicitly want to do that you can use\nthe :meth:`~flask.make_response` function and then modify it.\n\nSometimes you might want to set a cookie at a point where the response\nobject does not exist yet.  This is possible by utilizing the\n:doc:`patterns/deferredcallbacks` pattern.\n\nFor this also see :ref:`about-responses`.", "code_truncated": false}
{"chunk_id": "49fb0819a9be095a95d47cdcdd7fb31e4d0d8c12", "file_path": "d:\\499\\docs\\quickstart.rst", "symbol_type": "doc", "name": "Redirects and Errors", "qualname": "quickstart.rst#Redirects and Errors", "start_line": 594, "end_line": 631, "docstring": null, "code": "--------------------\n\nTo redirect a user to another endpoint, use the :func:`~flask.redirect`\nfunction; to abort a request early with an error code, use the\n:func:`~flask.abort` function::\n\n    from flask import abort, redirect, url_for\n\n    @app.route('/')\n    def index():\n        return redirect(url_for('login'))\n\n    @app.route('/login')\n    def login():\n        abort(401)\n        this_is_never_executed()\n\nThis is a rather pointless example because a user will be redirected from\nthe index to a page they cannot access (401 means access denied) but it\nshows how that works.\n\nBy default a black and white error page is shown for each error code.  If\nyou want to customize the error page, you can use the\n:meth:`~flask.Flask.errorhandler` decorator::\n\n    from flask import render_template\n\n    @app.errorhandler(404)\n    def page_not_found(error):\n        return render_template('page_not_found.html'), 404\n\nNote the ``404`` after the :func:`~flask.render_template` call.  This\ntells Flask that the status code of that page should be 404 which means\nnot found.  By default 200 is assumed which translates to: all went well.\n\nSee :doc:`errorhandling` for more details.\n\n.. _about-responses:", "code_truncated": false}
{"chunk_id": "ad64dd251fb0000925a3337f9f12a40b31f476a0", "file_path": "d:\\499\\docs\\quickstart.rst", "symbol_type": "doc", "name": "About Responses", "qualname": "quickstart.rst#About Responses", "start_line": 634, "end_line": 683, "docstring": null, "code": "---------------\n\nThe return value from a view function is automatically converted into\na response object for you. If the return value is a string it's\nconverted into a response object with the string as response body, a\n``200 OK`` status code and a :mimetype:`text/html` mimetype. If the\nreturn value is a dict or list, :func:`jsonify` is called to produce a\nresponse. The logic that Flask applies to converting return values into\nresponse objects is as follows:\n\n1.  If a response object of the correct type is returned it's directly\n    returned from the view.\n2.  If it's a string, a response object is created with that data and\n    the default parameters.\n3.  If it's an iterator or generator returning strings or bytes, it is\n    treated as a streaming response.\n4.  If it's a dict or list, a response object is created using\n    :func:`~flask.json.jsonify`.\n5.  If a tuple is returned the items in the tuple can provide extra\n    information. Such tuples have to be in the form\n    ``(response, status)``, ``(response, headers)``, or\n    ``(response, status, headers)``. The ``status`` value will override\n    the status code and ``headers`` can be a list or dictionary of\n    additional header values.\n6.  If none of that works, Flask will assume the return value is a\n    valid WSGI application and convert that into a response object.\n\nIf you want to get hold of the resulting response object inside the view\nyou can use the :func:`~flask.make_response` function.\n\nImagine you have a view like this::\n\n    from flask import render_template\n\n    @app.errorhandler(404)\n    def not_found(error):\n        return render_template('error.html'), 404\n\nYou just need to wrap the return expression with\n:func:`~flask.make_response` and get the response object to modify it, then\nreturn it::\n\n    from flask import make_response\n\n    @app.errorhandler(404)\n    def not_found(error):\n        resp = make_response(render_template('error.html'), 404)\n        resp.headers['X-Something'] = 'A value'\n        return resp", "code_truncated": false}
{"chunk_id": "6d11b185a8e67a27370230c0f6e2f08ab7126df7", "file_path": "d:\\499\\docs\\quickstart.rst", "symbol_type": "doc", "name": "APIs with JSON", "qualname": "quickstart.rst#APIs with JSON", "start_line": 686, "end_line": 719, "docstring": null, "code": "``````````````\n\nA common response format when writing an API is JSON. It's easy to get\nstarted writing such an API with Flask. If you return a ``dict`` or\n``list`` from a view, it will be converted to a JSON response.\n\n.. code-block:: python\n\n    @app.route(\"/me\")\n    def me_api():\n        user = get_current_user()\n        return {\n            \"username\": user.username,\n            \"theme\": user.theme,\n            \"image\": url_for(\"user_image\", filename=user.image),\n        }\n\n    @app.route(\"/users\")\n    def users_api():\n        users = get_all_users()\n        return [user.to_json() for user in users]\n\nThis is a shortcut to passing the data to the\n:func:`~flask.json.jsonify` function, which will serialize any supported\nJSON data type. That means that all the data in the dict or list must be\nJSON serializable.\n\nFor complex types such as database models, you'll want to use a\nserialization library to convert the data to valid JSON types first.\nThere are many serialization libraries and Flask API extensions\nmaintained by the community that support more complex applications.\n\n\n.. _sessions:", "code_truncated": false}
{"chunk_id": "a40424ac744b8ce63e6fd2e158f036a550e94031", "file_path": "d:\\499\\docs\\quickstart.rst", "symbol_type": "doc", "name": "Sessions", "qualname": "quickstart.rst#Sessions", "start_line": 722, "end_line": 781, "docstring": null, "code": "--------\n\nIn addition to the request object there is also a second object called\n:class:`~flask.session` which allows you to store information specific to a\nuser from one request to the next.  This is implemented on top of cookies\nfor you and signs the cookies cryptographically.  What this means is that\nthe user could look at the contents of your cookie but not modify it,\nunless they know the secret key used for signing.\n\nIn order to use sessions you have to set a secret key.  Here is how\nsessions work::\n\n    from flask import session\n\n    # Set the secret key to some random bytes. Keep this really secret!\n    app.secret_key = b'_5#y2L\"F4Q8z\\n\\xec]/'\n\n    @app.route('/')\n    def index():\n        if 'username' in session:\n            return f'Logged in as {session[\"username\"]}'\n        return 'You are not logged in'\n\n    @app.route('/login', methods=['GET', 'POST'])\n    def login():\n        if request.method == 'POST':\n            session['username'] = request.form['username']\n            return redirect(url_for('index'))\n        return '''\n            <form method=\"post\">\n                <p><input type=text name=username>\n                <p><input type=submit value=Login>\n            </form>\n        '''\n\n    @app.route('/logout')\n    def logout():\n        # remove the username from the session if it's there\n        session.pop('username', None)\n        return redirect(url_for('index'))\n\n.. admonition:: How to generate good secret keys\n\n    A secret key should be as random as possible. Your operating system has\n    ways to generate pretty random data based on a cryptographic random\n    generator. Use the following command to quickly generate a value for\n    :attr:`Flask.secret_key` (or :data:`SECRET_KEY`)::\n\n        $ python -c 'import secrets; print(secrets.token_hex())'\n        '192b9bdd22ab9ed4d12e236c78afcb9a393ec15f71bbf5dc987d54727823bcbf'\n\nA note on cookie-based sessions: Flask will take the values you put into the\nsession object and serialize them into a cookie.  If you are finding some\nvalues do not persist across requests, cookies are indeed enabled, and you are\nnot getting a clear error message, check the size of the cookie in your page\nresponses compared to the size supported by web browsers.\n\nBesides the default client-side based sessions, if you want to handle\nsessions on the server-side instead, there are several\nFlask extensions that support this.", "code_truncated": false}
{"chunk_id": "4cbf85e6fc2cbdf65cc4f9bb96fdf06a56fa7412", "file_path": "d:\\499\\docs\\quickstart.rst", "symbol_type": "doc", "name": "Message Flashing", "qualname": "quickstart.rst#Message Flashing", "start_line": 784, "end_line": 797, "docstring": null, "code": "----------------\n\nGood applications and user interfaces are all about feedback.  If the user\ndoes not get enough feedback they will probably end up hating the\napplication.  Flask provides a really simple way to give feedback to a\nuser with the flashing system.  The flashing system basically makes it\npossible to record a message at the end of a request and access it on the next\n(and only the next) request.  This is usually combined with a layout\ntemplate to expose the message.\n\nTo flash a message use the :func:`~flask.flash` method, to get hold of the\nmessages you can use :func:`~flask.get_flashed_messages` which is also\navailable in the templates. See :doc:`patterns/flashing` for a full\nexample.", "code_truncated": false}
{"chunk_id": "bc682ee3609a2936c4ea696a22dacab8d0d57289", "file_path": "d:\\499\\docs\\quickstart.rst", "symbol_type": "doc", "name": "Logging", "qualname": "quickstart.rst#Logging", "start_line": 800, "end_line": 827, "docstring": null, "code": "-------\n\n.. versionadded:: 0.3\n\nSometimes you might be in a situation where you deal with data that\nshould be correct, but actually is not.  For example you may have\nsome client-side code that sends an HTTP request to the server\nbut it's obviously malformed.  This might be caused by a user tampering\nwith the data, or the client code failing.  Most of the time it's okay\nto reply with ``400 Bad Request`` in that situation, but sometimes\nthat won't do and the code has to continue working.\n\nYou may still want to log that something fishy happened.  This is where\nloggers come in handy.  As of Flask 0.3 a logger is preconfigured for you\nto use.\n\nHere are some example log calls::\n\n    app.logger.debug('A value for debugging')\n    app.logger.warning('A warning occurred (%d apples)', 42)\n    app.logger.error('An error occurred')\n\nThe attached :attr:`~flask.Flask.logger` is a standard logging\n:class:`~logging.Logger`, so head over to the official :mod:`logging`\ndocs for more information.\n\nSee :doc:`errorhandling`.", "code_truncated": false}
{"chunk_id": "80f7aa26820b5ae6b7021c7f2a7ca003eacf3e04", "file_path": "d:\\499\\docs\\quickstart.rst", "symbol_type": "doc", "name": "Hooking in WSGI Middleware", "qualname": "quickstart.rst#Hooking in WSGI Middleware", "start_line": 830, "end_line": 844, "docstring": null, "code": "--------------------------\n\nTo add WSGI middleware to your Flask application, wrap the application's\n``wsgi_app`` attribute. For example, to apply Werkzeug's\n:class:`~werkzeug.middleware.proxy_fix.ProxyFix` middleware for running\nbehind Nginx:\n\n.. code-block:: python\n\n    from werkzeug.middleware.proxy_fix import ProxyFix\n    app.wsgi_app = ProxyFix(app.wsgi_app)\n\nWrapping ``app.wsgi_app`` instead of ``app`` means that ``app`` still\npoints at your Flask application, not at the middleware, so you can\ncontinue to use and configure ``app`` directly.", "code_truncated": false}
{"chunk_id": "a037061d1072fc8fb6d22d81c1f4fd4a6524c30c", "file_path": "d:\\499\\docs\\quickstart.rst", "symbol_type": "doc", "name": "Using Flask Extensions", "qualname": "quickstart.rst#Using Flask Extensions", "start_line": 847, "end_line": 853, "docstring": null, "code": "----------------------\n\nExtensions are packages that help you accomplish common tasks. For\nexample, Flask-SQLAlchemy provides SQLAlchemy support that makes it simple\nand easy to use with Flask.\n\nFor more on Flask extensions, see :doc:`extensions`.", "code_truncated": false}
{"chunk_id": "ee45d5f39a617a698ea1c65b8963ce9274952b48", "file_path": "d:\\499\\docs\\quickstart.rst", "symbol_type": "doc", "name": "Deploying to a Web Server", "qualname": "quickstart.rst#Deploying to a Web Server", "start_line": 856, "end_line": 858, "docstring": null, "code": "-------------------------\n\nReady to deploy your new Flask app? See :doc:`deploying/index`.", "code_truncated": false}
{"chunk_id": "76a8d0dc013e8b9e7042826a313f4202adbe37d4", "file_path": "d:\\499\\docs\\reqcontext.rst", "symbol_type": "doc", "name": "INTRO", "qualname": "reqcontext.rst#INTRO", "start_line": 1, "end_line": 1, "docstring": null, "code": ":orphan:", "code_truncated": false}
{"chunk_id": "d572eee6c969cac0745d34cfdea916b56f582b6b", "file_path": "d:\\499\\docs\\reqcontext.rst", "symbol_type": "doc", "name": "The Request Context", "qualname": "reqcontext.rst#The Request Context", "start_line": 4, "end_line": 6, "docstring": null, "code": "===================\n\nObsolete, see :doc:`/appcontext` instead.", "code_truncated": false}
{"chunk_id": "71efa8a5e3cd662e4a815dbe36a10f557bf25018", "file_path": "d:\\499\\docs\\server.rst", "symbol_type": "doc", "name": "INTRO", "qualname": "server.rst#INTRO", "start_line": 1, "end_line": 1, "docstring": null, "code": ".. currentmodule:: flask", "code_truncated": false}
{"chunk_id": "c46d1395056abd6fe2702b2a18da657dae12a180", "file_path": "d:\\499\\docs\\server.rst", "symbol_type": "doc", "name": "Development Server", "qualname": "server.rst#Development Server", "start_line": 4, "end_line": 16, "docstring": null, "code": "==================\n\nFlask provides a ``run`` command to run the application with a development server. In\ndebug mode, this server provides an interactive debugger and will reload when code is\nchanged.\n\n.. warning::\n\n    Do not use the development server when deploying to production. It\n    is intended for use only during local development. It is not\n    designed to be particularly efficient, stable, or secure.\n\n    See :doc:`/deploying/index` for deployment options.", "code_truncated": false}
{"chunk_id": "e4f18a20b4a1164e02b26ae2409b163bd9dce51a", "file_path": "d:\\499\\docs\\server.rst", "symbol_type": "doc", "name": "Command Line", "qualname": "server.rst#Command Line", "start_line": 19, "end_line": 35, "docstring": null, "code": "------------\n\nThe ``flask run`` CLI command is the recommended way to run the development server. Use\nthe ``--app`` option to point to your application, and the ``--debug`` option to enable\ndebug mode.\n\n.. code-block:: text\n\n    $ flask --app hello run --debug\n\nThis enables debug mode, including the interactive debugger and reloader, and then\nstarts the server on http://localhost:5000/. Use ``flask run --help`` to see the\navailable options, and :doc:`/cli` for detailed instructions about configuring and using\nthe CLI.\n\n\n.. _address-already-in-use:", "code_truncated": false}
{"chunk_id": "ee584989051aa4550258d45bc09fe70085ea7013", "file_path": "d:\\499\\docs\\server.rst", "symbol_type": "doc", "name": "Address already in use", "qualname": "server.rst#Address already in use", "start_line": 38, "end_line": 81, "docstring": null, "code": "~~~~~~~~~~~~~~~~~~~~~~\n\nIf another program is already using port 5000, you'll see an ``OSError``\nwhen the server tries to start. It may have one of the following\nmessages:\n\n-   ``OSError: [Errno 98] Address already in use``\n-   ``OSError: [WinError 10013] An attempt was made to access a socket\n    in a way forbidden by its access permissions``\n\nEither identify and stop the other program, or use\n``flask run --port 5001`` to pick a different port.\n\nYou can use ``netstat`` or ``lsof`` to identify what process id is using\na port, then use other operating system tools stop that process. The\nfollowing example shows that process id 6847 is using port 5000.\n\n.. tabs::\n\n    .. tab:: ``netstat`` (Linux)\n\n        .. code-block:: text\n\n            $ netstat -nlp | grep 5000\n            tcp 0 0 127.0.0.1:5000 0.0.0.0:* LISTEN 6847/python\n\n    .. tab:: ``lsof`` (macOS / Linux)\n\n        .. code-block:: text\n\n            $ lsof -P -i :5000\n            Python 6847 IPv4 TCP localhost:5000 (LISTEN)\n\n    .. tab:: ``netstat`` (Windows)\n\n        .. code-block:: text\n\n            > netstat -ano | findstr 5000\n            TCP 127.0.0.1:5000 0.0.0.0:0 LISTENING 6847\n\nmacOS Monterey and later automatically starts a service that uses port\n5000. You can choose to disable this service instead of using a different port by\nsearching for \"AirPlay Receiver\" in System Settings and toggling it off.", "code_truncated": false}
{"chunk_id": "4d96a8ee446c573ce01df12d98ed3564b8b1649d", "file_path": "d:\\499\\docs\\server.rst", "symbol_type": "doc", "name": "Deferred Errors on Reload", "qualname": "server.rst#Deferred Errors on Reload", "start_line": 84, "end_line": 95, "docstring": null, "code": "~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWhen using the ``flask run`` command with the reloader, the server will\ncontinue to run even if you introduce syntax errors or other\ninitialization errors into the code. Accessing the site will show the\ninteractive debugger for the error, rather than crashing the server.\n\nIf a syntax error is already present when calling ``flask run``, it will\nfail immediately and show the traceback rather than waiting until the\nsite is accessed. This is intended to make errors more visible initially\nwhile still allowing the server to handle errors on reload.", "code_truncated": false}
{"chunk_id": "dc65d119de76fc7ad63ee5fc70d972d8b03e5cd9", "file_path": "d:\\499\\docs\\server.rst", "symbol_type": "doc", "name": "In Code", "qualname": "server.rst#In Code", "start_line": 98, "end_line": 115, "docstring": null, "code": "-------\n\nThe development server can also be started from Python with the :meth:`Flask.run`\nmethod. This method takes arguments similar to the CLI options to control the server.\nThe main difference from the CLI command is that the server will crash if there are\nerrors when reloading. ``debug=True`` can be passed to enable debug mode.\n\nPlace the call in a main block, otherwise it will interfere when trying to import and\nrun the application with a production server later.\n\n.. code-block:: python\n\n    if __name__ == \"__main__\":\n        app.run(debug=True)\n\n.. code-block:: text\n\n    $ python hello.py", "code_truncated": false}
{"chunk_id": "004274c13e6e40f88632e5ced93aa7b53a8670b4", "file_path": "d:\\499\\docs\\shell.rst", "symbol_type": "doc", "name": "Working with the Shell", "qualname": "shell.rst#Working with the Shell", "start_line": 2, "end_line": 11, "docstring": null, "code": "======================\n\nOne of the reasons everybody loves Python is the interactive shell. It allows\nyou to play around with code in real time and immediately get results back.\nFlask provides the ``flask shell`` CLI command to start an interactive Python\nshell with some setup done to make working with the Flask app easier.\n\n.. code-block:: text\n\n    $ flask shell", "code_truncated": false}
{"chunk_id": "0214abd7810c5ea8f57db9d9c1f42781339e6f50", "file_path": "d:\\499\\docs\\shell.rst", "symbol_type": "doc", "name": "Creating a Request Context", "qualname": "shell.rst#Creating a Request Context", "start_line": 14, "end_line": 36, "docstring": null, "code": "--------------------------\n\n``flask shell`` pushes an app context automatically, so :data:`.current_app` and\n:data:`.g` are already available. However, there is no HTTP request being\nhandled in the shell, so :data:`.request` and :data:`.session` are not yet\navailable.\n\nThe easiest way to create a proper request context from the shell is by\nusing the :attr:`~flask.Flask.test_request_context` method which creates\nus a :class:`~flask.ctx.RequestContext`:\n\n>>> ctx = app.test_request_context()\n\nNormally you would use the ``with`` statement to make this context active, but\nin the shell it's easier to call :meth:`~.RequestContext.push` and\n:meth:`~.RequestContext.pop` manually:\n\n>>> ctx.push()\n\nFrom that point onwards you can work with the request object until you call\n``pop``:\n\n>>> ctx.pop()", "code_truncated": false}
{"chunk_id": "a944be639a21c36fed361badc84b203d857b64b7", "file_path": "d:\\499\\docs\\shell.rst", "symbol_type": "doc", "name": "Firing Before/After Request", "qualname": "shell.rst#Firing Before/After Request", "start_line": 39, "end_line": 69, "docstring": null, "code": "---------------------------\n\nBy just creating a request context, you still don't have run the code that\nis normally run before a request.  This might result in your database\nbeing unavailable if you are connecting to the database in a\nbefore-request callback or the current user not being stored on the\n:data:`~flask.g` object etc.\n\nThis however can easily be done yourself.  Just call\n:meth:`~flask.Flask.preprocess_request`:\n\n>>> ctx = app.test_request_context()\n>>> ctx.push()\n>>> app.preprocess_request()\n\nKeep in mind that the :meth:`~flask.Flask.preprocess_request` function\nmight return a response object, in that case just ignore it.\n\nTo shutdown a request, you need to trick a bit before the after request\nfunctions (triggered by :meth:`~flask.Flask.process_response`) operate on\na response object:\n\n>>> app.process_response(app.response_class())\n<Response 0 bytes [200 OK]>\n>>> ctx.pop()\n\nThe functions registered as :meth:`~flask.Flask.teardown_request` are\nautomatically called when the context is popped.  So this is the perfect\nplace to automatically tear down resources that were needed by the request\ncontext (such as database connections).", "code_truncated": false}
{"chunk_id": "0ce58f002499d42d83ecb801257f90e945625ee4", "file_path": "d:\\499\\docs\\shell.rst", "symbol_type": "doc", "name": "Further Improving the Shell Experience", "qualname": "shell.rst#Further Improving the Shell Experience", "start_line": 72, "end_line": 81, "docstring": null, "code": "--------------------------------------\n\nIf you like the idea of experimenting in a shell, create yourself a module\nwith stuff you want to star import into your interactive session.  There\nyou could also define some more helper methods for common things such as\ninitializing the database, dropping tables etc.\n\nJust put them into a module (like `shelltools`) and import from there:\n\n>>> from shelltools import *", "code_truncated": false}
{"chunk_id": "7994aed1c627176d4d25e605047551865472734b", "file_path": "d:\\499\\docs\\signals.rst", "symbol_type": "doc", "name": "Signals", "qualname": "signals.rst#Signals", "start_line": 2, "end_line": 18, "docstring": null, "code": "=======\n\nSignals are a lightweight way to notify subscribers of certain events during the\nlifecycle of the application and each request. When an event occurs, it emits the\nsignal, which calls each subscriber.\n\nSignals are implemented by the `Blinker`_ library. See its documentation for detailed\ninformation. Flask provides some built-in signals. Extensions may provide their own.\n\nMany signals mirror Flask's decorator-based callbacks with similar names. For example,\nthe :data:`.request_started` signal is similar to the :meth:`~.Flask.before_request`\ndecorator. The advantage of signals over handlers is that they can be subscribed to\ntemporarily, and can't directly affect the application. This is useful for testing,\nmetrics, auditing, and more. For example, if you want to know what templates were\nrendered at what parts of what requests, there is a signal that will notify you of that\ninformation.", "code_truncated": false}
{"chunk_id": "e354e602eb6468cc3b37b2340bafb97b2795d868", "file_path": "d:\\499\\docs\\signals.rst", "symbol_type": "doc", "name": "Core Signals", "qualname": "signals.rst#Core Signals", "start_line": 21, "end_line": 25, "docstring": null, "code": "------------\n\nSee :ref:`core-signals-list` for a list of all built-in signals. The :doc:`lifecycle`\npage also describes the order that signals and decorators execute.", "code_truncated": false}
{"chunk_id": "72d0c35c4e157303e50220f02358d51ffa9745c1", "file_path": "d:\\499\\docs\\signals.rst", "symbol_type": "doc", "name": "Subscribing to Signals", "qualname": "signals.rst#Subscribing to Signals", "start_line": 28, "end_line": 95, "docstring": null, "code": "----------------------\n\nTo subscribe to a signal, you can use the\n:meth:`~blinker.base.Signal.connect` method of a signal.  The first\nargument is the function that should be called when the signal is emitted,\nthe optional second argument specifies a sender.  To unsubscribe from a\nsignal, you can use the :meth:`~blinker.base.Signal.disconnect` method.\n\nFor all core Flask signals, the sender is the application that issued the\nsignal.  When you subscribe to a signal, be sure to also provide a sender\nunless you really want to listen for signals from all applications.  This is\nespecially true if you are developing an extension.\n\nFor example, here is a helper context manager that can be used in a unit test\nto determine which templates were rendered and what variables were passed\nto the template::\n\n    from flask import template_rendered\n    from contextlib import contextmanager\n\n    @contextmanager\n    def captured_templates(app):\n        recorded = []\n        def record(sender, template, context, **extra):\n            recorded.append((template, context))\n        template_rendered.connect(record, app)\n        try:\n            yield recorded\n        finally:\n            template_rendered.disconnect(record, app)\n\nThis can now easily be paired with a test client::\n\n    with captured_templates(app) as templates:\n        rv = app.test_client().get('/')\n        assert rv.status_code == 200\n        assert len(templates) == 1\n        template, context = templates[0]\n        assert template.name == 'index.html'\n        assert len(context['items']) == 10\n\nMake sure to subscribe with an extra ``**extra`` argument so that your\ncalls don't fail if Flask introduces new arguments to the signals.\n\nAll the template rendering in the code issued by the application `app`\nin the body of the ``with`` block will now be recorded in the `templates`\nvariable.  Whenever a template is rendered, the template object as well as\ncontext are appended to it.\n\nAdditionally there is a convenient helper method\n(:meth:`~blinker.base.Signal.connected_to`)  that allows you to\ntemporarily subscribe a function to a signal with a context manager on\nits own.  Because the return value of the context manager cannot be\nspecified that way, you have to pass the list in as an argument::\n\n    from flask import template_rendered\n\n    def captured_templates(app, recorded, **extra):\n        def record(sender, template, context):\n            recorded.append((template, context))\n        return template_rendered.connected_to(record, app)\n\nThe example above would then look like this::\n\n    templates = []\n    with captured_templates(app, templates, **extra):\n        ...\n        template, context = templates[0]", "code_truncated": false}
{"chunk_id": "34777f5318d5b7ad1987daccc75bc5eb08c065d2", "file_path": "d:\\499\\docs\\signals.rst", "symbol_type": "doc", "name": "Creating Signals", "qualname": "signals.rst#Creating Signals", "start_line": 98, "end_line": 116, "docstring": null, "code": "----------------\n\nIf you want to use signals in your own application, you can use the\nblinker library directly.  The most common use case are named signals in a\ncustom :class:`~blinker.base.Namespace`.  This is what is recommended\nmost of the time::\n\n    from blinker import Namespace\n    my_signals = Namespace()\n\nNow you can create new signals like this::\n\n    model_saved = my_signals.signal('model-saved')\n\nThe name for the signal here makes it unique and also simplifies\ndebugging.  You can access the name of the signal with the\n:attr:`~blinker.base.NamedSignal.name` attribute.\n\n.. _signals-sending:", "code_truncated": false}
{"chunk_id": "a992049f63fb89e5a95dba672d0a65a3dc42f652", "file_path": "d:\\499\\docs\\signals.rst", "symbol_type": "doc", "name": "Sending Signals", "qualname": "signals.rst#Sending Signals", "start_line": 119, "end_line": 142, "docstring": null, "code": "---------------\n\nIf you want to emit a signal, you can do so by calling the\n:meth:`~blinker.base.Signal.send` method.  It accepts a sender as first\nargument and optionally some keyword arguments that are forwarded to the\nsignal subscribers::\n\n    class Model(object):\n        ...\n\n        def save(self):\n            model_saved.send(self)\n\nTry to always pick a good sender.  If you have a class that is emitting a\nsignal, pass ``self`` as sender.  If you are emitting a signal from a random\nfunction, you can pass ``current_app._get_current_object()`` as sender.\n\n.. admonition:: Passing Proxies as Senders\n\n   Never pass :data:`~flask.current_app` as sender to a signal.  Use\n   ``current_app._get_current_object()`` instead.  The reason for this is\n   that :data:`~flask.current_app` is a proxy and not the real application\n   object.", "code_truncated": false}
{"chunk_id": "538a593ffb72d08cd947d1a2a57c19dca08e1131", "file_path": "d:\\499\\docs\\signals.rst", "symbol_type": "doc", "name": "Signals and Flask's Request Context", "qualname": "signals.rst#Signals and Flask's Request Context", "start_line": 145, "end_line": 151, "docstring": null, "code": "-----------------------------------\n\nContext-local proxies are available between :data:`~flask.request_started` and\n:data:`~flask.request_finished`, so you can rely on :class:`flask.g` and others\nas needed. Note the limitations described in :ref:`signals-sending` and the\n:data:`~flask.request_tearing_down` signal.", "code_truncated": false}
{"chunk_id": "aa9e2f5c69adc4967d2667675774702897d37178", "file_path": "d:\\499\\docs\\signals.rst", "symbol_type": "doc", "name": "Decorator Based Signal Subscriptions", "qualname": "signals.rst#Decorator Based Signal Subscriptions", "start_line": 154, "end_line": 166, "docstring": null, "code": "------------------------------------\n\nYou can also easily subscribe to signals by using the\n:meth:`~blinker.base.NamedSignal.connect_via` decorator::\n\n    from flask import template_rendered\n\n    @template_rendered.connect_via(app)\n    def when_template_rendered(sender, template, context, **extra):\n        print(f'Template {template.name} is rendered with {context}')\n\n\n.. _blinker: https://pypi.org/project/blinker/", "code_truncated": false}
{"chunk_id": "0b6ba4a4a2cdacee407fe0ce504b1008b71f20ce", "file_path": "d:\\499\\docs\\templating.rst", "symbol_type": "doc", "name": "Templates", "qualname": "templating.rst#Templates", "start_line": 2, "end_line": 13, "docstring": null, "code": "=========\n\nFlask leverages Jinja as its template engine.  You are obviously free to use\na different template engine, but you still have to install Jinja to run\nFlask itself.  This requirement is necessary to enable rich extensions.\nAn extension can depend on Jinja being present.\n\nThis section only gives a very quick introduction into how Jinja\nis integrated into Flask.  If you want information on the template\nengine's syntax itself, head over to the official `Jinja Template\nDocumentation <https://jinja.palletsprojects.com/templates/>`_ for\nmore information.", "code_truncated": false}
{"chunk_id": "6987818864195d742dc774c64b512a4f95692813", "file_path": "d:\\499\\docs\\templating.rst", "symbol_type": "doc", "name": "Jinja Setup", "qualname": "templating.rst#Jinja Setup", "start_line": 16, "end_line": 29, "docstring": null, "code": "-----------\n\nUnless customized, Jinja is configured by Flask as follows:\n\n-   autoescaping is enabled for all templates ending in ``.html``,\n    ``.htm``, ``.xml``, ``.xhtml``, as well as ``.svg`` when using\n    :func:`~flask.templating.render_template`.\n-   autoescaping is enabled for all strings when using\n    :func:`~flask.templating.render_template_string`.\n-   a template has the ability to opt in/out autoescaping with the\n    ``{% autoescape %}`` tag.\n-   Flask inserts a couple of global functions and helpers into the\n    Jinja context, additionally to the values that are present by\n    default.", "code_truncated": false}
{"chunk_id": "a754d70a3bd281cac6bb7ae163f63f87b3d0de45", "file_path": "d:\\499\\docs\\templating.rst", "symbol_type": "doc", "name": "Standard Context", "qualname": "templating.rst#Standard Context", "start_line": 32, "end_line": 97, "docstring": null, "code": "----------------\n\nThe following global variables are available within Jinja templates\nby default:\n\n.. data:: config\n   :noindex:\n\n   The current configuration object (:data:`flask.Flask.config`)\n\n   .. versionadded:: 0.6\n\n   .. versionchanged:: 0.10\n      This is now always available, even in imported templates.\n\n.. data:: request\n   :noindex:\n\n   The current request object (:class:`flask.request`).  This variable is\n   unavailable if the template was rendered without an active request\n   context.\n\n.. data:: session\n   :noindex:\n\n   The current session object (:class:`flask.session`).  This variable\n   is unavailable if the template was rendered without an active request\n   context.\n\n.. data:: g\n   :noindex:\n\n   The request-bound object for global variables (:data:`flask.g`).  This\n   variable is unavailable if the template was rendered without an active\n   request context.\n\n.. function:: url_for\n   :noindex:\n\n   The :func:`flask.url_for` function.\n\n.. function:: get_flashed_messages\n   :noindex:\n\n   The :func:`flask.get_flashed_messages` function.\n\n.. admonition:: The Jinja Context Behavior\n\n   These variables are added to the context of variables, they are not\n   global variables.  The difference is that by default these will not\n   show up in the context of imported templates.  This is partially caused\n   by performance considerations, partially to keep things explicit.\n\n   What does this mean for you?  If you have a macro you want to import,\n   that needs to access the request object you have two possibilities:\n\n   1.   you explicitly pass the request to the macro as parameter, or\n        the attribute of the request object you are interested in.\n   2.   you import the macro \"with context\".\n\n   Importing with context looks like this:\n\n   .. sourcecode:: jinja\n\n      {% from '_helpers.html' import my_macro with context %}", "code_truncated": false}
{"chunk_id": "c33683318150b2e52a0dff3e826d03e237e1b239", "file_path": "d:\\499\\docs\\templating.rst", "symbol_type": "doc", "name": "Controlling Autoescaping", "qualname": "templating.rst#Controlling Autoescaping", "start_line": 100, "end_line": 138, "docstring": null, "code": "------------------------\n\nAutoescaping is the concept of automatically escaping special characters\nfor you.  Special characters in the sense of HTML (or XML, and thus XHTML)\nare ``&``, ``>``, ``<``, ``\"`` as well as ``'``.  Because these characters\ncarry specific meanings in documents on their own you have to replace them\nby so called \"entities\" if you want to use them for text.  Not doing so\nwould not only cause user frustration by the inability to use these\ncharacters in text, but can also lead to security problems.  (see\n:ref:`security-xss`)\n\nSometimes however you will need to disable autoescaping in templates.\nThis can be the case if you want to explicitly inject HTML into pages, for\nexample if they come from a system that generates secure HTML like a\nmarkdown to HTML converter.\n\nThere are three ways to accomplish that:\n\n-   In the Python code, wrap the HTML string in a :class:`~markupsafe.Markup`\n    object before passing it to the template.  This is in general the\n    recommended way.\n-   Inside the template, use the ``|safe`` filter to explicitly mark a\n    string as safe HTML (``{{ myvariable|safe }}``)\n-   Temporarily disable the autoescape system altogether.\n\nTo disable the autoescape system in templates, you can use the ``{%\nautoescape %}`` block:\n\n.. sourcecode:: html+jinja\n\n    {% autoescape false %}\n        <p>autoescaping is disabled here\n        <p>{{ will_not_be_escaped }}\n    {% endautoescape %}\n\nWhenever you do this, please be very cautious about the variables you are\nusing in this block.\n\n.. _registering-filters:", "code_truncated": false}
{"chunk_id": "fd13ff4b299856822476f1181bba24f08c16a634", "file_path": "d:\\499\\docs\\templating.rst", "symbol_type": "doc", "name": "Registering Filters, Tests, and Globals", "qualname": "templating.rst#Registering Filters, Tests, and Globals", "start_line": 141, "end_line": 191, "docstring": null, "code": "---------------------------------------\n\nThe Flask app and blueprints provide decorators and methods to register your own\nfilters, tests, and global functions for use in Jinja templates. They all follow\nthe same pattern, so the following examples only discuss filters.\n\nDecorate a function with :meth:`~.Flask.template_filter` to register it as a\ntemplate filter.\n\n.. code-block:: python\n\n    @app.template_filter\n    def reverse(s):\n        return reversed(s)\n\n.. code-block:: jinja\n\n    {% for item in data | reverse %}\n    {% endfor %}\n\nBy default it will use the name of the function as the name of the filter, but\nthat can be changed by passing a name to the decorator.\n\n.. code-block:: python\n\n    @app.template_filter(\"reverse\")\n    def reverse_filter(s):\n        return reversed(s)\n\nA filter can be registered separately using :meth:`~.Flask.add_template_filter`.\nThe name is optional and will use the function name if not given.\n\n.. code-block:: python\n\n    def reverse_filter(s):\n        return reversed(s)\n\n    app.add_template_filter(reverse_filter, \"reverse\")\n\nFor template tests, use the :meth:`~.Flask.template_test` decorator or\n:meth:`~.Flask.add_template_test` method. For template global functions, use the\n:meth:`~.Flask.template_global` decorator or :meth:`~.Flask.add_template_global`\nmethod.\n\nThe same methods also exist on :class:`.Blueprint`, prefixed with ``app_`` to\nindicate that the registered functions will be available to all templates, not\nonly when rendering from within the blueprint.\n\nThe Jinja environment is also available as :attr:`~.Flask.jinja_env`. It may be\nmodified directly, as you would when using Jinja outside Flask.", "code_truncated": false}
{"chunk_id": "e24074335b940c026b79c87f9872da2d3c0fef17", "file_path": "d:\\499\\docs\\templating.rst", "symbol_type": "doc", "name": "Context Processors", "qualname": "templating.rst#Context Processors", "start_line": 194, "end_line": 229, "docstring": null, "code": "------------------\n\nTo inject new variables automatically into the context of a template,\ncontext processors exist in Flask.  Context processors run before the\ntemplate is rendered and have the ability to inject new values into the\ntemplate context.  A context processor is a function that returns a\ndictionary.  The keys and values of this dictionary are then merged with\nthe template context, for all templates in the app::\n\n    @app.context_processor\n    def inject_user():\n        return dict(user=g.user)\n\nThe context processor above makes a variable called `user` available in\nthe template with the value of `g.user`.  This example is not very\ninteresting because `g` is available in templates anyways, but it gives an\nidea how this works.\n\nVariables are not limited to values; a context processor can also make\nfunctions available to templates (since Python allows passing around\nfunctions)::\n\n    @app.context_processor\n    def utility_processor():\n        def format_price(amount, currency=\"\"):\n            return f\"{amount:.2f}{currency}\"\n        return dict(format_price=format_price)\n\nThe context processor above makes the `format_price` function available to all\ntemplates::\n\n    {{ format_price(0.33) }}\n\nYou could also build `format_price` as a template filter (see\n:ref:`registering-filters`), but this demonstrates how to pass functions in a\ncontext processor.", "code_truncated": false}
{"chunk_id": "706b01ea884838104b3e0294b335d790178a28d5", "file_path": "d:\\499\\docs\\templating.rst", "symbol_type": "doc", "name": "Streaming", "qualname": "templating.rst#Streaming", "start_line": 232, "end_line": 255, "docstring": null, "code": "---------\n\nIt can be useful to not render the whole template as one complete\nstring, instead render it as a stream, yielding smaller incremental\nstrings. This can be used for streaming HTML in chunks to speed up\ninitial page load, or to save memory when rendering a very large\ntemplate.\n\nThe Jinja template engine supports rendering a template piece\nby piece, returning an iterator of strings. Flask provides the\n:func:`~flask.stream_template` and :func:`~flask.stream_template_string`\nfunctions to make this easier to use.\n\n.. code-block:: python\n\n    from flask import stream_template\n\n    @app.get(\"/timeline\")\n    def timeline():\n        return stream_template(\"timeline.html\")\n\nThese functions automatically apply the\n:func:`~flask.stream_with_context` wrapper if a request is active, so\nthat it remains available in the template.", "code_truncated": false}
{"chunk_id": "72bfad932da3ca79ed980c907bb6d53759f54970", "file_path": "d:\\499\\docs\\testing.rst", "symbol_type": "doc", "name": "Testing Flask Applications", "qualname": "testing.rst#Testing Flask Applications", "start_line": 2, "end_line": 20, "docstring": null, "code": "==========================\n\nFlask provides utilities for testing an application. This documentation\ngoes over techniques for working with different parts of the application\nin tests.\n\nWe will use the `pytest`_ framework to set up and run our tests.\n\n.. code-block:: text\n\n    $ pip install pytest\n\n.. _pytest: https://docs.pytest.org/\n\nThe :doc:`tutorial </tutorial/index>` goes over how to write tests for\n100% coverage of the sample Flaskr blog application. See\n:doc:`the tutorial on tests </tutorial/tests>` for a detailed\nexplanation of specific tests for an application.", "code_truncated": false}
{"chunk_id": "5dd2eac0af13a9b3d7130adf9f5c7d5f71b47a1a", "file_path": "d:\\499\\docs\\testing.rst", "symbol_type": "doc", "name": "Identifying Tests", "qualname": "testing.rst#Identifying Tests", "start_line": 23, "end_line": 33, "docstring": null, "code": "-----------------\n\nTests are typically located in the ``tests`` folder. Tests are functions\nthat start with ``test_``, in Python modules that start with ``test_``.\nTests can also be further grouped in classes that start with ``Test``.\n\nIt can be difficult to know what to test. Generally, try to test the\ncode that you write, not the code of libraries that you use, since they\nare already tested. Try to extract complex behaviors as separate\nfunctions to test individually.", "code_truncated": false}
{"chunk_id": "9de7b711304a10cee933d22232ff1d123e47b036", "file_path": "d:\\499\\docs\\testing.rst", "symbol_type": "doc", "name": "Fixtures", "qualname": "testing.rst#Fixtures", "start_line": 36, "end_line": 81, "docstring": null, "code": "--------\n\nPytest *fixtures* allow writing pieces of code that are reusable across\ntests. A simple fixture returns a value, but a fixture can also do\nsetup, yield a value, then do teardown. Fixtures for the application,\ntest client, and CLI runner are shown below, they can be placed in\n``tests/conftest.py``.\n\nIf you're using an\n:doc:`application factory </patterns/appfactories>`, define an ``app``\nfixture to create and configure an app instance. You can add code before\nand after the ``yield`` to set up and tear down other resources, such as\ncreating and clearing a database.\n\nIf you're not using a factory, you already have an app object you can\nimport and configure directly. You can still use an ``app`` fixture to\nset up and tear down resources.\n\n.. code-block:: python\n\n    import pytest\n    from my_project import create_app\n\n    @pytest.fixture()\n    def app():\n        app = create_app()\n        app.config.update({\n            \"TESTING\": True,\n        })\n\n        # other setup can go here\n\n        yield app\n\n        # clean up / reset resources here\n\n\n    @pytest.fixture()\n    def client(app):\n        return app.test_client()\n\n\n    @pytest.fixture()\n    def runner(app):\n        return app.test_cli_runner()", "code_truncated": false}
{"chunk_id": "e0d0f246b2a25aaf1b7946a9fdd5628194cb36d1", "file_path": "d:\\499\\docs\\testing.rst", "symbol_type": "doc", "name": "Sending Requests with the Test Client", "qualname": "testing.rst#Sending Requests with the Test Client", "start_line": 84, "end_line": 118, "docstring": null, "code": "-------------------------------------\n\nThe test client makes requests to the application without running a live\nserver. Flask's client extends\n:doc:`Werkzeug's client <werkzeug:test>`, see those docs for additional\ninformation.\n\nThe ``client`` has methods that match the common HTTP request methods,\nsuch as ``client.get()`` and ``client.post()``. They take many arguments\nfor building the request; you can find the full documentation in\n:class:`~werkzeug.test.EnvironBuilder`. Typically you'll use ``path``,\n``query_string``, ``headers``, and ``data`` or ``json``.\n\nTo make a request, call the method the request should use with the path\nto the route to test. A :class:`~werkzeug.test.TestResponse` is returned\nto examine the response data. It has all the usual properties of a\nresponse object. You'll usually look at ``response.data``, which is the\nbytes returned by the view. If you want to use text, Werkzeug 2.1\nprovides ``response.text``, or use ``response.get_data(as_text=True)``.\n\n.. code-block:: python\n\n    def test_request_example(client):\n        response = client.get(\"/posts\")\n        assert b\"<h2>Hello, World!</h2>\" in response.data\n\n\nPass a dict ``query_string={\"key\": \"value\", ...}`` to set arguments in\nthe query string (after the ``?`` in the URL). Pass a dict\n``headers={}`` to set request headers.\n\nTo send a request body in a POST or PUT request, pass a value to\n``data``. If raw bytes are passed, that exact body is used. Usually,\nyou'll pass a dict to set form data.", "code_truncated": false}
{"chunk_id": "84907b68bb4ab2f96b7aaa362275e7f6776f89e5", "file_path": "d:\\499\\docs\\testing.rst", "symbol_type": "doc", "name": "Form Data", "qualname": "testing.rst#Form Data", "start_line": 121, "end_line": 150, "docstring": null, "code": "~~~~~~~~~\n\nTo send form data, pass a dict to ``data``. The ``Content-Type`` header\nwill be set to ``multipart/form-data`` or\n``application/x-www-form-urlencoded`` automatically.\n\nIf a value is a file object opened for reading bytes (``\"rb\"`` mode), it\nwill be treated as an uploaded file. To change the detected filename and\ncontent type, pass a ``(file, filename, content_type)`` tuple. File\nobjects will be closed after making the request, so they do not need to\nuse the usual ``with open() as f:`` pattern.\n\nIt can be useful to store files in a ``tests/resources`` folder, then\nuse ``pathlib.Path`` to get files relative to the current test file.\n\n.. code-block:: python\n\n    from pathlib import Path\n\n    # get the resources folder in the tests folder\n    resources = Path(__file__).parent / \"resources\"\n\n    def test_edit_user(client):\n        response = client.post(\"/user/2/edit\", data={\n            \"name\": \"Flask\",\n            \"theme\": \"dark\",\n            \"picture\": (resources / \"picture.png\").open(\"rb\"),\n        })\n        assert response.status_code == 200", "code_truncated": false}
{"chunk_id": "40c07df28aab4d663612c821e7f698c5809fb3a5", "file_path": "d:\\499\\docs\\testing.rst", "symbol_type": "doc", "name": "JSON Data", "qualname": "testing.rst#JSON Data", "start_line": 153, "end_line": 177, "docstring": null, "code": "~~~~~~~~~\n\nTo send JSON data, pass an object to ``json``. The ``Content-Type``\nheader will be set to ``application/json`` automatically.\n\nSimilarly, if the response contains JSON data, the ``response.json``\nattribute will contain the deserialized object.\n\n.. code-block:: python\n\n    def test_json_data(client):\n        response = client.post(\"/graphql\", json={\n            \"query\": \"\"\"\n                query User($id: String!) {\n                    user(id: $id) {\n                        name\n                        theme\n                        picture_url\n                    }\n                }\n            \"\"\",\n            variables={\"id\": 2},\n        })\n        assert response.json[\"data\"][\"user\"][\"name\"] == \"Flask\"", "code_truncated": false}
{"chunk_id": "f19176548ebc096d9ff9ea00ab42d6a775ff0605", "file_path": "d:\\499\\docs\\testing.rst", "symbol_type": "doc", "name": "Following Redirects", "qualname": "testing.rst#Following Redirects", "start_line": 180, "end_line": 200, "docstring": null, "code": "-------------------\n\nBy default, the client does not make additional requests if the response\nis a redirect. By passing ``follow_redirects=True`` to a request method,\nthe client will continue to make requests until a non-redirect response\nis returned.\n\n:attr:`TestResponse.history <werkzeug.test.TestResponse.history>` is\na tuple of the responses that led up to the final response. Each\nresponse has a :attr:`~werkzeug.test.TestResponse.request` attribute\nwhich records the request that produced that response.\n\n.. code-block:: python\n\n    def test_logout_redirect(client):\n        response = client.get(\"/logout\", follow_redirects=True)\n        # Check that there was one redirect response.\n        assert len(response.history) == 1\n        # Check that the second request was to the index page.\n        assert response.request.path == \"/index\"", "code_truncated": false}
{"chunk_id": "32deb0b4a0730650160f0a4dae949d2a16f74ca2", "file_path": "d:\\499\\docs\\testing.rst", "symbol_type": "doc", "name": "Accessing and Modifying the Session", "qualname": "testing.rst#Accessing and Modifying the Session", "start_line": 203, "end_line": 243, "docstring": null, "code": "-----------------------------------\n\nTo access Flask's context variables, mainly\n:data:`~flask.session`, use the client in a ``with`` statement.\nThe app and request context will remain active *after* making a request,\nuntil the ``with`` block ends.\n\n.. code-block:: python\n\n    from flask import session\n\n    def test_access_session(client):\n        with client:\n            client.post(\"/auth/login\", data={\"username\": \"flask\"})\n            # session is still accessible\n            assert session[\"user_id\"] == 1\n\n        # session is no longer accessible\n\nIf you want to access or set a value in the session *before* making a\nrequest, use the client's\n:meth:`~flask.testing.FlaskClient.session_transaction` method in a\n``with`` statement. It returns a session object, and will save the\nsession once the block ends.\n\n.. code-block:: python\n\n    from flask import session\n\n    def test_modify_session(client):\n        with client.session_transaction() as session:\n            # set a user id without going through the login route\n            session[\"user_id\"] = 1\n\n        # session is saved now\n\n        response = client.get(\"/users/me\")\n        assert response.json[\"username\"] == \"flask\"\n\n\n.. _testing-cli:", "code_truncated": false}
{"chunk_id": "de3bf1e0df018e0277079a6c6d691240f3ff46d5", "file_path": "d:\\499\\docs\\testing.rst", "symbol_type": "doc", "name": "Running Commands with the CLI Runner", "qualname": "testing.rst#Running Commands with the CLI Runner", "start_line": 246, "end_line": 273, "docstring": null, "code": "------------------------------------\n\nFlask provides :meth:`~flask.Flask.test_cli_runner` to create a\n:class:`~flask.testing.FlaskCliRunner`, which runs CLI commands in\nisolation and captures the output in a :class:`~click.testing.Result`\nobject. Flask's runner extends :doc:`Click's runner <click:testing>`,\nsee those docs for additional information.\n\nUse the runner's :meth:`~flask.testing.FlaskCliRunner.invoke` method to\ncall commands in the same way they would be called with the ``flask``\ncommand from the command line.\n\n.. code-block:: python\n\n    import click\n\n    @app.cli.command(\"hello\")\n    @click.option(\"--name\", default=\"World\")\n    def hello_command(name):\n        click.echo(f\"Hello, {name}!\")\n\n    def test_hello_command(runner):\n        result = runner.invoke(args=\"hello\")\n        assert \"World\" in result.output\n\n        result = runner.invoke(args=[\"hello\", \"--name\", \"Flask\"])\n        assert \"Flask\" in result.output", "code_truncated": false}
{"chunk_id": "1b5f68b53e56e654d79682ff3809d72ddc7e775d", "file_path": "d:\\499\\docs\\testing.rst", "symbol_type": "doc", "name": "Tests that depend on an Active Context", "qualname": "testing.rst#Tests that depend on an Active Context", "start_line": 276, "end_line": 318, "docstring": null, "code": "--------------------------------------\n\nYou may have functions that are called from views or commands, that expect an\nactive :doc:`app context </appcontext>` because they access :data:`.request`,\n:data:`.session`, :data:`.g`, or :data:`.current_app`. Rather than testing them by\nmaking a request or invoking the command, you can create and activate a context\ndirectly.\n\nUse ``with app.app_context()`` to push an application context. For\nexample, database extensions usually require an active app context to\nmake queries.\n\n.. code-block:: python\n\n    def test_db_post_model(app):\n        with app.app_context():\n            post = db.session.query(Post).get(1)\n\nUse ``with app.test_request_context()`` to push a request context. It\ntakes the same arguments as the test client's request methods.\n\n.. code-block:: python\n\n    def test_validate_user_edit(app):\n        with app.test_request_context(\n            \"/user/2/edit\", method=\"POST\", data={\"name\": \"\"}\n        ):\n            # call a function that accesses `request`\n            messages = validate_edit_user()\n\n        assert messages[\"name\"][0] == \"Name cannot be empty.\"\n\nCreating a test request context doesn't run any of the Flask dispatching\ncode, so ``before_request`` functions are not called. If you need to\ncall these, usually it's better to make a full request instead. However,\nit's possible to call them manually.\n\n.. code-block:: python\n\n    def test_auth_token(app):\n        with app.test_request_context(\"/user/2/edit\", headers={\"X-Auth-Token\": \"1\"}):\n            app.preprocess_request()\n            assert g.user.name == \"Flask\"", "code_truncated": false}
{"chunk_id": "d8230c46cea5093c5c81153cff9b3ef9d64c13d8", "file_path": "d:\\499\\docs\\tutorial\\blog.rst", "symbol_type": "doc", "name": "INTRO", "qualname": "tutorial\\blog.rst#INTRO", "start_line": 1, "end_line": 1, "docstring": null, "code": ".. currentmodule:: flask", "code_truncated": false}
{"chunk_id": "d981a77010086c52390564eb12f1a6816400340c", "file_path": "d:\\499\\docs\\tutorial\\blog.rst", "symbol_type": "doc", "name": "Blog Blueprint", "qualname": "tutorial\\blog.rst#Blog Blueprint", "start_line": 4, "end_line": 13, "docstring": null, "code": "==============\n\nYou'll use the same techniques you learned about when writing the\nauthentication blueprint to write the blog blueprint. The blog should\nlist all posts, allow logged in users to create posts, and allow the\nauthor of a post to edit or delete it.\n\nAs you implement each view, keep the development server running. As you\nsave your changes, try going to the URL in your browser and testing them\nout.", "code_truncated": false}
{"chunk_id": "dd201c28262846aa3074b54d1523849816978c18", "file_path": "d:\\499\\docs\\tutorial\\blog.rst", "symbol_type": "doc", "name": "The Blueprint", "qualname": "tutorial\\blog.rst#The Blueprint", "start_line": 16, "end_line": 67, "docstring": null, "code": "-------------\n\nDefine the blueprint and register it in the application factory.\n\n.. code-block:: python\n    :caption: ``flaskr/blog.py``\n\n    from flask import (\n        Blueprint, flash, g, redirect, render_template, request, url_for\n    )\n    from werkzeug.exceptions import abort\n\n    from flaskr.auth import login_required\n    from flaskr.db import get_db\n\n    bp = Blueprint('blog', __name__)\n\nImport and register the blueprint from the factory using\n:meth:`app.register_blueprint() <Flask.register_blueprint>`. Place the\nnew code at the end of the factory function before returning the app.\n\n.. code-block:: python\n    :caption: ``flaskr/__init__.py``\n\n    def create_app():\n        app = ...\n        # existing code omitted\n\n        from . import blog\n        app.register_blueprint(blog.bp)\n        app.add_url_rule('/', endpoint='index')\n\n        return app\n\n\nUnlike the auth blueprint, the blog blueprint does not have a\n``url_prefix``. So the ``index`` view will be at ``/``, the ``create``\nview at ``/create``, and so on. The blog is the main feature of Flaskr,\nso it makes sense that the blog index will be the main index.\n\nHowever, the endpoint for the ``index`` view defined below will be\n``blog.index``. Some of the authentication views referred to a plain\n``index`` endpoint. :meth:`app.add_url_rule() <Flask.add_url_rule>`\nassociates the endpoint name ``'index'`` with the ``/`` url so that\n``url_for('index')`` or ``url_for('blog.index')`` will both work,\ngenerating the same ``/`` URL either way.\n\nIn another application you might give the blog blueprint a\n``url_prefix`` and define a separate ``index`` view in the application\nfactory, similar to the ``hello`` view. Then the ``index`` and\n``blog.index`` endpoints and URLs would be different.", "code_truncated": false}
{"chunk_id": "b5153f3345c3b4a2b0ad45024b65b010b0544237", "file_path": "d:\\499\\docs\\tutorial\\blog.rst", "symbol_type": "doc", "name": "Index", "qualname": "tutorial\\blog.rst#Index", "start_line": 70, "end_line": 129, "docstring": null, "code": "-----\n\nThe index will show all of the posts, most recent first. A ``JOIN`` is\nused so that the author information from the ``user`` table is\navailable in the result.\n\n.. code-block:: python\n    :caption: ``flaskr/blog.py``\n\n    @bp.route('/')\n    def index():\n        db = get_db()\n        posts = db.execute(\n            'SELECT p.id, title, body, created, author_id, username'\n            ' FROM post p JOIN user u ON p.author_id = u.id'\n            ' ORDER BY created DESC'\n        ).fetchall()\n        return render_template('blog/index.html', posts=posts)\n\n.. code-block:: html+jinja\n    :caption: ``flaskr/templates/blog/index.html``\n\n    {% extends 'base.html' %}\n\n    {% block header %}\n      <h1>{% block title %}Posts{% endblock %}</h1>\n      {% if g.user %}\n        <a class=\"action\" href=\"{{ url_for('blog.create') }}\">New</a>\n      {% endif %}\n    {% endblock %}\n\n    {% block content %}\n      {% for post in posts %}\n        <article class=\"post\">\n          <header>\n            <div>\n              <h1>{{ post['title'] }}</h1>\n              <div class=\"about\">by {{ post['username'] }} on {{ post['created'].strftime('%Y-%m-%d') }}</div>\n            </div>\n            {% if g.user['id'] == post['author_id'] %}\n              <a class=\"action\" href=\"{{ url_for('blog.update', id=post['id']) }}\">Edit</a>\n            {% endif %}\n          </header>\n          <p class=\"body\">{{ post['body'] }}</p>\n        </article>\n        {% if not loop.last %}\n          <hr>\n        {% endif %}\n      {% endfor %}\n    {% endblock %}\n\nWhen a user is logged in, the ``header`` block adds a link to the\n``create`` view. When the user is the author of a post, they'll see an\n\"Edit\" link to the ``update`` view for that post. ``loop.last`` is a\nspecial variable available inside `Jinja for loops`_. It's used to\ndisplay a line after each post except the last one, to visually separate\nthem.\n\n.. _Jinja for loops: https://jinja.palletsprojects.com/templates/#for", "code_truncated": false}
{"chunk_id": "3ce1893fe8542d947fb31783e339d29caea4164e", "file_path": "d:\\499\\docs\\tutorial\\blog.rst", "symbol_type": "doc", "name": "Create", "qualname": "tutorial\\blog.rst#Create", "start_line": 132, "end_line": 188, "docstring": null, "code": "------\n\nThe ``create`` view works the same as the auth ``register`` view. Either\nthe form is displayed, or the posted data is validated and the post is\nadded to the database or an error is shown.\n\nThe ``login_required`` decorator you wrote earlier is used on the blog\nviews. A user must be logged in to visit these views, otherwise they\nwill be redirected to the login page.\n\n.. code-block:: python\n    :caption: ``flaskr/blog.py``\n\n    @bp.route('/create', methods=('GET', 'POST'))\n    @login_required\n    def create():\n        if request.method == 'POST':\n            title = request.form['title']\n            body = request.form['body']\n            error = None\n\n            if not title:\n                error = 'Title is required.'\n\n            if error is not None:\n                flash(error)\n            else:\n                db = get_db()\n                db.execute(\n                    'INSERT INTO post (title, body, author_id)'\n                    ' VALUES (?, ?, ?)',\n                    (title, body, g.user['id'])\n                )\n                db.commit()\n                return redirect(url_for('blog.index'))\n\n        return render_template('blog/create.html')\n\n.. code-block:: html+jinja\n    :caption: ``flaskr/templates/blog/create.html``\n\n    {% extends 'base.html' %}\n\n    {% block header %}\n      <h1>{% block title %}New Post{% endblock %}</h1>\n    {% endblock %}\n\n    {% block content %}\n      <form method=\"post\">\n        <label for=\"title\">Title</label>\n        <input name=\"title\" id=\"title\" value=\"{{ request.form['title'] }}\" required>\n        <label for=\"body\">Body</label>\n        <textarea name=\"body\" id=\"body\">{{ request.form['body'] }}</textarea>\n        <input type=\"submit\" value=\"Save\">\n      </form>\n    {% endblock %}", "code_truncated": false}
{"chunk_id": "bc87b2e94440afe289909b08dd896e6ddb1352db", "file_path": "d:\\499\\docs\\tutorial\\blog.rst", "symbol_type": "doc", "name": "Update", "qualname": "tutorial\\blog.rst#Update", "start_line": 191, "end_line": 310, "docstring": null, "code": "------\n\nBoth the ``update`` and ``delete`` views will need to fetch a ``post``\nby ``id`` and check if the author matches the logged in user. To avoid\nduplicating code, you can write a function to get the ``post`` and call\nit from each view.\n\n.. code-block:: python\n    :caption: ``flaskr/blog.py``\n\n    def get_post(id, check_author=True):\n        post = get_db().execute(\n            'SELECT p.id, title, body, created, author_id, username'\n            ' FROM post p JOIN user u ON p.author_id = u.id'\n            ' WHERE p.id = ?',\n            (id,)\n        ).fetchone()\n\n        if post is None:\n            abort(404, f\"Post id {id} doesn't exist.\")\n\n        if check_author and post['author_id'] != g.user['id']:\n            abort(403)\n\n        return post\n\n:func:`abort` will raise a special exception that returns an HTTP status\ncode. It takes an optional message to show with the error, otherwise a\ndefault message is used. ``404`` means \"Not Found\", and ``403`` means\n\"Forbidden\". (``401`` means \"Unauthorized\", but you redirect to the\nlogin page instead of returning that status.)\n\nThe ``check_author`` argument is defined so that the function can be\nused to get a ``post`` without checking the author. This would be useful\nif you wrote a view to show an individual post on a page, where the user\ndoesn't matter because they're not modifying the post.\n\n.. code-block:: python\n    :caption: ``flaskr/blog.py``\n\n    @bp.route('/<int:id>/update', methods=('GET', 'POST'))\n    @login_required\n    def update(id):\n        post = get_post(id)\n\n        if request.method == 'POST':\n            title = request.form['title']\n            body = request.form['body']\n            error = None\n\n            if not title:\n                error = 'Title is required.'\n\n            if error is not None:\n                flash(error)\n            else:\n                db = get_db()\n                db.execute(\n                    'UPDATE post SET title = ?, body = ?'\n                    ' WHERE id = ?',\n                    (title, body, id)\n                )\n                db.commit()\n                return redirect(url_for('blog.index'))\n\n        return render_template('blog/update.html', post=post)\n\nUnlike the views you've written so far, the ``update`` function takes\nan argument, ``id``. That corresponds to the ``<int:id>`` in the route.\nA real URL will look like ``/1/update``. Flask will capture the ``1``,\nensure it's an :class:`int`, and pass it as the ``id`` argument. If you\ndon't specify ``int:`` and instead do ``<id>``, it will be a string.\nTo generate a URL to the update page, :func:`url_for` needs to be passed\nthe ``id`` so it knows what to fill in:\n``url_for('blog.update', id=post['id'])``. This is also in the\n``index.html`` file above.\n\nThe ``create`` and ``update`` views look very similar. The main\ndifference is that the ``update`` view uses a ``post`` object and an\n``UPDATE`` query instead of an ``INSERT``. With some clever refactoring,\nyou could use one view and template for both actions, but for the\ntutorial it's clearer to keep them separate.\n\n.. code-block:: html+jinja\n    :caption: ``flaskr/templates/blog/update.html``\n\n    {% extends 'base.html' %}\n\n    {% block header %}\n      <h1>{% block title %}Edit \"{{ post['title'] }}\"{% endblock %}</h1>\n    {% endblock %}\n\n    {% block content %}\n      <form method=\"post\">\n        <label for=\"title\">Title</label>\n        <input name=\"title\" id=\"title\"\n          value=\"{{ request.form['title'] or post['title'] }}\" required>\n        <label for=\"body\">Body</label>\n        <textarea name=\"body\" id=\"body\">{{ request.form['body'] or post['body'] }}</textarea>\n        <input type=\"submit\" value=\"Save\">\n      </form>\n      <hr>\n      <form action=\"{{ url_for('blog.delete', id=post['id']) }}\" method=\"post\">\n        <input class=\"danger\" type=\"submit\" value=\"Delete\" onclick=\"return confirm('Are you sure?');\">\n      </form>\n    {% endblock %}\n\nThis template has two forms. The first posts the edited data to the\ncurrent page (``/<id>/update``). The other form contains only a button\nand specifies an ``action`` attribute that posts to the delete view\ninstead. The button uses some JavaScript to show a confirmation dialog\nbefore submitting.\n\nThe pattern ``{{ request.form['title'] or post['title'] }}`` is used to\nchoose what data appears in the form. When the form hasn't been\nsubmitted, the original ``post`` data appears, but if invalid form data\nwas posted you want to display that so the user can fix the error, so\n``request.form`` is used instead. :data:`.request` is another variable\nthat's automatically available in templates.", "code_truncated": false}
{"chunk_id": "d21069f9eb453b606e976d927675256afc4a3b61", "file_path": "d:\\499\\docs\\tutorial\\blog.rst", "symbol_type": "doc", "name": "Delete", "qualname": "tutorial\\blog.rst#Delete", "start_line": 313, "end_line": 336, "docstring": null, "code": "------\n\nThe delete view doesn't have its own template, the delete button is part\nof ``update.html`` and posts to the ``/<id>/delete`` URL. Since there\nis no template, it will only handle the ``POST`` method and then redirect\nto the ``index`` view.\n\n.. code-block:: python\n    :caption: ``flaskr/blog.py``\n\n    @bp.route('/<int:id>/delete', methods=('POST',))\n    @login_required\n    def delete(id):\n        get_post(id)\n        db = get_db()\n        db.execute('DELETE FROM post WHERE id = ?', (id,))\n        db.commit()\n        return redirect(url_for('blog.index'))\n\nCongratulations, you've now finished writing your application! Take some\ntime to try out everything in the browser. However, there's still more\nto do before the project is complete.\n\nContinue to :doc:`install`.", "code_truncated": false}
{"chunk_id": "3b05d678d61870edb490e6c3df6830ab7d89e9ec", "file_path": "d:\\499\\docs\\tutorial\\database.rst", "symbol_type": "doc", "name": "INTRO", "qualname": "tutorial\\database.rst#INTRO", "start_line": 1, "end_line": 1, "docstring": null, "code": ".. currentmodule:: flask", "code_truncated": false}
{"chunk_id": "0ec1f861b30101aff957c9648ece100eb6c1354c", "file_path": "d:\\499\\docs\\tutorial\\database.rst", "symbol_type": "doc", "name": "Define and Access the Database", "qualname": "tutorial\\database.rst#Define and Access the Database", "start_line": 4, "end_line": 22, "docstring": null, "code": "==============================\n\nThe application will use a `SQLite`_ database to store users and posts.\nPython comes with built-in support for SQLite in the :mod:`sqlite3`\nmodule.\n\nSQLite is convenient because it doesn't require setting up a separate\ndatabase server and is built-in to Python. However, if concurrent\nrequests try to write to the database at the same time, they will slow\ndown as each write happens sequentially. Small applications won't notice\nthis. Once you become big, you may want to switch to a different\ndatabase.\n\nThe tutorial doesn't go into detail about SQL. If you are not familiar\nwith it, the SQLite docs describe the `language`_.\n\n.. _SQLite: https://sqlite.org/about.html\n.. _language: https://sqlite.org/lang.html", "code_truncated": false}
{"chunk_id": "406ecff19e5ef52dfb57c8d1d9bf3709fd7a7338", "file_path": "d:\\499\\docs\\tutorial\\database.rst", "symbol_type": "doc", "name": "Connect to the Database", "qualname": "tutorial\\database.rst#Connect to the Database", "start_line": 25, "end_line": 86, "docstring": null, "code": "-----------------------\n\nThe first thing to do when working with a SQLite database (and most\nother Python database libraries) is to create a connection to it. Any\nqueries and operations are performed using the connection, which is\nclosed after the work is finished.\n\nIn web applications this connection is typically tied to the request. It\nis created at some point when handling a request, and closed before the\nresponse is sent.\n\n.. code-block:: python\n    :caption: ``flaskr/db.py``\n\n    import sqlite3\n    from datetime import datetime\n\n    import click\n    from flask import current_app, g\n\n\n    def get_db():\n        if 'db' not in g:\n            g.db = sqlite3.connect(\n                current_app.config['DATABASE'],\n                detect_types=sqlite3.PARSE_DECLTYPES\n            )\n            g.db.row_factory = sqlite3.Row\n\n        return g.db\n\n\n    def close_db(e=None):\n        db = g.pop('db', None)\n\n        if db is not None:\n            db.close()\n\n:data:`.g` is a special object that is unique for each request. It is\nused to store data that might be accessed by multiple functions during\nthe request. The connection is stored and reused instead of creating a\nnew connection if ``get_db`` is called a second time in the same\nrequest.\n\n:data:`.current_app` is another special object that points to the Flask\napplication handling the request. Since you used an application factory,\nthere is no application object when writing the rest of your code.\n``get_db`` will be called when the application has been created and is\nhandling a request, so :data:`.current_app` can be used.\n\n:func:`sqlite3.connect` establishes a connection to the file pointed at\nby the ``DATABASE`` configuration key. This file doesn't have to exist\nyet, and won't until you initialize the database later.\n\n:class:`sqlite3.Row` tells the connection to return rows that behave\nlike dicts. This allows accessing the columns by name.\n\n``close_db`` checks if a connection was created by checking if ``g.db``\nwas set. If the connection exists, it is closed. Further down you will\ntell your application about the ``close_db`` function in the application\nfactory so that it is called after each request.", "code_truncated": false}
{"chunk_id": "50ecba2f8db1255312a4f8edf1471ca8d4df0261", "file_path": "d:\\499\\docs\\tutorial\\database.rst", "symbol_type": "doc", "name": "Create the Tables", "qualname": "tutorial\\database.rst#Create the Tables", "start_line": 89, "end_line": 154, "docstring": null, "code": "-----------------\n\nIn SQLite, data is stored in *tables* and *columns*. These need to be\ncreated before you can store and retrieve data. Flaskr will store users\nin the ``user`` table, and posts in the ``post`` table. Create a file\nwith the SQL commands needed to create empty tables:\n\n.. code-block:: sql\n    :caption: ``flaskr/schema.sql``\n\n    DROP TABLE IF EXISTS user;\n    DROP TABLE IF EXISTS post;\n\n    CREATE TABLE user (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      username TEXT UNIQUE NOT NULL,\n      password TEXT NOT NULL\n    );\n\n    CREATE TABLE post (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      author_id INTEGER NOT NULL,\n      created TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n      title TEXT NOT NULL,\n      body TEXT NOT NULL,\n      FOREIGN KEY (author_id) REFERENCES user (id)\n    );\n\nAdd the Python functions that will run these SQL commands to the\n``db.py`` file:\n\n.. code-block:: python\n    :caption: ``flaskr/db.py``\n\n    def init_db():\n        db = get_db()\n\n        with current_app.open_resource('schema.sql') as f:\n            db.executescript(f.read().decode('utf8'))\n\n\n    @click.command('init-db')\n    def init_db_command():\n        \"\"\"Clear the existing data and create new tables.\"\"\"\n        init_db()\n        click.echo('Initialized the database.')\n\n\n    sqlite3.register_converter(\n        \"timestamp\", lambda v: datetime.fromisoformat(v.decode())\n    )\n\n:meth:`open_resource() <Flask.open_resource>` opens a file relative to\nthe ``flaskr`` package, which is useful since you won't necessarily know\nwhere that location is when deploying the application later. ``get_db``\nreturns a database connection, which is used to execute the commands\nread from the file.\n\n:func:`click.command` defines a command line command called ``init-db``\nthat calls the ``init_db`` function and shows a success message to the\nuser. You can read :doc:`/cli` to learn more about writing commands.\n\nThe call to :func:`sqlite3.register_converter` tells Python how to\ninterpret timestamp values in the database. We convert the value to a\n:class:`datetime.datetime`.", "code_truncated": false}
{"chunk_id": "08484c2fb1736ce49318a044debe3fc94049cc3e", "file_path": "d:\\499\\docs\\tutorial\\database.rst", "symbol_type": "doc", "name": "Register with the Application", "qualname": "tutorial\\database.rst#Register with the Application", "start_line": 157, "end_line": 193, "docstring": null, "code": "-----------------------------\n\nThe ``close_db`` and ``init_db_command`` functions need to be registered\nwith the application instance; otherwise, they won't be used by the\napplication. However, since you're using a factory function, that\ninstance isn't available when writing the functions. Instead, write a\nfunction that takes an application and does the registration.\n\n.. code-block:: python\n    :caption: ``flaskr/db.py``\n\n    def init_app(app):\n        app.teardown_appcontext(close_db)\n        app.cli.add_command(init_db_command)\n\n:meth:`app.teardown_appcontext() <Flask.teardown_appcontext>` tells\nFlask to call that function when cleaning up after returning the\nresponse.\n\n:meth:`app.cli.add_command() <click.Group.add_command>` adds a new\ncommand that can be called with the ``flask`` command.\n\nImport and call this function from the factory. Place the new code at\nthe end of the factory function before returning the app.\n\n.. code-block:: python\n    :caption: ``flaskr/__init__.py``\n\n    def create_app():\n        app = ...\n        # existing code omitted\n\n        from . import db\n        db.init_app(app)\n\n        return app", "code_truncated": false}
{"chunk_id": "401ba5724bea5257891b9c8170605ef473e318ec", "file_path": "d:\\499\\docs\\tutorial\\database.rst", "symbol_type": "doc", "name": "Initialize the Database File", "qualname": "tutorial\\database.rst#Initialize the Database File", "start_line": 196, "end_line": 219, "docstring": null, "code": "----------------------------\n\nNow that ``init-db`` has been registered with the app, it can be called\nusing the ``flask`` command, similar to the ``run`` command from the\nprevious page.\n\n.. note::\n\n    If you're still running the server from the previous page, you can\n    either stop the server, or run this command in a new terminal. If\n    you use a new terminal, remember to change to your project directory\n    and activate the env as described in :doc:`/installation`.\n\nRun the ``init-db`` command:\n\n.. code-block:: none\n\n    $ flask --app flaskr init-db\n    Initialized the database.\n\nThere will now be a ``flaskr.sqlite`` file in the ``instance`` folder in\nyour project.\n\nContinue to :doc:`views`.", "code_truncated": false}
{"chunk_id": "1f594e698247cf9df13512b1fb6c0f1b0f32f658", "file_path": "d:\\499\\docs\\tutorial\\deploy.rst", "symbol_type": "doc", "name": "Deploy to Production", "qualname": "tutorial\\deploy.rst#Deploy to Production", "start_line": 2, "end_line": 12, "docstring": null, "code": "====================\n\nThis part of the tutorial assumes you have a server that you want to\ndeploy your application to. It gives an overview of how to create the\ndistribution file and install it, but won't go into specifics about\nwhat server or software to use. You can set up a new environment on your\ndevelopment computer to try out the instructions below, but probably\nshouldn't use it for hosting a real public application. See\n:doc:`/deploying/index` for a list of many different ways to host your\napplication.", "code_truncated": false}
{"chunk_id": "d88eab6ae978a5854d2879e0dfb22253a93226c6", "file_path": "d:\\499\\docs\\tutorial\\deploy.rst", "symbol_type": "doc", "name": "Build and Install", "qualname": "tutorial\\deploy.rst#Build and Install", "start_line": 15, "end_line": 49, "docstring": null, "code": "-----------------\n\nWhen you want to deploy your application elsewhere, you build a *wheel*\n(``.whl``) file. Install and use the ``build`` tool to do this.\n\n.. code-block:: none\n\n    $ pip install build\n    $ python -m build --wheel\n\nYou can find the file in ``dist/flaskr-1.0.0-py3-none-any.whl``. The\nfile name is in the format of {project name}-{version}-{python tag}\n-{abi tag}-{platform tag}.\n\nCopy this file to another machine,\n:ref:`set up a new virtualenv <install-create-env>`, then install the\nfile with ``pip``.\n\n.. code-block:: none\n\n    $ pip install flaskr-1.0.0-py3-none-any.whl\n\nPip will install your project along with its dependencies.\n\nSince this is a different machine, you need to run ``init-db`` again to\ncreate the database in the instance folder.\n\n    .. code-block:: text\n\n        $ flask --app flaskr init-db\n\nWhen Flask detects that it's installed (not in editable mode), it uses\na different directory for the instance folder. You can find it at\n``.venv/var/flaskr-instance`` instead.", "code_truncated": false}
{"chunk_id": "0dd7350ba6ee78a419bd1df973140130572dcc64", "file_path": "d:\\499\\docs\\tutorial\\deploy.rst", "symbol_type": "doc", "name": "Configure the Secret Key", "qualname": "tutorial\\deploy.rst#Configure the Secret Key", "start_line": 52, "end_line": 77, "docstring": null, "code": "------------------------\n\nIn the beginning of the tutorial that you gave a default value for\n:data:`SECRET_KEY`. This should be changed to some random bytes in\nproduction. Otherwise, attackers could use the public ``'dev'`` key to\nmodify the session cookie, or anything else that uses the secret key.\n\nYou can use the following command to output a random secret key:\n\n.. code-block:: none\n\n    $ python -c 'import secrets; print(secrets.token_hex())'\n\n    '192b9bdd22ab9ed4d12e236c78afcb9a393ec15f71bbf5dc987d54727823bcbf'\n\nCreate the ``config.py`` file in the instance folder, which the factory\nwill read from if it exists. Copy the generated value into it.\n\n.. code-block:: python\n    :caption: ``.venv/var/flaskr-instance/config.py``\n\n    SECRET_KEY = '192b9bdd22ab9ed4d12e236c78afcb9a393ec15f71bbf5dc987d54727823bcbf'\n\nYou can also set any other necessary configuration here, although\n``SECRET_KEY`` is the only one needed for Flaskr.", "code_truncated": false}
{"chunk_id": "0bf4feadc514802193660a8d80c723ba6f25fa64", "file_path": "d:\\499\\docs\\tutorial\\deploy.rst", "symbol_type": "doc", "name": "Run with a Production Server", "qualname": "tutorial\\deploy.rst#Run with a Production Server", "start_line": 80, "end_line": 111, "docstring": null, "code": "----------------------------\n\nWhen running publicly rather than in development, you should not use the\nbuilt-in development server (``flask run``). The development server is\nprovided by Werkzeug for convenience, but is not designed to be\nparticularly efficient, stable, or secure.\n\nInstead, use a production WSGI server. For example, to use `Waitress`_,\nfirst install it in the virtual environment:\n\n.. code-block:: none\n\n    $ pip install waitress\n\nYou need to tell Waitress about your application, but it doesn't use\n``--app`` like ``flask run`` does. You need to tell it to import and\ncall the application factory to get an application object.\n\n.. code-block:: none\n\n    $ waitress-serve --call 'flaskr:create_app'\n\n    Serving on http://0.0.0.0:8080\n\nSee :doc:`/deploying/index` for a list of many different ways to host\nyour application. Waitress is just an example, chosen for the tutorial\nbecause it supports both Windows and Linux. There are many more WSGI\nservers and deployment options that you may choose for your project.\n\n.. _Waitress: https://docs.pylonsproject.org/projects/waitress/en/stable/\n\nContinue to :doc:`next`.", "code_truncated": false}
{"chunk_id": "0d103dcdfebc349b570d8f3e29d87a28d4403a08", "file_path": "d:\\499\\docs\\tutorial\\factory.rst", "symbol_type": "doc", "name": "INTRO", "qualname": "tutorial\\factory.rst#INTRO", "start_line": 1, "end_line": 1, "docstring": null, "code": ".. currentmodule:: flask", "code_truncated": false}
{"chunk_id": "6c369b39dd3d4d946e9a1920f0669ab59888ae44", "file_path": "d:\\499\\docs\\tutorial\\factory.rst", "symbol_type": "doc", "name": "Application Setup", "qualname": "tutorial\\factory.rst#Application Setup", "start_line": 4, "end_line": 21, "docstring": null, "code": "=================\n\nA Flask application is an instance of the :class:`Flask` class.\nEverything about the application, such as configuration and URLs, will\nbe registered with this class.\n\nThe most straightforward way to create a Flask application is to create\na global :class:`Flask` instance directly at the top of your code, like\nhow the \"Hello, World!\" example did on the previous page. While this is\nsimple and useful in some cases, it can cause some tricky issues as the\nproject grows.\n\nInstead of creating a :class:`Flask` instance globally, you will create\nit inside a function. This function is known as the *application\nfactory*. Any configuration, registration, and other setup the\napplication needs will happen inside the function, then the application\nwill be returned.", "code_truncated": false}
{"chunk_id": "06a360c3a3f9fe167724889a64648e5b26c3a559", "file_path": "d:\\499\\docs\\tutorial\\factory.rst", "symbol_type": "doc", "name": "The Application Factory", "qualname": "tutorial\\factory.rst#The Application Factory", "start_line": 24, "end_line": 123, "docstring": null, "code": "-----------------------\n\nIt's time to start coding! Create the ``flaskr`` directory and add the\n``__init__.py`` file. The ``__init__.py`` serves double duty: it will\ncontain the application factory, and it tells Python that the ``flaskr``\ndirectory should be treated as a package.\n\n.. code-block:: none\n\n    $ mkdir flaskr\n\n.. code-block:: python\n    :caption: ``flaskr/__init__.py``\n\n    import os\n\n    from flask import Flask\n\n\n    def create_app(test_config=None):\n        # create and configure the app\n        app = Flask(__name__, instance_relative_config=True)\n        app.config.from_mapping(\n            SECRET_KEY='dev',\n            DATABASE=os.path.join(app.instance_path, 'flaskr.sqlite'),\n        )\n\n        if test_config is None:\n            # load the instance config, if it exists, when not testing\n            app.config.from_pyfile('config.py', silent=True)\n        else:\n            # load the test config if passed in\n            app.config.from_mapping(test_config)\n\n        # ensure the instance folder exists\n        try:\n            os.makedirs(app.instance_path)\n        except OSError:\n            pass\n\n        # a simple page that says hello\n        @app.route('/hello')\n        def hello():\n            return 'Hello, World!'\n\n        return app\n\n``create_app`` is the application factory function. You'll add to it\nlater in the tutorial, but it already does a lot.\n\n#.  ``app = Flask(__name__, instance_relative_config=True)`` creates the\n    :class:`Flask` instance.\n\n    *   ``__name__`` is the name of the current Python module. The app\n        needs to know where it's located to set up some paths, and\n        ``__name__`` is a convenient way to tell it that.\n\n    *   ``instance_relative_config=True`` tells the app that\n        configuration files are relative to the\n        :ref:`instance folder <instance-folders>`. The instance folder\n        is located outside the ``flaskr`` package and can hold local\n        data that shouldn't be committed to version control, such as\n        configuration secrets and the database file.\n\n#.  :meth:`app.config.from_mapping() <Config.from_mapping>` sets\n    some default configuration that the app will use:\n\n    *   :data:`SECRET_KEY` is used by Flask and extensions to keep data\n        safe. It's set to ``'dev'`` to provide a convenient value\n        during development, but it should be overridden with a random\n        value when deploying.\n\n    *   ``DATABASE`` is the path where the SQLite database file will be\n        saved. It's under\n        :attr:`app.instance_path <Flask.instance_path>`, which is the\n        path that Flask has chosen for the instance folder. You'll learn\n        more about the database in the next section.\n\n#.  :meth:`app.config.from_pyfile() <Config.from_pyfile>` overrides\n    the default configuration with values taken from the ``config.py``\n    file in the instance folder if it exists. For example, when\n    deploying, this can be used to set a real ``SECRET_KEY``.\n\n    *   ``test_config`` can also be passed to the factory, and will be\n        used instead of the instance configuration. This is so the tests\n        you'll write later in the tutorial can be configured\n        independently of any development values you have configured.\n\n#.  :func:`os.makedirs` ensures that\n    :attr:`app.instance_path <Flask.instance_path>` exists. Flask\n    doesn't create the instance folder automatically, but it needs to be\n    created because your project will create the SQLite database file\n    there.\n\n#.  :meth:`@app.route() <Flask.route>` creates a simple route so you can\n    see the application working before getting into the rest of the\n    tutorial. It creates a connection between the URL ``/hello`` and a\n    function that returns a response, the string ``'Hello, World!'`` in\n    this case.", "code_truncated": false}
{"chunk_id": "71c79746b9867c6dbabab9891171822061b61f5e", "file_path": "d:\\499\\docs\\tutorial\\factory.rst", "symbol_type": "doc", "name": "Run The Application", "qualname": "tutorial\\factory.rst#Run The Application", "start_line": 126, "end_line": 162, "docstring": null, "code": "-------------------\n\nNow you can run your application using the ``flask`` command. From the\nterminal, tell Flask where to find your application, then run it in\ndebug mode. Remember, you should still be in the top-level\n``flask-tutorial`` directory, not the ``flaskr`` package.\n\nDebug mode shows an interactive debugger whenever a page raises an\nexception, and restarts the server whenever you make changes to the\ncode. You can leave it running and just reload the browser page as you\nfollow the tutorial.\n\n.. code-block:: text\n\n    $ flask --app flaskr run --debug\n\nYou'll see output similar to this:\n\n.. code-block:: text\n\n     * Serving Flask app \"flaskr\"\n     * Debug mode: on\n     * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n     * Restarting with stat\n     * Debugger is active!\n     * Debugger PIN: nnn-nnn-nnn\n\nVisit http://127.0.0.1:5000/hello in a browser and you should see the\n\"Hello, World!\" message. Congratulations, you're now running your Flask\nweb application!\n\nIf another program is already using port 5000, you'll see\n``OSError: [Errno 98]`` or ``OSError: [WinError 10013]`` when the\nserver tries to start. See :ref:`address-already-in-use` for how to\nhandle that.\n\nContinue to :doc:`database`.", "code_truncated": false}
{"chunk_id": "dcb8997e409983ff4ae7d6a4c26ac425ee1938a8", "file_path": "d:\\499\\docs\\tutorial\\index.rst", "symbol_type": "doc", "name": "Tutorial", "qualname": "tutorial\\index.rst#Tutorial", "start_line": 2, "end_line": 64, "docstring": null, "code": "========\n\n.. toctree::\n    :caption: Contents:\n    :maxdepth: 1\n\n    layout\n    factory\n    database\n    views\n    templates\n    static\n    blog\n    install\n    tests\n    deploy\n    next\n\nThis tutorial will walk you through creating a basic blog application\ncalled Flaskr. Users will be able to register, log in, create posts,\nand edit or delete their own posts. You will be able to package and\ninstall the application on other computers.\n\n.. image:: flaskr_index.png\n    :align: center\n    :class: screenshot\n    :alt: screenshot of index page\n\nIt's assumed that you're already familiar with Python. The `official\ntutorial`_ in the Python docs is a great way to learn or review first.\n\n.. _official tutorial: https://docs.python.org/3/tutorial/\n\nWhile it's designed to give a good starting point, the tutorial doesn't\ncover all of Flask's features. Check out the :doc:`/quickstart` for an\noverview of what Flask can do, then dive into the docs to find out more.\nThe tutorial only uses what's provided by Flask and Python. In another\nproject, you might decide to use :doc:`/extensions` or other libraries\nto make some tasks simpler.\n\n.. image:: flaskr_login.png\n    :align: center\n    :class: screenshot\n    :alt: screenshot of login page\n\nFlask is flexible. It doesn't require you to use any particular project\nor code layout. However, when first starting, it's helpful to use a more\nstructured approach. This means that the tutorial will require a bit of\nboilerplate up front, but it's done to avoid many common pitfalls that\nnew developers encounter, and it creates a project that's easy to expand\non. Once you become more comfortable with Flask, you can step out of\nthis structure and take full advantage of Flask's flexibility.\n\n.. image:: flaskr_edit.png\n    :align: center\n    :class: screenshot\n    :alt: screenshot of edit page\n\n:gh:`The tutorial project is available as an example in the Flask\nrepository <examples/tutorial>`, if you want to compare your project\nwith the final product as you follow the tutorial.\n\nContinue to :doc:`layout`.", "code_truncated": false}
{"chunk_id": "fc12f3a545cb93f03a6af8893281b8738ba7efdf", "file_path": "d:\\499\\docs\\tutorial\\install.rst", "symbol_type": "doc", "name": "Make the Project Installable", "qualname": "tutorial\\install.rst#Make the Project Installable", "start_line": 2, "end_line": 25, "docstring": null, "code": "============================\n\nMaking your project installable means that you can build a *wheel* file and install that\nin another environment, just like you installed Flask in your project's environment.\nThis makes deploying your project the same as installing any other library, so you're\nusing all the standard Python tools to manage everything.\n\nInstalling also comes with other benefits that might not be obvious from\nthe tutorial or as a new Python user, including:\n\n*   Currently, Python and Flask understand how to use the ``flaskr``\n    package only because you're running from your project's directory.\n    Installing means you can import it no matter where you run from.\n\n*   You can manage your project's dependencies just like other packages\n    do, so ``pip install yourproject.whl`` installs them.\n\n*   Test tools can isolate your test environment from your development\n    environment.\n\n.. note::\n    This is being introduced late in the tutorial, but in your future\n    projects you should always start with this.", "code_truncated": false}
{"chunk_id": "e1501ae4282754b42df1981c17f67bca4ad0a2ed", "file_path": "d:\\499\\docs\\tutorial\\install.rst", "symbol_type": "doc", "name": "Describe the Project", "qualname": "tutorial\\install.rst#Describe the Project", "start_line": 28, "end_line": 51, "docstring": null, "code": "--------------------\n\nThe ``pyproject.toml`` file describes your project and how to build it.\n\n.. code-block:: toml\n    :caption: ``pyproject.toml``\n\n    [project]\n    name = \"flaskr\"\n    version = \"1.0.0\"\n    description = \"The basic blog app built in the Flask tutorial.\"\n    dependencies = [\n        \"flask\",\n    ]\n\n    [build-system]\n    requires = [\"flit_core<4\"]\n    build-backend = \"flit_core.buildapi\"\n\nSee the official `Packaging tutorial <packaging tutorial_>`_ for more\nexplanation of the files and options used.\n\n.. _packaging tutorial: https://packaging.python.org/tutorials/packaging-projects/", "code_truncated": false}
{"chunk_id": "bd6d0a479daffb59ee34ec7f294222f0c0293814", "file_path": "d:\\499\\docs\\tutorial\\install.rst", "symbol_type": "doc", "name": "Install the Project", "qualname": "tutorial\\install.rst#Install the Project", "start_line": 54, "end_line": 89, "docstring": null, "code": "-------------------\n\nUse ``pip`` to install your project in the virtual environment.\n\n.. code-block:: none\n\n    $ pip install -e .\n\nThis tells pip to find ``pyproject.toml`` in the current directory and install the\nproject in *editable* or *development* mode. Editable mode means that as you make\nchanges to your local code, you'll only need to re-install if you change the metadata\nabout the project, such as its dependencies.\n\nYou can observe that the project is now installed with ``pip list``.\n\n.. code-block:: none\n\n    $ pip list\n\n    Package        Version   Location\n    -------------- --------- ----------------------------------\n    click          6.7\n    Flask          1.0\n    flaskr         1.0.0     /home/user/Projects/flask-tutorial\n    itsdangerous   0.24\n    Jinja2         2.10\n    MarkupSafe     1.0\n    pip            9.0.3\n    Werkzeug       0.14.1\n\nNothing changes from how you've been running your project so far.\n``--app`` is still set to ``flaskr`` and ``flask run`` still runs\nthe application, but you can call it from anywhere, not just the\n``flask-tutorial`` directory.\n\nContinue to :doc:`tests`.", "code_truncated": false}
{"chunk_id": "4f6f18eb975bb6684f3b923ac07eff784b69aa35", "file_path": "d:\\499\\docs\\tutorial\\layout.rst", "symbol_type": "doc", "name": "Project Layout", "qualname": "tutorial\\layout.rst#Project Layout", "start_line": 2, "end_line": 110, "docstring": null, "code": "==============\n\nCreate a project directory and enter it:\n\n.. code-block:: none\n\n    $ mkdir flask-tutorial\n    $ cd flask-tutorial\n\nThen follow the :doc:`installation instructions </installation>` to set\nup a Python virtual environment and install Flask for your project.\n\nThe tutorial will assume you're working from the ``flask-tutorial``\ndirectory from now on. The file names at the top of each code block are\nrelative to this directory.\n\n----\n\nA Flask application can be as simple as a single file.\n\n.. code-block:: python\n    :caption: ``hello.py``\n\n    from flask import Flask\n\n    app = Flask(__name__)\n\n\n    @app.route('/')\n    def hello():\n        return 'Hello, World!'\n\nHowever, as a project gets bigger, it becomes overwhelming to keep all\nthe code in one file. Python projects use *packages* to organize code\ninto multiple modules that can be imported where needed, and the\ntutorial will do this as well.\n\nThe project directory will contain:\n\n* ``flaskr/``, a Python package containing your application code and\n  files.\n* ``tests/``, a directory containing test modules.\n* ``.venv/``, a Python virtual environment where Flask and other\n  dependencies are installed.\n* Installation files telling Python how to install your project.\n* Version control config, such as `git`_. You should make a habit of\n  using some type of version control for all your projects, no matter\n  the size.\n* Any other project files you might add in the future.\n\n.. _git: https://git-scm.com/\n\nBy the end, your project layout will look like this:\n\n.. code-block:: none\n\n    /home/user/Projects/flask-tutorial\n     flaskr/\n        __init__.py\n        db.py\n        schema.sql\n        auth.py\n        blog.py\n        templates/\n           base.html\n           auth/\n              login.html\n              register.html\n           blog/\n               create.html\n               index.html\n               update.html\n        static/\n            style.css\n     tests/\n        conftest.py\n        data.sql\n        test_factory.py\n        test_db.py\n        test_auth.py\n        test_blog.py\n     .venv/\n     pyproject.toml\n     MANIFEST.in\n\nIf you're using version control, the following files that are generated\nwhile running your project should be ignored. There may be other files\nbased on the editor you use. In general, ignore files that you didn't\nwrite. For example, with git:\n\n.. code-block:: none\n    :caption: ``.gitignore``\n\n    .venv/\n\n    *.pyc\n    __pycache__/\n\n    instance/\n\n    .pytest_cache/\n    .coverage\n    htmlcov/\n\n    dist/\n    build/\n    *.egg-info/\n\nContinue to :doc:`factory`.", "code_truncated": false}
{"chunk_id": "3a18481600be3203bf2e73986e305292c8eb71d5", "file_path": "d:\\499\\docs\\tutorial\\next.rst", "symbol_type": "doc", "name": "Keep Developing!", "qualname": "tutorial\\next.rst#Keep Developing!", "start_line": 2, "end_line": 38, "docstring": null, "code": "================\n\nYou've learned about quite a few Flask and Python concepts throughout\nthe tutorial. Go back and review the tutorial and compare your code with\nthe steps you took to get there. Compare your project to the\n:gh:`example project <examples/tutorial>`, which might look a bit\ndifferent due to the step-by-step nature of the tutorial.\n\nThere's a lot more to Flask than what you've seen so far. Even so,\nyou're now equipped to start developing your own web applications. Check\nout the :doc:`/quickstart` for an overview of what Flask can do, then\ndive into the docs to keep learning. Flask uses `Jinja`_, `Click`_,\n`Werkzeug`_, and `ItsDangerous`_ behind the scenes, and they all have\ntheir own documentation too. You'll also be interested in\n:doc:`/extensions` which make tasks like working with the database or\nvalidating form data easier and more powerful.\n\nIf you want to keep developing your Flaskr project, here are some ideas\nfor what to try next:\n\n*   A detail view to show a single post. Click a post's title to go to\n    its page.\n*   Like / unlike a post.\n*   Comments.\n*   Tags. Clicking a tag shows all the posts with that tag.\n*   A search box that filters the index page by name.\n*   Paged display. Only show 5 posts per page.\n*   Upload an image to go along with a post.\n*   Format posts using Markdown.\n*   An RSS feed of new posts.\n\nHave fun and make awesome applications!\n\n.. _Jinja: https://palletsprojects.com/p/jinja/\n.. _Click: https://palletsprojects.com/p/click/\n.. _Werkzeug: https://palletsprojects.com/p/werkzeug/\n.. _ItsDangerous: https://palletsprojects.com/p/itsdangerous/", "code_truncated": false}
{"chunk_id": "09f2063148c97d1cdf912b67e659b2c14a850b37", "file_path": "d:\\499\\docs\\tutorial\\static.rst", "symbol_type": "doc", "name": "Static Files", "qualname": "tutorial\\static.rst#Static Files", "start_line": 2, "end_line": 72, "docstring": null, "code": "============\n\nThe authentication views and templates work, but they look very plain\nright now. Some `CSS`_ can be added to add style to the HTML layout you\nconstructed. The style won't change, so it's a *static* file rather than\na template.\n\nFlask automatically adds a ``static`` view that takes a path relative\nto the ``flaskr/static`` directory and serves it. The ``base.html``\ntemplate already has a link to the ``style.css`` file:\n\n.. code-block:: html+jinja\n\n    {{ url_for('static', filename='style.css') }}\n\nBesides CSS, other types of static files might be files with JavaScript\nfunctions, or a logo image. They are all placed under the\n``flaskr/static`` directory and referenced with\n``url_for('static', filename='...')``.\n\nThis tutorial isn't focused on how to write CSS, so you can just copy\nthe following into the ``flaskr/static/style.css`` file:\n\n.. code-block:: css\n    :caption: ``flaskr/static/style.css``\n\n    html { font-family: sans-serif; background: #eee; padding: 1rem; }\n    body { max-width: 960px; margin: 0 auto; background: white; }\n    h1 { font-family: serif; color: #377ba8; margin: 1rem 0; }\n    a { color: #377ba8; }\n    hr { border: none; border-top: 1px solid lightgray; }\n    nav { background: lightgray; display: flex; align-items: center; padding: 0 0.5rem; }\n    nav h1 { flex: auto; margin: 0; }\n    nav h1 a { text-decoration: none; padding: 0.25rem 0.5rem; }\n    nav ul  { display: flex; list-style: none; margin: 0; padding: 0; }\n    nav ul li a, nav ul li span, header .action { display: block; padding: 0.5rem; }\n    .content { padding: 0 1rem 1rem; }\n    .content > header { border-bottom: 1px solid lightgray; display: flex; align-items: flex-end; }\n    .content > header h1 { flex: auto; margin: 1rem 0 0.25rem 0; }\n    .flash { margin: 1em 0; padding: 1em; background: #cae6f6; border: 1px solid #377ba8; }\n    .post > header { display: flex; align-items: flex-end; font-size: 0.85em; }\n    .post > header > div:first-of-type { flex: auto; }\n    .post > header h1 { font-size: 1.5em; margin-bottom: 0; }\n    .post .about { color: slategray; font-style: italic; }\n    .post .body { white-space: pre-line; }\n    .content:last-child { margin-bottom: 0; }\n    .content form { margin: 1em 0; display: flex; flex-direction: column; }\n    .content label { font-weight: bold; margin-bottom: 0.5em; }\n    .content input, .content textarea { margin-bottom: 1em; }\n    .content textarea { min-height: 12em; resize: vertical; }\n    input.danger { color: #cc2f2e; }\n    input[type=submit] { align-self: start; min-width: 10em; }\n\nYou can find a less compact version of ``style.css`` in the\n:gh:`example code <examples/tutorial/flaskr/static/style.css>`.\n\nGo to http://127.0.0.1:5000/auth/login and the page should look like the\nscreenshot below.\n\n.. image:: flaskr_login.png\n    :align: center\n    :class: screenshot\n    :alt: screenshot of login page\n\nYou can read more about CSS from `Mozilla's documentation <CSS_>`_. If\nyou change a static file, refresh the browser page. If the change\ndoesn't show up, try clearing your browser's cache.\n\n.. _CSS: https://developer.mozilla.org/docs/Web/CSS\n\nContinue to :doc:`blog`.", "code_truncated": false}
{"chunk_id": "0cef43bc405b14a3b87e9ecee960acb58ee7d706", "file_path": "d:\\499\\docs\\tutorial\\templates.rst", "symbol_type": "doc", "name": "INTRO", "qualname": "tutorial\\templates.rst#INTRO", "start_line": 1, "end_line": 1, "docstring": null, "code": ".. currentmodule:: flask", "code_truncated": false}
{"chunk_id": "27158e3239abec0913fc276b7dee2b604593c5b8", "file_path": "d:\\499\\docs\\tutorial\\templates.rst", "symbol_type": "doc", "name": "Templates", "qualname": "tutorial\\templates.rst#Templates", "start_line": 4, "end_line": 36, "docstring": null, "code": "=========\n\nYou've written the authentication views for your application, but if\nyou're running the server and try to go to any of the URLs, you'll see a\n``TemplateNotFound`` error. That's because the views are calling\n:func:`render_template`, but you haven't written the templates yet.\nThe template files will be stored in the ``templates`` directory inside\nthe ``flaskr`` package.\n\nTemplates are files that contain static data as well as placeholders\nfor dynamic data. A template is rendered with specific data to produce a\nfinal document. Flask uses the `Jinja`_ template library to render\ntemplates.\n\nIn your application, you will use templates to render `HTML`_ which\nwill display in the user's browser. In Flask, Jinja is configured to\n*autoescape* any data that is rendered in HTML templates. This means\nthat it's safe to render user input; any characters they've entered that\ncould mess with the HTML, such as ``<`` and ``>`` will be *escaped* with\n*safe* values that look the same in the browser but don't cause unwanted\neffects.\n\nJinja looks and behaves mostly like Python. Special delimiters are used\nto distinguish Jinja syntax from the static data in the template.\nAnything between ``{{`` and ``}}`` is an expression that will be output\nto the final document. ``{%`` and ``%}`` denotes a control flow\nstatement like ``if`` and ``for``. Unlike Python, blocks are denoted\nby start and end tags rather than indentation since static text within\na block could change indentation.\n\n.. _Jinja: https://jinja.palletsprojects.com/templates/\n.. _HTML: https://developer.mozilla.org/docs/Web/HTML", "code_truncated": false}
{"chunk_id": "aa063cd439b9df5cb810d38c01e2903e52904ff5", "file_path": "d:\\499\\docs\\tutorial\\templates.rst", "symbol_type": "doc", "name": "The Base Layout", "qualname": "tutorial\\templates.rst#The Base Layout", "start_line": 39, "end_line": 100, "docstring": null, "code": "---------------\n\nEach page in the application will have the same basic layout around a\ndifferent body. Instead of writing the entire HTML structure in each\ntemplate, each template will *extend* a base template and override\nspecific sections.\n\n.. code-block:: html+jinja\n    :caption: ``flaskr/templates/base.html``\n\n    <!doctype html>\n    <title>{% block title %}{% endblock %} - Flaskr</title>\n    <link rel=\"stylesheet\" href=\"{{ url_for('static', filename='style.css') }}\">\n    <nav>\n      <h1>Flaskr</h1>\n      <ul>\n        {% if g.user %}\n          <li><span>{{ g.user['username'] }}</span>\n          <li><a href=\"{{ url_for('auth.logout') }}\">Log Out</a>\n        {% else %}\n          <li><a href=\"{{ url_for('auth.register') }}\">Register</a>\n          <li><a href=\"{{ url_for('auth.login') }}\">Log In</a>\n        {% endif %}\n      </ul>\n    </nav>\n    <section class=\"content\">\n      <header>\n        {% block header %}{% endblock %}\n      </header>\n      {% for message in get_flashed_messages() %}\n        <div class=\"flash\">{{ message }}</div>\n      {% endfor %}\n      {% block content %}{% endblock %}\n    </section>\n\n:data:`.g` is automatically available in templates. Based on if\n``g.user`` is set (from ``load_logged_in_user``), either the username\nand a log out link are displayed, or links to register and log in\nare displayed. :func:`url_for` is also automatically available, and is\nused to generate URLs to views instead of writing them out manually.\n\nAfter the page title, and before the content, the template loops over\neach message returned by :func:`get_flashed_messages`. You used\n:func:`flash` in the views to show error messages, and this is the code\nthat will display them.\n\nThere are three blocks defined here that will be overridden in the other\ntemplates:\n\n#.  ``{% block title %}`` will change the title displayed in the\n    browser's tab and window title.\n\n#.  ``{% block header %}`` is similar to ``title`` but will change the\n    title displayed on the page.\n\n#.  ``{% block content %}`` is where the content of each page goes, such\n    as the login form or a blog post.\n\nThe base template is directly in the ``templates`` directory. To keep\nthe others organized, the templates for a blueprint will be placed in a\ndirectory with the same name as the blueprint.", "code_truncated": false}
{"chunk_id": "a63dbfc5993aeb19fab0b158faff20628fdd7e9d", "file_path": "d:\\499\\docs\\tutorial\\templates.rst", "symbol_type": "doc", "name": "Register", "qualname": "tutorial\\templates.rst#Register", "start_line": 103, "end_line": 141, "docstring": null, "code": "--------\n\n.. code-block:: html+jinja\n    :caption: ``flaskr/templates/auth/register.html``\n\n    {% extends 'base.html' %}\n\n    {% block header %}\n      <h1>{% block title %}Register{% endblock %}</h1>\n    {% endblock %}\n\n    {% block content %}\n      <form method=\"post\">\n        <label for=\"username\">Username</label>\n        <input name=\"username\" id=\"username\" required>\n        <label for=\"password\">Password</label>\n        <input type=\"password\" name=\"password\" id=\"password\" required>\n        <input type=\"submit\" value=\"Register\">\n      </form>\n    {% endblock %}\n\n``{% extends 'base.html' %}`` tells Jinja that this template should\nreplace the blocks from the base template. All the rendered content must\nappear inside ``{% block %}`` tags that override blocks from the base\ntemplate.\n\nA useful pattern used here is to place ``{% block title %}`` inside\n``{% block header %}``. This will set the title block and then output\nthe value of it into the header block, so that both the window and page\nshare the same title without writing it twice.\n\nThe ``input`` tags are using the ``required`` attribute here. This tells\nthe browser not to submit the form until those fields are filled in. If\nthe user is using an older browser that doesn't support that attribute,\nor if they are using something besides a browser to make requests, you\nstill want to validate the data in the Flask view. It's important to\nalways fully validate the data on the server, even if the client does\nsome validation as well.", "code_truncated": false}
{"chunk_id": "f959757bb0d8fbbdb9c413eaeae60d83866c97f9", "file_path": "d:\\499\\docs\\tutorial\\templates.rst", "symbol_type": "doc", "name": "Log In", "qualname": "tutorial\\templates.rst#Log In", "start_line": 144, "end_line": 167, "docstring": null, "code": "------\n\nThis is identical to the register template except for the title and\nsubmit button.\n\n.. code-block:: html+jinja\n    :caption: ``flaskr/templates/auth/login.html``\n\n    {% extends 'base.html' %}\n\n    {% block header %}\n      <h1>{% block title %}Log In{% endblock %}</h1>\n    {% endblock %}\n\n    {% block content %}\n      <form method=\"post\">\n        <label for=\"username\">Username</label>\n        <input name=\"username\" id=\"username\" required>\n        <label for=\"password\">Password</label>\n        <input type=\"password\" name=\"password\" id=\"password\" required>\n        <input type=\"submit\" value=\"Log In\">\n      </form>\n    {% endblock %}", "code_truncated": false}
{"chunk_id": "0f747bcc2ff9c960f0340ef425f41aaf80991cc9", "file_path": "d:\\499\\docs\\tutorial\\templates.rst", "symbol_type": "doc", "name": "Register A User", "qualname": "tutorial\\templates.rst#Register A User", "start_line": 170, "end_line": 187, "docstring": null, "code": "---------------\n\nNow that the authentication templates are written, you can register a\nuser. Make sure the server is still running (``flask run`` if it's not),\nthen go to http://127.0.0.1:5000/auth/register.\n\nTry clicking the \"Register\" button without filling out the form and see\nthat the browser shows an error message. Try removing the ``required``\nattributes from the ``register.html`` template and click \"Register\"\nagain. Instead of the browser showing an error, the page will reload and\nthe error from :func:`flash` in the view will be shown.\n\nFill out a username and password and you'll be redirected to the login\npage. Try entering an incorrect username, or the correct username and\nincorrect password. If you log in you'll get an error because there's\nno ``index`` view to redirect to yet.\n\nContinue to :doc:`static`.", "code_truncated": false}
{"chunk_id": "d1bbccbe8c15ba6cdfc2f70071efddef4dfd42c8", "file_path": "d:\\499\\docs\\tutorial\\tests.rst", "symbol_type": "doc", "name": "INTRO", "qualname": "tutorial\\tests.rst#INTRO", "start_line": 1, "end_line": 1, "docstring": null, "code": ".. currentmodule:: flask", "code_truncated": false}
{"chunk_id": "e14c2b75028e5315eb60b1bf53393bc968190e95", "file_path": "d:\\499\\docs\\tutorial\\tests.rst", "symbol_type": "doc", "name": "Test Coverage", "qualname": "tutorial\\tests.rst#Test Coverage", "start_line": 4, "end_line": 35, "docstring": null, "code": "=============\n\nWriting unit tests for your application lets you check that the code\nyou wrote works the way you expect. Flask provides a test client that\nsimulates requests to the application and returns the response data.\n\nYou should test as much of your code as possible. Code in functions only\nruns when the function is called, and code in branches, such as ``if``\nblocks, only runs when the condition is met. You want to make sure that\neach function is tested with data that covers each branch.\n\nThe closer you get to 100% coverage, the more comfortable you can be\nthat making a change won't unexpectedly change other behavior. However,\n100% coverage doesn't guarantee that your application doesn't have bugs.\nIn particular, it doesn't test how the user interacts with the\napplication in the browser. Despite this, test coverage is an important\ntool to use during development.\n\n.. note::\n    This is being introduced late in the tutorial, but in your future\n    projects you should test as you develop.\n\nYou'll use `pytest`_ and `coverage`_ to test and measure your code.\nInstall them both:\n\n.. code-block:: none\n\n    $ pip install pytest coverage\n\n.. _pytest: https://pytest.readthedocs.io/\n.. _coverage: https://coverage.readthedocs.io/", "code_truncated": false}
{"chunk_id": "ff97edc626ccd921df37b905b4d8addb4119a258", "file_path": "d:\\499\\docs\\tutorial\\tests.rst", "symbol_type": "doc", "name": "Setup and Fixtures", "qualname": "tutorial\\tests.rst#Setup and Fixtures", "start_line": 38, "end_line": 134, "docstring": null, "code": "------------------\n\nThe test code is located in the ``tests`` directory. This directory is\n*next to* the ``flaskr`` package, not inside it. The\n``tests/conftest.py`` file contains setup functions called *fixtures*\nthat each test will use. Tests are in Python modules that start with\n``test_``, and each test function in those modules also starts with\n``test_``.\n\nEach test will create a new temporary database file and populate some\ndata that will be used in the tests. Write a SQL file to insert that\ndata.\n\n.. code-block:: sql\n    :caption: ``tests/data.sql``\n\n    INSERT INTO user (username, password)\n    VALUES\n      ('test', 'pbkdf2:sha256:50000$TCI4GzcX$0de171a4f4dac32e3364c7ddc7c14f3e2fa61f2d17574483f7ffbb431b4acb2f'),\n      ('other', 'pbkdf2:sha256:50000$kJPKsz6N$d2d4784f1b030a9761f5ccaeeaca413f27f2ecb76d6168407af962ddce849f79');\n\n    INSERT INTO post (title, body, author_id, created)\n    VALUES\n      ('test title', 'test' || x'0a' || 'body', 1, '2018-01-01 00:00:00');\n\nThe ``app`` fixture will call the factory and pass ``test_config`` to\nconfigure the application and database for testing instead of using your\nlocal development configuration.\n\n.. code-block:: python\n    :caption: ``tests/conftest.py``\n\n    import os\n    import tempfile\n\n    import pytest\n    from flaskr import create_app\n    from flaskr.db import get_db, init_db\n\n    with open(os.path.join(os.path.dirname(__file__), 'data.sql'), 'rb') as f:\n        _data_sql = f.read().decode('utf8')\n\n\n    @pytest.fixture\n    def app():\n        db_fd, db_path = tempfile.mkstemp()\n\n        app = create_app({\n            'TESTING': True,\n            'DATABASE': db_path,\n        })\n\n        with app.app_context():\n            init_db()\n            get_db().executescript(_data_sql)\n\n        yield app\n\n        os.close(db_fd)\n        os.unlink(db_path)\n\n\n    @pytest.fixture\n    def client(app):\n        return app.test_client()\n\n\n    @pytest.fixture\n    def runner(app):\n        return app.test_cli_runner()\n\n:func:`tempfile.mkstemp` creates and opens a temporary file, returning\nthe file descriptor and the path to it. The ``DATABASE`` path is\noverridden so it points to this temporary path instead of the instance\nfolder. After setting the path, the database tables are created and the\ntest data is inserted. After the test is over, the temporary file is\nclosed and removed.\n\n:data:`TESTING` tells Flask that the app is in test mode. Flask changes\nsome internal behavior so it's easier to test, and other extensions can\nalso use the flag to make testing them easier.\n\nThe ``client`` fixture calls\n:meth:`app.test_client() <Flask.test_client>` with the application\nobject created by the ``app`` fixture. Tests will use the client to make\nrequests to the application without running the server.\n\nThe ``runner`` fixture is similar to ``client``.\n:meth:`app.test_cli_runner() <Flask.test_cli_runner>` creates a runner\nthat can call the Click commands registered with the application.\n\nPytest uses fixtures by matching their function names with the names\nof arguments in the test functions. For example, the ``test_hello``\nfunction you'll write next takes a ``client`` argument. Pytest matches\nthat with the ``client`` fixture function, calls it, and passes the\nreturned value to the test function.", "code_truncated": false}
{"chunk_id": "811a298f92ee55eee09b963418ac313a6f5a1083", "file_path": "d:\\499\\docs\\tutorial\\tests.rst", "symbol_type": "doc", "name": "Factory", "qualname": "tutorial\\tests.rst#Factory", "start_line": 137, "end_line": 165, "docstring": null, "code": "-------\n\nThere's not much to test about the factory itself. Most of the code will\nbe executed for each test already, so if something fails the other tests\nwill notice.\n\nThe only behavior that can change is passing test config. If config is\nnot passed, there should be some default configuration, otherwise the\nconfiguration should be overridden.\n\n.. code-block:: python\n    :caption: ``tests/test_factory.py``\n\n    from flaskr import create_app\n\n\n    def test_config():\n        assert not create_app().testing\n        assert create_app({'TESTING': True}).testing\n\n\n    def test_hello(client):\n        response = client.get('/hello')\n        assert response.data == b'Hello, World!'\n\nYou added the ``hello`` route as an example when writing the factory at\nthe beginning of the tutorial. It returns \"Hello, World!\", so the test\nchecks that the response data matches.", "code_truncated": false}
{"chunk_id": "d7d6da3e2b60989b4936bdd5bdeafc792a4a392a", "file_path": "d:\\499\\docs\\tutorial\\tests.rst", "symbol_type": "doc", "name": "Database", "qualname": "tutorial\\tests.rst#Database", "start_line": 168, "end_line": 215, "docstring": null, "code": "--------\n\nWithin an application context, ``get_db`` should return the same\nconnection each time it's called. After the context, the connection\nshould be closed.\n\n.. code-block:: python\n    :caption: ``tests/test_db.py``\n\n    import sqlite3\n\n    import pytest\n    from flaskr.db import get_db\n\n\n    def test_get_close_db(app):\n        with app.app_context():\n            db = get_db()\n            assert db is get_db()\n\n        with pytest.raises(sqlite3.ProgrammingError) as e:\n            db.execute('SELECT 1')\n\n        assert 'closed' in str(e.value)\n\nThe ``init-db`` command should call the ``init_db`` function and output\na message.\n\n.. code-block:: python\n    :caption: ``tests/test_db.py``\n\n    def test_init_db_command(runner, monkeypatch):\n        class Recorder(object):\n            called = False\n\n        def fake_init_db():\n            Recorder.called = True\n\n        monkeypatch.setattr('flaskr.db.init_db', fake_init_db)\n        result = runner.invoke(args=['init-db'])\n        assert 'Initialized' in result.output\n        assert Recorder.called\n\nThis test uses Pytest's ``monkeypatch`` fixture to replace the\n``init_db`` function with one that records that it's been called. The\n``runner`` fixture you wrote above is used to call the ``init-db``\ncommand by name.", "code_truncated": false}
{"chunk_id": "0825129ea520db0e859e89ccb5f9e31cbfd6ccd6", "file_path": "d:\\499\\docs\\tutorial\\tests.rst", "symbol_type": "doc", "name": "Authentication", "qualname": "tutorial\\tests.rst#Authentication", "start_line": 218, "end_line": 354, "docstring": null, "code": "--------------\n\nFor most of the views, a user needs to be logged in. The easiest way to\ndo this in tests is to make a ``POST`` request to the ``login`` view\nwith the client. Rather than writing that out every time, you can write\na class with methods to do that, and use a fixture to pass it the client\nfor each test.\n\n.. code-block:: python\n    :caption: ``tests/conftest.py``\n\n    class AuthActions(object):\n        def __init__(self, client):\n            self._client = client\n\n        def login(self, username='test', password='test'):\n            return self._client.post(\n                '/auth/login',\n                data={'username': username, 'password': password}\n            )\n\n        def logout(self):\n            return self._client.get('/auth/logout')\n\n\n    @pytest.fixture\n    def auth(client):\n        return AuthActions(client)\n\nWith the ``auth`` fixture, you can call ``auth.login()`` in a test to\nlog in as the ``test`` user, which was inserted as part of the test\ndata in the ``app`` fixture.\n\nThe ``register`` view should render successfully on ``GET``. On ``POST``\nwith valid form data, it should redirect to the login URL and the user's\ndata should be in the database. Invalid data should display error\nmessages.\n\n.. code-block:: python\n    :caption: ``tests/test_auth.py``\n\n    import pytest\n    from flask import g, session\n    from flaskr.db import get_db\n\n\n    def test_register(client, app):\n        assert client.get('/auth/register').status_code == 200\n        response = client.post(\n            '/auth/register', data={'username': 'a', 'password': 'a'}\n        )\n        assert response.headers[\"Location\"] == \"/auth/login\"\n\n        with app.app_context():\n            assert get_db().execute(\n                \"SELECT * FROM user WHERE username = 'a'\",\n            ).fetchone() is not None\n\n\n    @pytest.mark.parametrize(('username', 'password', 'message'), (\n        ('', '', b'Username is required.'),\n        ('a', '', b'Password is required.'),\n        ('test', 'test', b'already registered'),\n    ))\n    def test_register_validate_input(client, username, password, message):\n        response = client.post(\n            '/auth/register',\n            data={'username': username, 'password': password}\n        )\n        assert message in response.data\n\n:meth:`client.get() <werkzeug.test.Client.get>` makes a ``GET`` request\nand returns the :class:`Response` object returned by Flask. Similarly,\n:meth:`client.post() <werkzeug.test.Client.post>` makes a ``POST``\nrequest, converting the ``data`` dict into form data.\n\nTo test that the page renders successfully, a simple request is made and\nchecked for a ``200 OK`` :attr:`~Response.status_code`. If\nrendering failed, Flask would return a ``500 Internal Server Error``\ncode.\n\n:attr:`~Response.headers` will have a ``Location`` header with the login\nURL when the register view redirects to the login view.\n\n:attr:`~Response.data` contains the body of the response as bytes. If\nyou expect a certain value to render on the page, check that it's in\n``data``. Bytes must be compared to bytes. If you want to compare text,\nuse :meth:`get_data(as_text=True) <werkzeug.wrappers.Response.get_data>`\ninstead.\n\n``pytest.mark.parametrize`` tells Pytest to run the same test function\nwith different arguments. You use it here to test different invalid\ninput and error messages without writing the same code three times.\n\nThe tests for the ``login`` view are very similar to those for\n``register``. Rather than testing the data in the database,\n:data:`.session` should have ``user_id`` set after logging in.\n\n.. code-block:: python\n    :caption: ``tests/test_auth.py``\n\n    def test_login(client, auth):\n        assert client.get('/auth/login').status_code == 200\n        response = auth.login()\n        assert response.headers[\"Location\"] == \"/\"\n\n        with client:\n            client.get('/')\n            assert session['user_id'] == 1\n            assert g.user['username'] == 'test'\n\n\n    @pytest.mark.parametrize(('username', 'password', 'message'), (\n        ('a', 'test', b'Incorrect username.'),\n        ('test', 'a', b'Incorrect password.'),\n    ))\n    def test_login_validate_input(auth, username, password, message):\n        response = auth.login(username, password)\n        assert message in response.data\n\nUsing ``client`` in a ``with`` block allows accessing context variables\nsuch as :data:`.session` after the response is returned. Normally,\naccessing ``session`` outside of a request would raise an error.\n\nTesting ``logout`` is the opposite of ``login``. :data:`.session` should\nnot contain ``user_id`` after logging out.\n\n.. code-block:: python\n    :caption: ``tests/test_auth.py``\n\n    def test_logout(client, auth):\n        auth.login()\n\n        with client:\n            auth.logout()\n            assert 'user_id' not in session", "code_truncated": false}
{"chunk_id": "6cc393c7855b29d8534543195753e4cbb3576302", "file_path": "d:\\499\\docs\\tutorial\\tests.rst", "symbol_type": "doc", "name": "Blog", "qualname": "tutorial\\tests.rst#Blog", "start_line": 357, "end_line": 488, "docstring": null, "code": "----\n\nAll the blog views use the ``auth`` fixture you wrote earlier. Call\n``auth.login()`` and subsequent requests from the client will be logged\nin as the ``test`` user.\n\nThe ``index`` view should display information about the post that was\nadded with the test data. When logged in as the author, there should be\na link to edit the post.\n\nYou can also test some more authentication behavior while testing the\n``index`` view. When not logged in, each page shows links to log in or\nregister. When logged in, there's a link to log out.\n\n.. code-block:: python\n    :caption: ``tests/test_blog.py``\n\n    import pytest\n    from flaskr.db import get_db\n\n\n    def test_index(client, auth):\n        response = client.get('/')\n        assert b\"Log In\" in response.data\n        assert b\"Register\" in response.data\n\n        auth.login()\n        response = client.get('/')\n        assert b'Log Out' in response.data\n        assert b'test title' in response.data\n        assert b'by test on 2018-01-01' in response.data\n        assert b'test\\nbody' in response.data\n        assert b'href=\"/1/update\"' in response.data\n\nA user must be logged in to access the ``create``, ``update``, and\n``delete`` views. The logged in user must be the author of the post to\naccess ``update`` and ``delete``, otherwise a ``403 Forbidden`` status\nis returned. If a ``post`` with the given ``id`` doesn't exist,\n``update`` and ``delete`` should return ``404 Not Found``.\n\n.. code-block:: python\n    :caption: ``tests/test_blog.py``\n\n    @pytest.mark.parametrize('path', (\n        '/create',\n        '/1/update',\n        '/1/delete',\n    ))\n    def test_login_required(client, path):\n        response = client.post(path)\n        assert response.headers[\"Location\"] == \"/auth/login\"\n\n\n    def test_author_required(app, client, auth):\n        # change the post author to another user\n        with app.app_context():\n            db = get_db()\n            db.execute('UPDATE post SET author_id = 2 WHERE id = 1')\n            db.commit()\n\n        auth.login()\n        # current user can't modify other user's post\n        assert client.post('/1/update').status_code == 403\n        assert client.post('/1/delete').status_code == 403\n        # current user doesn't see edit link\n        assert b'href=\"/1/update\"' not in client.get('/').data\n\n\n    @pytest.mark.parametrize('path', (\n        '/2/update',\n        '/2/delete',\n    ))\n    def test_exists_required(client, auth, path):\n        auth.login()\n        assert client.post(path).status_code == 404\n\nThe ``create`` and ``update`` views should render and return a\n``200 OK`` status for a ``GET`` request. When valid data is sent in a\n``POST`` request, ``create`` should insert the new post data into the\ndatabase, and ``update`` should modify the existing data. Both pages\nshould show an error message on invalid data.\n\n.. code-block:: python\n    :caption: ``tests/test_blog.py``\n\n    def test_create(client, auth, app):\n        auth.login()\n        assert client.get('/create').status_code == 200\n        client.post('/create', data={'title': 'created', 'body': ''})\n\n        with app.app_context():\n            db = get_db()\n            count = db.execute('SELECT COUNT(id) FROM post').fetchone()[0]\n            assert count == 2\n\n\n    def test_update(client, auth, app):\n        auth.login()\n        assert client.get('/1/update').status_code == 200\n        client.post('/1/update', data={'title': 'updated', 'body': ''})\n\n        with app.app_context():\n            db = get_db()\n            post = db.execute('SELECT * FROM post WHERE id = 1').fetchone()\n            assert post['title'] == 'updated'\n\n\n    @pytest.mark.parametrize('path', (\n        '/create',\n        '/1/update',\n    ))\n    def test_create_update_validate(client, auth, path):\n        auth.login()\n        response = client.post(path, data={'title': '', 'body': ''})\n        assert b'Title is required.' in response.data\n\nThe ``delete`` view should redirect to the index URL and the post should\nno longer exist in the database.\n\n.. code-block:: python\n    :caption: ``tests/test_blog.py``\n\n    def test_delete(client, auth, app):\n        auth.login()\n        response = client.post('/1/delete')\n        assert response.headers[\"Location\"] == \"/\"\n\n        with app.app_context():\n            db = get_db()\n            post = db.execute('SELECT * FROM post WHERE id = 1').fetchone()\n            assert post is None", "code_truncated": false}
{"chunk_id": "6e16a37e20860b7c92a8b1c68561ff90757b0107", "file_path": "d:\\499\\docs\\tutorial\\tests.rst", "symbol_type": "doc", "name": "Running the Tests", "qualname": "tutorial\\tests.rst#Running the Tests", "start_line": 491, "end_line": 559, "docstring": null, "code": "-----------------\n\nSome extra configuration, which is not required but makes running tests with coverage\nless verbose, can be added to the project's ``pyproject.toml`` file.\n\n.. code-block:: toml\n    :caption: ``pyproject.toml``\n\n    [tool.pytest.ini_options]\n    testpaths = [\"tests\"]\n\n    [tool.coverage.run]\n    branch = true\n    source = [\"flaskr\"]\n\nTo run the tests, use the ``pytest`` command. It will find and run all\nthe test functions you've written.\n\n.. code-block:: none\n\n    $ pytest\n\n    ========================= test session starts ==========================\n    platform linux -- Python 3.6.4, pytest-3.5.0, py-1.5.3, pluggy-0.6.0\n    rootdir: /home/user/Projects/flask-tutorial\n    collected 23 items\n\n    tests/test_auth.py ........                                      [ 34%]\n    tests/test_blog.py ............                                  [ 86%]\n    tests/test_db.py ..                                              [ 95%]\n    tests/test_factory.py ..                                         [100%]\n\n    ====================== 24 passed in 0.64 seconds =======================\n\nIf any tests fail, pytest will show the error that was raised. You can\nrun ``pytest -v`` to get a list of each test function rather than dots.\n\nTo measure the code coverage of your tests, use the ``coverage`` command\nto run pytest instead of running it directly.\n\n.. code-block:: none\n\n    $ coverage run -m pytest\n\nYou can either view a simple coverage report in the terminal:\n\n.. code-block:: none\n\n    $ coverage report\n\n    Name                 Stmts   Miss Branch BrPart  Cover\n    ------------------------------------------------------\n    flaskr/__init__.py      21      0      2      0   100%\n    flaskr/auth.py          54      0     22      0   100%\n    flaskr/blog.py          54      0     16      0   100%\n    flaskr/db.py            24      0      4      0   100%\n    ------------------------------------------------------\n    TOTAL                  153      0     44      0   100%\n\nAn HTML report allows you to see which lines were covered in each file:\n\n.. code-block:: none\n\n    $ coverage html\n\nThis generates files in the ``htmlcov`` directory. Open\n``htmlcov/index.html`` in your browser to see the report.\n\nContinue to :doc:`deploy`.", "code_truncated": false}
{"chunk_id": "3dd02193ca8c954fb8e17b65d5d0a366a6a00f96", "file_path": "d:\\499\\docs\\tutorial\\views.rst", "symbol_type": "doc", "name": "INTRO", "qualname": "tutorial\\views.rst#INTRO", "start_line": 1, "end_line": 1, "docstring": null, "code": ".. currentmodule:: flask", "code_truncated": false}
{"chunk_id": "b54e5abbcd84e6da60b9fceae2fde37b95ee8d59", "file_path": "d:\\499\\docs\\tutorial\\views.rst", "symbol_type": "doc", "name": "Blueprints and Views", "qualname": "tutorial\\views.rst#Blueprints and Views", "start_line": 4, "end_line": 11, "docstring": null, "code": "====================\n\nA view function is the code you write to respond to requests to your\napplication. Flask uses patterns to match the incoming request URL to\nthe view that should handle it. The view returns data that Flask turns\ninto an outgoing response. Flask can also go the other direction and\ngenerate a URL to a view based on its name and arguments.", "code_truncated": false}
{"chunk_id": "6781bdc0436c2b353223272bc53e7ce9f2d87cd6", "file_path": "d:\\499\\docs\\tutorial\\views.rst", "symbol_type": "doc", "name": "Create a Blueprint", "qualname": "tutorial\\views.rst#Create a Blueprint", "start_line": 14, "end_line": 64, "docstring": null, "code": "------------------\n\nA :class:`Blueprint` is a way to organize a group of related views and\nother code. Rather than registering views and other code directly with\nan application, they are registered with a blueprint. Then the blueprint\nis registered with the application when it is available in the factory\nfunction.\n\nFlaskr will have two blueprints, one for authentication functions and\none for the blog posts functions. The code for each blueprint will go\nin a separate module. Since the blog needs to know about authentication,\nyou'll write the authentication one first.\n\n.. code-block:: python\n    :caption: ``flaskr/auth.py``\n\n    import functools\n\n    from flask import (\n        Blueprint, flash, g, redirect, render_template, request, session, url_for\n    )\n    from werkzeug.security import check_password_hash, generate_password_hash\n\n    from flaskr.db import get_db\n\n    bp = Blueprint('auth', __name__, url_prefix='/auth')\n\nThis creates a :class:`Blueprint` named ``'auth'``. Like the application\nobject, the blueprint needs to know where it's defined, so ``__name__``\nis passed as the second argument. The ``url_prefix`` will be prepended\nto all the URLs associated with the blueprint.\n\nImport and register the blueprint from the factory using\n:meth:`app.register_blueprint() <Flask.register_blueprint>`. Place the\nnew code at the end of the factory function before returning the app.\n\n.. code-block:: python\n    :caption: ``flaskr/__init__.py``\n\n    def create_app():\n        app = ...\n        # existing code omitted\n\n        from . import auth\n        app.register_blueprint(auth.bp)\n\n        return app\n\nThe authentication blueprint will have views to register new users and\nto log in and log out.", "code_truncated": false}
{"chunk_id": "e9ec038d5d4d9c8dd71d84f9c0b78c5d2b77433a", "file_path": "d:\\499\\docs\\tutorial\\views.rst", "symbol_type": "doc", "name": "The First View: Register", "qualname": "tutorial\\views.rst#The First View: Register", "start_line": 67, "end_line": 163, "docstring": null, "code": "------------------------\n\nWhen the user visits the ``/auth/register`` URL, the ``register`` view\nwill return `HTML`_ with a form for them to fill out. When they submit\nthe form, it will validate their input and either show the form again\nwith an error message or create the new user and go to the login page.\n\n.. _HTML: https://developer.mozilla.org/docs/Web/HTML\n\nFor now you will just write the view code. On the next page, you'll\nwrite templates to generate the HTML form.\n\n.. code-block:: python\n    :caption: ``flaskr/auth.py``\n\n    @bp.route('/register', methods=('GET', 'POST'))\n    def register():\n        if request.method == 'POST':\n            username = request.form['username']\n            password = request.form['password']\n            db = get_db()\n            error = None\n\n            if not username:\n                error = 'Username is required.'\n            elif not password:\n                error = 'Password is required.'\n\n            if error is None:\n                try:\n                    db.execute(\n                        \"INSERT INTO user (username, password) VALUES (?, ?)\",\n                        (username, generate_password_hash(password)),\n                    )\n                    db.commit()\n                except db.IntegrityError:\n                    error = f\"User {username} is already registered.\"\n                else:\n                    return redirect(url_for(\"auth.login\"))\n\n            flash(error)\n\n        return render_template('auth/register.html')\n\nHere's what the ``register`` view function is doing:\n\n#.  :meth:`@bp.route <Blueprint.route>` associates the URL ``/register``\n    with the ``register`` view function. When Flask receives a request\n    to ``/auth/register``, it will call the ``register`` view and use\n    the return value as the response.\n\n#.  If the user submitted the form,\n    :attr:`request.method <Request.method>` will be ``'POST'``. In this\n    case, start validating the input.\n\n#.  :attr:`request.form <Request.form>` is a special type of\n    :class:`dict` mapping submitted form keys and values. The user will\n    input their ``username`` and ``password``.\n\n#.  Validate that ``username`` and ``password`` are not empty.\n\n#.  If validation succeeds, insert the new user data into the database.\n\n    -   :meth:`db.execute <sqlite3.Connection.execute>` takes a SQL\n        query with ``?`` placeholders for any user input, and a tuple of\n        values to replace the placeholders with. The database library\n        will take care of escaping the values so you are not vulnerable\n        to a *SQL injection attack*.\n\n    -   For security, passwords should never be stored in the database\n        directly. Instead,\n        :func:`~werkzeug.security.generate_password_hash` is used to\n        securely hash the password, and that hash is stored. Since this\n        query modifies data,\n        :meth:`db.commit() <sqlite3.Connection.commit>` needs to be\n        called afterwards to save the changes.\n\n    -   An :exc:`sqlite3.IntegrityError` will occur if the username\n        already exists, which should be shown to the user as another\n        validation error.\n\n#.  After storing the user, they are redirected to the login page.\n    :func:`url_for` generates the URL for the login view based on its\n    name. This is preferable to writing the URL directly as it allows\n    you to change the URL later without changing all code that links to\n    it. :func:`redirect` generates a redirect response to the generated\n    URL.\n\n#.  If validation fails, the error is shown to the user. :func:`flash`\n    stores messages that can be retrieved when rendering the template.\n\n#.  When the user initially navigates to ``auth/register``, or\n    there was a validation error, an HTML page with the registration\n    form should be shown. :func:`render_template` will render a template\n    containing the HTML, which you'll write in the next step of the\n    tutorial.", "code_truncated": false}
{"chunk_id": "b88b0cde0b1229ae3d7ba33e75ba05a81f583f1a", "file_path": "d:\\499\\docs\\tutorial\\views.rst", "symbol_type": "doc", "name": "Login", "qualname": "tutorial\\views.rst#Login", "start_line": 166, "end_line": 243, "docstring": null, "code": "-----\n\nThis view follows the same pattern as the ``register`` view above.\n\n.. code-block:: python\n    :caption: ``flaskr/auth.py``\n\n    @bp.route('/login', methods=('GET', 'POST'))\n    def login():\n        if request.method == 'POST':\n            username = request.form['username']\n            password = request.form['password']\n            db = get_db()\n            error = None\n            user = db.execute(\n                'SELECT * FROM user WHERE username = ?', (username,)\n            ).fetchone()\n\n            if user is None:\n                error = 'Incorrect username.'\n            elif not check_password_hash(user['password'], password):\n                error = 'Incorrect password.'\n\n            if error is None:\n                session.clear()\n                session['user_id'] = user['id']\n                return redirect(url_for('index'))\n\n            flash(error)\n\n        return render_template('auth/login.html')\n\nThere are a few differences from the ``register`` view:\n\n#.  The user is queried first and stored in a variable for later use.\n\n    :meth:`~sqlite3.Cursor.fetchone` returns one row from the query.\n    If the query returned no results, it returns ``None``. Later,\n    :meth:`~sqlite3.Cursor.fetchall` will be used, which returns a list\n    of all results.\n\n#.  :func:`~werkzeug.security.check_password_hash` hashes the submitted\n    password in the same way as the stored hash and securely compares\n    them. If they match, the password is valid.\n\n#.  :data:`.session` is a :class:`dict` that stores data across requests.\n    When validation succeeds, the user's ``id`` is stored in a new\n    session. The data is stored in a *cookie* that is sent to the\n    browser, and the browser then sends it back with subsequent requests.\n    Flask securely *signs* the data so that it can't be tampered with.\n\nNow that the user's ``id`` is stored in the :data:`.session`, it will be\navailable on subsequent requests. At the beginning of each request, if\na user is logged in their information should be loaded and made\navailable to other views.\n\n.. code-block:: python\n    :caption: ``flaskr/auth.py``\n\n    @bp.before_app_request\n    def load_logged_in_user():\n        user_id = session.get('user_id')\n\n        if user_id is None:\n            g.user = None\n        else:\n            g.user = get_db().execute(\n                'SELECT * FROM user WHERE id = ?', (user_id,)\n            ).fetchone()\n\n:meth:`bp.before_app_request() <Blueprint.before_app_request>` registers\na function that runs before the view function, no matter what URL is\nrequested. ``load_logged_in_user`` checks if a user id is stored in the\n:data:`.session` and gets that user's data from the database, storing it\non :data:`g.user <g>`, which lasts for the length of the request. If\nthere is no user id, or if the id doesn't exist, ``g.user`` will be\n``None``.", "code_truncated": false}
{"chunk_id": "193babab00b45a7b23b5d9e8c1d3497ac4ffea53", "file_path": "d:\\499\\docs\\tutorial\\views.rst", "symbol_type": "doc", "name": "Logout", "qualname": "tutorial\\views.rst#Logout", "start_line": 246, "end_line": 258, "docstring": null, "code": "------\n\nTo log out, you need to remove the user id from the :data:`.session`.\nThen ``load_logged_in_user`` won't load a user on subsequent requests.\n\n.. code-block:: python\n    :caption: ``flaskr/auth.py``\n\n    @bp.route('/logout')\n    def logout():\n        session.clear()\n        return redirect(url_for('index'))", "code_truncated": false}
{"chunk_id": "c0b7498367e7f47f51c937229d75c203cbd71709", "file_path": "d:\\499\\docs\\tutorial\\views.rst", "symbol_type": "doc", "name": "Require Authentication in Other Views", "qualname": "tutorial\\views.rst#Require Authentication in Other Views", "start_line": 261, "end_line": 284, "docstring": null, "code": "-------------------------------------\n\nCreating, editing, and deleting blog posts will require a user to be\nlogged in. A *decorator* can be used to check this for each view it's\napplied to.\n\n.. code-block:: python\n    :caption: ``flaskr/auth.py``\n\n    def login_required(view):\n        @functools.wraps(view)\n        def wrapped_view(**kwargs):\n            if g.user is None:\n                return redirect(url_for('auth.login'))\n\n            return view(**kwargs)\n\n        return wrapped_view\n\nThis decorator returns a new view function that wraps the original view\nit's applied to. The new function checks if a user is loaded and\nredirects to the login page otherwise. If a user is loaded the original\nview is called and continues normally. You'll use this decorator when\nwriting the blog views.", "code_truncated": false}
{"chunk_id": "acf76f9a37203dee7b5f120652dd2bb82511e93e", "file_path": "d:\\499\\docs\\tutorial\\views.rst", "symbol_type": "doc", "name": "Endpoints and URLs", "qualname": "tutorial\\views.rst#Endpoints and URLs", "start_line": 287, "end_line": 305, "docstring": null, "code": "------------------\n\nThe :func:`url_for` function generates the URL to a view based on a name\nand arguments. The name associated with a view is also called the\n*endpoint*, and by default it's the same as the name of the view\nfunction.\n\nFor example, the ``hello()`` view that was added to the app\nfactory earlier in the tutorial has the name ``'hello'`` and can be\nlinked to with ``url_for('hello')``. If it took an argument, which\nyou'll see later, it would be linked to using\n``url_for('hello', who='World')``.\n\nWhen using a blueprint, the name of the blueprint is prepended to the\nname of the function, so the endpoint for the ``login`` function you\nwrote above is ``'auth.login'`` because you added it to the ``'auth'``\nblueprint.\n\nContinue to :doc:`templates`.", "code_truncated": false}
{"chunk_id": "2f74d142e106694b78167378c3ac967643780ed8", "file_path": "d:\\499\\docs\\views.rst", "symbol_type": "doc", "name": "Class-based Views", "qualname": "views.rst#Class-based Views", "start_line": 2, "end_line": 19, "docstring": null, "code": "=================\n\n.. currentmodule:: flask.views\n\nThis page introduces using the :class:`View` and :class:`MethodView`\nclasses to write class-based views.\n\nA class-based view is a class that acts as a view function. Because it\nis a class, different instances of the class can be created with\ndifferent arguments, to change the behavior of the view. This is also\nknown as generic, reusable, or pluggable views.\n\nAn example of where this is useful is defining a class that creates an\nAPI based on the database model it is initialized with.\n\nFor more complex API behavior and customization, look into the various\nAPI extensions for Flask.", "code_truncated": false}
{"chunk_id": "45352b5f8ac1bba8efd84e3439bf76c7cf69df13", "file_path": "d:\\499\\docs\\views.rst", "symbol_type": "doc", "name": "Basic Reusable View", "qualname": "views.rst#Basic Reusable View", "start_line": 22, "end_line": 99, "docstring": null, "code": "-------------------\n\nLet's walk through an example converting a view function to a view\nclass. We start with a view function that queries a list of users then\nrenders a template to show the list.\n\n.. code-block:: python\n\n    @app.route(\"/users/\")\n    def user_list():\n        users = User.query.all()\n        return render_template(\"users.html\", users=users)\n\nThis works for the user model, but let's say you also had more models\nthat needed list pages. You'd need to write another view function for\neach model, even though the only thing that would change is the model\nand template name.\n\nInstead, you can write a :class:`View` subclass that will query a model\nand render a template. As the first step, we'll convert the view to a\nclass without any customization.\n\n.. code-block:: python\n\n    from flask.views import View\n\n    class UserList(View):\n        def dispatch_request(self):\n            users = User.query.all()\n            return render_template(\"users.html\", objects=users)\n\n    app.add_url_rule(\"/users/\", view_func=UserList.as_view(\"user_list\"))\n\nThe :meth:`View.dispatch_request` method is the equivalent of the view\nfunction. Calling :meth:`View.as_view` method will create a view\nfunction that can be registered on the app with its\n:meth:`~flask.Flask.add_url_rule` method. The first argument to\n``as_view`` is the name to use to refer to the view with\n:func:`~flask.url_for`.\n\n.. note::\n\n    You can't decorate the class with ``@app.route()`` the way you'd\n    do with a basic view function.\n\nNext, we need to be able to register the same view class for different\nmodels and templates, to make it more useful than the original function.\nThe class will take two arguments, the model and template, and store\nthem on ``self``. Then ``dispatch_request`` can reference these instead\nof hard-coded values.\n\n.. code-block:: python\n\n    class ListView(View):\n        def __init__(self, model, template):\n            self.model = model\n            self.template = template\n\n        def dispatch_request(self):\n            items = self.model.query.all()\n            return render_template(self.template, items=items)\n\nRemember, we create the view function with ``View.as_view()`` instead of\ncreating the class directly. Any extra arguments passed to ``as_view``\nare then passed when creating the class. Now we can register the same\nview to handle multiple models.\n\n.. code-block:: python\n\n    app.add_url_rule(\n        \"/users/\",\n        view_func=ListView.as_view(\"user_list\", User, \"users.html\"),\n    )\n    app.add_url_rule(\n        \"/stories/\",\n        view_func=ListView.as_view(\"story_list\", Story, \"stories.html\"),\n    )", "code_truncated": false}
{"chunk_id": "92467a9cdaf6ced4bab1be9078cff80165629c91", "file_path": "d:\\499\\docs\\views.rst", "symbol_type": "doc", "name": "URL Variables", "qualname": "views.rst#URL Variables", "start_line": 102, "end_line": 123, "docstring": null, "code": "-------------\n\nAny variables captured by the URL are passed as keyword arguments to the\n``dispatch_request`` method, as they would be for a regular view\nfunction.\n\n.. code-block:: python\n\n    class DetailView(View):\n        def __init__(self, model):\n            self.model = model\n            self.template = f\"{model.__name__.lower()}/detail.html\"\n\n        def dispatch_request(self, id)\n            item = self.model.query.get_or_404(id)\n            return render_template(self.template, item=item)\n\n    app.add_url_rule(\n        \"/users/<int:id>\",\n        view_func=DetailView.as_view(\"user_detail\", User)\n    )", "code_truncated": false}
{"chunk_id": "20499cd098bd0eab33c472398fa4d64bb982ff08", "file_path": "d:\\499\\docs\\views.rst", "symbol_type": "doc", "name": "View Lifetime and ``self``", "qualname": "views.rst#View Lifetime and ``self``", "start_line": 126, "end_line": 158, "docstring": null, "code": "--------------------------\n\nBy default, a new instance of the view class is created every time a\nrequest is handled. This means that it is safe to write other data to\n``self`` during the request, since the next request will not see it,\nunlike other forms of global state.\n\nHowever, if your view class needs to do a lot of complex initialization,\ndoing it for every request is unnecessary and can be inefficient. To\navoid this, set :attr:`View.init_every_request` to ``False``, which will\nonly create one instance of the class and use it for every request. In\nthis case, writing to ``self`` is not safe. If you need to store data\nduring the request, use :data:`~flask.g` instead.\n\nIn the ``ListView`` example, nothing writes to ``self`` during the\nrequest, so it is more efficient to create a single instance.\n\n.. code-block:: python\n\n    class ListView(View):\n        init_every_request = False\n\n        def __init__(self, model, template):\n            self.model = model\n            self.template = template\n\n        def dispatch_request(self):\n            items = self.model.query.all()\n            return render_template(self.template, items=items)\n\nDifferent instances will still be created each for each ``as_view``\ncall, but not for each request to those views.", "code_truncated": false}
{"chunk_id": "160d81e15988b6f7d1f98d5234d8a1ec8d16792d", "file_path": "d:\\499\\docs\\views.rst", "symbol_type": "doc", "name": "View Decorators", "qualname": "views.rst#View Decorators", "start_line": 161, "end_line": 194, "docstring": null, "code": "---------------\n\nThe view class itself is not the view function. View decorators need to\nbe applied to the view function returned by ``as_view``, not the class\nitself. Set :attr:`View.decorators` to a list of decorators to apply.\n\n.. code-block:: python\n\n    class UserList(View):\n        decorators = [cache(minutes=2), login_required]\n\n    app.add_url_rule('/users/', view_func=UserList.as_view())\n\nIf you didn't set ``decorators``, you could apply them manually instead.\nThis is equivalent to:\n\n.. code-block:: python\n\n    view = UserList.as_view(\"users_list\")\n    view = cache(minutes=2)(view)\n    view = login_required(view)\n    app.add_url_rule('/users/', view_func=view)\n\nKeep in mind that order matters. If you're used to ``@decorator`` style,\nthis is equivalent to:\n\n.. code-block:: python\n\n    @app.route(\"/users/\")\n    @login_required\n    @cache(minutes=2)\n    def user_list():\n        ...", "code_truncated": false}
{"chunk_id": "72c219b013465bdcbd39530993437346edcb90d3", "file_path": "d:\\499\\docs\\views.rst", "symbol_type": "doc", "name": "Method Hints", "qualname": "views.rst#Method Hints", "start_line": 197, "end_line": 226, "docstring": null, "code": "------------\n\nA common pattern is to register a view with ``methods=[\"GET\", \"POST\"]``,\nthen check ``request.method == \"POST\"`` to decide what to do. Setting\n:attr:`View.methods` is equivalent to passing the list of methods to\n``add_url_rule`` or ``route``.\n\n.. code-block:: python\n\n    class MyView(View):\n        methods = [\"GET\", \"POST\"]\n\n        def dispatch_request(self):\n            if request.method == \"POST\":\n                ...\n            ...\n\n    app.add_url_rule('/my-view', view_func=MyView.as_view('my-view'))\n\nThis is equivalent to the following, except further subclasses can\ninherit or change the methods.\n\n.. code-block:: python\n\n    app.add_url_rule(\n        \"/my-view\",\n        view_func=MyView.as_view(\"my-view\"),\n        methods=[\"GET\", \"POST\"],\n    )", "code_truncated": false}
{"chunk_id": "a939e47af39e5c3237b16026ccc38f01b7fa757c", "file_path": "d:\\499\\docs\\views.rst", "symbol_type": "doc", "name": "Method Dispatching and APIs", "qualname": "views.rst#Method Dispatching and APIs", "start_line": 229, "end_line": 324, "docstring": null, "code": "---------------------------\n\nFor APIs it can be helpful to use a different function for each HTTP\nmethod. :class:`MethodView` extends the basic :class:`View` to dispatch\nto different methods of the class based on the request method. Each HTTP\nmethod maps to a method of the class with the same (lowercase) name.\n\n:class:`MethodView` automatically sets :attr:`View.methods` based on the\nmethods defined by the class. It even knows how to handle subclasses\nthat override or define other methods.\n\nWe can make a generic ``ItemAPI`` class that provides get (detail),\npatch (edit), and delete methods for a given model. A ``GroupAPI`` can\nprovide get (list) and post (create) methods.\n\n.. code-block:: python\n\n    from flask.views import MethodView\n\n    class ItemAPI(MethodView):\n        init_every_request = False\n\n        def __init__(self, model):\n            self.model = model\n            self.validator = generate_validator(model)\n\n        def _get_item(self, id):\n            return self.model.query.get_or_404(id)\n\n        def get(self, id):\n            item = self._get_item(id)\n            return jsonify(item.to_json())\n\n        def patch(self, id):\n            item = self._get_item(id)\n            errors = self.validator.validate(item, request.json)\n\n            if errors:\n                return jsonify(errors), 400\n\n            item.update_from_json(request.json)\n            db.session.commit()\n            return jsonify(item.to_json())\n\n        def delete(self, id):\n            item = self._get_item(id)\n            db.session.delete(item)\n            db.session.commit()\n            return \"\", 204\n\n    class GroupAPI(MethodView):\n        init_every_request = False\n\n        def __init__(self, model):\n            self.model = model\n            self.validator = generate_validator(model, create=True)\n\n        def get(self):\n            items = self.model.query.all()\n            return jsonify([item.to_json() for item in items])\n\n        def post(self):\n            errors = self.validator.validate(request.json)\n\n            if errors:\n                return jsonify(errors), 400\n\n            db.session.add(self.model.from_json(request.json))\n            db.session.commit()\n            return jsonify(item.to_json())\n\n    def register_api(app, model, name):\n        item = ItemAPI.as_view(f\"{name}-item\", model)\n        group = GroupAPI.as_view(f\"{name}-group\", model)\n        app.add_url_rule(f\"/{name}/<int:id>\", view_func=item)\n        app.add_url_rule(f\"/{name}/\", view_func=group)\n\n    register_api(app, User, \"users\")\n    register_api(app, Story, \"stories\")\n\nThis produces the following views, a standard REST API!\n\n================= ========== ===================\nURL               Method     Description\n----------------- ---------- -------------------\n``/users/``       ``GET``    List all users\n``/users/``       ``POST``   Create a new user\n``/users/<id>``   ``GET``    Show a single user\n``/users/<id>``   ``PATCH``  Update a user\n``/users/<id>``   ``DELETE`` Delete a user\n``/stories/``     ``GET``    List all stories\n``/stories/``     ``POST``   Create a new story\n``/stories/<id>`` ``GET``    Show a single story\n``/stories/<id>`` ``PATCH``  Update a story\n``/stories/<id>`` ``DELETE`` Delete a story\n================= ========== ===================", "code_truncated": false}
{"chunk_id": "129666661e21da641cc70247236e34242361161b", "file_path": "d:\\499\\docs\\web-security.rst", "symbol_type": "doc", "name": "Security Considerations", "qualname": "web-security.rst#Security Considerations", "start_line": 2, "end_line": 10, "docstring": null, "code": "=======================\n\nWeb applications face many types of potential security problems, and it can be\nhard to get everything right, or even to know what \"right\" is in general. Flask\ntries to solve a few of these things by default, but there are other parts you\nmay have to take care of yourself. Many of these solutions are tradeoffs, and\nwill depend on each application's specific needs and threat model. Many hosting\nplatforms may take care of certain types of problems without the need for the\nFlask application to handle them.", "code_truncated": false}
{"chunk_id": "997670d9e824d562b79a247044201d7b0fe24c5c", "file_path": "d:\\499\\docs\\web-security.rst", "symbol_type": "doc", "name": "Resource Use", "qualname": "web-security.rst#Resource Use", "start_line": 13, "end_line": 42, "docstring": null, "code": "------------\n\nA common category of attacks is \"Denial of Service\" (DoS or DDoS). This is a\nvery broad category, and different variants target different layers in a\ndeployed application. In general, something is done to increase how much\nprocessing time or memory is used to handle each request, to the point where\nthere are not enough resources to handle legitimate requests.\n\nFlask provides a few configuration options to handle resource use. They can\nalso be set on individual requests to customize only that request. The\ndocumentation for each goes into more detail.\n\n-   :data:`MAX_CONTENT_LENGTH` or :attr:`.Request.max_content_length` controls\n    how much data will be read from a request. It is not set by default,\n    although it will still block truly unlimited streams unless the WSGI server\n    indicates support.\n-   :data:`MAX_FORM_MEMORY_SIZE` or :attr:`.Request.max_form_memory_size`\n    controls how large any non-file ``multipart/form-data`` field can be. It is\n    set to 500kB by default.\n-   :data:`MAX_FORM_PARTS` or :attr:`.Request.max_form_parts` controls how many\n    ``multipart/form-data`` fields can be parsed. It is set to 1000 by default.\n    Combined with the default `max_form_memory_size`, this means that a form\n    will occupy at most 500MB of memory.\n\nRegardless of these settings, you should also review what settings are available\nfrom your operating system, container deployment (Docker etc), WSGI server, HTTP\nserver, and hosting platform. They typically have ways to set process resource\nlimits, timeouts, and other checks regardless of how Flask is configured.\n\n.. _security-xss:", "code_truncated": false}
{"chunk_id": "f9c5c9f24b8ebf409b7431876e6ee124b89c59e0", "file_path": "d:\\499\\docs\\web-security.rst", "symbol_type": "doc", "name": "Cross-Site Scripting (XSS)", "qualname": "web-security.rst#Cross-Site Scripting (XSS)", "start_line": 45, "end_line": 101, "docstring": null, "code": "--------------------------\n\nCross site scripting is the concept of injecting arbitrary HTML (and with\nit JavaScript) into the context of a website.  To remedy this, developers\nhave to properly escape text so that it cannot include arbitrary HTML\ntags.  For more information on that have a look at the Wikipedia article\non `Cross-Site Scripting\n<https://en.wikipedia.org/wiki/Cross-site_scripting>`_.\n\nFlask configures Jinja to automatically escape all values unless\nexplicitly told otherwise.  This should rule out all XSS problems caused\nin templates, but there are still other places where you have to be\ncareful:\n\n-   generating HTML without the help of Jinja\n-   calling :class:`~markupsafe.Markup` on data submitted by users\n-   sending out HTML from uploaded files, never do that, use the\n    ``Content-Disposition: attachment`` header to prevent that problem.\n-   sending out textfiles from uploaded files.  Some browsers are using\n    content-type guessing based on the first few bytes so users could\n    trick a browser to execute HTML.\n\nAnother thing that is very important are unquoted attributes.  While\nJinja can protect you from XSS issues by escaping HTML, there is one\nthing it cannot protect you from: XSS by attribute injection.  To counter\nthis possible attack vector, be sure to always quote your attributes with\neither double or single quotes when using Jinja expressions in them:\n\n.. sourcecode:: html+jinja\n\n    <input value=\"{{ value }}\">\n\nWhy is this necessary?  Because if you would not be doing that, an\nattacker could easily inject custom JavaScript handlers.  For example an\nattacker could inject this piece of HTML+JavaScript:\n\n.. sourcecode:: html\n\n    onmouseover=alert(document.cookie)\n\nWhen the user would then move with the mouse over the input, the cookie\nwould be presented to the user in an alert window.  But instead of showing\nthe cookie to the user, a good attacker might also execute any other\nJavaScript code.  In combination with CSS injections the attacker might\neven make the element fill out the entire page so that the user would\njust have to have the mouse anywhere on the page to trigger the attack.\n\nThere is one class of XSS issues that Jinja's escaping does not protect\nagainst. The ``a`` tag's ``href`` attribute can contain a `javascript:` URI,\nwhich the browser will execute when clicked if not secured properly.\n\n.. sourcecode:: html\n\n    <a href=\"{{ value }}\">click here</a>\n    <a href=\"javascript:alert('unsafe');\">click here</a>\n\nTo prevent this, you'll need to set the :ref:`security-csp` response header.", "code_truncated": false}
{"chunk_id": "3c447aebbf02ecb62f11e4edbe2035630424a05a", "file_path": "d:\\499\\docs\\web-security.rst", "symbol_type": "doc", "name": "Cross-Site Request Forgery (CSRF)", "qualname": "web-security.rst#Cross-Site Request Forgery (CSRF)", "start_line": 104, "end_line": 138, "docstring": null, "code": "---------------------------------\n\nAnother big problem is CSRF.  This is a very complex topic and I won't\noutline it here in detail just mention what it is and how to theoretically\nprevent it.\n\nIf your authentication information is stored in cookies, you have implicit\nstate management.  The state of \"being logged in\" is controlled by a\ncookie, and that cookie is sent with each request to a page.\nUnfortunately that includes requests triggered by 3rd party sites.  If you\ndon't keep that in mind, some people might be able to trick your\napplication's users with social engineering to do stupid things without\nthem knowing.\n\nSay you have a specific URL that, when you sent ``POST`` requests to will\ndelete a user's profile (say ``http://example.com/user/delete``).  If an\nattacker now creates a page that sends a post request to that page with\nsome JavaScript they just have to trick some users to load that page and\ntheir profiles will end up being deleted.\n\nImagine you were to run Facebook with millions of concurrent users and\nsomeone would send out links to images of little kittens.  When users\nwould go to that page, their profiles would get deleted while they are\nlooking at images of fluffy cats.\n\nHow can you prevent that?  Basically for each request that modifies\ncontent on the server you would have to either use a one-time token and\nstore that in the cookie **and** also transmit it with the form data.\nAfter receiving the data on the server again, you would then have to\ncompare the two tokens and ensure they are equal.\n\nWhy does Flask not do that for you?  The ideal place for this to happen is\nthe form validation framework, which does not exist in Flask.\n\n.. _security-json:", "code_truncated": false}
{"chunk_id": "3b4316b221219dcb0f5833e0f637b574de66c1b1", "file_path": "d:\\499\\docs\\web-security.rst", "symbol_type": "doc", "name": "JSON Security", "qualname": "web-security.rst#JSON Security", "start_line": 141, "end_line": 151, "docstring": null, "code": "-------------\n\nIn Flask 0.10 and lower, :func:`~flask.jsonify` did not serialize top-level\narrays to JSON. This was because of a security vulnerability in ECMAScript 4.\n\nECMAScript 5 closed this vulnerability, so only extremely old browsers are\nstill vulnerable. All of these browsers have `other more serious\nvulnerabilities\n<https://github.com/pallets/flask/issues/248#issuecomment-59934857>`_, so\nthis behavior was changed and :func:`~flask.jsonify` now supports serializing\narrays.", "code_truncated": false}
{"chunk_id": "f7ec71927ecf5908bb1002715dd574088d9548dc", "file_path": "d:\\499\\docs\\web-security.rst", "symbol_type": "doc", "name": "Security Headers", "qualname": "web-security.rst#Security Headers", "start_line": 154, "end_line": 161, "docstring": null, "code": "----------------\n\nBrowsers recognize various response headers in order to control security. We\nrecommend reviewing each of the headers below for use in your application.\nThe `Flask-Talisman`_ extension can be used to manage HTTPS and the security\nheaders for you.\n\n.. _Flask-Talisman: https://github.com/wntrblm/flask-talisman", "code_truncated": false}
{"chunk_id": "40b8e0ebaf6c342a64354f6bcb89834c8f7c2f48", "file_path": "d:\\499\\docs\\web-security.rst", "symbol_type": "doc", "name": "HTTP Strict Transport Security (HSTS)", "qualname": "web-security.rst#HTTP Strict Transport Security (HSTS)", "start_line": 164, "end_line": 173, "docstring": null, "code": "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nTells the browser to convert all HTTP requests to HTTPS, preventing\nman-in-the-middle (MITM) attacks. ::\n\n    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'\n\n- https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security\n\n.. _security-csp:", "code_truncated": false}
{"chunk_id": "ccd3d83882112b6c5f45dbe444b6d1af1f6086e0", "file_path": "d:\\499\\docs\\web-security.rst", "symbol_type": "doc", "name": "Content Security Policy (CSP)", "qualname": "web-security.rst#Content Security Policy (CSP)", "start_line": 176, "end_line": 185, "docstring": null, "code": "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nTell the browser where it can load various types of resource from. This header\nshould be used whenever possible, but requires some work to define the correct\npolicy for your site. A very strict policy would be::\n\n    response.headers['Content-Security-Policy'] = \"default-src 'self'\"\n\n- https://csp.withgoogle.com/docs/index.html\n- https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy", "code_truncated": false}
{"chunk_id": "bb5bd78071d07e3e567a6b44c2e2d9dc4a453b52", "file_path": "d:\\499\\docs\\web-security.rst", "symbol_type": "doc", "name": "X-Content-Type-Options", "qualname": "web-security.rst#X-Content-Type-Options", "start_line": 188, "end_line": 196, "docstring": null, "code": "~~~~~~~~~~~~~~~~~~~~~~\n\nForces the browser to honor the response content type instead of trying to\ndetect it, which can be abused to generate a cross-site scripting (XSS)\nattack. ::\n\n    response.headers['X-Content-Type-Options'] = 'nosniff'\n\n- https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options", "code_truncated": false}
{"chunk_id": "0f509a870218ebe44c0fee276996e8d2b0b9d17d", "file_path": "d:\\499\\docs\\web-security.rst", "symbol_type": "doc", "name": "X-Frame-Options", "qualname": "web-security.rst#X-Frame-Options", "start_line": 199, "end_line": 210, "docstring": null, "code": "~~~~~~~~~~~~~~~\n\nPrevents external sites from embedding your site in an ``iframe``. This\nprevents a class of attacks where clicks in the outer frame can be translated\ninvisibly to clicks on your page's elements. This is also known as\n\"clickjacking\". ::\n\n    response.headers['X-Frame-Options'] = 'SAMEORIGIN'\n\n- https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options\n\n.. _security-cookie:", "code_truncated": false}
{"chunk_id": "12436a2ed1924123a36381e9296f5d2ab3e27074", "file_path": "d:\\499\\docs\\web-security.rst", "symbol_type": "doc", "name": "Set-Cookie options", "qualname": "web-security.rst#Set-Cookie options", "start_line": 213, "end_line": 270, "docstring": null, "code": "~~~~~~~~~~~~~~~~~~\n\nThese options can be added to a ``Set-Cookie`` header to improve their\nsecurity. Flask has configuration options to set these on the session cookie.\nThey can be set on other cookies too.\n\n- ``Secure`` limits cookies to HTTPS traffic only.\n- ``HttpOnly`` protects the contents of cookies from being read with\n  JavaScript.\n- ``SameSite`` restricts how cookies are sent with requests from\n  external sites. Can be set to ``'Lax'`` (recommended) or ``'Strict'``.\n  ``Lax`` prevents sending cookies with CSRF-prone requests from\n  external sites, such as submitting a form. ``Strict`` prevents sending\n  cookies with all external requests, including following regular links.\n\n::\n\n    app.config.update(\n        SESSION_COOKIE_SECURE=True,\n        SESSION_COOKIE_HTTPONLY=True,\n        SESSION_COOKIE_SAMESITE='Lax',\n    )\n\n    response.set_cookie('username', 'flask', secure=True, httponly=True, samesite='Lax')\n\nSpecifying ``Expires`` or ``Max-Age`` options, will remove the cookie after\nthe given time, or the current time plus the age, respectively. If neither\noption is set, the cookie will be removed when the browser is closed. ::\n\n    # cookie expires after 10 minutes\n    response.set_cookie('snakes', '3', max_age=600)\n\nFor the session cookie, if :attr:`session.permanent <flask.session.permanent>`\nis set, then :data:`PERMANENT_SESSION_LIFETIME` is used to set the expiration.\nFlask's default cookie implementation validates that the cryptographic\nsignature is not older than this value. Lowering this value may help mitigate\nreplay attacks, where intercepted cookies can be sent at a later time. ::\n\n    app.config.update(\n        PERMANENT_SESSION_LIFETIME=600\n    )\n\n    @app.route('/login', methods=['POST'])\n    def login():\n        ...\n        session.clear()\n        session['user_id'] = user.id\n        session.permanent = True\n        ...\n\nUse :class:`itsdangerous.TimedSerializer` to sign and validate other cookie\nvalues (or any values that need secure signatures).\n\n- https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies\n- https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie\n\n.. _samesite_support: https://caniuse.com/#feat=same-site-cookie-attribute", "code_truncated": false}
{"chunk_id": "308635ba8d772241dc6ed230914da841aab7965e", "file_path": "d:\\499\\docs\\web-security.rst", "symbol_type": "doc", "name": "Host Header Validation", "qualname": "web-security.rst#Host Header Validation", "start_line": 273, "end_line": 291, "docstring": null, "code": "----------------------\n\nThe ``Host`` header is used by the client to indicate what host name the request\nwas made to. This is used, for example, by ``url_for(..., _external=True)`` to\ngenerate full URLs, for use in email or other messages outside the browser\nwindow.\n\nBy default the app doesn't know what host(s) it is allowed to be accessed\nthrough, and assumes any host is valid. Although browsers do not allow setting\nthe ``Host`` header, requests made by attackers in other scenarios could set\nthe ``Host`` header to a value they want.\n\nWhen deploying your application, set :data:`TRUSTED_HOSTS` to restrict what\nvalues the ``Host`` header may be.\n\nThe ``Host`` header may be modified by proxies in between the client and your\napplication. See :doc:`deploying/proxy_fix` to tell your app which proxy values\nto trust.", "code_truncated": false}
{"chunk_id": "1d9da4e5aceb0bc10d7857f2b1da950ad2b009ce", "file_path": "d:\\499\\docs\\web-security.rst", "symbol_type": "doc", "name": "Copy/Paste to Terminal", "qualname": "web-security.rst#Copy/Paste to Terminal", "start_line": 294, "end_line": 316, "docstring": null, "code": "----------------------\n\nHidden characters such as the backspace character (``\\b``, ``^H``) can\ncause text to render differently in HTML than how it is interpreted if\n`pasted into a terminal <https://security.stackexchange.com/q/39118>`__.\n\nFor example, ``import y\\bose\\bm\\bi\\bt\\be\\b`` renders as\n``import yosemite`` in HTML, but the backspaces are applied when pasted\ninto a terminal, and it becomes ``import os``.\n\nIf you expect users to copy and paste untrusted code from your site,\nsuch as from comments posted by users on a technical blog, consider\napplying extra filtering, such as replacing all ``\\b`` characters.\n\n.. code-block:: python\n\n    body = body.replace(\"\\b\", \"\")\n\nMost modern terminals will warn about and remove hidden characters when\npasting, so this isn't strictly necessary. It's also possible to craft\ndangerous commands in other ways that aren't possible to filter.\nDepending on your site's use case, it may be good to show a warning\nabout copying code in general.", "code_truncated": false}
