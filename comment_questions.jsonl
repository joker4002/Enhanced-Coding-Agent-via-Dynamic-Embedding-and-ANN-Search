{"repo": "pallets/flask", "issue_number": 5897, "issue_url": "https://github.com/pallets/flask/issues/5897", "comment_url": "https://github.com/pallets/flask/issues/5897#issuecomment-3800170835", "comment_id": 3800170835, "created_at": "2026-01-26T15:24:35+00:00", "text": "@davidism thanks for looking at this and apologies if the cut-down wasn't clear. Just to check -- does your example still not reproduce the issue if the package is installed in editable mode? (i.e: `pip install -e ./app`) For me the issue only reproduces when the package is installed in editable mode."}
{"repo": "pallets/flask", "issue_number": 5897, "issue_url": "https://github.com/pallets/flask/issues/5897", "comment_url": "https://github.com/pallets/flask/issues/5897#issuecomment-3807550447", "comment_id": 3807550447, "created_at": "2026-01-27T21:10:27+00:00", "text": "Hrm, it turns out my original case also required a \"flat layout\" (rather than a \"src layout\") though that doesn't change anything when using a `pyproject.toml` based install. I think the conclusion here is that something about the newer style editable install sets up the paths differently, which lets the code work.\n\nI'm not sure why you were unable to reproduce the issue, though I'm happy to accept that I need to bite the bullet and change the build system in use. Thanks for investigating."}
{"repo": "pallets/flask", "issue_number": 5897, "issue_url": "https://github.com/pallets/flask/issues/5897", "comment_url": "https://github.com/pallets/flask/issues/5897#issuecomment-3807715716", "comment_id": 3807715716, "created_at": "2026-01-27T21:51:58+00:00", "text": "Without src works for me also. Your exact example works fine, minus the legacy config I mentioned. My example was just to show what I'd do now, since there were a lot of other legacy patterns being used."}
{"repo": "pallets/flask", "issue_number": 5881, "issue_url": "https://github.com/pallets/flask/issues/5881", "comment_url": "https://github.com/pallets/flask/issues/5881#issuecomment-3712042611", "comment_id": 3712042611, "created_at": "2026-01-05T20:51:45+00:00", "text": "https://github.com/gfmio/asyncio-gevent/issues/12#issuecomment-3058277636 seems relevant:\n\n> asyncio expects there to be a single loop (per OS thread!).\n>\n> Before patching, threading.Thread creates a new OS thread and all is fine.\n> \n> After patching, threading.Thread will create a new green thread / greenlet running on the same OS thread. Since there is now only one OS thread, attempting to create a second loop will raise an exception."}
{"repo": "pallets/flask", "issue_number": 5881, "issue_url": "https://github.com/pallets/flask/issues/5881", "comment_url": "https://github.com/pallets/flask/issues/5881#issuecomment-3712548140", "comment_id": 3712548140, "created_at": "2026-01-06T00:13:59+00:00", "text": "Disclaimer, I do not have a solution to offer for this problem, but I wanted to share my understanding of the issue in case it helps.\n\nThe requirement for any gevent + asyncio solution to work well is that gevent runs in one thread, and asyncio runs in another thread. You can't have gevent and asyncio running on the same physical thread because then one loop would block the other.\n\nWhat's happening when you run the example above is that the monkey patching prevents asgiref from launching a separate asyncio thread. It thinks it is launching a new thread, but due to the monkey patching it is launching a greenlet instead. So then the asyncio loop ends up running in the same physical thread as gevent, and this is bad even without the error messages.\n\nI was actually able to get your example to run without errors only by commenting out the logic that raises the `RuntimeError` in asgiref. But this only masks the issue, it does not remove it. The correct solution would be for asgiref to somehow identify that it is running under a monkey patched gevent and figure out how to access the original unpatched threading module to launch a physical thread."}
{"repo": "pallets/flask", "issue_number": 5881, "issue_url": "https://github.com/pallets/flask/issues/5881", "comment_url": "https://github.com/pallets/flask/issues/5881#issuecomment-3712791799", "comment_id": 3712791799, "created_at": "2026-01-06T01:54:25+00:00", "text": "Yes that's what I was starting to figure out as well. I actually stripped asgiref out for a simple `threading.Thread` in `Flask.async_to_sync` to simplify things, and the problem still occurs. I was hoping to find some way to write `async_to_sync` using Gevent, but it doesn't seem possible with how asyncio and threads work. Tried asyncio-gevent `async_to_sync` as well, but it just freezes with concurrent requests. I also tried `gevent.monkey.patch_all(threading=False)`, but that fails as well."}
{"repo": "pallets/flask", "issue_number": 5881, "issue_url": "https://github.com/pallets/flask/issues/5881", "comment_url": "https://github.com/pallets/flask/issues/5881#issuecomment-3714425019", "comment_id": 3714425019, "created_at": "2026-01-06T11:52:42+00:00", "text": "> Individual requests do work\n\nIn my opinion this needs to be investigated to be sure that it is true in all cases. A simple async view function that just sleeps works, but a view function that does real async work could have interference from monkey-patched stuff in the standard library. For example, will you be able to launch a subprocess or use the process executor from the async function? Probably not, because `subprocess` is monkey-patched by gevent. Same for anything dealing with sockets or anything else that gevent monkey-patches and asyncio expects to be unpatched.\n\nAs I said above, after I commented out the `RuntimeError` in asgiref, your example runs cleanly for me. Asgiref by default runs only one asyncio thread for all the calls to `async_to_sync`, so under monkey-patching I see it create a single async loop inside a single greenlet. So at a high-level, this is all good, if you ignore that you now have a gevent loop and an asyncio loop competing with each other inside the same thread."}
{"repo": "pallets/flask", "issue_number": 5881, "issue_url": "https://github.com/pallets/flask/issues/5881", "comment_url": "https://github.com/pallets/flask/issues/5881#issuecomment-3719800928", "comment_id": 3719800928, "created_at": "2026-01-07T16:52:34+00:00", "text": "Okay, I thought it was going to be easy to change your example and make it break, but after trying a few things I could not.\n\nI have an updated theory of why this appears to work well. Both loops are still running in the same physical thread, but the asyncio loop is using a monkey-patched selector in its scheduler, so that allows it to coexist with the gevent scheduler, with both working cooperatively, and both using greenlet-based non-blocking waits."}
{"repo": "pallets/flask", "issue_number": 5881, "issue_url": "https://github.com/pallets/flask/issues/5881", "comment_url": "https://github.com/pallets/flask/issues/5881#issuecomment-3719884274", "comment_id": 3719884274, "created_at": "2026-01-07T17:13:09+00:00", "text": "Correction. This does appear to work with standard asyncio, but it hangs with uvloop. Below is a short demo. If you comment out the monkey patching, then the coroutine runs fine and you can Ctrl-C it.\n\n```python\nimport gevent.monkey\ngevent.monkey.patch_all()\n\nimport asyncio\nimport threading\nimport uvloop\n\nuvloop.install()\nloop = uvloop.loop.Loop()\n\nthreading.Thread(target=loop.run_forever).start()\n\nasync def count():\n    for i in range(5):\n        await asyncio.sleep(1)\n        print(i)\n\nasyncio.run_coroutine_threadsafe(count(), loop)\n```\n\nI don't have a Windows machine at hand right now. You should test on that OS, which uses a loop that is not based on selectors."}
{"repo": "pallets/flask", "issue_number": 5881, "issue_url": "https://github.com/pallets/flask/issues/5881", "comment_url": "https://github.com/pallets/flask/issues/5881#issuecomment-3720017114", "comment_id": 3720017114, "created_at": "2026-01-07T17:44:45+00:00", "text": "I don't think I'm going to integrate this directly into Flask, as it requires setting up the event loop externally ahead of time. I'd also prefer to avoid gevent-specific code paths.\n\nI was thinking a new documentation page about using gevent in general and explaining the method override pattern. This would also provide an example of why `Flask.async_to_sync` is intended to be overridden, for other cases such as trio as well. If we figure anything out with uvloop, that can be shown as well."}
{"repo": "pallets/flask", "issue_number": 5881, "issue_url": "https://github.com/pallets/flask/issues/5881", "comment_url": "https://github.com/pallets/flask/issues/5881#issuecomment-3796959440", "comment_id": 3796959440, "created_at": "2026-01-25T17:02:57+00:00", "text": "Yep, after testing, putting the following at the top works. I have no idea how to tell if it's actually more performant than the default though.\n\n```python\nimport gevent\ngevent.config.loop = \"libuv\"\n```"}
{"repo": "pallets/flask", "issue_number": 5870, "issue_url": "https://github.com/pallets/flask/issues/5870", "comment_url": "https://github.com/pallets/flask/issues/5870#issuecomment-3690159511", "comment_id": 3690159511, "created_at": "2025-12-24T16:01:34+00:00", "text": "From the [docs](https://flask.palletsprojects.com/en/stable/reqcontext/#teardown-callbacks) about teardown callbacks:\n\n> Be sure to write these functions in a way that does not depend on other callbacks and will not fail.\n\nTeardown happens after the response has already started, so there's no way to indicate that there was a server error at that point except by crashing. If we silently ignored exceptions in these handlers, the app could end up in an unexpected state."}
{"repo": "pallets/flask", "issue_number": 5863, "issue_url": "https://github.com/pallets/flask/issues/5863", "comment_url": "https://github.com/pallets/flask/issues/5863#issuecomment-3656561738", "comment_id": 3656561738, "created_at": "2025-12-15T16:32:26+00:00", "text": "> Handling Missing Headers: Current proposal allows requests with valid Origin header when Sec-Fetch-Site is missing. Should this be configurable or should we reject outright?\n\nRequiring `Origin` seems like a massive breaking change for APIs (where CSRF is generally not an issue anyway since you need to provide a Bearer token for authentication, or for unauthenticated APIs that do not require CSRF protections).\n\nSo default-on would likely be a breaking change."}
{"repo": "pallets/flask", "issue_number": 5863, "issue_url": "https://github.com/pallets/flask/issues/5863", "comment_url": "https://github.com/pallets/flask/issues/5863#issuecomment-3656598856", "comment_id": 3656598856, "created_at": "2025-12-15T16:38:36+00:00", "text": "> > Handling Missing Headers: Current proposal allows requests with valid Origin header when Sec-Fetch-Site is missing. Should this be configurable or should we reject outright?\n> \n> Requiring `Origin` seems like a massive breaking change for APIs (where CSRF is generally not an issue anyway since you need to provide a Bearer token for authentication, or for unauthenticated APIs that do not require CSRF protections).\n> \n> So default-on would likely be a breaking change.\n\nThe algorithm I was hoping to implement was Filippo's recommended appraoch:\n\n1. Allow safe methods (GET, HEAD, OPTIONS)\n2. If Origin in trusted list â†’ allow\n3. If Sec-Fetch-Site present:\n   - same-origin or none â†’ allow\n   - same-site or cross-site â†’ REJECT\n4. If neither header present â†’ allow (not a browser)\n5. If Origin host == Host â†’ allow, else reject\n\nBased on this.\n\n**What gets rejected:**\n\n- Browser requests where Sec-Fetch-Site is cross-site or same-site\n- Browser requests where Origin is present but doesn't match Host (old browsers)\n\n**What gets allowed:**\n\n- Sec-Fetch-Site: same-origin (browser, same origin)\n- Sec-Fetch-Site: none (browser, user-initiated like bookmarks)\n- No Sec-Fetch-Site + no Origin (not a browser â€” API clients)\n- No Sec-Fetch-Site + Origin matches Host (old browser, same origin)\n- Any request to a trusted origin in CSRF_TRUSTED_ORIGINS \n\nSo default-on should not break APIs at all. The protection only kicks in when browser-specific headers are present and indicate a cross-origin request.\n\nDoes this address your concern, or am I missing an edge case?"}
{"repo": "pallets/flask", "issue_number": 5863, "issue_url": "https://github.com/pallets/flask/issues/5863", "comment_url": "https://github.com/pallets/flask/issues/5863#issuecomment-3661305957", "comment_id": 3661305957, "created_at": "2025-12-16T16:08:00+00:00", "text": "@davidism Here's how I was thinking of implementing this.\n\n**Option 1: Flask + Werkzeug implementation**\n\n1. Accept csrf as a parameter to `@app.route | @blueprint.route` but will still be in `**options` kwargs\n2. `werkzeug.routing.Rule` [class](https://github.com/pallets/werkzeug/blob/a9f6b3c7924912e62ea74f39f10fb611d6e7725e/src/werkzeug/routing/rules.py#L459-L473) to have the argument `csrf` and attribute `csrf` \n3. In `flask.App.full_dispatch_request`, call `self.check_csrf(ctx.request)` after `request_started.send` and before `self.preprocess_request` \n\nhttps://github.com/pallets/flask/blob/2579ce9f18e67ec3213c6eceb5240310ccd46af8/src/flask/app.py#L1001-L1002\n\n**Option 2: Flask only implementation**\n\n1. Same as above\n2. Instead of adding argument to `werkzeug.routing.Rule`, just set `rule_obj.csrf = options.get(\"csrf\")` similar to how `provide_automatic_options` is set.\n3. Same as above \n\nhttps://github.com/pallets/flask/blob/2579ce9f18e67ec3213c6eceb5240310ccd46af8/src/flask/sansio/app.py#L647-L648\n\n---\n\n**On exempt paths:** This approach avoids the \"separate map of exempt paths\" problem entirely. Since `csrf` is stored on the `Rule` object itself, we just check `request.url_rule.csrf` at dispatch time requiring no separate data structure to sync.\n\n**On `TRUSTED_HOSTS` vs origins:** You're right, they're different. So I'd keep them separate:\n\n- `TRUSTED_HOSTS`: existing, for [Host header validation](https://flask.palletsprojects.com/en/stable/api/#flask.Request.trusted_hosts)\n- `CSRF_TRUSTED_ORIGINS`: new, full origins for cross-origin allowlist (OAuth callbacks, etc.)\n\n**On Werkzeug vs Flask:** I lean toward Option 2 (Flask only) since:\n- The check logic references Flask's `app.config` for `CSRF_TRUSTED_ORIGINS`\n- It follows the `provide_automatic_options` precedent\n- Werkzeug stays transport-layer focused\n\nThe core check logic (~40 lines) could still live in Werkzeug as a utility function that Flask calls, if you want other frameworks to benefit. But the routing integration feels Flask-specific.\n\nWant me to put together a draft PR for Option 2?"}
{"repo": "pallets/flask", "issue_number": 5861, "issue_url": "https://github.com/pallets/flask/issues/5861", "comment_url": "https://github.com/pallets/flask/issues/5861#issuecomment-3649220777", "comment_id": 3649220777, "created_at": "2025-12-13T11:07:07+00:00", "text": "@ThiefMaster \nYes, so I've already created it, and I'd like to discuss here what features would be useful."}
{"repo": "pallets/flask", "issue_number": 5839, "issue_url": "https://github.com/pallets/flask/issues/5839", "comment_url": "https://github.com/pallets/flask/issues/5839#issuecomment-3470371619", "comment_id": 3470371619, "created_at": "2025-10-30T21:38:48+00:00", "text": "Also, your webserver should typically be configured with sane limits. In fact, the code in your function won't even run until the file has been uploaded."}
{"repo": "pallets/flask", "issue_number": 5839, "issue_url": "https://github.com/pallets/flask/issues/5839", "comment_url": "https://github.com/pallets/flask/issues/5839#issuecomment-3470506696", "comment_id": 3470506696, "created_at": "2025-10-30T22:39:08+00:00", "text": "Regardless of frustration you may be feeling, your approach to reporting this issue and asking for help was not acceptable. Please reflect on how you'd like people to interact with you, then apply that to future interactions with others."}
{"repo": "pallets/flask", "issue_number": 5836, "issue_url": "https://github.com/pallets/flask/issues/5836", "comment_url": "https://github.com/pallets/flask/issues/5836#issuecomment-3509562075", "comment_id": 3509562075, "created_at": "2025-11-10T06:04:07+00:00", "text": "@davidism I am on the fence, should this bug hold up releasing click 8.3.1?"}
{"repo": "pallets/flask", "issue_number": 5825, "issue_url": "https://github.com/pallets/flask/issues/5825", "comment_url": "https://github.com/pallets/flask/issues/5825#issuecomment-3685573340", "comment_id": 3685573340, "created_at": "2025-12-23T07:42:23+00:00", "text": "Hi, Iâ€™d like to work on this documentation issue.Iâ€™ll review the â€œreceiving JSONâ€ section and add clarification about when and why\na 415 (Unsupported Media Type) error occurs, along with an example if appropriate."}
{"repo": "pallets/flask", "issue_number": 5825, "issue_url": "https://github.com/pallets/flask/issues/5825", "comment_url": "https://github.com/pallets/flask/issues/5825#issuecomment-3703489635", "comment_id": 3703489635, "created_at": "2026-01-01T09:57:17+00:00", "text": "Hi, I looked into this issue and it appears to be related to how Flask handles\nrequest.get_json() when the Content-Type header is missing or incorrect.\n\nFrom reading the documentation, the 415 error can occur when a request does\nnot specify 'application/json' or sends invalid JSON, but this behavior is\nnot clearly explained for users.\n\nAdding a short explanation and a simple example to the\nrequest.get_json() documentation (in docs/reqcontext.rst) should help\nusers understand why this error occurs and how to resolve it.\n\nPlease let me know if this approach makes sense before I proceed."}
{"repo": "pallets/flask", "issue_number": 5817, "issue_url": "https://github.com/pallets/flask/issues/5817", "comment_url": "https://github.com/pallets/flask/issues/5817#issuecomment-3299257146", "comment_id": 3299257146, "created_at": "2025-09-16T15:19:23+00:00", "text": "~~Oh no, it actually works with uwsgi.~~\nIt doesn't work either with uwsgi\n```\nRuntimeError: You cannot use AsyncToSync in the same thread as an async event loop - just await the async function directly.\n```"}
{"repo": "pallets/flask", "issue_number": 5817, "issue_url": "https://github.com/pallets/flask/issues/5817", "comment_url": "https://github.com/pallets/flask/issues/5817#issuecomment-3312326834", "comment_id": 3312326834, "created_at": "2025-09-19T14:02:01+00:00", "text": "It would be helpful if you showed a minimal example of what you are using using that causes issues."}
{"repo": "pallets/flask", "issue_number": 5817, "issue_url": "https://github.com/pallets/flask/issues/5817", "comment_url": "https://github.com/pallets/flask/issues/5817#issuecomment-3314181146", "comment_id": 3314181146, "created_at": "2025-09-19T23:32:18+00:00", "text": "@pgjones could you take a look at this if you have a chance?"}
{"repo": "pallets/flask", "issue_number": 5816, "issue_url": "https://github.com/pallets/flask/issues/5816", "comment_url": "https://github.com/pallets/flask/issues/5816#issuecomment-3504916542", "comment_id": 3504916542, "created_at": "2025-11-07T20:56:09+00:00", "text": "@davidism Would you assign this to me?\nI am interested in contributing to this."}
{"repo": "pallets/flask", "issue_number": 5816, "issue_url": "https://github.com/pallets/flask/issues/5816", "comment_url": "https://github.com/pallets/flask/issues/5816#issuecomment-3517944440", "comment_id": 3517944440, "created_at": "2025-11-11T17:13:32+00:00", "text": "Hi @davidism,\nIâ€™ve been going through the context preservation and teardown logic in Flask and would love to contribute to this issue.\nI understand this task was marked as not suitable for new contributors, but I have experience with Python internals and would like to work carefully under your guidance.\n\nIâ€™ve already explored how should_ignore_error interacts with teardown handlers and can open a draft PR showing a safe deprecation path (with tests).\n\nWould you be open to me working on this?"}
{"repo": "pallets/flask", "issue_number": 5815, "issue_url": "https://github.com/pallets/flask/issues/5815", "comment_url": "https://github.com/pallets/flask/issues/5815#issuecomment-3308554602", "comment_id": 3308554602, "created_at": "2025-09-18T16:56:11+00:00", "text": "It may be very difficult to do this in a way that existing overridden code will not fail and will show a deprecation warning.\n\nWe want to upgrade an overridden method that does not take the new `ctx: AppContext` parameter. We can detect this in `__init_subclass__` with `inspect.signature`, and wrap the function to take the correct signature, so that other parts of the dispatch code will call it correctly. But that's the \"simple\" part.\n\nWhat if other user code is still calling the method, overridden or not, without the new argument? The most obvious way this happens is with `super().method` within the overridden method. The wrapper could perhaps be clever enough to check the type of the first argument, and decide to make a new or old signature call. The wrapper would have to be applied to every base method to handle the `super` call case.\n\nI haven't tried to write this more complex wrapper yet. I have a feeling it will be difficult to write. I know it will add overhead to every request, since multiple methods will now have to do detection on the arguments passed to them. This overhead will mostly be waste, as the vast majority of code will not be overridden.\n\nPerhaps we can just say this is a breaking change in 4.0? I still think the result is worth it. We could still show a better error message by doing some detection in `__init_subclass__`, but showing an error instead of applying a wrapper and showing a warning."}
{"repo": "pallets/flask", "issue_number": 5815, "issue_url": "https://github.com/pallets/flask/issues/5815", "comment_url": "https://github.com/pallets/flask/issues/5815#issuecomment-3308868579", "comment_id": 3308868579, "created_at": "2025-09-18T18:04:34+00:00", "text": "The following method signatures would change to add `ctx: AppContext` as the first parameter:\n\n- `update_template_context`\n- `handle_http_exception`\n- `handle_user_exception`\n- `handle_exception`\n- `log_exception`\n- `dispatch_request`\n- `full_dispatch_request`\n- `finalize_request`\n- `make_default_options_response`\n- `preprocess_request`\n- `process_response`\n- `do_teardown_request`\n- `do_teardown_appcontext`\n\nI'd be somewhat surprised to find any of these overridden. They're either really internal, or they're the machinery that calls registered callback functions."}
{"repo": "pallets/flask", "issue_number": 5804, "issue_url": "https://github.com/pallets/flask/issues/5804", "comment_url": "https://github.com/pallets/flask/issues/5804#issuecomment-3288692782", "comment_id": 3288692782, "created_at": "2025-09-13T18:05:39+00:00", "text": "This will be fixed as a side effect of #5812 in 3.2. I'm not sure how to fix it in the mean time, without reintroducing the other issue, but I'm open to reviewing a PR if you can figure it out sooner.\n\nI do understand how this is an issue, but note that the docs already call out that you can't make assumptions about how many times teardown functions will run or what will have or have not run before them. That's something you should address regardless of this being fixed."}
{"repo": "pallets/flask", "issue_number": 5804, "issue_url": "https://github.com/pallets/flask/issues/5804", "comment_url": "https://github.com/pallets/flask/issues/5804#issuecomment-3292350761", "comment_id": 3292350761, "created_at": "2025-09-15T14:05:20+00:00", "text": "> This will be fixed as a side effect of https://github.com/pallets/flask/pull/5812 in 3.2. I'm not sure how to fix it in the mean time\n\nSeems like it does the trick indeed, thanks. The fact that it won't be fixed until then is not really an issue for us, I've just pinned flask to <3.1.2 until we can upgrade.\n\n> the docs already call out that you can't make assumptions about how many times teardown functions will run or what will have or have not run before them\n\nhttps://flask.palletsprojects.com/en/stable/reqcontext/#teardown-callbacks here ? It's not immediately obvious to me that they could run more than once, but even then this isn't the original issue we encountered, because our teardown callbacks are indeed idempotent â€” the `g.pop()` was used here to exhibit the issue.\n\nMy issue was more around *when* it can be called: in this specific case, even before entering the generator passed to `stream_with_context()`. I wouldn't expect a teardown callback to be called at this point, considering `do_teardown_request()` is Â« Called after the request is dispatched and the response is returned Â»."}
{"repo": "pallets/flask", "issue_number": 5804, "issue_url": "https://github.com/pallets/flask/issues/5804", "comment_url": "https://github.com/pallets/flask/issues/5804#issuecomment-3322169181", "comment_id": 3322169181, "created_at": "2025-09-23T02:46:59+00:00", "text": "Is there an expected release date for 3.2.0? We also encountered this problem in OTEL."}
{"repo": "pallets/flask", "issue_number": 5804, "issue_url": "https://github.com/pallets/flask/issues/5804", "comment_url": "https://github.com/pallets/flask/issues/5804#issuecomment-3348322234", "comment_id": 3348322234, "created_at": "2025-09-29T18:02:26+00:00", "text": "I think we should supress the error as a warning till the issue gets resolves as a side effect by wrapping the \nteardown call on the lines of:\n\nfrom contextlib import suppress\n\ndef do_teardown_request(self, exc: BaseException | None = None) -> None:\n    \"\"\"Called after the request is dispatched and the response is finalized.\"\"\"\n    req = _cv_app.get().request\n\n    for name in chain(req.blueprints, (None,)):\n        if name in self.teardown_request_funcs:\n            for func in reversed(self.teardown_request_funcs[name]):\n                with suppress(KeyError):\n                    self.ensure_sync(func)(exc)\n\n    request_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)"}
{"repo": "pallets/flask", "issue_number": 5804, "issue_url": "https://github.com/pallets/flask/issues/5804", "comment_url": "https://github.com/pallets/flask/issues/5804#issuecomment-3665784285", "comment_id": 3665784285, "created_at": "2025-12-17T15:09:18+00:00", "text": "We are suffering the same issue with 3.1.2, and had to pin Flask to version < 3.1.2.\nDid not quite get it: is this expected to be resolved in Flask 3.2.0? \nThanks"}
{"repo": "pallets/flask", "issue_number": 5804, "issue_url": "https://github.com/pallets/flask/issues/5804", "comment_url": "https://github.com/pallets/flask/issues/5804#issuecomment-3665928055", "comment_id": 3665928055, "created_at": "2025-12-17T15:38:24+00:00", "text": "> is this expected to be resolved in Flask 3.2.0?\n\nyes"}
{"repo": "pallets/flask", "issue_number": 5786, "issue_url": "https://github.com/pallets/flask/issues/5786", "comment_url": "https://github.com/pallets/flask/issues/5786#issuecomment-3197466823", "comment_id": 3197466823, "created_at": "2025-08-18T15:46:31+00:00", "text": "I tracked this down to how the request context is being restored by the client. It was entering them in the reverse order, newest to oldest instead of oldest to newest. Therefore the first request's session was at the top of the stack, obscuring the second request."}
{"repo": "pallets/flask", "issue_number": 5774, "issue_url": "https://github.com/pallets/flask/issues/5774", "comment_url": "https://github.com/pallets/flask/issues/5774#issuecomment-3198514429", "comment_id": 3198514429, "created_at": "2025-08-18T21:43:27+00:00", "text": "Never mind, this is a specific fixable issue with `stream_with_context`, not an issue with async views. Thanks for finding the PR that affected it, when I took another look at this it put me on the right path.\n\nThe problem is related to how we automatically push an app context when pushing a request context. If an app context is not already pushed, we create one and push it, recording that we should pop it when the request context is popped. We store this using `ContextVars`, which are sensitive to the async loop/thread they were modified from. The order that pushes and pops happens in is important, and is pretty complex when dealing with the request/response, stream with context, and test client context preservation all at once.\n\nThe immediate issue you reported is because of when `stream_with_context` was pushing the request. It would push it as soon as the generator started, and in the case of an async view it is running in a temporary async loop context only for that view function. Therefore, when we went to pop it later during cleanup and test client, the context it was pushed in no longer matched the current context.\n\nThat can be fixed by adjusting when the context is pushed to when the streaming response starts, rather than when the generator starts. But this resulted in another error, because at that point the app context had already been cleaned up, but recorded for client preservation. So the generator would automatically push a new app context, then things would get cleaned up in the wrong order.\n\nThat can be fixed by pushing the app and request contexts separately in `stream_with_context`, so that the request context will not automatically add or clean up the app context.\n\nThere's a comment in `stream_with_context` saying that pushing at the point it was is intentional and required for correct operation. But as far as I can tell with further test scenarios, everything works correctly with the change. Perhaps it was required before that PR changed how things worked.\n\nPhew ðŸ˜®â€ðŸ’¨"}
{"repo": "pallets/flask", "issue_number": 5768, "issue_url": "https://github.com/pallets/flask/issues/5768", "comment_url": "https://github.com/pallets/flask/issues/5768#issuecomment-3053163642", "comment_id": 3053163642, "created_at": "2025-07-09T15:51:47+00:00", "text": "Can I assume that any feature request from the community will simply be closed as 'not planned'? \nIs there a process or criteria for what gets considered?"}
{"repo": "pallets/flask", "issue_number": 5751, "issue_url": "https://github.com/pallets/flask/issues/5751", "comment_url": "https://github.com/pallets/flask/issues/5751#issuecomment-2934757408", "comment_id": 2934757408, "created_at": "2025-06-03T11:18:10+00:00", "text": "You'll want to use `werkzeug.Response` for most annotations. Specificially for `redirect`, that's what it returns. `flask.Response` is a subclass, meaning it's not valid in that typing context. This is in general impossible to solve, we've gone back and forth before and it causes issues in user code no matter whether we use Flask's or Werkzeug's `Response` in our own annotations."}
{"repo": "pallets/flask", "issue_number": 5738, "issue_url": "https://github.com/pallets/flask/issues/5738", "comment_url": "https://github.com/pallets/flask/issues/5738#issuecomment-2893924221", "comment_id": 2893924221, "created_at": "2025-05-20T11:02:12+00:00", "text": "@ThiefMaster Do you mean by setting different blueprints to different templates? \nI believe this has its limitations if so"}
{"repo": "pallets/flask", "issue_number": 5729, "issue_url": "https://github.com/pallets/flask/issues/5729", "comment_url": "https://github.com/pallets/flask/issues/5729#issuecomment-2880813090", "comment_id": 2880813090, "created_at": "2025-05-14T16:14:54+00:00", "text": "@davidism \nHi! ðŸ‘‹ I'm new to contributing to Flask and really interested in getting involved in the project.\nThis issue looks like something I could help with and learn from â€” would it be okay if I took it on?\n\nI'm not entirely sure whether this suggestion aligns with Flaskâ€™s design philosophy and consistency with similar decorators. If it's confirmed that this is a change the team would consider, Iâ€™d love to help implement it.\n\nCould I be assigned as the assignee for this issue?\n\nThanks!"}
{"repo": "pallets/flask", "issue_number": 5729, "issue_url": "https://github.com/pallets/flask/issues/5729", "comment_url": "https://github.com/pallets/flask/issues/5729#issuecomment-2887347838", "comment_id": 2887347838, "created_at": "2025-05-16T17:51:48+00:00", "text": "@alexwlchan is it okay if i take up this issue? I understand from `https://palletsprojects.com/contributing` that I don't have to ask first but I thought it would be a good idea to do so out of courtesy anyway, if you could assign me. Thanks!"}
{"repo": "pallets/flask", "issue_number": 5729, "issue_url": "https://github.com/pallets/flask/issues/5729", "comment_url": "https://github.com/pallets/flask/issues/5729#issuecomment-2887355138", "comment_id": 2887355138, "created_at": "2025-05-16T17:55:52+00:00", "text": "Not the author of the issue (not sure why you pinged him) but a maintainer: Yes sure, feel free to work on it. PRs to fix bugs are always welcome!"}
{"repo": "pallets/flask", "issue_number": 5729, "issue_url": "https://github.com/pallets/flask/issues/5729", "comment_url": "https://github.com/pallets/flask/issues/5729#issuecomment-2901346515", "comment_id": 2901346515, "created_at": "2025-05-22T14:01:22+00:00", "text": "Hi there! \n\nI'm keen to start contributing to Flask and this issue caught my eye. It seems like a great way for me to get familiar with the project.\nIf addressing this decorator behavior fits the team's vision for Flask's design, I'd be happy to take it on. Could I get assigned?\n\nThanks!"}
{"repo": "pallets/flask", "issue_number": 5729, "issue_url": "https://github.com/pallets/flask/issues/5729", "comment_url": "https://github.com/pallets/flask/issues/5729#issuecomment-2901357629", "comment_id": 2901357629, "created_at": "2025-05-22T14:04:37+00:00", "text": "There's already a draft PR for this... why do you want to start working on yet another one while there's an open PR? :)"}
{"repo": "pallets/flask", "issue_number": 5729, "issue_url": "https://github.com/pallets/flask/issues/5729", "comment_url": "https://github.com/pallets/flask/issues/5729#issuecomment-2901382680", "comment_id": 2901382680, "created_at": "2025-05-22T14:12:03+00:00", "text": "> There's already a draft PR for this... why do you want to start working on yet another one while there's an open PR? :)\n\n    Thanks for letting me know... I appreciate the heads-up about the existing draft PR. I'll definitely find another issue to work on."}
{"repo": "pallets/flask", "issue_number": 5729, "issue_url": "https://github.com/pallets/flask/issues/5729", "comment_url": "https://github.com/pallets/flask/issues/5729#issuecomment-2901384109", "comment_id": 2901384109, "created_at": "2025-05-22T14:12:27+00:00", "text": "What is it about this that has attracted _five_ completely new contributors who aren't reading the [contributing guide](https://palletsprojects.com/contributing):\n\n> Anyone is welcome to work on any open ticket in any project's issue tracker, without asking first. Before starting, check if anyone else is assigned to the issue, or if there are any linked open pull requests. Look through the issue for that information as well as discussion and other linked issues for context."}
{"repo": "pallets/flask", "issue_number": 5718, "issue_url": "https://github.com/pallets/flask/issues/5718", "comment_url": "https://github.com/pallets/flask/issues/5718#issuecomment-2833241276", "comment_id": 2833241276, "created_at": "2025-04-27T06:58:25+00:00", "text": "Hi, Iâ€™m new to open source and would like to work on this issue. Can I take it?"}
{"repo": "pallets/flask", "issue_number": 5718, "issue_url": "https://github.com/pallets/flask/issues/5718", "comment_url": "https://github.com/pallets/flask/issues/5718#issuecomment-2847789749", "comment_id": 2847789749, "created_at": "2025-05-02T17:57:59+00:00", "text": "Thanks for the contribution and this looks great! I appreciate the clean and thoughtful write-up.\n\nGlad to see the issue addressed this thoroughly. Let me know if I can help further."}
{"repo": "pallets/flask", "issue_number": 5692, "issue_url": "https://github.com/pallets/flask/issues/5692", "comment_url": "https://github.com/pallets/flask/issues/5692#issuecomment-2736265866", "comment_id": 2736265866, "created_at": "2025-03-19T11:18:02+00:00", "text": "Is there a specific reason why you need to use an alpha build of Python?\n\nAlso, see:\n\nhttps://peps.python.org/pep-0745/\nhttps://palletsprojects.com/releases"}
{"repo": "pallets/flask", "issue_number": 5692, "issue_url": "https://github.com/pallets/flask/issues/5692", "comment_url": "https://github.com/pallets/flask/issues/5692#issuecomment-2736289763", "comment_id": 2736289763, "created_at": "2025-03-19T11:27:17+00:00", "text": "I should have been more verbose in justification. Yes, my intention is to make you aware of the issue coming soon - there will only be one more alpha release in ~month. In Fedora, we're testing from the 1st alpha of a new Python release, to make sure the ecosystem is gradually ready from the day of release."}
